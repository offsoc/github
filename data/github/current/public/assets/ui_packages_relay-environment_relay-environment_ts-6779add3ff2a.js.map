{"version":3,"file":"ui_packages_relay-environment_relay-environment_ts-xxxxxxxxxxxx.js","mappings":"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","sources":["ui/packages/alive/alive.ts","ui/packages/alive/connect-alive-subscription.ts","ui/packages/alive/session.ts","ui/packages/analytics-overrides/analytics-overrides.ts","ui/packages/failbot/failbot.ts","ui/packages/fetch-graphql/fetch-graphql.ts","ui/packages/internal-api-insights/index.ts","ui/packages/relay-environment/alive-subscription.ts","ui/packages/relay-environment/missing-field-handlers.ts","ui/packages/relay-environment/relay-environment.ts","ui/packages/relay-environment/scheduler.ts","ui/packages/trusted-types-policies/alive.ts","ui/packages/trusted-types-policies/policy.ts","ui/packages/trusted-types/trusted-types.ts","ui/packages/verified-fetch/verified-fetch.ts"],"sourcesContent":["import type {AliveEvent, MetadataUpdate, Notifier, Subscription} from '@github/alive-client'\nimport {PresenceMetadataSet, SubscriptionSet, isPresenceChannel} from '@github/alive-client'\nimport {AliveSession} from './session'\nimport {debounce} from '@github/mini-throttle'\nimport {ready} from '@github-ui/document-ready'\nimport safeStorage from '@github-ui/safe-storage'\nimport {alivePolicy, InvalidSourceRelError} from '@github-ui/trusted-types-policies/alive'\nimport {isSafari} from '@braintree/browser-detection'\n\nexport interface Dispatchable {\n  dispatchEvent: (e: Event) => unknown\n}\n\nfunction isSharedWorkerSupported(): boolean {\n  // There is currently a bug in safari that causes shared workers to stop working after a while\n  // see https://github.com/github/web-systems/issues/965\n  if (isSafari()) return false\n  return 'SharedWorker' in window && safeStorage('localStorage').getItem('bypassSharedWorker') !== 'true'\n}\n\nexport function workerSrc(): string | null {\n  const url =\n    document.head.querySelector<HTMLLinkElement>(`link[rel=shared-web-socket-src]`)?.getAttribute('href') ?? ''\n  try {\n    return alivePolicy.createScriptURL(url)\n  } catch (e) {\n    if (e instanceof InvalidSourceRelError) {\n      return null\n    }\n    throw e\n  }\n}\n\nfunction socketUrl(): string | null {\n  return document.head.querySelector<HTMLLinkElement>('link[rel=shared-web-socket]')?.href ?? null\n}\n\nfunction socketRefreshUrl(): string | null {\n  return (\n    document.head.querySelector<HTMLLinkElement>('link[rel=shared-web-socket]')?.getAttribute('data-refresh-url') ??\n    null\n  )\n}\n\nfunction sessionIdentifier(): string | null {\n  return (\n    document.head.querySelector<HTMLLinkElement>('link[rel=shared-web-socket]')?.getAttribute('data-session-id') ?? null\n  )\n}\n\n/**\n * dispatches events of type: 'socket:message' | 'socket:presence'\n */\nfunction notify(subscribers: Iterable<Dispatchable>, {channel, type, data}: AliveEvent) {\n  for (const el of subscribers) {\n    el.dispatchEvent(\n      new CustomEvent(`socket:${type}`, {\n        bubbles: false,\n        cancelable: false,\n        detail: {name: channel, data},\n      }),\n    )\n  }\n}\n\nclass AliveSessionProxy {\n  private worker: SharedWorker\n  private subscriptions = new SubscriptionSet<Dispatchable>()\n  private presenceMetadata = new PresenceMetadataSet<Dispatchable>()\n  private notify: Notifier<Dispatchable>\n\n  constructor(src: string, url: string, refreshUrl: string, sessionId: string, notifier: Notifier<Dispatchable>) {\n    this.notify = notifier\n    // eslint-disable-next-line ssr-friendly/no-dom-globals-in-constructor, compat/compat\n    this.worker = new SharedWorker(src, `github-socket-worker-v2-${sessionId}`)\n    this.worker.port.onmessage = ({data}) => this.receive(data)\n    this.worker.port.postMessage({connect: {url, refreshUrl}})\n  }\n\n  subscribe(subs: Array<Subscription<Dispatchable>>) {\n    const added = this.subscriptions.add(...subs)\n    if (added.length) {\n      this.worker.port.postMessage({subscribe: added})\n    }\n\n    // We may be adding a subscription to a presence channel which is already subscribed.\n    // In this case, we need to explicitly ask the SharedWorker to send us the presence data.\n    const addedChannels = new Set(added.map(topic => topic.name))\n    const redundantPresenceChannels = subs.reduce((redundantChannels, subscription) => {\n      const channel = subscription.topic.name\n\n      if (isPresenceChannel(channel) && !addedChannels.has(channel)) {\n        redundantChannels.add(channel)\n      }\n\n      return redundantChannels\n    }, new Set<string>())\n\n    if (redundantPresenceChannels.size) {\n      this.worker.port.postMessage({requestPresence: Array.from(redundantPresenceChannels)})\n    }\n  }\n\n  unsubscribeAll(...subscribers: Dispatchable[]) {\n    const removed = this.subscriptions.drain(...subscribers)\n    if (removed.length) {\n      this.worker.port.postMessage({unsubscribe: removed})\n    }\n\n    const updatedPresenceChannels = this.presenceMetadata.removeSubscribers(subscribers)\n    this.sendPresenceMetadataUpdate(updatedPresenceChannels)\n  }\n\n  updatePresenceMetadata(metadataUpdates: Array<MetadataUpdate<Dispatchable>>) {\n    const updatedChannels = new Set<string>()\n\n    for (const update of metadataUpdates) {\n      // update the local metadata for this specific element\n      this.presenceMetadata.setMetadata(update)\n      updatedChannels.add(update.channelName)\n    }\n\n    // Send the full local metadata for these channels to the SharedWorker\n    this.sendPresenceMetadataUpdate(updatedChannels)\n  }\n\n  sendPresenceMetadataUpdate(channelNames: Set<string>) {\n    if (!channelNames.size) {\n      return\n    }\n\n    const updatesForSharedWorker: Array<Omit<MetadataUpdate<Element>, 'subscriber'>> = []\n\n    for (const channelName of channelNames) {\n      // get all metadata for this channel (from all elements) to send to the SharedWorker\n      updatesForSharedWorker.push({\n        channelName,\n        metadata: this.presenceMetadata.getChannelMetadata(channelName),\n      })\n    }\n\n    // Send the full metadata updates to the SharedWorker\n    this.worker.port.postMessage({updatePresenceMetadata: updatesForSharedWorker})\n  }\n\n  online() {\n    this.worker.port.postMessage({online: true})\n  }\n\n  offline() {\n    this.worker.port.postMessage({online: false})\n  }\n\n  hangup() {\n    this.worker.port.postMessage({hangup: true})\n  }\n\n  private notifyPresenceDebouncedByChannel = new Map<string, Notifier<Dispatchable>>()\n  private receive(event: AliveEvent) {\n    const {channel} = event\n\n    if (event.type === 'presence') {\n      // There are times when we get a flood of messages from the SharedWorker, such as a tab that has been idle for a long time and then comes back to the foreground.\n      // Since each presence message for a channel contains the full list of users, we can debounce the events and only notify subscribers with the last one\n      let debouncedNotify = this.notifyPresenceDebouncedByChannel.get(channel)\n      if (!debouncedNotify) {\n        debouncedNotify = debounce((subscribers, debouncedEvent) => {\n          this.notify(subscribers, debouncedEvent)\n          this.notifyPresenceDebouncedByChannel.delete(channel)\n        }, 100)\n        this.notifyPresenceDebouncedByChannel.set(channel, debouncedNotify)\n      }\n\n      debouncedNotify(this.subscriptions.subscribers(channel), event)\n      return\n    }\n\n    // For non-presence messages, we can send them through immediately since they may contain different messages/data\n    this.notify(this.subscriptions.subscribers(channel), event)\n  }\n}\n\nasync function connect() {\n  const src = workerSrc()\n  if (!src) return\n\n  const url = socketUrl()\n  if (!url) return\n\n  const refreshUrl = socketRefreshUrl()\n  if (!refreshUrl) return\n\n  const sessionId = sessionIdentifier()\n  if (!sessionId) return\n\n  const createSession = () => {\n    if (isSharedWorkerSupported()) {\n      try {\n        return new AliveSessionProxy(src, url, refreshUrl, sessionId, notify)\n      } catch (_) {\n        // ignore errors.  CSP will some times block SharedWorker creation. Fall back to standard AliveSession.\n      }\n    }\n\n    return new AliveSession(url, refreshUrl, false, notify)\n  }\n  const session = createSession()\n\n  window.addEventListener('online', () => session.online())\n  window.addEventListener('offline', () => session.offline())\n  window.addEventListener('pagehide', () => {\n    if ('hangup' in session) session.hangup()\n  })\n\n  return session\n}\n\nasync function connectWhenReady() {\n  await ready\n  return connect()\n}\n\nlet sessionPromise: undefined | ReturnType<typeof connectWhenReady>\n\nexport function getSession() {\n  return (sessionPromise ||= connectWhenReady())\n}\n","import type {getSession} from '@github-ui/alive'\nimport {Topic} from '@github/alive-client'\n\n/**\n * Connect to an Alive subscription\n * @param aliveSession the Alive session\n * @param channelName the signed channel name\n * @param callback a callback to receive events from the alive channel. This callback should be memoized to avoid unnecessary resubscribes when React re-renders.\n */\n\nexport function connectAliveSubscription<T>(\n  aliveSession: Awaited<ReturnType<typeof getSession>>,\n  channelName: string | null,\n  callback: (data: T) => unknown,\n) {\n  if (!aliveSession) {\n    // the alive session failed to connect\n    throw new Error('Not connected to alive')\n  }\n\n  if (!channelName) {\n    throw new Error('No channel name')\n  }\n\n  const topic = Topic.parse(channelName)\n\n  if (!topic) {\n    throw new Error('Invalid channel name')\n  }\n\n  const aliveSubscription = {\n    subscriber: {\n      dispatchEvent: (event: Event) => {\n        if (event instanceof CustomEvent) {\n          const subscriptionEvent = event.detail\n          callback(subscriptionEvent.data)\n        }\n      },\n    },\n    topic,\n  }\n\n  aliveSession.subscribe([aliveSubscription])\n  return {\n    unsubscribe: () => aliveSession.unsubscribeAll(aliveSubscription.subscriber),\n  }\n}\n","import {AliveSession as BaseAliveSession} from '@github/alive-client'\nimport type {Notifier} from '@github/alive-client'\nexport class AliveSession<T> extends BaseAliveSession<T> {\n  constructor(\n    url: string,\n    private refreshUrl: string,\n    shared: boolean,\n    notify: Notifier<T>,\n  ) {\n    super(url, () => this.getUrlFromRefreshUrl(), shared, notify)\n  }\n\n  private getUrlFromRefreshUrl() {\n    return fetchRefreshUrl(this.refreshUrl)\n  }\n}\n\ntype PostUrl = {url?: string; token?: string}\nasync function fetchRefreshUrl(url: string): Promise<string | null> {\n  const data = await fetchJSON<PostUrl>(url)\n  return data && data.url && data.token ? post(data.url, data.token) : null\n}\n\nasync function fetchJSON<T>(url: string): Promise<T | null> {\n  const response = await fetch(url, {headers: {Accept: 'application/json'}})\n  if (response.ok) {\n    return response.json()\n  } else if (response.status === 404) {\n    return null\n  } else {\n    throw new Error('fetch error')\n  }\n}\n\nasync function post(url: string, csrf: string): Promise<string> {\n  const response = await fetch(url, {\n    method: 'POST',\n    mode: 'same-origin',\n    headers: {\n      'Scoped-CSRF-Token': csrf,\n    },\n  })\n  if (response.ok) {\n    return response.text()\n  } else {\n    throw new Error('fetch error')\n  }\n}\n","function queryLast<T extends Element>(selector: string): T | undefined {\n  const list = document.querySelectorAll<T>(selector)\n  if (list.length > 0) {\n    return list[list.length - 1]\n  }\n}\n\nfunction pagePathname() {\n  const locationOverride = queryLast<HTMLMetaElement>('meta[name=analytics-location]')\n  if (locationOverride) {\n    return locationOverride.content\n  } else {\n    return window.location.pathname\n  }\n}\n\nfunction pageQuery() {\n  const stripParams = queryLast<HTMLMetaElement>('meta[name=analytics-location-query-strip]')\n  let search = ''\n\n  if (!stripParams) {\n    search = window.location.search\n  }\n\n  const extraParams = queryLast<HTMLMetaElement>('meta[name=analytics-location-params]')\n  if (extraParams) {\n    search += (search ? '&' : '?') + extraParams.content\n  }\n\n  for (const meta of document.querySelectorAll<HTMLMetaElement>('meta[name=analytics-param-rename]')) {\n    const names = meta.content.split(':', 2)\n    search = search.replace(new RegExp(`(^|[?&])${names[0]}($|=)`, 'g'), `$1${names[1]}$2`)\n  }\n\n  return search\n}\n\nexport function requestUri() {\n  return `${window.location.protocol}//${window.location.host}${pagePathname() + pageQuery()}`\n}\n","// Report uncaught JS errors to Sentry\n//   https://sentry.io/github/github-js\n\nimport {getOrCreateClientId} from '@github/hydro-analytics-client'\nimport {isSupported} from '@github/browser-support'\nimport {parse} from 'stacktrace-parser'\nimport {requestUri} from '@github-ui/analytics-overrides'\nimport {bundler} from '@github-ui/runtime-environment'\nimport {ssrSafeWindow} from '@github-ui/ssr-utils'\nimport {isFeatureEnabled} from '@github-ui/feature-flags'\nimport {getSoftNavReferrer} from '@github-ui/soft-nav/utils'\n\nlet extensionErrors = false\nlet errorsReported = 0\nconst loadTime = Date.now()\n// network error messages are not consistent across browsers, this is a list of known messages for chrome and firefox\nexport const EXPECTED_NETWORK_ERROR_MESSAGES = new Set([\n  'Failed to fetch',\n  'NetworkError when attempting to fetch resource.',\n])\n\ntype ErrorContext = {\n  message?: string\n}\n\n// Check if an arbitrary object is an error, or at least an object that satisfies the interface of an error,\n// with the necessary information to be able to report it to Sentry.\nfunction isError(error: unknown): error is Error {\n  // Check if it's a definite instance of an error\n  if (error instanceof Error) return true\n  // Otherwise, check that it at least satisfies the interface of an error\n  return (\n    typeof error === 'object' &&\n    error !== null &&\n    'name' in error &&\n    typeof error.name === 'string' &&\n    'message' in error &&\n    typeof error.message === 'string'\n  )\n}\n\n/** Tries to serialize an arbitrary error value that is not an Error object, and returns a default message otherwise */\nfunction serializeNonError(error: unknown): string {\n  try {\n    return JSON.stringify(error)\n  } catch {\n    return 'Unserializable'\n  }\n}\n\nfunction isExpectedError(error: Error): boolean {\n  // We use AbortController to control events and some workflows. When we call `abort()` on it, it will raise an\n  // `AbortError` which doesn't represent a real error, so we don't want to report it.\n  if (error.name === 'AbortError') return true\n  // Failed to fetch errors are usually related to the user's network connection. They also do not represent\n  // real errors related to our code, so we will also ignore them.\n  if (error.name === 'TypeError' && EXPECTED_NETWORK_ERROR_MESSAGES.has(error.message)) return true\n  // For memex we use an ApiError class to represent errors returned from the API\n  // Additional details in the format of ApiErrorOpts are affixed to the name as a stringified JSON object\n  // so we just need to ensure the error name starts with ApiError\n  // see ui/packages/memex/src/client/platform/api-error.ts for more details.\n  if (error.name.startsWith('ApiError') && EXPECTED_NETWORK_ERROR_MESSAGES.has(error.message)) return true\n\n  return false\n}\n\n// @deprecated Re-throw the caught exception instead.\nexport function reportError(error: unknown, context: ErrorContext = {}) {\n  if (isFeatureEnabled('FAILBOT_HANDLE_NON_ERRORS')) {\n    if (!isError(error)) {\n      if (isIgnoredNonError(error)) return\n\n      // Create an error instance so that we can get the stacktrace of how this was reported\n      const errorForStackTrace = new Error()\n      const serializedErrorValue = serializeNonError(error)\n      // Construct a custom error object so we can keep track of anywhere that we report an error that isn't an Error object\n      const newError: PlatformJavascriptError = {\n        type: 'UnknownError',\n        value: `Unable to report error, due to a thrown non-Error type: ${typeof error}, with value ${serializedErrorValue}`,\n        stacktrace: stacktrace(errorForStackTrace),\n        catalogService: undefined,\n      }\n      report(errorContext(newError, context))\n      return\n    }\n    if (!isExpectedError(error)) {\n      report(errorContext(formatError(error), context))\n    }\n  } else {\n    // Without feature flag, we will cast the `error` variable which was implicitly the old\n    // behavior of the non-feature flagged code.\n    if (!isExpectedError(error as Error)) {\n      report(errorContext(formatError(error as Error), context))\n    }\n  }\n}\n\n// Report context info to Sentry.\nasync function report(context: PlatformReportBrowserErrorInput) {\n  if (!reportable()) return\n\n  const url = document.head?.querySelector<HTMLMetaElement>('meta[name=\"browser-errors-url\"]')?.content\n  if (!url) return\n\n  if (isExtensionError(context.error.stacktrace)) {\n    extensionErrors = true\n    return\n  }\n\n  errorsReported++\n\n  try {\n    await fetch(url, {method: 'post', body: JSON.stringify(context)})\n  } catch {\n    // Error reporting failed so do nothing.\n  }\n}\n\nfunction formatError(error: Error): PlatformJavascriptError {\n  return {\n    type: error.name,\n    value: error.message,\n    stacktrace: stacktrace(error),\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    catalogService: (error as any)['catalogService'],\n  }\n}\n\nfunction errorContext(error: PlatformJavascriptError, context: ErrorContext = {}): PlatformReportBrowserErrorInput {\n  return Object.assign(\n    {\n      error,\n      sanitizedUrl: requestUri() || window.location.href,\n      readyState: document.readyState,\n      referrer: getSoftNavReferrer(),\n      timeSinceLoad: Math.round(Date.now() - loadTime),\n      user: pageUser() || undefined,\n      bundler,\n      ui: Boolean(document.querySelector('meta[name=\"ui\"]')),\n    },\n    context,\n  )\n}\n\nexport function stacktrace(error: Error): PlatformStackframe[] {\n  return parse(error.stack || '').map(frame => ({\n    filename: frame.file || '',\n    function: String(frame.methodName),\n    lineno: (frame.lineNumber || 0).toString(),\n    colno: (frame.column || 0).toString(),\n  }))\n}\n\nconst extensions = /(chrome|moz|safari)-extension:\\/\\//\n\n// Does this stack trace contain frames from browser extensions?\nfunction isExtensionError(stack: PlatformStackframe[]): boolean {\n  return stack.some(frame => extensions.test(frame.filename) || extensions.test(frame.function))\n}\n\nexport function pageUser() {\n  const login = document.head?.querySelector<HTMLMetaElement>('meta[name=\"user-login\"]')?.content\n  if (login) return login\n\n  const clientId = getOrCreateClientId()\n  return `anonymous-${clientId}`\n}\n\nlet unloaded = false\nssrSafeWindow?.addEventListener('pageshow', () => (unloaded = false))\nssrSafeWindow?.addEventListener('pagehide', () => (unloaded = true))\n\nfunction reportable() {\n  return !unloaded && !extensionErrors && errorsReported < 10 && isSupported()\n}\n\nif (typeof BroadcastChannel === 'function') {\n  const sharedWorkerErrorChannel = new BroadcastChannel('shared-worker-error')\n  sharedWorkerErrorChannel.addEventListener('message', event => {\n    // SharedWorker will emit a formatted error\n    reportError(event.data.error)\n  })\n}\n\nconst ignoredErrorMessages = [\n  'Object Not Found Matching Id', // from Microsoft Outlook SafeLink crawler\n  'Not implemented on this platform', // LastPass Safari extension\n  `provider because it's not your default extension`, // MetaMask extension\n]\n\n/**\n * We see a fair number of \"errors\" which are not actually Error objects. This function will return true if the\n * error is one of these known non-Error types and has content which we know can safely be ignored.\n * Most of these errors come from specific browsers or extensions which we can't control, so we just ignore them.\n * @param error An error that is not an Error object\n * @returns boolean\n */\nfunction isIgnoredNonError(error: unknown) {\n  if (!error || typeof error === 'boolean' || typeof error === 'number') {\n    // Rejected with a type that is not useful to report. Just ignore it.\n    return true\n  } else if (typeof error === 'string') {\n    // rejected with a string. See if it's a known error that we can ignore\n    if (ignoredErrorMessages.some(message => error.includes(message))) {\n      return true\n    }\n  } else if (\n    typeof error === 'object' &&\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    typeof (error as any).message === 'string' &&\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    typeof (error as any).code === 'number'\n  ) {\n    // We see an object like {\"message\":\"Not connected\",\"code\":4900} from some extension, likely MetaMask. Ignore these\n    return true\n  }\n\n  return false\n}\n","import {type Variables, type GraphQLResponse, stableCopy, type GraphQLResponseWithoutData} from 'relay-runtime'\nimport type {Sink} from 'relay-runtime/lib/network/RelayObservable'\nimport {getInsightsUrl, reportTraceData} from '@github-ui/internal-api-insights'\nimport {verifiedFetch} from '@github-ui/verified-fetch'\nimport {ssrSafeWindow} from '@github-ui/ssr-utils'\n// eslint-disable-next-line no-restricted-imports\nimport {reportError} from '@github-ui/failbot'\n\ntype Json = string | number | boolean | null | {[property: string]: Json} | Json[]\n\ntype JsonRoot = {[property: string]: Json}\n\nexport type GraphQLError = {type: string; message: string; path: Array<string | number>}\ntype GraphQLSuccessfulResult = {\n  data: JsonRoot\n  timestamp?: number\n  extensions?: Record<string, Record<string, JsonRoot>>\n}\ntype GraphQLErrorResult = {\n  errors: GraphQLError[]\n  data?: JsonRoot\n  timestamp?: number\n  extensions: Record<string, string>\n}\n\ntype ErrorTypeCallbacks = Record<string, () => void>\nexport type ErrorCallbacks = Record<number, ErrorTypeCallbacks>\n\n// \"SERVICE_UNAVAILABLE\" are availability issues. It is allowed as we expect the app code to handle it\nconst ALLOWED_ERRORS = ['SAML', 'SERVICE_UNAVAILABLE']\n// For some errors, we want to allow them in certain contexts and let the app handle them\nconst CONDITIONAL_ALLOWED_ERRORS: Record<string, string[]> = {\n  FORBIDDEN: ['SAML error'],\n  AUTHENTICATION: ['Couldnâ€™t authenticate you'],\n}\n\nexport const IssuesShowRegex = new RegExp(/^\\/[\\w-_]*\\/[\\w-_]*\\/issues\\/\\d*$/)\n\nexport type GraphQLResult = GraphQLSuccessfulResult | GraphQLErrorResult\nexport type GraphQLSubscriptionResult = {subscriptionId: string | null; response: GraphQLResponse}\n\nfunction validateNoErrors(\n  decoded: GraphQLResult,\n  requestId: string,\n  persistedQueryId: string,\n  observer?: Sink<GraphQLResponse>,\n): GraphQLSuccessfulResult {\n  removeAllowedErrors(requestId, decoded)\n  if ('errors' in decoded && decoded.errors.length) {\n    const formatted = decoded.errors\n      .map(error => `GraphQL error: ${error.type}: ${error.message} (path: ${error.path})`)\n      .join(', ')\n    const error = new ValidationError(\n      `${formatted} (Persisted query id: ${persistedQueryId})`,\n      {cause: decoded.errors},\n      decoded.extensions?.query_owning_catalog_service,\n    )\n    if (observer) {\n      reportError(error)\n      observer.error(error)\n    } else {\n      throw error\n    }\n  }\n  if (!('data' in decoded)) {\n    const error = new Error(`Expected data property in response: ${JSON.stringify(decoded)}`)\n    if (observer) {\n      reportError(error)\n      observer.error(error)\n    } else {\n      throw error\n    }\n  }\n  return decoded as GraphQLSuccessfulResult\n}\n\nclass ValidationError extends Error {\n  catalogService: string | undefined\n  constructor(message: string, options: ErrorOptions, catalogService?: string) {\n    super(message, options)\n    this.catalogService = catalogService\n  }\n}\n\nasync function assertNoHttpErrors(response: Response): Promise<void> {\n  // 404 is handled by GraphQL\n  if (response.status >= 400 && response.status !== 404) {\n    const text = await response.text()\n    throw new Error(`HTTP error (${response.status}): ${text}`)\n  }\n}\n\nfunction removeAllowedErrors(requestId: string, decoded: GraphQLResult): GraphQLResult {\n  if ('errors' in decoded) {\n    decoded.errors\n      .filter(\n        error =>\n          ALLOWED_ERRORS.includes(error.type) || !!CONDITIONAL_ALLOWED_ERRORS[error.type]?.includes(error.message),\n      )\n      .map(error => {\n        // eslint-disable-next-line no-console\n        console.error(\n          `Failed to fetch data. Please use this request ID when contacting support: ${requestId} Error: ${error.type}: ${error.message} (path: ${error.path})`,\n        )\n      })\n\n    decoded.errors = decoded.errors.filter(\n      error => !ALLOWED_ERRORS.includes(error.type) && !CONDITIONAL_ALLOWED_ERRORS[error.type]?.includes(error.message),\n    )\n  }\n  return decoded\n}\n\n// Fetch GraphQL from the server and return a decoded result.\nexport default async function fetchGraphQL(\n  persistedQueryId: string,\n  variables: Variables,\n  method: 'GET' | 'POST' = 'GET',\n  baseUrl?: string,\n  enabledFeatures?: {[key: string]: boolean},\n  errorCallbacks?: ErrorCallbacks,\n  observer?: Sink<GraphQLResponse>,\n): Promise<GraphQLResponse> {\n  const result = await fetchGraphQLWithSubscription(\n    persistedQueryId,\n    variables,\n    method,\n    {\n      isSubscription: false,\n      scope: undefined,\n    },\n    baseUrl,\n    enabledFeatures,\n    errorCallbacks,\n    observer,\n  )\n  return result.response\n}\n\n// Fetch GraphQL from the server and return a response promise along with an\n// optional subscriptionId if the query is a subscription.\nexport async function fetchGraphQLWithSubscription(\n  persistedQueryId: string,\n  variables: Variables,\n  method: 'GET' | 'POST' = 'POST',\n  options: {\n    isSubscription?: boolean\n    subscriptionTopic?: string\n    dispatchTime?: number\n    scopeObject?: Record<string, unknown>\n    scope?: string\n  } = {},\n  baseUrl?: string,\n  enabledFeatures?: {[key: string]: boolean},\n  errorCallbacks?: ErrorCallbacks,\n  observer?: Sink<GraphQLResponse>,\n): Promise<GraphQLSubscriptionResult> {\n  const canonicalizedPayload = JSON.stringify(\n    // stableCopy will alphabetize the keys in the variable payload.\n    // Necessary to ensure a match against early-hinted/preloaded requests.\n    stableCopy({\n      query: persistedQueryId,\n      variables,\n      ...(options.scopeObject ? {scopeObject: options.scopeObject} : {}),\n    }),\n  )\n\n  const {isSubscription, scope, subscriptionTopic, dispatchTime} = options\n\n  const url = constructUrl(\n    method,\n    encodeURIComponent(canonicalizedPayload),\n    isSubscription,\n    subscriptionTopic,\n    scope,\n    dispatchTime,\n    baseUrl,\n  )\n  let subscriptionId = null\n\n  try {\n    const {\n      subscriptionId: currentSubscriptionId,\n      requestId,\n      json,\n      status,\n    } = await getGraphQLQuery(url, method, canonicalizedPayload, enabledFeatures)\n    subscriptionId = currentSubscriptionId\n    if (errorCallbacks && json.errors) {\n      const callbacks = errorCallbacks[status]\n      if (callbacks) {\n        for (const error of json.errors) {\n          const callback = callbacks[error.type]\n          callback?.()\n        }\n      }\n    }\n    const cleaned = validateNoErrors(json as GraphQLResult, requestId, persistedQueryId, observer)\n    if (cleaned) {\n      reportTraceData(cleaned)\n    }\n    return {subscriptionId, response: cleaned}\n  } catch (error) {\n    if (observer) {\n      reportError(error)\n      observer.error(error as Error)\n      const errorResponse = {\n        errors: [{message: 'An error occurred while fetching data. Please try again later.'}],\n        extensions: {},\n      } as GraphQLResponseWithoutData\n      return {subscriptionId, response: errorResponse}\n    } else {\n      throw error\n    }\n  }\n}\n\nfunction constructUrl(\n  method: 'GET' | 'POST',\n  content: string,\n  isSubscription?: boolean,\n  subscriptionTopic?: string,\n  scope?: string,\n  dispatchTime?: number,\n  baseUrl = '/_graphql',\n) {\n  const queryParameters = []\n  if (method === 'GET') {\n    queryParameters.push(`body=${content}`)\n  }\n  if (isSubscription) {\n    queryParameters.push('subscription=1')\n  }\n  if (scope) {\n    queryParameters.push(`scope=${encodeURIComponent(scope)}`)\n  }\n  if (subscriptionTopic) {\n    queryParameters.push(`subscriptionTopic=${encodeURIComponent(subscriptionTopic)}`)\n  }\n  if (dispatchTime) {\n    queryParameters.push(`dispatchTime=${encodeURIComponent(dispatchTime)}`)\n  }\n\n  // grab and forward any feature flags from the URL\n  if (ssrSafeWindow) {\n    const url = new URL(ssrSafeWindow.location.href, ssrSafeWindow.location.origin)\n    const features = url.searchParams.get('_features')\n    if (features) {\n      queryParameters.push(`_features=${features}`)\n    }\n  }\n\n  return queryParameters.length > 0 ? `${baseUrl}?${queryParameters.join('&')}` : baseUrl\n}\n\nasync function getGraphQLQuery(url: string, method: string, body?: string, enabledFeatures?: {[key: string]: boolean}) {\n  const effectiveUrl = getInsightsUrl(url)\n  return getGraphQLData(effectiveUrl, method, body, enabledFeatures)\n}\n\nasync function getGraphQLData(url: string, method: string, body?: string, enabledFeatures?: {[key: string]: boolean}) {\n  let httpResponse: Response\n\n  const bodyInit = body ? {body} : undefined\n\n  const headers: {[key: string]: string} = {}\n  if (enabledFeatures?.issues_react_perf_test) {\n    headers['X-LUC-Environment'] = 'issues'\n  }\n\n  headers['X-Requested-With'] = 'XMLHttpRequest'\n\n  if (method === 'GET') {\n    httpResponse = await fetch(url, {\n      method,\n      cache: 'no-cache',\n      credentials: 'include',\n      headers,\n    })\n  } else {\n    httpResponse = await verifiedFetch(url, {\n      method,\n      headers: {\n        Accept: 'application/json',\n        ...headers,\n      },\n      ...bodyInit,\n    })\n  }\n\n  await assertNoHttpErrors(httpResponse)\n  const json = await httpResponse.json()\n  const subscriptionId = httpResponse.headers.get('X-Subscription-ID')\n  const requestId = httpResponse.headers.get('X-Github-Request-Id') || ''\n  const status = httpResponse.status\n\n  return {subscriptionId, requestId, json, status}\n}\n","import {ssrSafeWindow, ssrSafeLocation} from '@github-ui/ssr-utils'\n\n// TODO: do not export those constants and instead provide functions to push and read data\nexport const TraceDataKey = 'GraphQLTraces'\nexport const TraceDataRefreshCallbackKey = 'GraphQLTracingRefresh'\n\nexport const disabledClusters = getDisabledClusters()\n\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nexport function reportTraceData(json: any) {\n  if (!ssrSafeWindow) return\n  if (!isTracingEnabled()) return\n  if (!json) return\n\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  const rootWindowContent = ssrSafeWindow as {[key: string]: any} | undefined\n\n  if (rootWindowContent && !rootWindowContent[TraceDataKey]) {\n    rootWindowContent[TraceDataKey] = []\n  }\n\n  if (rootWindowContent && json['__trace']) {\n    rootWindowContent[TraceDataKey].push(json['__trace'])\n    if (typeof rootWindowContent[TraceDataRefreshCallbackKey] === 'function') {\n      rootWindowContent[TraceDataRefreshCallbackKey]()\n    }\n  }\n}\n\nexport function isTracingEnabled() {\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  const rootWindowContent = ssrSafeWindow as {[key: string]: any} | undefined\n\n  return (\n    new URLSearchParams(ssrSafeLocation.search).get('_tracing') === 'true' ||\n    (rootWindowContent && rootWindowContent[TraceDataKey] !== undefined)\n  )\n}\n\nfunction clustersDisabled() {\n  return disabledClusters.length > 0\n}\n\nexport function getInsightsUrl(url: string) {\n  if (!isTracingEnabled() && !clustersDisabled()) return url\n\n  const urlObject = new URL(url, ssrSafeLocation.origin)\n\n  if (isTracingEnabled()) {\n    urlObject.searchParams.set('_tracing', 'true')\n  }\n\n  if (clustersDisabled()) {\n    urlObject.searchParams.set('disable_clusters', disabledClusters.join(','))\n  }\n\n  return urlObject.pathname + urlObject.search\n}\n\nfunction getDisabledClusters() {\n  return decodeURIComponent(new URLSearchParams(ssrSafeLocation.search).get('disable_clusters') || '')\n    .split(',')\n    .filter(c => c !== '')\n}\n\nexport function isClusterDisabled(cluster: string) {\n  return disabledClusters.indexOf(cluster) > -1\n}\n\nexport function toggleClusterState(cluster: string) {\n  const index = disabledClusters.indexOf(cluster)\n\n  if (index > -1) {\n    disabledClusters.splice(index, 1)\n  } else {\n    disabledClusters.push(cluster)\n  }\n\n  const params = new URLSearchParams(ssrSafeLocation.search)\n  params.set('disable_clusters', disabledClusters.join(','))\n\n  const url = ssrSafeLocation\n  url.search = params.toString()\n}\n","import type {RequestParameters, GraphQLResponse, Variables} from 'relay-runtime'\nimport {Observable} from 'relay-runtime'\nimport {fetchGraphQLWithSubscription, type GraphQLSubscriptionResult} from '@github-ui/fetch-graphql'\nimport {getSession} from '@github-ui/alive'\nimport {connectAliveSubscription} from '@github-ui/alive/connect-alive-subscription'\n// eslint-disable-next-line no-restricted-imports\nimport {reportError} from '@github-ui/failbot'\n\ntype SubscriptionMetadata = {\n  subscription_topic: string\n  dispatch_time: number\n  scope_object?: Record<string, unknown>\n}\n\n/**\n * Function to configure the Relay store so that it can handle subscriptions\n */\nexport function subscribe(\n  operation: RequestParameters,\n  variables: Variables,\n  preloadedSubscriptions: Map<string, Map<string, GraphQLSubscriptionResult>> = new Map(),\n): Observable<GraphQLResponse> {\n  const persistedQueryId = operation.id\n\n  return Observable.create<GraphQLResponse>(observer => {\n    let unsubscribeFromAlive = () => {}\n    let closed = false\n\n    async function subscribeToAlive() {\n      // Connect the subscription\n      if (!persistedQueryId) {\n        throw new Error('unexpected operation with no id!')\n      }\n      const scope = operation.metadata?.scope as string | undefined\n      const preloadedSubscription = getPreloadedSubscriptions(\n        persistedQueryId,\n        variables,\n        scope,\n        preloadedSubscriptions,\n      )\n      let channelName = null\n\n      if (preloadedSubscription) {\n        channelName = preloadedSubscription.subscriptionId\n        if (preloadedSubscription.response) {\n          observer.next(preloadedSubscription.response)\n        }\n      } else {\n        const fetchedSubscription = await fetchGraphQLWithSubscription(persistedQueryId, variables, 'GET', {\n          isSubscription: true,\n          scope,\n        })\n        channelName = fetchedSubscription.subscriptionId\n        if (fetchedSubscription.response) {\n          observer.next(fetchedSubscription.response)\n        }\n      }\n      try {\n        const aliveSession = await getSession()\n        if (closed) {\n          // observable was closed before graphql fetch returned\n          // this is fine, we just don't subscribe to the channel on the alive side\n          return\n        }\n\n        const resp = connectAliveSubscription<SubscriptionMetadata>(\n          aliveSession,\n          channelName,\n          async ({scope_object, subscription_topic, dispatch_time}) => {\n            try {\n              const {response: updateResponse} = await fetchGraphQLWithSubscription(\n                persistedQueryId,\n                {...variables},\n                'GET',\n                {\n                  isSubscription: true,\n                  scopeObject: scope_object,\n                  subscriptionTopic: subscription_topic,\n                  dispatchTime: dispatch_time,\n                  scope,\n                },\n              )\n              if (updateResponse) {\n                observer.next(updateResponse)\n              }\n            } catch (e) {\n              reportError(e, {\n                message: `Error in fetching update for ${persistedQueryId} with variables ${JSON.stringify(variables)}`,\n              })\n            }\n          },\n        )\n        if (resp?.unsubscribe) {\n          unsubscribeFromAlive = resp.unsubscribe\n        }\n      } catch (e) {\n        // @ts-expect-error catch blocks are bound to `unknown` so we need to validate the type before using it\n        observer.error(e)\n      }\n    }\n\n    subscribeToAlive()\n\n    // Return object with cleanup function\n    // per https://github.com/facebook/relay/blob/aadd54d373cea6e096b95985ad0cdf298d7a7374/packages/relay-runtime/network/RelayObservable.js#L20-L23\n    return {\n      get closed() {\n        return closed\n      },\n      unsubscribe() {\n        closed = true\n        unsubscribeFromAlive()\n      },\n    }\n  })\n}\n\n/**\n * @param preloadedSubscriptions Map of persisted query ID to preloaded subscription responses for that query. Each\n * response should be keyed by a JSON-stringified object. This object is a map of variable names to expected variables,\n * for example: `{\"issueId\": \"XYZ\"}`. The special variable name `\"$scope\"` can be used to match the `scope`. Extra\n * entries in the `variables` object that are not present in the JSON string will be ignored.\n */\nfunction getPreloadedSubscriptions(\n  persistedQueryId: string,\n  variables: Variables,\n  scope: string | undefined,\n  preloadedSubscriptions: Map<string, Map<string, GraphQLSubscriptionResult>>,\n): GraphQLSubscriptionResult | undefined {\n  const preloadedSubscription = preloadedSubscriptions.get(persistedQueryId)\n  if (!preloadedSubscription) return undefined\n\n  subscriptionsLoop: for (const [variablesMatcher, subscription] of preloadedSubscription) {\n    for (const [name, expectedValue] of Object.entries(JSON.parse(variablesMatcher)))\n      if ((name === '$scope' && scope !== expectedValue) || variables[name] !== expectedValue)\n        continue subscriptionsLoop\n\n    return subscription\n  }\n}\n","import {ROOT_TYPE} from 'relay-runtime'\nimport type {MissingFieldHandler} from 'relay-runtime/lib/store/RelayStoreTypes'\n\n// By using these missing field handlers, we can avoid making unnecesssary network requests for the following queries:\n//\n// - node(id: $id)\n// - nodes(ids: $ids)\n//\n// By default these queries will hit the network, regardless of whether you have the data in the store already.\n// By using these missing field handlers relay will query the relay store for the node when this field is queried.\n// If the node(s) do not exist (or they are missing data) in the store relay will fall back to making the request\n// to the network (That is unless you are using `store-only`). One can override this behavior by passing in a\n// fetchPolicy of 'network-only', which will result in bypassing the local store.\n//\n// TLDR: All these handlers do is tell relay: when you see a query with the node/nodes field name,\n// look in the store via this ID. All other behavior stays the same.\n//\n// Documentation: https://relay.dev/docs/guided-tour/reusing-cached-data/filling-in-missing-data/\nexport const missingFieldHandlers: MissingFieldHandler[] = [\n  {\n    kind: 'linked',\n    handle(field, record, argValues) {\n      if (record != null && record.getType() === ROOT_TYPE && field.name === 'node' && argValues.hasOwnProperty('id')) {\n        // If field is node(id: $id), look up the record by the value of $id\n        return argValues.id\n      }\n      return undefined\n    },\n  },\n  {\n    kind: 'pluralLinked',\n    handle(field, record, argValues) {\n      if (\n        record != null &&\n        record.getType() === ROOT_TYPE &&\n        field.name === 'nodes' &&\n        argValues.hasOwnProperty('ids')\n      ) {\n        // If field is nodes(ids: $id), look up the records by the value of $ids\n        return argValues.ids\n      }\n    },\n  },\n]\n","import {unstable_batchedUpdates} from 'react-dom'\nimport type {Environment as RelayEnvironment} from 'react-relay'\nimport type {\n  RequestParameters,\n  Variables,\n  TaskScheduler,\n  CacheConfig,\n  INetwork,\n  GraphQLTaggedNode,\n  OperationType,\n  GraphQLResponse,\n} from 'relay-runtime'\nimport {\n  Environment,\n  Network,\n  Observable,\n  RecordSource,\n  Store,\n  createOperationDescriptor,\n  fetchQuery,\n  generateClientID,\n  getRequest,\n} from 'relay-runtime'\nimport type {ErrorCallbacks, GraphQLResult, GraphQLSubscriptionResult} from '@github-ui/fetch-graphql'\nimport fetchGraphQL from '@github-ui/fetch-graphql'\nimport {missingFieldHandlers} from './missing-field-handlers'\nimport {subscribe} from './alive-subscription'\nimport {scheduleLowPriority} from './scheduler'\nimport {wasServerRendered, IS_BROWSER} from '@github-ui/ssr-utils'\nimport type {Sink} from 'relay-runtime/lib/network/RelayObservable'\n\ntype QueryId = string\ntype SerializedParams = string\ntype ParamsToResult = Map<SerializedParams, GraphQLResult>\ntype fetchRelayInternalType = {\n  params: RequestParameters\n  variables: Variables\n  observer: Sink<GraphQLResponse>\n  ssrPreloadedQueries?: Map<QueryId, ParamsToResult>\n  baseUrl?: string\n  emitWarning?: (message: string) => void\n  enabledFeatures: FeatureFlagMap\n  maxAge?: number\n  errorCallbacks?: ErrorCallbacks\n}\n\nexport type FeatureFlagMap = {\n  [key: string]: boolean\n}\n\n// Wrapped helper that first tries to fetch from preloaded data in the JSON\n// island and falls back to the API if nothing is there.\nexport function fetchRelayInternal({\n  params,\n  variables,\n  ssrPreloadedQueries,\n  baseUrl,\n  emitWarning,\n  enabledFeatures,\n  maxAge,\n  errorCallbacks,\n  observer,\n}: fetchRelayInternalType) {\n  if (!params.id) throw new Error('params has no id property!')\n\n  // try to get the query from the environment options via the preloaded queries\n  if (params.id && ssrPreloadedQueries) {\n    const variablesKey = JSON.stringify(variables)\n    const result = ssrPreloadedQueries.get(params.id)?.get(variablesKey)\n\n    const currentTimestamp = Math.floor(new Date().getTime() / 1000)\n    const responseTimestamp = result?.timestamp\n\n    const isStale = maxAge && responseTimestamp ? currentTimestamp > responseTimestamp + maxAge : false\n    if (result) {\n      // we have a preloaded query notifying the observer with the result\n      observer.next(result)\n      // if the query is not stale we can complete the observer\n      // otherwise we need to fetch the query from the server to make sure it is up to date\n      if (!isStale) {\n        observer.complete()\n        return\n      }\n    }\n\n    if (\n      params.metadata?.isRelayRouteRequest &&\n      wasServerRendered() &&\n      emitWarning &&\n      (process.env.NODE_ENV === 'development' || process.env.NODE_ENV === 'test')\n    ) {\n      if (ssrPreloadedQueries.size === 0) {\n        emitWarning(\n          'Relay SSR Error: There where no preloaded queries found. \\n' +\n            'More context can be found here: https://thehub.github.com/support/ecosystem/api-graphql/training/graphql-relay/#ssr-error-1',\n        )\n      } else {\n        const queryMap = ssrPreloadedQueries.get(params.id)\n        if (!queryMap) {\n          emitWarning(\n            `Relay SSR Error: There where no preloaded queries found for ${params.id} \\n` +\n              'More context can be found here: https://thehub.github.com/support/ecosystem/api-graphql/training/graphql-relay/#ssr-error-2',\n          )\n        } else {\n          emitWarning(\n            `Relay SSR Error: There where no preloaded queries found for ${params.id} with variables ${variablesKey} \\n` +\n              `The persisted query (${params.id}) contains preloaded queries for the following set of variables: \\n` +\n              `${Array.from(queryMap.keys()).join('\\n')} \\n` +\n              'More context can be found here: https://thehub.github.com/support/ecosystem/api-graphql/training/graphql-relay/#ssr-error-3',\n          )\n        }\n      }\n    }\n  }\n\n  const method = params.operationKind === 'mutation' ? 'POST' : 'GET'\n  // only fetch from the API if we are in the browser\n  if (IS_BROWSER) {\n    // return the promise\n    return fetchGraphQL(params.id, variables, method, baseUrl, enabledFeatures, errorCallbacks, observer)\n  }\n}\n\n// this fixes a bug in relay where children can be re-rendered with deleted relay data\n// before the parent re-renders, causing a crash. This is a workaround provided by the relay team\n// in https://github.com/facebook/relay/issues/3514\nconst RelayScheduler: TaskScheduler = {\n  cancel: () => false,\n  schedule: task => {\n    unstable_batchedUpdates(task)\n    return ''\n  },\n}\n\ntype ServerPreloadedData<T> = Map<string, T>\nexport type ServerPreloadedSubscription = ServerPreloadedData<GraphQLSubscriptionResult>\nexport type ServerPreloadedQuery = ServerPreloadedData<GraphQLResult>\n\nexport class SSRNetwork {\n  relayNetwork: INetwork\n  ssrPreloadedData: Map<string, ServerPreloadedQuery>\n  preloadedSubscriptions: Map<string, ServerPreloadedSubscription>\n  warningsShown: Set<string>\n  enabled_features: FeatureFlagMap\n  maxAge?: number\n  errorCallbacks?: ErrorCallbacks\n  constructor(\n    ssrPreloadedData: Map<string, ServerPreloadedQuery>,\n    enabled_features: FeatureFlagMap = {},\n    preloadedSubscriptions: Map<string, ServerPreloadedSubscription>,\n    baseUrl?: string,\n    maxAge?: number,\n    errorCallbacks?: ErrorCallbacks,\n  ) {\n    this.ssrPreloadedData = ssrPreloadedData\n    this.enabled_features = enabled_features\n    this.preloadedSubscriptions = preloadedSubscriptions\n    this.warningsShown = new Set()\n    this.maxAge = maxAge\n    this.errorCallbacks = errorCallbacks\n    this.relayNetwork = Network.create(\n      (params: RequestParameters, variables: Variables) => {\n        return Observable.create(observer => {\n          const response = fetchRelayInternal({\n            params,\n            variables,\n            ssrPreloadedQueries: this.ssrPreloadedData,\n            baseUrl,\n            emitWarning: (message: string) => {\n              if (!this.warningsShown.has(message)) {\n                this.warningsShown.add(message)\n                // eslint-disable-next-line no-console\n                console.warn(message)\n              }\n            },\n            enabledFeatures: this.enabled_features,\n            maxAge,\n            errorCallbacks: this.errorCallbacks,\n            observer,\n          })\n\n          if (response instanceof Promise) {\n            // eslint-disable-next-line github/no-then\n            response.then(resolved => {\n              if (!Array.isArray(resolved)) {\n                if ('extensions' in resolved && resolved.extensions && resolved.extensions.subscriptions) {\n                  const subscriptions = resolved.extensions.subscriptions\n                  for (const queryId in subscriptions) {\n                    if (!this.preloadedSubscriptions.has(queryId)) {\n                      this.preloadedSubscriptions.set(queryId, new Map())\n                    }\n                    for (const variablesKey in subscriptions[queryId]) {\n                      this.preloadedSubscriptions.get(queryId)?.set(variablesKey, subscriptions[queryId][variablesKey])\n                    }\n                  }\n                }\n              }\n\n              observer.next(resolved)\n              observer.complete()\n            })\n          }\n        })\n      },\n      (params: RequestParameters, variables: Variables) => {\n        return subscribe(params, variables, this.preloadedSubscriptions)\n      },\n    )\n  }\n\n  execute(\n    request: RequestParameters,\n    variables: Variables,\n    cacheConfig: CacheConfig,\n    // uploadables: UploadableMap | undefined = undefined,\n  ) {\n    return this.relayNetwork.execute(request, variables, cacheConfig)\n  }\n\n  getPreloadedSubscriptions() {\n    return this.preloadedSubscriptions\n  }\n}\n\n// Relay environment with missingFieldHandlers. This is used mainly for controlled rollout of missingFieldHandlers.\n// Once we gain confidence in these changes we will upstream to the main Environment instance.\nexport const relayEnvironmentWithMissingFieldHandlerForNode = (\n  baseUrl?: string,\n  errorCallbacks?: ErrorCallbacks,\n): Environment => {\n  const customNetwork = new SSRNetwork(new Map(), {}, new Map(), baseUrl, undefined, errorCallbacks)\n  const localEnvironment = new Environment({\n    scheduler: RelayScheduler,\n    store: new Store(new RecordSource(), {\n      // Keep a buffer of at most 50 released queries to avoid them being disposed. Helpful for back forward\n      // navigation in short succession alleviates the need for a query to go out to the network if a component\n      // is remounted quickly.\n      gcReleaseBufferSize: 50,\n      // Keep stale entries around for a maximum of 5 mins.\n      queryCacheExpirationTime: 5 * 60 * 1e3,\n      // Don't garbage collect immediately, wait at least 10s before performing garbage collection.\n      // See: https://relay.dev/docs/guided-tour/reusing-cached-data/presence-of-data/#gc-scheduler\n      gcScheduler: scheduleLowPriority,\n    }),\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    getDataID: (fieldValue: {[key: string]: any}, typeName: string) => {\n      // This is basically the default (defaultGetDataID.js) implementation\n      // Special handling for ProjectV2SingleSelectFieldOption due to it having a non-unique id field\n      if (typeName === 'Viewer') {\n        return fieldValue.id == null ? generateClientID('client:root', 'viewer') : fieldValue.id\n      }\n      if (typeName === 'ProjectV2SingleSelectFieldOption') {\n        const idFields: Array<string | number> = []\n        if (fieldValue.id) idFields.push(fieldValue.id)\n        if (fieldValue.name) idFields.push(fieldValue.name)\n        if (fieldValue.color) idFields.push(fieldValue.color)\n        if (fieldValue.description) idFields.push(getHash(fieldValue.description))\n        return idFields.join('_')\n      }\n      return fieldValue.id\n    },\n    network: customNetwork,\n    missingFieldHandlers,\n  })\n\n  localEnvironment.options = {\n    baseUrl,\n    getPreloadedSubscriptions: () => {\n      return customNetwork.getPreloadedSubscriptions()\n    },\n  }\n  return localEnvironment\n}\n\nfunction getHash(input: string) {\n  let hash = 0\n  if (input.length === 0) return hash\n  for (let i = 0; i < input.length; i++) {\n    const chr = input.charCodeAt(i)\n    hash = (hash << 5) - hash + chr\n    hash |= 0\n  }\n  return hash\n}\n\nexport function clientSideRelayFetchQueryRetained<T extends OperationType>({\n  environment,\n  query,\n  variables = {},\n}: {\n  environment: RelayEnvironment\n  query: GraphQLTaggedNode\n  variables?: Record<string, unknown>\n}) {\n  const queryRequest = getRequest(query)\n  const queryDescriptor = createOperationDescriptor(queryRequest, variables)\n  environment.retain(queryDescriptor)\n  return fetchQuery<T>(environment, query, variables, {fetchPolicy: 'store-or-network'})\n}\n","import {unstable_scheduleCallback, unstable_LowPriority} from 'scheduler'\n\n/**\n * Executes the callback at least 10s after this method runs. And never before high priority work, like user\n * interactions, scroll events and so forth.\n *\n * @see https://github.com/facebook/react/blob/2655c9354d8e1c54ba888444220f63e836925caa/packages/scheduler/src/forks/Scheduler.js#L83\n *\n * @example\n *\n * ```ts\n * function performGarbageCollection() { }\n *\n * // Non IO blocking work\n * scheduleLowPriority(performGarbageCollection);\n * ```\n */\nexport function scheduleLowPriority(callback: () => void) {\n  return unstable_scheduleCallback(unstable_LowPriority, callback)\n}\n","import {ghTrustedTypes} from '@github-ui/trusted-types'\nimport {isStaff} from '@github-ui/stats'\nimport {TrustedTypesPolicyError, trustedTypesPolicy} from './policy'\n\nconst policyName = 'alive'\n\nexport class InvalidSourceRelError extends TrustedTypesPolicyError {}\nexport const alivePolicy = ghTrustedTypes.createPolicy(policyName, {\n  createScriptURL: (url: string) => {\n    return trustedTypesPolicy.apply({\n      policy: () => {\n        if (!isStaff()) return url\n        if (!url.startsWith('/')) throw new InvalidSourceRelError('Alive worker src URL must start with a slash')\n        return url\n      },\n      policyName,\n      fallback: url,\n      fallbackOnError: true,\n    })\n  },\n})\n","import {isFeatureEnabled} from '@github-ui/feature-flags'\nimport {sendStats} from '@github-ui/stats'\n// eslint-disable-next-line no-restricted-imports\nimport {reportError} from '@github-ui/failbot'\nimport dompurify from 'dompurify'\nimport {sendEvent} from '@github-ui/hydro-analytics'\n\nexport class TrustedTypesPolicyError extends Error {}\n\ninterface PolicyParam {\n  policy: () => string\n  policyName: string\n  fallback: string\n  fallbackOnError?: boolean\n  sanitize?: boolean // report-only mode for now\n  silenceErrorReporting?: boolean\n}\n\nfunction apply({\n  policy,\n  policyName,\n  fallback,\n  fallbackOnError = false,\n  sanitize,\n  silenceErrorReporting = false,\n}: PolicyParam): string {\n  try {\n    if (isFeatureEnabled('BYPASS_TRUSTED_TYPES_POLICY_RULES')) return fallback\n    sendStats({incrementKey: 'TRUSTED_TYPES_POLICY_CALLED', trustedTypesPolicyName: policyName}, false, 0.1)\n    const policyOutput = policy()\n    if (sanitize) {\n      new Promise(resolve => {\n        const startTime = window.performance.now()\n        const sanitized = dompurify.sanitize(policyOutput, {FORBID_ATTR: []})\n        const endTime = window.performance.now()\n        const executionTime = endTime - startTime\n        if (policyOutput.length !== sanitized.length) {\n          const err = new Error('Trusted Types policy output sanitized')\n          const stack = err.stack?.slice(0, 1000)\n          const output = policyOutput.slice(0, 250)\n          sendEvent('trusted_types_policy.sanitize', {\n            policyName,\n            output,\n            stack,\n            outputLength: policyOutput.length,\n            sanitizedLength: sanitized.length,\n            executionTime,\n          })\n          resolve(policyOutput)\n        }\n      })\n    }\n    return policyOutput\n  } catch (e) {\n    if (e instanceof TrustedTypesPolicyError) throw e\n    if (!silenceErrorReporting) reportError(e)\n    sendStats({incrementKey: 'TRUSTED_TYPES_POLICY_ERROR', trustedTypesPolicyName: policyName})\n    if (!fallbackOnError) throw e\n  }\n\n  return fallback\n}\n\nexport const trustedTypesPolicy = {apply}\n","/* eslint no-restricted-globals: ['off', '__TRUSTED_TYPE_POLICIES__'] */\nimport {ssrSafeDocument} from '@github-ui/ssr-utils'\nimport {sendStats} from '@github-ui/stats'\n\n/*\n * Tinyfill for trusted types\n */\n\ninterface GHTrustedTypePolicyOptions {\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  createHTML: (input: string, ...args: any[]) => string\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  createScript: (input: string, ...args: any[]) => string\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  createScriptURL: (input: string, ...args: any[]) => string\n}\n\ninterface GHTrustedTypePolicyWithName extends GHTrustedTypePolicyOptions {\n  name: string\n}\n\nfunction unimplemented(functionName: string) {\n  return () => {\n    throw new TypeError(`The policy does not implement the function ${functionName}`)\n  }\n}\n\nconst fallbacks = {\n  createHTML: unimplemented('createHTML'),\n  createScript: unimplemented('createScript'),\n  createScriptURL: unimplemented('createScriptURL'),\n}\n\nconst tinyfill = {\n  createPolicy: (name: string, rules: Partial<GHTrustedTypePolicyOptions>): GHTrustedTypePolicyWithName => ({\n    name,\n    ...fallbacks,\n    ...rules,\n  }),\n}\n\ntype TrustedTypesPolicies = Map<string, GHTrustedTypePolicyOptions>\n\ndeclare global {\n  // eslint-disable-next-line no-var\n  var trustedTypes: typeof tinyfill | undefined\n  // We need to store the policies in a global variable so that they accurately track the global policy store in the\n  // browser. This prevents false misses when there is more than one instance of this module loaded on the page.\n  // eslint-disable-next-line no-var\n  var __TRUSTED_TYPE_POLICIES__: TrustedTypesPolicies\n}\n\nconst registeredPolicies: TrustedTypesPolicies = (globalThis.__TRUSTED_TYPE_POLICIES__ ??= new Map())\n\n// eslint-disable-next-line compat/compat\nconst trustedTypes = globalThis.trustedTypes ?? tinyfill\n\nexport const ghTrustedTypes = {\n  createPolicy: (name: string, rules: Partial<GHTrustedTypePolicyOptions>): GHTrustedTypePolicyWithName => {\n    if (registeredPolicies.has(name)) {\n      sendStats({\n        incrementKey: 'TRUSTED_TYPES_POLICY_INITIALIZED_TWICE',\n      })\n      return registeredPolicies.get(name) as GHTrustedTypePolicyWithName\n    } else {\n      const policy = Object.freeze(trustedTypes.createPolicy(name, rules))\n      registeredPolicies.set(name, policy)\n      return policy\n    }\n  },\n}\n\n// This export is only for testing. Do not import in production code.\nexport const registeredPoliciesForTesting = registeredPolicies\nexport const tinyfillForTesting = tinyfill\n\n/*\n *\n * This is a temporary warning to indicate to hubbers that the following errors are expected and safe to ignore.\n *\n */\nlet hasWarnedHubberAboutTrustedTypes = false\n\nssrSafeDocument?.addEventListener('securitypolicyviolation', (e: SecurityPolicyViolationEvent) => {\n  if (e.violatedDirective === 'require-trusted-types-for' && !hasWarnedHubberAboutTrustedTypes) {\n    // eslint-disable-next-line no-console\n    console.warn(`Hi fellow Hubber!\n    You're probably seeing a Report Only Trusted Types error near this message. This is intended behaviour, staff-only,\n    does not impact application control flow, and is used solely for statistic collection. Unfortunately we\n    can't gather these statistics without adding the above warnings to your console. Sorry about that!\n    Feel free to drop by #prodsec-engineering if you have any additional questions about Trusted Types or CSP.`)\n    hasWarnedHubberAboutTrustedTypes = true\n  }\n})\n","/**\n * A Fetch function which will automatically add the correct headers for\n * making requests to GitHub application servers as long as the associated controller methods allow it.\n * Track down the associated controller method and confirm the controller includes\n * ApplicationController::VerifiedFetchDependency as well as `allow_verified_fetch only:`\n * to the relevant controller methods.\n *\n * ## Example\n *\n *     const onClick = async () => {\n *       const resp = await verifiedFetch('/foo', {method: 'POST'})\n *       if (resp.ok) console.log('The response was', await resp.text())\ntest.\n *     }\n */\nexport function verifiedFetch(path: string, init: RequestInit = {}): Promise<Response> {\n  assertRelativePathOrSameOrigin(path)\n\n  const headers: HeadersInit = {\n    ...init.headers,\n    'GitHub-Verified-Fetch': 'true',\n    'X-Requested-With': 'XMLHttpRequest',\n  }\n\n  return fetch(path, {...init, headers})\n}\n\nexport interface JSONRequestInit extends Omit<RequestInit, 'body'> {\n  body?: unknown\n}\n\nfunction assertRelativePathOrSameOrigin(path: string) {\n  if (process.env.NODE_ENV === 'test' && !window.location.origin) return\n  const url = new URL(path, window.location.origin)\n  if (url.origin !== window.location.origin) {\n    throw new Error('Can not make cross-origin requests from verifiedFetch')\n  }\n}\n\n/**\n * A Fetch function which will automatically add the correct headers for\n * making JSON requests\n *\n * Will also `JSON.stringify` the request body if provided.\n\n * ## Example\n *\n *     const onClick = async () => {\n *       const resp = await verifiedFetchJSON('/foo', {body: {foo: 'bar'}, method: 'POST'})\n *       if (resp.ok) console.log('The response was', await resp.json())\n *     }\n */\nexport function verifiedFetchJSON(path: string, init?: JSONRequestInit): Promise<Response> {\n  const initHeaders: HeadersInit = init?.headers ?? {}\n\n  const headers: HeadersInit = {\n    ...initHeaders,\n    Accept: 'application/json',\n    'Content-Type': 'application/json',\n  }\n\n  const body = init?.body ? JSON.stringify(init.body) : undefined\n\n  return verifiedFetch(path, {...init, body, headers})\n}\n\n/**\n * A Fetch function which will automatically add the GitHub-Is-React header for\n * making JSON requests. It will in turn call verifiedFetchJSON.\n *\n * Using this in React components to fetch data enables us to track these\n * requests in Datadog in the request.dist.referrer metric.\n */\nexport function reactFetch(path: string, init: RequestInit = {}): Promise<Response> {\n  const headers: HeadersInit = {\n    ...init.headers,\n    'GitHub-Is-React': 'true',\n  }\n\n  return verifiedFetch(path, {...init, headers})\n}\n\n/**\n * A Fetch function which will automatically add the GitHub-Is-React header for\n * making JSON requests. It will in turn call verifiedFetchJSON.\n *\n * Using this in React components to fetch data enables us to track these\n * requests in Datadog in the request.dist.referrer metric.\n */\nexport function reactFetchJSON(path: string, init?: JSONRequestInit): Promise<Response> {\n  const initHeaders: HeadersInit = init?.headers ?? {}\n\n  const headers: HeadersInit = {\n    ...initHeaders,\n    'GitHub-Is-React': 'true',\n  }\n\n  return verifiedFetchJSON(path, {...init, headers})\n}\n"],"names":["sessionPromise","notify","subscribers","channel","type","data","el","dispatchEvent","CustomEvent","bubbles","cancelable","detail","name","AliveSessionProxy","subscribe","subs","added","subscriptions","add","length","worker","port","postMessage","addedChannels","Set","map","topic","redundantPresenceChannels","reduce","redundantChannels","subscription","isPresenceChannel","has","size","requestPresence","Array","from","unsubscribeAll","removed","drain","unsubscribe","updatedPresenceChannels","presenceMetadata","removeSubscribers","sendPresenceMetadataUpdate","updatePresenceMetadata","metadataUpdates","updatedChannels","update","setMetadata","channelName","channelNames","updatesForSharedWorker","push","metadata","getChannelMetadata","online","offline","hangup","receive","event","debouncedNotify","notifyPresenceDebouncedByChannel","get","debounce","debouncedEvent","delete","set","constructor","src","url","refreshUrl","sessionId","notifier","SubscriptionSet","PresenceMetadataSet","Map","SharedWorker","onmessage","connect","workerSrc","document","head","querySelector","getAttribute","alivePolicy","createScriptURL","e","InvalidSourceRelError","href","session","createSession","isSafari","window","safeStorage","getItem","_","AliveSession","addEventListener","connectWhenReady","ready","getSession","connectAliveSubscription","aliveSession","callback","Topic","parse","aliveSubscription","subscriber","subscriptionEvent","BaseAliveSession","getUrlFromRefreshUrl","fetchRefreshUrl","shared","fetchJSON","token","post","response","fetch","headers","Accept","ok","json","status","csrf","method","mode","text","queryLast","selector","list","querySelectorAll","requestUri","location","protocol","host","pagePathname","locationOverride","content","pathname","pageQuery","stripParams","search","extraParams","meta","names","split","replace","extensionErrors","errorsReported","loadTime","Date","now","EXPECTED_NETWORK_ERROR_MESSAGES","isExpectedError","error","message","startsWith","reportError","context","isFeatureEnabled","Error","isIgnoredNonError","ignoredErrorMessages","some","includes","code","errorForStackTrace","serializedErrorValue","serializeNonError","JSON","stringify","report","errorContext","value","stacktrace","catalogService","undefined","formatError","unloaded","isSupported","stack","frame","extensions","test","filename","function","body","Object","assign","sanitizedUrl","readyState","referrer","getSoftNavReferrer","timeSinceLoad","Math","round","user","pageUser","login","clientId","getOrCreateClientId","bundler","ui","Boolean","file","String","methodName","lineno","lineNumber","toString","colno","column","ssrSafeWindow","BroadcastChannel","sharedWorkerErrorChannel","ALLOWED_ERRORS","CONDITIONAL_ALLOWED_ERRORS","FORBIDDEN","AUTHENTICATION","ValidationError","options","assertNoHttpErrors","fetchGraphQL","persistedQueryId","variables","baseUrl","enabledFeatures","errorCallbacks","observer","result","fetchGraphQLWithSubscription","isSubscription","scope","canonicalizedPayload","stableCopy","query","scopeObject","subscriptionTopic","dispatchTime","constructUrl","queryParameters","encodeURIComponent","features","URL","origin","searchParams","join","subscriptionId","currentSubscriptionId","requestId","getGraphQLQuery","errors","callbacks","cleaned","validateNoErrors","decoded","filter","console","path","formatted","cause","query_owning_catalog_service","reportTraceData","getGraphQLData","getInsightsUrl","httpResponse","issues_react_perf_test","cache","credentials","verifiedFetch","TraceDataKey","TraceDataRefreshCallbackKey","disabledClusters","decodeURIComponent","URLSearchParams","ssrSafeLocation","c","isTracingEnabled","rootWindowContent","clustersDisabled","urlObject","isClusterDisabled","cluster","indexOf","toggleClusterState","index","splice","params","operation","preloadedSubscriptions","id","Observable","create","unsubscribeFromAlive","closed","subscribeToAlive","preloadedSubscription","getPreloadedSubscriptions","subscriptionsLoop","variablesMatcher","expectedValue","entries","next","fetchedSubscription","resp","scope_object","subscription_topic","dispatch_time","updateResponse","missingFieldHandlers","kind","handle","field","record","argValues","getType","ROOT_TYPE","hasOwnProperty","ids","RelayScheduler","cancel","schedule","task","unstable_batchedUpdates","SSRNetwork","execute","request","cacheConfig","relayNetwork","ssrPreloadedData","enabled_features","maxAge","warningsShown","Network","fetchRelayInternal","ssrPreloadedQueries","emitWarning","variablesKey","currentTimestamp","floor","getTime","responseTimestamp","timestamp","complete","isRelayRouteRequest","wasServerRendered","operationKind","IS_BROWSER","warn","Promise","then","resolved","isArray","queryId","relayEnvironmentWithMissingFieldHandlerForNode","customNetwork","localEnvironment","Environment","scheduler","store","Store","RecordSource","gcReleaseBufferSize","queryCacheExpirationTime","gcScheduler","scheduleLowPriority","getDataID","fieldValue","typeName","generateClientID","idFields","color","description","getHash","input","hash","i","charCodeAt","network","clientSideRelayFetchQueryRetained","environment","queryRequest","getRequest","queryDescriptor","createOperationDescriptor","retain","fetchQuery","fetchPolicy","unstable_scheduleCallback","unstable_LowPriority","policyName","TrustedTypesPolicyError","ghTrustedTypes","createPolicy","trustedTypesPolicy","apply","policy","isStaff","fallback","fallbackOnError","sanitize","silenceErrorReporting","sendStats","incrementKey","trustedTypesPolicyName","policyOutput","resolve","startTime","performance","sanitized","dompurify","FORBID_ATTR","endTime","err","slice","output","sendEvent","outputLength","sanitizedLength","executionTime","globalThis","unimplemented","functionName","fallbacks","createHTML","createScript","registeredPolicies","__TRUSTED_TYPE_POLICIES__","trustedTypes","rules","freeze","hasWarnedHubberAboutTrustedTypes","ssrSafeDocument","violatedDirective","init","assertRelativePathOrSameOrigin","verifiedFetchJSON","reactFetch","reactFetchJSON"],"sourceRoot":""}