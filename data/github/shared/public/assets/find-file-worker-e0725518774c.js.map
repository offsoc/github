{"version":3,"file":"find-file-worker-xxxxxxxxxxxx.js","mappings":"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","sources":["node_modules/@github/memoize/dist/esm/index.js","node_modules/fzy.js/index.js","ui/packages/code-view-shared/worker-jobs/find-file.ts","app/assets/workers/find-file-worker.ts"],"sourcesContent":["export function defaultHash(...args) {\n    // JSON.stringify ellides `undefined` and function values by default. We do not want that.\n    return JSON.stringify(args, (_, v) => (typeof v === 'object' ? v : String(v)));\n}\nexport default function memoize(fn, opts = {}) {\n    const { hash = defaultHash, cache = new Map() } = opts;\n    return function (...args) {\n        const id = hash.apply(this, args);\n        if (cache.has(id))\n            return cache.get(id);\n        let result = fn.apply(this, args);\n        if (result instanceof Promise) {\n            // eslint-disable-next-line github/no-then\n            result = result.catch(error => {\n                cache.delete(id);\n                throw error;\n            });\n        }\n        cache.set(id, result);\n        return result;\n    };\n}\n","var SCORE_MIN = -Infinity;\nvar SCORE_MAX = Infinity;\n\nvar SCORE_GAP_LEADING = -0.005\nvar SCORE_GAP_TRAILING = -0.005\nvar SCORE_GAP_INNER = -0.01\nvar SCORE_MATCH_CONSECUTIVE = 1.0\nvar SCORE_MATCH_SLASH = 0.9\nvar SCORE_MATCH_WORD = 0.8\nvar SCORE_MATCH_CAPITAL = 0.7\nvar SCORE_MATCH_DOT = 0.6\n\nfunction islower(s) {\n\treturn s.toLowerCase() === s;\n}\n\nfunction isupper(s) {\n\treturn s.toUpperCase() === s;\n}\n\nfunction precompute_bonus(haystack) {\n\t/* Which positions are beginning of words */\n\tvar m = haystack.length;\n\tvar match_bonus = new Array(m);\n\n\tvar last_ch = '/';\n\tfor (var i = 0; i < m; i++) {\n\t\tvar ch = haystack[i];\n\n\t\tif (last_ch === '/') {\n\t\t\tmatch_bonus[i] = SCORE_MATCH_SLASH;\n\t\t} else if (last_ch === '-' || last_ch === '_' || last_ch === ' ') {\n\t\t\tmatch_bonus[i] = SCORE_MATCH_WORD;\n\t\t} else if (last_ch === '.') {\n\t\t\tmatch_bonus[i] = SCORE_MATCH_DOT;\n\t\t} else if (islower(last_ch) && isupper(ch)) {\n\t\t\tmatch_bonus[i] = SCORE_MATCH_CAPITAL;\n\t\t} else {\n\t\t\tmatch_bonus[i] = 0;\n\t\t}\n\n\t\tlast_ch = ch;\n\t}\n\n\treturn match_bonus;\n}\n\nfunction compute(needle, haystack, D, M) {\n\tvar n = needle.length;\n\tvar m = haystack.length;\n\n\tvar lower_needle = needle.toLowerCase();\n\tvar lower_haystack = haystack.toLowerCase();\n\n\tvar match_bonus = precompute_bonus(haystack, match_bonus);\n\n\t/*\n\t * D[][] Stores the best score for this position ending with a match.\n\t * M[][] Stores the best possible score at this position.\n\t */\n\n\tfor (var i = 0; i < n; i++) {\n\t\tD[i] = new Array(m);\n\t\tM[i] = new Array(m);\n\n\t\tvar prev_score = SCORE_MIN;\n\t\tvar gap_score = i === n - 1 ? SCORE_GAP_TRAILING : SCORE_GAP_INNER;\n\n\t\tfor (var j = 0; j < m; j++) {\n\t\t\tif (lower_needle[i] === lower_haystack[j]) {\n\t\t\t\tvar score = SCORE_MIN;\n\t\t\t\tif (!i) {\n\t\t\t\t\tscore = (j * SCORE_GAP_LEADING) + match_bonus[j];\n\t\t\t\t} else if (j) { /* i > 0 && j > 0*/\n\t\t\t\t\tscore = Math.max(\n\t\t\t\t\t\tM[i - 1][j - 1] + match_bonus[j],\n\n\t\t\t\t\t\t/* consecutive match, doesn't stack with match_bonus */\n\t\t\t\t\t\tD[i - 1][j - 1] + SCORE_MATCH_CONSECUTIVE);\n\t\t\t\t}\n\t\t\t\tD[i][j] = score;\n\t\t\t\tM[i][j] = prev_score = Math.max(score, prev_score + gap_score);\n\t\t\t} else {\n\t\t\t\tD[i][j] = SCORE_MIN;\n\t\t\t\tM[i][j] = prev_score = prev_score + gap_score;\n\t\t\t}\n\t\t}\n\t}\n}\n\nfunction score(needle, haystack) {\n\tvar n = needle.length;\n\tvar m = haystack.length;\n\n\tif (!n || !m)\n\t\treturn SCORE_MIN;\n\n\tif (n === m) {\n\t\t/* Since this method can only be called with a haystack which\n\t\t * matches needle. If the lengths of the strings are equal the\n\t\t * strings themselves must also be equal (ignoring case).\n\t\t */\n\t\treturn SCORE_MAX;\n\t}\n\n\tif (m > 1024) {\n\t\t/*\n\t\t * Unreasonably large candidate: return no score\n\t\t * If it is a valid match it will still be returned, it will\n\t\t * just be ranked below any reasonably sized candidates\n\t\t */\n\t\treturn SCORE_MIN;\n\t}\n\n\tvar D = new Array(n);\n\tvar M = new Array(n);\n\n\tcompute(needle, haystack, D, M)\n\n\treturn M[n - 1][m - 1];\n}\n\nfunction positions(needle, haystack) {\n\tvar n = needle.length;\n\tvar m = haystack.length;\n\n\tvar positions = new Array(n);\n\n\tif (!n || !m)\n\t\treturn positions;\n\n\tif (n === m) {\n\t\tfor (var i = 0; i < n; i++)\n\t\t\tpositions[i] = i;\n\t\treturn positions;\n\t}\n\n\tif (m > 1024) {\n\t\treturn positions;\n\t}\n\n\tvar D = new Array(n);\n\tvar M = new Array(n);\n\n\tcompute(needle, haystack, D, M)\n\n\t/* backtrack to find the positions of optimal matching */\n\tvar match_required = false;\n\n\tfor (var i = n - 1, j = m - 1; i >= 0; i--) {\n\t\tfor (; j >= 0; j--) {\n\t\t\t/*\n\t\t\t * There may be multiple paths which result in\n\t\t\t * the optimal weight.\n\t\t\t *\n\t\t\t * For simplicity, we will pick the first one\n\t\t\t * we encounter, the latest in the candidate\n\t\t\t * string.\n\t\t\t */\n\t\t\tif (D[i][j] !== SCORE_MIN &&\n\t\t\t    (match_required || D[i][j] === M[i][j])) {\n\t\t\t\t/* If this score was determined using\n\t\t\t\t * SCORE_MATCH_CONSECUTIVE, the\n\t\t\t\t * previous character MUST be a match\n\t\t\t\t */\n\t\t\t\tmatch_required =\n\t\t\t\t    i && j &&\n\t\t\t\t    M[i][j] === D[i - 1][j - 1] + SCORE_MATCH_CONSECUTIVE;\n\t\t\t\tpositions[i] = j--;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn positions;\n}\n\nfunction hasMatch(needle, haystack) {\n  needle = needle.toLowerCase()\n  haystack = haystack.toLowerCase()\n  var l = needle.length\n  for (var i = 0, j = 0; i < l; i += 1) {\n    j = haystack.indexOf(needle[i], j) + 1\n    if (j === 0) return false\n  }\n  return true\n}\n\nexport {\n\t/* constants */\n\tSCORE_MIN,\n\tSCORE_MAX,\n\n\tSCORE_GAP_LEADING,\n\tSCORE_GAP_TRAILING,\n\tSCORE_GAP_INNER,\n\tSCORE_MATCH_CONSECUTIVE,\n\tSCORE_MATCH_SLASH,\n\tSCORE_MATCH_WORD,\n\tSCORE_MATCH_CAPITAL,\n\tSCORE_MATCH_DOT,\n\n\t/* functions */\n\tscore,\n\tpositions,\n\thasMatch\n}\n","import memoize from '@github/memoize'\nimport {hasMatch, score} from 'fzy.js'\n\nexport interface FindFileRequest {\n  baseList: string[]\n  query: string\n  startTime: number\n}\n\nexport interface FindFileResponse {\n  query: string\n  list: string[]\n  baseCount: number\n  startTime: number\n}\n\nconst fuzzyScore = memoize(score)\n\nexport function findFileWorkerJob({data}: {data: FindFileRequest}): FindFileResponse {\n  const {query, baseList, startTime} = data\n  const queryWithoutBackslash = query.replaceAll('\\\\', '')\n  const list = baseList\n    .filter(item => filterItem(item, queryWithoutBackslash))\n    .sort((itemA, itemB) => fuzzyScore(queryWithoutBackslash, itemB) - fuzzyScore(queryWithoutBackslash, itemA))\n\n  return {query, list, baseCount: baseList.length, startTime}\n}\n\nfunction filterItem(item: string, query: string) {\n  return query === '' || (hasMatch(query, item) && fuzzyScore(query, item) > 0)\n}\n","import type {FindFileRequest} from '@github-ui/code-view-shared/components/files-search/FileResultsList'\nimport {findFileWorkerJob} from '@github-ui/code-view-shared/worker-jobs/find-file'\n\nself.onmessage = (message: {data: FindFileRequest}) => {\n  self.postMessage(findFileWorkerJob(message))\n}\n"],"names":["defaultHash","args","JSON","stringify","_","v","String","SCORE_MIN","Infinity","SCORE_MAX","fuzzyScore","memoize","fn","opts","hash","cache","Map","id","apply","has","get","result","Promise","catch","error","delete","set","needle","haystack","n","length","m","D","M","compute","lower_needle","toLowerCase","lower_haystack","match_bonus","precompute_bonus","last_ch","i","s","ch","islower","toUpperCase","prev_score","gap_score","j","score","Math","max","self","onmessage","postMessage","findFileWorkerJob","data","query","baseList","startTime","queryWithoutBackslash","replaceAll","list","filter","item","hasMatch","l","indexOf","sort","itemA","itemB","baseCount","message"],"sourceRoot":""}