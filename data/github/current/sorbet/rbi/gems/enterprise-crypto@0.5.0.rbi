# typed: true

# DO NOT EDIT MANUALLY
# This is an autogenerated file for types exported from the `enterprise-crypto` gem.
# Please instead update this file by running `bin/tapioca gem enterprise-crypto`.

# source://enterprise-crypto//lib/enterprise/crypto.rb#14
module Enterprise; end

# source://enterprise-crypto//lib/enterprise/crypto.rb#15
module Enterprise::Crypto
  class << self
    # source://enterprise-crypto//lib/enterprise/crypto.rb#28
    def current_vault; end

    # Returns the value of attribute customer_vault.
    #
    # source://enterprise-crypto//lib/enterprise/crypto.rb#17
    def customer_vault; end

    # Sets the attribute customer_vault
    #
    # @param value the value to set the attribute customer_vault to.
    #
    # source://enterprise-crypto//lib/enterprise/crypto.rb#17
    def customer_vault=(_arg0); end

    # Returns the value of attribute key_size.
    #
    # source://enterprise-crypto//lib/enterprise/crypto.rb#20
    def key_size; end

    # Sets the attribute key_size
    #
    # @param value the value to set the attribute key_size to.
    #
    # source://enterprise-crypto//lib/enterprise/crypto.rb#17
    def key_size=(_arg0); end

    # source://enterprise-crypto//lib/enterprise/crypto.rb#17
    def license_vault; end

    # source://enterprise-crypto//lib/enterprise/crypto.rb#17
    def license_vault=(_arg0); end

    # Returns the value of attribute package_vault.
    #
    # source://enterprise-crypto//lib/enterprise/crypto.rb#17
    def package_vault; end

    # Sets the attribute package_vault
    #
    # @param value the value to set the attribute package_vault to.
    #
    # source://enterprise-crypto//lib/enterprise/crypto.rb#17
    def package_vault=(_arg0); end

    # source://enterprise-crypto//lib/enterprise/crypto.rb#24
    def vaults; end

    # source://enterprise-crypto//lib/enterprise/crypto.rb#32
    def with_vault(vault, cleanup = T.unsafe(nil)); end
  end
end

# A Customer represents the cryptographic data associated with an
# enterprise customer: secret & public key data, and identification data.
# Customer has methods for generating new customer data, and loading
# customer data from raw key data.
#
# source://enterprise-crypto//lib/enterprise/crypto/customer.rb#10
class Enterprise::Crypto::Customer < ::Struct
  # source://enterprise-crypto//lib/enterprise/crypto/customer.rb#71
  def generate_license(*a); end

  # The customer's public key.
  #
  # source://enterprise-crypto//lib/enterprise/crypto/customer.rb#51
  def public_key(vault = T.unsafe(nil)); end

  # The customer's secret key.
  #
  # source://enterprise-crypto//lib/enterprise/crypto/customer.rb#61
  def secret_key(vault = T.unsafe(nil)); end

  class << self
    # Deserializes a customer's encryption data.
    #
    # secret_key_data - the secret data portion of a customer's key as a String.
    # public_key_data - the public data portion of a customer's key as a String.
    #
    # source://enterprise-crypto//lib/enterprise/crypto/customer.rb#35
    def from(secret_key_data, public_key_data, vault = T.unsafe(nil)); end

    # Creates a new customer's encryption data.
    #
    # name  - name of the customer as a String.
    # email - email of the customer as a String.
    #
    # source://enterprise-crypto//lib/enterprise/crypto/customer.rb#17
    def generate(name, email, vault = T.unsafe(nil)); end
  end
end

# A Vault for working with customer GPG keys. Used to
# generate and verify a customer keypair.
#
# source://enterprise-crypto//lib/enterprise/crypto/customer_vault.rb#6
class Enterprise::Crypto::CustomerVault < ::Enterprise::Crypto::Vault
  # source://enterprise-crypto//lib/enterprise/crypto/customer_vault.rb#41
  def customer_key_params(name, email, comments); end

  # Generate a new customer keypair signed by the customer key.
  #
  # name      - The Name-Real segment.
  # email     - The Name-Email segment.
  # comments  - The Name-Comments segment.
  #
  # source://enterprise-crypto//lib/enterprise/crypto/customer_vault.rb#14
  def generate_customer_key(name, email, comments); end

  # source://enterprise-crypto//lib/enterprise/crypto/customer_vault.rb#27
  def sign_with_customer_key(key); end
end

# source://enterprise-crypto//lib/enterprise/crypto/error.rb#3
class Enterprise::Crypto::Error < ::StandardError; end

# source://enterprise-crypto//lib/enterprise/crypto/license.rb#8
class Enterprise::Crypto::License < ::Struct
  include ::Enterprise::Crypto::SafeDir
  include ::Enterprise::Crypto::Tar
  extend ::Enterprise::Crypto::SafeDir
  extend ::Enterprise::Crypto::Tar::Ext

  # source://enterprise-crypto//lib/enterprise/crypto/license.rb#218
  def advanced_security_enabled; end

  # source://enterprise-crypto//lib/enterprise/crypto/license.rb#223
  def advanced_security_enabled=(value); end

  # source://enterprise-crypto//lib/enterprise/crypto/license.rb#218
  def advanced_security_enabled?; end

  # source://enterprise-crypto//lib/enterprise/crypto/license.rb#227
  def advanced_security_seats; end

  # source://enterprise-crypto//lib/enterprise/crypto/license.rb#231
  def advanced_security_seats=(count); end

  # source://enterprise-crypto//lib/enterprise/crypto/license.rb#172
  def cluster_support; end

  # source://enterprise-crypto//lib/enterprise/crypto/license.rb#177
  def cluster_support=(value); end

  # source://enterprise-crypto//lib/enterprise/crypto/license.rb#172
  def cluster_support?; end

  # source://enterprise-crypto//lib/enterprise/crypto/license.rb#71
  def company; end

  # source://enterprise-crypto//lib/enterprise/crypto/license.rb#75
  def company=(c); end

  # source://enterprise-crypto//lib/enterprise/crypto/license.rb#181
  def croquet_support; end

  # source://enterprise-crypto//lib/enterprise/crypto/license.rb#186
  def croquet_support=(value); end

  # source://enterprise-crypto//lib/enterprise/crypto/license.rb#181
  def croquet_support?; end

  # source://enterprise-crypto//lib/enterprise/crypto/license.rb#190
  def custom_terms; end

  # source://enterprise-crypto//lib/enterprise/crypto/license.rb#195
  def custom_terms=(value); end

  # source://enterprise-crypto//lib/enterprise/crypto/license.rb#190
  def custom_terms?; end

  # source://enterprise-crypto//lib/enterprise/crypto/license.rb#129
  def customer_private_key; end

  # source://enterprise-crypto//lib/enterprise/crypto/license.rb#133
  def customer_private_key=(value); end

  # source://enterprise-crypto//lib/enterprise/crypto/license.rb#121
  def customer_public_key; end

  # source://enterprise-crypto//lib/enterprise/crypto/license.rb#125
  def customer_public_key=(value); end

  # source://enterprise-crypto//lib/enterprise/crypto/license.rb#104
  def evaluation; end

  # source://enterprise-crypto//lib/enterprise/crypto/license.rb#109
  def evaluation=(value); end

  # source://enterprise-crypto//lib/enterprise/crypto/license.rb#104
  def evaluation?; end

  # source://enterprise-crypto//lib/enterprise/crypto/license.rb#113
  def expire_at; end

  # source://enterprise-crypto//lib/enterprise/crypto/license.rb#117
  def expire_at=(time); end

  # source://enterprise-crypto//lib/enterprise/crypto/license.rb#199
  def insights_enabled; end

  # source://enterprise-crypto//lib/enterprise/crypto/license.rb#204
  def insights_enabled=(value); end

  # source://enterprise-crypto//lib/enterprise/crypto/license.rb#199
  def insights_enabled?; end

  # source://enterprise-crypto//lib/enterprise/crypto/license.rb#208
  def insights_expire_at; end

  # source://enterprise-crypto//lib/enterprise/crypto/license.rb#213
  def insights_expire_at=(date); end

  # source://enterprise-crypto//lib/enterprise/crypto/license.rb#95
  def learning_lab_evaluation_expires; end

  # source://enterprise-crypto//lib/enterprise/crypto/license.rb#99
  def learning_lab_evaluation_expires=(date); end

  # source://enterprise-crypto//lib/enterprise/crypto/license.rb#87
  def learning_lab_seats; end

  # source://enterprise-crypto//lib/enterprise/crypto/license.rb#91
  def learning_lab_seats=(count); end

  # source://enterprise-crypto//lib/enterprise/crypto/license.rb#235
  def metered; end

  # source://enterprise-crypto//lib/enterprise/crypto/license.rb#240
  def metered=(value); end

  # source://enterprise-crypto//lib/enterprise/crypto/license.rb#235
  def metered?; end

  # source://enterprise-crypto//lib/enterprise/crypto/license.rb#145
  def perpetual; end

  # source://enterprise-crypto//lib/enterprise/crypto/license.rb#150
  def perpetual=(value); end

  # source://enterprise-crypto//lib/enterprise/crypto/license.rb#145
  def perpetual?; end

  # source://enterprise-crypto//lib/enterprise/crypto/license.rb#79
  def seats; end

  # source://enterprise-crypto//lib/enterprise/crypto/license.rb#83
  def seats=(count); end

  # source://enterprise-crypto//lib/enterprise/crypto/license.rb#163
  def ssh_allowed; end

  # source://enterprise-crypto//lib/enterprise/crypto/license.rb#168
  def ssh_allowed=(value); end

  # source://enterprise-crypto//lib/enterprise/crypto/license.rb#163
  def ssh_allowed?; end

  # source://enterprise-crypto//lib/enterprise/crypto/license.rb#137
  def support_key; end

  # source://enterprise-crypto//lib/enterprise/crypto/license.rb#141
  def support_key=(value); end

  # source://enterprise-crypto//lib/enterprise/crypto/license.rb#59
  def to_bin(vault = T.unsafe(nil)); end

  # source://enterprise-crypto//lib/enterprise/crypto/license.rb#262
  def to_dir(dir = T.unsafe(nil)); end

  # source://enterprise-crypto//lib/enterprise/crypto/license.rb#154
  def unlimited_seating; end

  # source://enterprise-crypto//lib/enterprise/crypto/license.rb#159
  def unlimited_seating=(value); end

  # source://enterprise-crypto//lib/enterprise/crypto/license.rb#154
  def unlimited_seating?; end

  class << self
    # source://enterprise-crypto//lib/enterprise/crypto/license.rb#244
    def from_dir(dir); end

    # source://enterprise-crypto//lib/enterprise/crypto/license.rb#21
    def generate(customer, seats, expire_at, support_key = T.unsafe(nil), extra_metadata = T.unsafe(nil), files = T.unsafe(nil)); end

    # source://enterprise-crypto//lib/enterprise/crypto/license.rb#40
    def load(asc_data, vault = T.unsafe(nil), tmp = T.unsafe(nil)); end
  end
end

# source://enterprise-crypto//lib/enterprise/crypto/license_vault.rb#5
class Enterprise::Crypto::LicenseVault < ::Enterprise::Crypto::Vault
  # source://enterprise-crypto//lib/enterprise/crypto/vault.rb#124
  def generate_license(raw); end

  # source://enterprise-crypto//lib/enterprise/crypto/vault.rb#139
  def read_license(object); end
end

# An update package which contains chef cookbooks and debian packages.
# Packages are versioned and architecture specific.
#
# source://enterprise-crypto//lib/enterprise/crypto/package.rb#8
class Enterprise::Crypto::Package < ::Struct
  include ::Enterprise::Crypto::SafeDir
  include ::Enterprise::Crypto::Tar
  extend ::Enterprise::Crypto::Tar::Ext

  # source://enterprise-crypto//lib/enterprise/crypto/package.rb#103
  def checksums; end

  # source://enterprise-crypto//lib/enterprise/crypto/package.rb#162
  def cleanup_cookbooks(dir); end

  # source://enterprise-crypto//lib/enterprise/crypto/package.rb#154
  def copy(dir, files); end

  # source://enterprise-crypto//lib/enterprise/crypto/package.rb#150
  def default_package_path; end

  # source://enterprise-crypto//lib/enterprise/crypto/package.rb#121
  def md5(file); end

  # source://enterprise-crypto//lib/enterprise/crypto/package.rb#77
  def metadata; end

  # source://enterprise-crypto//lib/enterprise/crypto/package.rb#125
  def to_dir(dir = T.unsafe(nil)); end

  # Compiles this update package to a file.
  #
  # path  - the file path to the package output.
  #
  # source://enterprise-crypto//lib/enterprise/crypto/package.rb#89
  def to_ghp(path = T.unsafe(nil), vault = T.unsafe(nil), tmp_dir = T.unsafe(nil)); end

  # source://enterprise-crypto//lib/enterprise/crypto/package.rb#142
  def write(file, data, encoding = T.unsafe(nil), mode = T.unsafe(nil)); end

  class << self
    # Removes all Package files when an extract fails.
    #
    # source://enterprise-crypto//lib/enterprise/crypto/package.rb#59
    def abort_extract(output_path); end

    # source://enterprise-crypto//lib/enterprise/crypto/package.rb#71
    def execute_support_script(path); end

    # Extracts an update package into the provided path.
    #
    # package_path  - the path to the update package.
    # output_path   - the path to the extracted package contents.
    #
    # Returns the metadata Hash or raises an error.
    #
    # source://enterprise-crypto//lib/enterprise/crypto/package.rb#18
    def extract(package_path, output_path, vault = T.unsafe(nil)); end

    # source://enterprise-crypto//lib/enterprise/crypto/package.rb#63
    def verify_checksum(file, expected); end

    # Checks that a Package was extracted properly. Raises an exception
    # if something went wrong.
    #
    # Returns the metadata Hash or raises an error.
    #
    # @raise [Error]
    #
    # source://enterprise-crypto//lib/enterprise/crypto/package.rb#38
    def verify_extraction(output_path); end
  end
end

# A Vault for creating and extracting update packages.
#
# source://enterprise-crypto//lib/enterprise/crypto/package_vault.rb#5
class Enterprise::Crypto::PackageVault < ::Enterprise::Crypto::Vault
  # Creates an encrypted and signed enterprise package.
  #
  # raw - The package data as a String.
  #
  # source://enterprise-crypto//lib/enterprise/crypto/vault.rb#124
  def generate_package(raw); end

  # source://enterprise-crypto//lib/enterprise/crypto/package_vault.rb#18
  def new_signed_data(object); end

  # Returns the decrypted and verified package data.
  #
  # object  - signed package data.
  #
  # source://enterprise-crypto//lib/enterprise/crypto/vault.rb#139
  def read_package(object); end
end

# source://enterprise-crypto//lib/enterprise/crypto/safe_dir.rb#7
module Enterprise::Crypto::SafeDir
  # source://enterprise-crypto//lib/enterprise/crypto/safe_dir.rb#18
  def mktmpdir(name = T.unsafe(nil)); end

  # source://enterprise-crypto//lib/enterprise/crypto/safe_dir.rb#8
  def tmpdir; end
end

# source://enterprise-crypto//lib/enterprise/crypto/tar.rb#3
module Enterprise::Crypto::Tar
  include ::Enterprise::Crypto::SafeDir

  mixes_in_class_methods ::Enterprise::Crypto::Tar::Ext

  # source://enterprise-crypto//lib/enterprise/crypto/tar.rb#29
  def secure_tmp_path; end

  # source://enterprise-crypto//lib/enterprise/crypto/tar.rb#21
  def to_tar(input, output = T.unsafe(nil)); end

  class << self
    # @private
    #
    # source://enterprise-crypto//lib/enterprise/crypto/tar.rb#6
    def included(klass); end
  end
end

# source://enterprise-crypto//lib/enterprise/crypto/tar.rb#10
module Enterprise::Crypto::Tar::Ext
  # source://enterprise-crypto//lib/enterprise/crypto/tar.rb#11
  def from_tar(tar_path, output = T.unsafe(nil)); end
end

# source://enterprise-crypto//lib/enterprise/crypto/vault.rb#12
class Enterprise::Crypto::Vault
  include ::Enterprise::Crypto::SafeDir

  # Create a vault with a homedir and 0 or more (paired) keys.
  #
  # key_data  - An Array of gpg key data as Strings.
  #
  # @return [Vault] a new instance of Vault
  #
  # source://enterprise-crypto//lib/enterprise/crypto/vault.rb#43
  def initialize(*key_data, blank_password: T.unsafe(nil)); end

  # Add a new key to the Vault. It must match the fingerprint
  # of the existing key(s), if there is one.
  #
  # key_data  - The gpg data of the key as a String.
  #
  # source://enterprise-crypto//lib/enterprise/crypto/vault.rb#81
  def add_key(key_data); end

  # source://enterprise-crypto//lib/enterprise/crypto/vault.rb#344
  def agent_config; end

  # source://enterprise-crypto//lib/enterprise/crypto/vault.rb#350
  def agent_config_path; end

  # source://enterprise-crypto//lib/enterprise/crypto/vault.rb#215
  def blank_password_context_options; end

  # source://enterprise-crypto//lib/enterprise/crypto/vault.rb#160
  def check_signatures(signatures); end

  # source://enterprise-crypto//lib/enterprise/crypto/vault.rb#247
  def cleanup!; end

  # source://enterprise-crypto//lib/enterprise/crypto/vault.rb#243
  def close!; end

  # Symmetrically decrypts and verifies the object.
  # Note: only verifies for now.
  #
  # object - An encrypted and signed object as a String.
  #
  # source://enterprise-crypto//lib/enterprise/crypto/vault.rb#139
  def decrypt_and_verify(object); end

  # source://enterprise-crypto//lib/enterprise/crypto/vault.rb#205
  def default_context_options; end

  # Symmetrically encrypts then signs the data.
  # Note: only signs for now.
  #
  # raw - A String of data.
  #
  # source://enterprise-crypto//lib/enterprise/crypto/vault.rb#124
  def encrypt_and_sign(raw); end

  # Returns the public gpg key data as a String.
  #
  # fingerprint - The gpg fingerprint of the public key to export.
  #
  # source://enterprise-crypto//lib/enterprise/crypto/vault.rb#111
  def export_public(fingerprint); end

  # Returns the secret gpg key data as a String.
  #
  # fingerprint - The fingerprint of the secret key to export.
  #
  # source://enterprise-crypto//lib/enterprise/crypto/vault.rb#93
  def export_secret(fingerprint); end

  # source://enterprise-crypto//lib/enterprise/crypto/vault.rb#178
  def find_key(type, fingerprint); end

  # source://enterprise-crypto//lib/enterprise/crypto/vault.rb#174
  def find_private_key(fingerprint); end

  # source://enterprise-crypto//lib/enterprise/crypto/vault.rb#166
  def find_public_key(fingerprint); end

  # source://enterprise-crypto//lib/enterprise/crypto/vault.rb#170
  def find_secret_key(fingerprint); end

  # Returns the value of attribute fingerprint.
  #
  # source://enterprise-crypto//lib/enterprise/crypto/vault.rb#17
  def fingerprint; end

  # Sets the attribute fingerprint
  #
  # @param value the value to set the attribute fingerprint to.
  #
  # source://enterprise-crypto//lib/enterprise/crypto/vault.rb#17
  def fingerprint=(_arg0); end

  # source://enterprise-crypto//lib/enterprise/crypto/vault.rb#229
  def home_dir; end

  # source://enterprise-crypto//lib/enterprise/crypto/vault.rb#273
  def import_key(key_data); end

  # source://enterprise-crypto//lib/enterprise/crypto/vault.rb#254
  def import_main_key(key_data); end

  # source://enterprise-crypto//lib/enterprise/crypto/vault.rb#279
  def load_master_public_key; end

  # source://enterprise-crypto//lib/enterprise/crypto/vault.rb#264
  def load_vault; end

  # The public key of the Master keypair. Used to verify that other
  # keypairs are signed by the Master key.
  #
  # Note: the private key should never be loaded into this library.
  #
  # source://enterprise-crypto//lib/enterprise/crypto/vault.rb#53
  def master_key; end

  # source://enterprise-crypto//lib/enterprise/crypto/vault.rb#156
  def new_signed_data(object); end

  # source://enterprise-crypto//lib/enterprise/crypto/vault.rb#233
  def open!; end

  # The public key portion for this vault. May be nil.
  # Used to verify signed data.
  #
  # source://enterprise-crypto//lib/enterprise/crypto/vault.rb#70
  def public_key; end

  # source://enterprise-crypto//lib/enterprise/crypto/vault.rb#61
  def secret_key; end

  # source://enterprise-crypto//lib/enterprise/crypto/vault.rb#187
  def with_context(options = T.unsafe(nil)); end

  # source://enterprise-crypto//lib/enterprise/crypto/vault.rb#197
  def with_vault; end

  # source://enterprise-crypto//lib/enterprise/crypto/vault.rb#336
  def write_agent_config; end

  class << self
    # Raise an error unless the key's fingerprint matches the provided
    # fingerprint. Useful for asserting a keypair.
    #
    # source://enterprise-crypto//lib/enterprise/crypto/vault.rb#33
    def verify_key_fingerprint!(key, fingerprint); end

    # Raise an error unless the key is signed by the signing_key. Useful
    # for asserting that a keypair is signed by the master key.
    #
    # source://enterprise-crypto//lib/enterprise/crypto/vault.rb#22
    def verify_key_signature!(key, signing_key); end
  end
end

# source://enterprise-crypto//lib/enterprise/crypto/vault.rb#15
Enterprise::Crypto::Vault::MASTER_FINGERPRINT = T.let(T.unsafe(nil), String)

# source://enterprise-crypto//lib/enterprise/crypto/vault_validator.rb#3
module Enterprise::Crypto::VaultValidator
  extend ::Enterprise::Crypto::VaultValidator

  # source://enterprise-crypto//lib/enterprise/crypto/vault_validator.rb#12
  def check_master_key(vault); end

  # The public key should be signed by the master key
  #
  # source://enterprise-crypto//lib/enterprise/crypto/vault_validator.rb#17
  def check_public_key(vault); end

  # The secret key fingerprint & public key fingerprint should match
  #
  # source://enterprise-crypto//lib/enterprise/crypto/vault_validator.rb#22
  def check_secret_key(vault); end

  # source://enterprise-crypto//lib/enterprise/crypto/vault_validator.rb#6
  def validate!(vault); end
end
