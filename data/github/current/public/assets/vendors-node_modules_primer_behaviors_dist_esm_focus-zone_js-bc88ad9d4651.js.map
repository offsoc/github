{"version":3,"file":"vendors-node_modules_primer_behaviors_dist_esm_focus-zone_js-xxxxxxxxxxxx.js","mappings":"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","sources":["node_modules/@primer/behaviors/dist/esm/focus-zone.js","node_modules/@primer/behaviors/dist/esm/polyfills/event-listener-signal.js","node_modules/@primer/behaviors/dist/esm/utils/iterate-focusable-elements.js","node_modules/@primer/behaviors/dist/esm/utils/unique-id.js","node_modules/@primer/behaviors/dist/esm/utils/user-agent.js"],"sourcesContent":["import { polyfill as eventListenerSignalPolyfill } from './polyfills/event-listener-signal.js';\nimport { isMacOS } from './utils/user-agent.js';\nimport { iterateFocusableElements } from './utils/iterate-focusable-elements.js';\nimport { uniqueId } from './utils/unique-id.js';\neventListenerSignalPolyfill();\nexport var FocusKeys;\n(function (FocusKeys) {\n    FocusKeys[FocusKeys[\"ArrowHorizontal\"] = 1] = \"ArrowHorizontal\";\n    FocusKeys[FocusKeys[\"ArrowVertical\"] = 2] = \"ArrowVertical\";\n    FocusKeys[FocusKeys[\"JK\"] = 4] = \"JK\";\n    FocusKeys[FocusKeys[\"HL\"] = 8] = \"HL\";\n    FocusKeys[FocusKeys[\"HomeAndEnd\"] = 16] = \"HomeAndEnd\";\n    FocusKeys[FocusKeys[\"PageUpDown\"] = 256] = \"PageUpDown\";\n    FocusKeys[FocusKeys[\"WS\"] = 32] = \"WS\";\n    FocusKeys[FocusKeys[\"AD\"] = 64] = \"AD\";\n    FocusKeys[FocusKeys[\"Tab\"] = 128] = \"Tab\";\n    FocusKeys[FocusKeys[\"Backspace\"] = 512] = \"Backspace\";\n    FocusKeys[FocusKeys[\"ArrowAll\"] = 3] = \"ArrowAll\";\n    FocusKeys[FocusKeys[\"HJKL\"] = 12] = \"HJKL\";\n    FocusKeys[FocusKeys[\"WASD\"] = 96] = \"WASD\";\n    FocusKeys[FocusKeys[\"All\"] = 511] = \"All\";\n})(FocusKeys || (FocusKeys = {}));\nconst KEY_TO_BIT = {\n    ArrowLeft: FocusKeys.ArrowHorizontal,\n    ArrowDown: FocusKeys.ArrowVertical,\n    ArrowUp: FocusKeys.ArrowVertical,\n    ArrowRight: FocusKeys.ArrowHorizontal,\n    h: FocusKeys.HL,\n    j: FocusKeys.JK,\n    k: FocusKeys.JK,\n    l: FocusKeys.HL,\n    a: FocusKeys.AD,\n    s: FocusKeys.WS,\n    w: FocusKeys.WS,\n    d: FocusKeys.AD,\n    Tab: FocusKeys.Tab,\n    Home: FocusKeys.HomeAndEnd,\n    End: FocusKeys.HomeAndEnd,\n    PageUp: FocusKeys.PageUpDown,\n    PageDown: FocusKeys.PageUpDown,\n    Backspace: FocusKeys.Backspace,\n};\nconst KEY_TO_DIRECTION = {\n    ArrowLeft: 'previous',\n    ArrowDown: 'next',\n    ArrowUp: 'previous',\n    ArrowRight: 'next',\n    h: 'previous',\n    j: 'next',\n    k: 'previous',\n    l: 'next',\n    a: 'previous',\n    s: 'next',\n    w: 'previous',\n    d: 'next',\n    Tab: 'next',\n    Home: 'start',\n    End: 'end',\n    PageUp: 'start',\n    PageDown: 'end',\n    Backspace: 'previous',\n};\nfunction getDirection(keyboardEvent) {\n    const direction = KEY_TO_DIRECTION[keyboardEvent.key];\n    if (keyboardEvent.key === 'Tab' && keyboardEvent.shiftKey) {\n        return 'previous';\n    }\n    const isMac = isMacOS();\n    if ((isMac && keyboardEvent.metaKey) || (!isMac && keyboardEvent.ctrlKey)) {\n        if (keyboardEvent.key === 'ArrowLeft' || keyboardEvent.key === 'ArrowUp') {\n            return 'start';\n        }\n        else if (keyboardEvent.key === 'ArrowRight' || keyboardEvent.key === 'ArrowDown') {\n            return 'end';\n        }\n    }\n    return direction;\n}\nfunction shouldIgnoreFocusHandling(keyboardEvent, activeElement) {\n    const key = keyboardEvent.key;\n    const keyLength = [...key].length;\n    const isTextInput = (activeElement instanceof HTMLInputElement && activeElement.type === 'text') ||\n        activeElement instanceof HTMLTextAreaElement;\n    if (isTextInput && (keyLength === 1 || key === 'Home' || key === 'End')) {\n        return true;\n    }\n    if (activeElement instanceof HTMLSelectElement) {\n        if (keyLength === 1) {\n            return true;\n        }\n        if (key === 'ArrowDown' && isMacOS() && !keyboardEvent.metaKey) {\n            return true;\n        }\n        if (key === 'ArrowDown' && !isMacOS() && keyboardEvent.altKey) {\n            return true;\n        }\n    }\n    if (activeElement instanceof HTMLTextAreaElement && (key === 'PageUp' || key === 'PageDown')) {\n        return true;\n    }\n    if (isTextInput) {\n        const textInput = activeElement;\n        const cursorAtStart = textInput.selectionStart === 0 && textInput.selectionEnd === 0;\n        const cursorAtEnd = textInput.selectionStart === textInput.value.length && textInput.selectionEnd === textInput.value.length;\n        if (key === 'ArrowLeft' && !cursorAtStart) {\n            return true;\n        }\n        if (key === 'ArrowRight' && !cursorAtEnd) {\n            return true;\n        }\n        if (textInput instanceof HTMLTextAreaElement) {\n            if (key === 'ArrowUp' && !cursorAtStart) {\n                return true;\n            }\n            if (key === 'ArrowDown' && !cursorAtEnd) {\n                return true;\n            }\n        }\n    }\n    return false;\n}\nexport const isActiveDescendantAttribute = 'data-is-active-descendant';\nexport const activeDescendantActivatedDirectly = 'activated-directly';\nexport const activeDescendantActivatedIndirectly = 'activated-indirectly';\nexport const hasActiveDescendantAttribute = 'data-has-active-descendant';\nexport function focusZone(container, settings) {\n    var _a, _b, _c, _d, _e;\n    const focusableElements = [];\n    const savedTabIndex = new WeakMap();\n    const bindKeys = (_a = settings === null || settings === void 0 ? void 0 : settings.bindKeys) !== null && _a !== void 0 ? _a : ((settings === null || settings === void 0 ? void 0 : settings.getNextFocusable) ? FocusKeys.ArrowAll : FocusKeys.ArrowVertical) | FocusKeys.HomeAndEnd;\n    const focusOutBehavior = (_b = settings === null || settings === void 0 ? void 0 : settings.focusOutBehavior) !== null && _b !== void 0 ? _b : 'stop';\n    const focusInStrategy = (_c = settings === null || settings === void 0 ? void 0 : settings.focusInStrategy) !== null && _c !== void 0 ? _c : 'previous';\n    const activeDescendantControl = settings === null || settings === void 0 ? void 0 : settings.activeDescendantControl;\n    const activeDescendantCallback = settings === null || settings === void 0 ? void 0 : settings.onActiveDescendantChanged;\n    let currentFocusedElement;\n    const preventScroll = (_d = settings === null || settings === void 0 ? void 0 : settings.preventScroll) !== null && _d !== void 0 ? _d : false;\n    function getFirstFocusableElement() {\n        return focusableElements[0];\n    }\n    function isActiveDescendantInputFocused() {\n        return document.activeElement === activeDescendantControl;\n    }\n    function updateFocusedElement(to, directlyActivated = false) {\n        const from = currentFocusedElement;\n        currentFocusedElement = to;\n        if (activeDescendantControl) {\n            if (to && isActiveDescendantInputFocused()) {\n                setActiveDescendant(from, to, directlyActivated);\n            }\n            else {\n                clearActiveDescendant();\n            }\n            return;\n        }\n        if (from && from !== to && savedTabIndex.has(from)) {\n            from.setAttribute('tabindex', '-1');\n        }\n        to === null || to === void 0 ? void 0 : to.setAttribute('tabindex', '0');\n    }\n    function setActiveDescendant(from, to, directlyActivated = false) {\n        if (!to.id) {\n            to.setAttribute('id', uniqueId());\n        }\n        if (from && from !== to) {\n            from.removeAttribute(isActiveDescendantAttribute);\n        }\n        if (!activeDescendantControl ||\n            (!directlyActivated && activeDescendantControl.getAttribute('aria-activedescendant') === to.id)) {\n            return;\n        }\n        activeDescendantControl.setAttribute('aria-activedescendant', to.id);\n        container.setAttribute(hasActiveDescendantAttribute, to.id);\n        to.setAttribute(isActiveDescendantAttribute, directlyActivated ? activeDescendantActivatedDirectly : activeDescendantActivatedIndirectly);\n        activeDescendantCallback === null || activeDescendantCallback === void 0 ? void 0 : activeDescendantCallback(to, from, directlyActivated);\n    }\n    function clearActiveDescendant(previouslyActiveElement = currentFocusedElement) {\n        if (focusInStrategy === 'first') {\n            currentFocusedElement = undefined;\n        }\n        activeDescendantControl === null || activeDescendantControl === void 0 ? void 0 : activeDescendantControl.removeAttribute('aria-activedescendant');\n        container.removeAttribute(hasActiveDescendantAttribute);\n        previouslyActiveElement === null || previouslyActiveElement === void 0 ? void 0 : previouslyActiveElement.removeAttribute(isActiveDescendantAttribute);\n        activeDescendantCallback === null || activeDescendantCallback === void 0 ? void 0 : activeDescendantCallback(undefined, previouslyActiveElement, false);\n    }\n    function beginFocusManagement(...elements) {\n        const filteredElements = elements.filter(e => { var _a, _b; return (_b = (_a = settings === null || settings === void 0 ? void 0 : settings.focusableElementFilter) === null || _a === void 0 ? void 0 : _a.call(settings, e)) !== null && _b !== void 0 ? _b : true; });\n        if (filteredElements.length === 0) {\n            return;\n        }\n        focusableElements.splice(findInsertionIndex(filteredElements), 0, ...filteredElements);\n        for (const element of filteredElements) {\n            if (!savedTabIndex.has(element)) {\n                savedTabIndex.set(element, element.getAttribute('tabindex'));\n            }\n            element.setAttribute('tabindex', '-1');\n        }\n        if (!currentFocusedElement) {\n            updateFocusedElement(getFirstFocusableElement());\n        }\n    }\n    function findInsertionIndex(elementsToInsert) {\n        const firstElementToInsert = elementsToInsert[0];\n        if (focusableElements.length === 0)\n            return 0;\n        let iMin = 0;\n        let iMax = focusableElements.length - 1;\n        while (iMin <= iMax) {\n            const i = Math.floor((iMin + iMax) / 2);\n            const element = focusableElements[i];\n            if (followsInDocument(firstElementToInsert, element)) {\n                iMax = i - 1;\n            }\n            else {\n                iMin = i + 1;\n            }\n        }\n        return iMin;\n    }\n    function followsInDocument(first, second) {\n        return (second.compareDocumentPosition(first) & Node.DOCUMENT_POSITION_PRECEDING) > 0;\n    }\n    function endFocusManagement(...elements) {\n        for (const element of elements) {\n            const focusableElementIndex = focusableElements.indexOf(element);\n            if (focusableElementIndex >= 0) {\n                focusableElements.splice(focusableElementIndex, 1);\n            }\n            const savedIndex = savedTabIndex.get(element);\n            if (savedIndex !== undefined) {\n                if (savedIndex === null) {\n                    element.removeAttribute('tabindex');\n                }\n                else {\n                    element.setAttribute('tabindex', savedIndex);\n                }\n                savedTabIndex.delete(element);\n            }\n            if (element === currentFocusedElement) {\n                const nextElementToFocus = getFirstFocusableElement();\n                updateFocusedElement(nextElementToFocus);\n            }\n        }\n    }\n    const iterateFocusableElementsOptions = {\n        reverse: settings === null || settings === void 0 ? void 0 : settings.reverse,\n        strict: settings === null || settings === void 0 ? void 0 : settings.strict,\n        onlyTabbable: settings === null || settings === void 0 ? void 0 : settings.onlyTabbable,\n    };\n    beginFocusManagement(...iterateFocusableElements(container, iterateFocusableElementsOptions));\n    const initialElement = typeof focusInStrategy === 'function' ? focusInStrategy(document.body) : getFirstFocusableElement();\n    updateFocusedElement(initialElement);\n    const observer = new MutationObserver(mutations => {\n        for (const mutation of mutations) {\n            for (const removedNode of mutation.removedNodes) {\n                if (removedNode instanceof HTMLElement) {\n                    endFocusManagement(...iterateFocusableElements(removedNode));\n                }\n            }\n            if (mutation.type === 'attributes' && mutation.oldValue === null) {\n                if (mutation.target instanceof HTMLElement) {\n                    endFocusManagement(mutation.target);\n                }\n            }\n        }\n        for (const mutation of mutations) {\n            for (const addedNode of mutation.addedNodes) {\n                if (addedNode instanceof HTMLElement) {\n                    beginFocusManagement(...iterateFocusableElements(addedNode, iterateFocusableElementsOptions));\n                }\n            }\n            if (mutation.type === 'attributes' && mutation.oldValue !== null) {\n                if (mutation.target instanceof HTMLElement) {\n                    beginFocusManagement(mutation.target);\n                }\n            }\n        }\n    });\n    observer.observe(container, {\n        subtree: true,\n        childList: true,\n        attributeFilter: ['hidden', 'disabled'],\n        attributeOldValue: true,\n    });\n    const controller = new AbortController();\n    const signal = (_e = settings === null || settings === void 0 ? void 0 : settings.abortSignal) !== null && _e !== void 0 ? _e : controller.signal;\n    signal.addEventListener('abort', () => {\n        endFocusManagement(...focusableElements);\n    });\n    let elementIndexFocusedByClick = undefined;\n    container.addEventListener('mousedown', event => {\n        if (event.target instanceof HTMLElement && event.target !== document.activeElement) {\n            elementIndexFocusedByClick = focusableElements.indexOf(event.target);\n        }\n    }, { signal });\n    if (activeDescendantControl) {\n        container.addEventListener('focusin', event => {\n            if (event.target instanceof HTMLElement && focusableElements.includes(event.target)) {\n                activeDescendantControl.focus({ preventScroll });\n                updateFocusedElement(event.target);\n            }\n        });\n        container.addEventListener('mousemove', ({ target }) => {\n            if (!(target instanceof Node)) {\n                return;\n            }\n            const focusableElement = focusableElements.find(element => element.contains(target));\n            if (focusableElement) {\n                updateFocusedElement(focusableElement);\n            }\n        }, { signal, capture: true });\n        activeDescendantControl.addEventListener('focusin', () => {\n            if (!currentFocusedElement) {\n                updateFocusedElement(getFirstFocusableElement());\n            }\n            else {\n                setActiveDescendant(undefined, currentFocusedElement);\n            }\n        });\n        activeDescendantControl.addEventListener('focusout', () => {\n            clearActiveDescendant();\n        });\n    }\n    else {\n        container.addEventListener('focusin', event => {\n            if (event.target instanceof HTMLElement) {\n                if (elementIndexFocusedByClick !== undefined) {\n                    if (elementIndexFocusedByClick >= 0) {\n                        if (focusableElements[elementIndexFocusedByClick] !== currentFocusedElement) {\n                            updateFocusedElement(focusableElements[elementIndexFocusedByClick]);\n                        }\n                    }\n                    elementIndexFocusedByClick = undefined;\n                }\n                else {\n                    if (focusInStrategy === 'previous') {\n                        updateFocusedElement(event.target);\n                    }\n                    else if (focusInStrategy === 'closest' || focusInStrategy === 'first') {\n                        if (event.relatedTarget instanceof Element && !container.contains(event.relatedTarget)) {\n                            const targetElementIndex = lastKeyboardFocusDirection === 'previous' ? focusableElements.length - 1 : 0;\n                            const targetElement = focusableElements[targetElementIndex];\n                            targetElement === null || targetElement === void 0 ? void 0 : targetElement.focus({ preventScroll });\n                            return;\n                        }\n                        else {\n                            updateFocusedElement(event.target);\n                        }\n                    }\n                    else if (typeof focusInStrategy === 'function') {\n                        if (event.relatedTarget instanceof Element && !container.contains(event.relatedTarget)) {\n                            const elementToFocus = focusInStrategy(event.relatedTarget);\n                            const requestedFocusElementIndex = elementToFocus ? focusableElements.indexOf(elementToFocus) : -1;\n                            if (requestedFocusElementIndex >= 0 && elementToFocus instanceof HTMLElement) {\n                                elementToFocus.focus({ preventScroll });\n                                return;\n                            }\n                            else {\n                                console.warn('Element requested is not a known focusable element.');\n                            }\n                        }\n                        else {\n                            updateFocusedElement(event.target);\n                        }\n                    }\n                }\n            }\n            lastKeyboardFocusDirection = undefined;\n        }, { signal });\n    }\n    const keyboardEventRecipient = activeDescendantControl !== null && activeDescendantControl !== void 0 ? activeDescendantControl : container;\n    let lastKeyboardFocusDirection = undefined;\n    if (focusInStrategy === 'closest') {\n        document.addEventListener('keydown', event => {\n            if (event.key === 'Tab') {\n                lastKeyboardFocusDirection = getDirection(event);\n            }\n        }, { signal, capture: true });\n    }\n    function getCurrentFocusedIndex() {\n        if (!currentFocusedElement) {\n            return 0;\n        }\n        const focusedIndex = focusableElements.indexOf(currentFocusedElement);\n        const fallbackIndex = currentFocusedElement === container ? -1 : 0;\n        return focusedIndex !== -1 ? focusedIndex : fallbackIndex;\n    }\n    keyboardEventRecipient.addEventListener('keydown', event => {\n        var _a;\n        if (event.key in KEY_TO_DIRECTION) {\n            const keyBit = KEY_TO_BIT[event.key];\n            if (!event.defaultPrevented &&\n                (keyBit & bindKeys) > 0 &&\n                !shouldIgnoreFocusHandling(event, document.activeElement)) {\n                const direction = getDirection(event);\n                let nextElementToFocus = undefined;\n                if (settings === null || settings === void 0 ? void 0 : settings.getNextFocusable) {\n                    nextElementToFocus = settings.getNextFocusable(direction, (_a = document.activeElement) !== null && _a !== void 0 ? _a : undefined, event);\n                }\n                if (!nextElementToFocus) {\n                    const lastFocusedIndex = getCurrentFocusedIndex();\n                    let nextFocusedIndex = lastFocusedIndex;\n                    if (direction === 'previous') {\n                        nextFocusedIndex -= 1;\n                    }\n                    else if (direction === 'start') {\n                        nextFocusedIndex = 0;\n                    }\n                    else if (direction === 'next') {\n                        nextFocusedIndex += 1;\n                    }\n                    else {\n                        nextFocusedIndex = focusableElements.length - 1;\n                    }\n                    if (nextFocusedIndex < 0) {\n                        if (focusOutBehavior === 'wrap' && event.key !== 'Tab') {\n                            nextFocusedIndex = focusableElements.length - 1;\n                        }\n                        else {\n                            nextFocusedIndex = 0;\n                        }\n                    }\n                    if (nextFocusedIndex >= focusableElements.length) {\n                        if (focusOutBehavior === 'wrap' && event.key !== 'Tab') {\n                            nextFocusedIndex = 0;\n                        }\n                        else {\n                            nextFocusedIndex = focusableElements.length - 1;\n                        }\n                    }\n                    if (lastFocusedIndex !== nextFocusedIndex) {\n                        nextElementToFocus = focusableElements[nextFocusedIndex];\n                    }\n                }\n                if (activeDescendantControl) {\n                    updateFocusedElement(nextElementToFocus || currentFocusedElement, true);\n                }\n                else if (nextElementToFocus) {\n                    lastKeyboardFocusDirection = direction;\n                    nextElementToFocus.focus({ preventScroll });\n                }\n                if (event.key !== 'Tab' || nextElementToFocus) {\n                    event.preventDefault();\n                }\n            }\n        }\n    }, { signal });\n    return controller;\n}\n","let signalSupported = false;\nfunction noop() { }\ntry {\n    const options = Object.create({}, {\n        signal: {\n            get() {\n                signalSupported = true;\n            },\n        },\n    });\n    window.addEventListener('test', noop, options);\n    window.removeEventListener('test', noop, options);\n}\ncatch (e) {\n}\nfunction featureSupported() {\n    return signalSupported;\n}\nfunction monkeyPatch() {\n    if (typeof window === 'undefined') {\n        return;\n    }\n    const originalAddEventListener = EventTarget.prototype.addEventListener;\n    EventTarget.prototype.addEventListener = function (name, originalCallback, optionsOrCapture) {\n        if (typeof optionsOrCapture === 'object' &&\n            'signal' in optionsOrCapture &&\n            optionsOrCapture.signal instanceof AbortSignal) {\n            originalAddEventListener.call(optionsOrCapture.signal, 'abort', () => {\n                this.removeEventListener(name, originalCallback, optionsOrCapture);\n            });\n        }\n        return originalAddEventListener.call(this, name, originalCallback, optionsOrCapture);\n    };\n}\nexport function polyfill() {\n    if (!featureSupported()) {\n        monkeyPatch();\n        signalSupported = true;\n    }\n}\n","export function* iterateFocusableElements(container, options = {}) {\n    var _a, _b;\n    const strict = (_a = options.strict) !== null && _a !== void 0 ? _a : false;\n    const acceptFn = ((_b = options.onlyTabbable) !== null && _b !== void 0 ? _b : false) ? isTabbable : isFocusable;\n    const walker = document.createTreeWalker(container, NodeFilter.SHOW_ELEMENT, {\n        acceptNode: node => node instanceof HTMLElement && acceptFn(node, strict) ? NodeFilter.FILTER_ACCEPT : NodeFilter.FILTER_SKIP,\n    });\n    let nextNode = null;\n    if (!options.reverse && acceptFn(container, strict)) {\n        yield container;\n    }\n    if (options.reverse) {\n        let lastChild = walker.lastChild();\n        while (lastChild) {\n            nextNode = lastChild;\n            lastChild = walker.lastChild();\n        }\n    }\n    else {\n        nextNode = walker.firstChild();\n    }\n    while (nextNode instanceof HTMLElement) {\n        yield nextNode;\n        nextNode = options.reverse ? walker.previousNode() : walker.nextNode();\n    }\n    if (options.reverse && acceptFn(container, strict)) {\n        yield container;\n    }\n    return undefined;\n}\nexport function getFocusableChild(container, lastChild = false) {\n    return iterateFocusableElements(container, { reverse: lastChild, strict: true, onlyTabbable: true }).next().value;\n}\nexport function isFocusable(elem, strict = false) {\n    const disabledAttrInert = ['BUTTON', 'INPUT', 'SELECT', 'TEXTAREA', 'OPTGROUP', 'OPTION', 'FIELDSET'].includes(elem.tagName) &&\n        elem.disabled;\n    const hiddenInert = elem.hidden;\n    const hiddenInputInert = elem instanceof HTMLInputElement && elem.type === 'hidden';\n    const sentinelInert = elem.classList.contains('sentinel');\n    if (disabledAttrInert || hiddenInert || hiddenInputInert || sentinelInert) {\n        return false;\n    }\n    if (strict) {\n        const style = getComputedStyle(elem);\n        const sizeInert = elem.offsetWidth === 0 || elem.offsetHeight === 0;\n        const visibilityInert = ['hidden', 'collapse'].includes(style.visibility);\n        const displayInert = style.display === 'none' || !elem.offsetParent;\n        const clientRectsInert = elem.getClientRects().length === 0;\n        if (sizeInert || visibilityInert || clientRectsInert || displayInert) {\n            return false;\n        }\n    }\n    if (elem.getAttribute('tabindex') != null) {\n        return true;\n    }\n    if (elem.getAttribute('contenteditable') === 'true' || elem.getAttribute('contenteditable') === 'plaintext-only') {\n        return true;\n    }\n    if (elem instanceof HTMLAnchorElement && elem.getAttribute('href') == null) {\n        return false;\n    }\n    return elem.tabIndex !== -1;\n}\nexport function isTabbable(elem, strict = false) {\n    return isFocusable(elem, strict) && elem.getAttribute('tabindex') !== '-1';\n}\n","let idSeed = 10000;\nexport function uniqueId() {\n    return `__primer_id_${idSeed++}`;\n}\n","let isMac = undefined;\nexport function isMacOS() {\n    if (isMac === undefined) {\n        isMac = /^mac/i.test(window.navigator.platform);\n    }\n    return isMac;\n}\n"],"names":["FocusKeys","KEY_TO_BIT","ArrowLeft","ArrowHorizontal","ArrowDown","ArrowVertical","ArrowUp","ArrowRight","h","HL","j","JK","k","l","a","AD","s","WS","w","d","Tab","Home","HomeAndEnd","End","PageUp","PageUpDown","PageDown","Backspace","KEY_TO_DIRECTION","getDirection","keyboardEvent","direction","key","shiftKey","isMac","metaKey","ctrlKey","isActiveDescendantAttribute","hasActiveDescendantAttribute","focusZone","container","settings","_a","_b","_c","_d","_e","currentFocusedElement","elementIndexFocusedByClick","lastKeyboardFocusDirection","focusableElements","savedTabIndex","WeakMap","bindKeys","getNextFocusable","ArrowAll","focusOutBehavior","focusInStrategy","activeDescendantControl","activeDescendantCallback","onActiveDescendantChanged","preventScroll","updateFocusedElement","to","directlyActivated","from","document","activeElement","setActiveDescendant","clearActiveDescendant","has","setAttribute","id","removeAttribute","getAttribute","previouslyActiveElement","undefined","beginFocusManagement","elements","filteredElements","filter","e","focusableElementFilter","call","length","element","splice","findInsertionIndex","elementsToInsert","firstElementToInsert","iMin","iMax","i","Math","floor","second","compareDocumentPosition","Node","DOCUMENT_POSITION_PRECEDING","set","endFocusManagement","focusableElementIndex","indexOf","savedIndex","get","delete","iterateFocusableElementsOptions","reverse","strict","onlyTabbable","body","observer","MutationObserver","mutations","mutation","removedNode","removedNodes","HTMLElement","type","oldValue","target","addedNode","addedNodes","observe","subtree","childList","attributeFilter","attributeOldValue","controller","AbortController","signal","abortSignal","addEventListener","event","includes","focus","focusableElement","find","contains","capture","relatedTarget","Element","targetElementIndex","targetElement","elementToFocus","requestedFocusElementIndex","console","warn","keyboardEventRecipient","keyBit","defaultPrevented","shouldIgnoreFocusHandling","keyLength","isTextInput","HTMLInputElement","HTMLTextAreaElement","HTMLSelectElement","altKey","cursorAtStart","textInput","selectionStart","selectionEnd","cursorAtEnd","value","nextElementToFocus","lastFocusedIndex","getCurrentFocusedIndex","focusedIndex","fallbackIndex","nextFocusedIndex","preventDefault","signalSupported","noop","options","Object","create","window","removeEventListener","polyfill","monkeyPatch","originalAddEventListener","EventTarget","prototype","name","originalCallback","optionsOrCapture","AbortSignal","iterateFocusableElements","acceptFn","isTabbable","isFocusable","walker","createTreeWalker","NodeFilter","SHOW_ELEMENT","acceptNode","node","FILTER_ACCEPT","FILTER_SKIP","nextNode","lastChild","firstChild","previousNode","getFocusableChild","next","elem","disabledAttrInert","tagName","disabled","hiddenInert","hidden","hiddenInputInert","sentinelInert","classList","style","getComputedStyle","sizeInert","offsetWidth","offsetHeight","visibilityInert","visibility","displayInert","display","offsetParent","clientRectsInert","getClientRects","HTMLAnchorElement","tabIndex","idSeed","uniqueId","isMacOS","test","navigator","platform"],"sourceRoot":""}