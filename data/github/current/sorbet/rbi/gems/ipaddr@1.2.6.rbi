# typed: true

# DO NOT EDIT MANUALLY
# This is an autogenerated file for types exported from the `ipaddr` gem.
# Please instead update this file by running `bin/tapioca gem ipaddr`.

# IPAddr provides a set of methods to manipulate an IP address.  Both IPv4 and
# IPv6 are supported.
#
# == Example
#
#   require 'ipaddr'
#
#   ipaddr1 = IPAddr.new "3ffe:505:2::1"
#
#   p ipaddr1                   #=> #<IPAddr: IPv6:3ffe:0505:0002:0000:0000:0000:0000:0001/ffff:ffff:ffff:ffff:ffff:ffff:ffff:ffff>
#
#   p ipaddr1.to_s              #=> "3ffe:505:2::1"
#
#   ipaddr2 = ipaddr1.mask(48)  #=> #<IPAddr: IPv6:3ffe:0505:0002:0000:0000:0000:0000:0000/ffff:ffff:ffff:0000:0000:0000:0000:0000>
#
#   p ipaddr2.to_s              #=> "3ffe:505:2::"
#
#   ipaddr3 = IPAddr.new "192.168.2.0/24"
#
#   p ipaddr3                   #=> #<IPAddr: IPv4:192.168.2.0/255.255.255.0>
class IPAddr
  include ::Comparable

  # Creates a new ipaddr object either from a human readable IP
  # address representation in string, or from a packed in_addr value
  # followed by an address family.
  #
  # In the former case, the following are the valid formats that will
  # be recognized: "address", "address/prefixlen" and "address/mask",
  # where IPv6 address may be enclosed in square brackets (`[' and
  # `]').  If a prefixlen or a mask is specified, it returns a masked
  # IP address.  Although the address family is determined
  # automatically from a specified string, you can specify one
  # explicitly by the optional second argument.
  #
  # Otherwise an IP address is generated from a packed in_addr value
  # and an address family.
  #
  # The IPAddr class defines many methods and operators, and some of
  # those, such as &, |, include? and ==, accept a string, or a packed
  # in_addr value instead of an IPAddr object.
  #
  # @return [IPAddr] a new instance of IPAddr
  #
  # source://ipaddr//ipaddr.rb#593
  def initialize(addr = T.unsafe(nil), family = T.unsafe(nil)); end

  # Returns a new ipaddr built by bitwise AND.
  #
  # source://ipaddr//ipaddr.rb#125
  def &(other); end

  # Returns a new ipaddr built by bitwise left shift.
  #
  # source://ipaddr//ipaddr.rb#140
  def <<(num); end

  # Compares the ipaddr with another.
  #
  # source://ipaddr//ipaddr.rb#386
  def <=>(other); end

  # Returns true if two ipaddrs are equal.
  #
  # source://ipaddr//ipaddr.rb#150
  def ==(other); end

  # Returns true if the given ipaddr is in the range.
  #
  # e.g.:
  #   require 'ipaddr'
  #   net1 = IPAddr.new("192.168.2.0/24")
  #   net2 = IPAddr.new("192.168.2.100")
  #   net3 = IPAddr.new("192.168.3.0")
  #   net4 = IPAddr.new("192.168.2.0/16")
  #   p net1.include?(net2)     #=> true
  #   p net1.include?(net3)     #=> false
  #   p net1.include?(net4)     #=> false
  #   p net4.include?(net1)     #=> true
  #
  # @return [Boolean]
  #
  # source://ipaddr//ipaddr.rb#176
  def ===(other); end

  # Returns a new ipaddr built by bitwise right-shift.
  #
  # source://ipaddr//ipaddr.rb#135
  def >>(num); end

  # Checks equality used by Hash.
  #
  # @return [Boolean]
  #
  # source://ipaddr//ipaddr.rb#396
  def eql?(other); end

  # Returns the address family of this IP address.
  #
  # source://ipaddr//ipaddr.rb#103
  def family; end

  # Returns a hash value used by Hash, Set, and Array classes
  #
  # source://ipaddr//ipaddr.rb#401
  def hash; end

  # Returns a network byte ordered string form of the IP address.
  #
  # source://ipaddr//ipaddr.rb#226
  def hton; end

  # Returns true if the given ipaddr is in the range.
  #
  # e.g.:
  #   require 'ipaddr'
  #   net1 = IPAddr.new("192.168.2.0/24")
  #   net2 = IPAddr.new("192.168.2.100")
  #   net3 = IPAddr.new("192.168.3.0")
  #   net4 = IPAddr.new("192.168.2.0/16")
  #   p net1.include?(net2)     #=> true
  #   p net1.include?(net3)     #=> false
  #   p net1.include?(net4)     #=> false
  #   p net4.include?(net1)     #=> true
  #
  # @return [Boolean]
  #
  # source://ipaddr//ipaddr.rb#176
  def include?(other); end

  # Returns a string containing a human-readable representation of the
  # ipaddr. ("#<IPAddr: family:address/mask>")
  #
  # source://ipaddr//ipaddr.rb#441
  def inspect; end

  # Returns a string for DNS reverse lookup compatible with RFC3172.
  #
  # source://ipaddr//ipaddr.rb#365
  def ip6_arpa; end

  # Returns a string for DNS reverse lookup compatible with RFC1886.
  #
  # source://ipaddr//ipaddr.rb#373
  def ip6_int; end

  # Returns true if the ipaddr is an IPv4 address.
  #
  # @return [Boolean]
  #
  # source://ipaddr//ipaddr.rb#240
  def ipv4?; end

  # Returns a new ipaddr built by converting the native IPv4 address
  # into an IPv4-compatible IPv6 address.
  #
  # source://ipaddr//ipaddr.rb#333
  def ipv4_compat; end

  # Returns true if the ipaddr is an IPv4-compatible IPv6 address.
  #
  # @return [Boolean]
  #
  # source://ipaddr//ipaddr.rb#305
  def ipv4_compat?; end

  # Returns a new ipaddr built by converting the native IPv4 address
  # into an IPv4-mapped IPv6 address.
  #
  # source://ipaddr//ipaddr.rb#322
  def ipv4_mapped; end

  # Returns true if the ipaddr is an IPv4-mapped IPv6 address.
  #
  # @return [Boolean]
  #
  # source://ipaddr//ipaddr.rb#300
  def ipv4_mapped?; end

  # Returns true if the ipaddr is an IPv6 address.
  #
  # @return [Boolean]
  #
  # source://ipaddr//ipaddr.rb#245
  def ipv6?; end

  # Returns true if the ipaddr is a link-local address.  IPv4
  # addresses in 169.254.0.0/16 reserved by RFC 3927 and Link-Local
  # IPv6 Unicast Addresses in fe80::/10 reserved by RFC 4291 are
  # considered link-local.
  #
  # @return [Boolean]
  #
  # source://ipaddr//ipaddr.rb#288
  def link_local?; end

  # Returns true if the ipaddr is a loopback address.
  #
  # @return [Boolean]
  #
  # source://ipaddr//ipaddr.rb#250
  def loopback?; end

  # Returns a new ipaddr built by masking IP address with the given
  # prefixlen/netmask. (e.g. 8, 64, "255.255.255.0", etc.)
  #
  # source://ipaddr//ipaddr.rb#160
  def mask(prefixlen); end

  # Returns a new ipaddr built by converting the IPv6 address into a
  # native IPv4 address.  If the IP address is not an IPv4-mapped or
  # IPv4-compatible IPv6 address, returns self.
  #
  # source://ipaddr//ipaddr.rb#344
  def native; end

  # Returns the netmask in string format e.g. 255.255.0.0
  #
  # source://ipaddr//ipaddr.rb#456
  def netmask; end

  # Returns the prefix length in bits for the ipaddr.
  #
  # source://ipaddr//ipaddr.rb#411
  def prefix; end

  # Sets the prefix length in bits
  #
  # source://ipaddr//ipaddr.rb#430
  def prefix=(prefix); end

  # Returns a string for DNS reverse lookup.  It returns a string in
  # RFC3172 form for an IPv6 address.
  #
  # source://ipaddr//ipaddr.rb#353
  def reverse; end

  # Returns the successor to the ipaddr.
  #
  # source://ipaddr//ipaddr.rb#381
  def succ; end

  # Returns the integer representation of the ipaddr.
  #
  # source://ipaddr//ipaddr.rb#184
  def to_i; end

  # Creates a Range object for the network address.
  #
  # source://ipaddr//ipaddr.rb#406
  def to_range; end

  # Returns a string containing the IP address representation.
  #
  # source://ipaddr//ipaddr.rb#189
  def to_s; end

  # Returns a string containing the IP address representation in
  # canonical form.
  #
  # source://ipaddr//ipaddr.rb#215
  def to_string; end

  # Returns the IPv6 zone identifier, if present.
  # Raises InvalidAddressError if not an IPv6 address.
  #
  # source://ipaddr//ipaddr.rb#462
  def zone_id; end

  # Returns the IPv6 zone identifier, if present.
  # Raises InvalidAddressError if not an IPv6 address.
  #
  # source://ipaddr//ipaddr.rb#472
  def zone_id=(zid); end

  # Returns a new ipaddr built by bitwise OR.
  #
  # source://ipaddr//ipaddr.rb#130
  def |(other); end

  # Returns a new ipaddr built by bitwise negation.
  #
  # source://ipaddr//ipaddr.rb#145
  def ~; end

  protected

  # source://ipaddr//ipaddr.rb#487
  def begin_addr; end

  # source://ipaddr//ipaddr.rb#491
  def end_addr; end

  # Set current netmask to given mask.
  #
  # source://ipaddr//ipaddr.rb#529
  def mask!(mask); end

  # Set +@addr+, the internal stored ip address, to given +addr+. The
  # parameter +addr+ is validated using the first +family+ member,
  # which is +Socket::AF_INET+ or +Socket::AF_INET6+.
  #
  # source://ipaddr//ipaddr.rb#505
  def set(addr, *family); end

  private

  # @return [Boolean]
  #
  # source://ipaddr//ipaddr.rb#310
  def _ipv4_compat?; end

  # source://ipaddr//ipaddr.rb#716
  def _reverse; end

  # source://ipaddr//ipaddr.rb#729
  def _to_string(addr); end

  # source://ipaddr//ipaddr.rb#705
  def addr_mask(addr); end

  # source://ipaddr//ipaddr.rb#642
  def coerce_other(other); end

  # source://ipaddr//ipaddr.rb#668
  def in6_addr(left); end

  # source://ipaddr//ipaddr.rb#653
  def in_addr(addr); end

  class << self
    # Creates a new ipaddr containing the given network byte ordered
    # string form of an IP address.
    #
    # source://ipaddr//ipaddr.rb#107
    def new_ntoh(addr); end

    # Convert a network byte ordered string form of an IP address into
    # human readable form.
    #
    # source://ipaddr//ipaddr.rb#113
    def ntop(addr); end
  end
end

# source://ipaddr//ipaddr.rb#43
IPAddr::VERSION = T.let(T.unsafe(nil), String)
