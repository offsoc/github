# typed: true

# DO NOT EDIT MANUALLY
# This is an autogenerated file for types exported from the `re2` gem.
# Please instead update this file by running `bin/tapioca gem re2`.

# source://re2//lib/re2/regexp.rb#10
module RE2
  private

  def GlobalReplace(_arg0, _arg1, _arg2); end
  def QuoteMeta(_arg0); end
  def Replace(_arg0, _arg1, _arg2); end

  class << self
    def GlobalReplace(_arg0, _arg1, _arg2); end
    def QuoteMeta(_arg0); end
    def Replace(_arg0, _arg1, _arg2); end
  end
end

class RE2::MatchData
  def [](*_arg0); end
  def begin(_arg0); end
  def deconstruct; end
  def deconstruct_keys(_arg0); end
  def end(_arg0); end
  def inspect; end
  def length; end
  def regexp; end
  def size; end
  def string; end
  def to_a; end
  def to_s; end
end

# source://re2//lib/re2/regexp.rb#11
class RE2::Regexp
  def initialize(*_arg0); end

  def ===(_arg0); end
  def =~(_arg0); end
  def case_insensitive?; end
  def case_sensitive?; end
  def casefold?; end
  def error; end
  def error_arg; end

  # Match the pattern against the given `text` exactly and return a
  # {RE2::MatchData} instance with the specified number of submatches
  # (defaults to the total number of capturing groups) or a boolean (if no
  # submatches are required).
  #
  # The number of submatches has a significant impact on performance: requesting
  # one submatch is much faster than requesting more than one and requesting
  # zero submatches is faster still.
  #
  # @example
  #   r = RE2::Regexp.new('w(o)(o)')
  #   r.full_match('woo')                #=> #<RE2::MatchData "woo" 1:"o" 2:"o">
  #   r.full_match('woot')               #=> nil
  #   r.full_match('woo', submatches: 1) #=> #<RE2::MatchData "woo" 1:"o">
  #   r.full_match('woo', submatches: 0) #=> true
  # @option options
  # @param text [String] the text to search
  # @param options [Hash] the options with which to perform the match
  # @raise [ArgumentError] if given a negative number of submatches
  # @raise [NoMemoryError] if there was not enough memory to allocate the
  #   matches
  # @raise [TypeError] if given non-numeric submatches or non-hash options
  # @return [RE2::MatchData, nil] if extracting any submatches
  # @return [Boolean] if not extracting any submatches
  #
  # source://re2//lib/re2/regexp.rb#66
  def full_match(text, options = T.unsafe(nil)); end

  def full_match?(_arg0); end
  def inspect; end
  def literal?; end
  def log_errors?; end
  def longest_match?; end
  def match(*_arg0); end
  def match?(_arg0); end
  def max_mem; end
  def named_capturing_groups; end
  def never_nl?; end
  def number_of_capturing_groups; end
  def ok?; end
  def one_line?; end
  def options; end

  # Match the pattern against any substring of the given `text` and return a
  # {RE2::MatchData} instance with the specified number of submatches
  # (defaults to the total number of capturing groups) or a boolean (if no
  # submatches are required).
  #
  # The number of submatches has a significant impact on performance: requesting
  # one submatch is much faster than requesting more than one and requesting
  # zero submatches is faster still.
  #
  # @example
  #   r = RE2::Regexp.new('w(o)(o)')
  #   r.partial_match('woot')                #=> #<RE2::MatchData "woo" 1:"o" 2:"o">
  #   r.partial_match('nope')                #=> nil
  #   r.partial_match('woot', submatches: 1) #=> #<RE2::MatchData "woo" 1:"o">
  #   r.partial_match('woot', submatches: 0) #=> true
  # @option options
  # @param text [String] the text to search
  # @param options [Hash] the options with which to perform the match
  # @raise [ArgumentError] if given a negative number of submatches
  # @raise [NoMemoryError] if there was not enough memory to allocate the
  #   matches
  # @raise [TypeError] if given non-numeric submatches or non-hash options
  # @return [RE2::MatchData, nil] if extracting any submatches
  # @return [Boolean] if not extracting any submatches
  #
  # source://re2//lib/re2/regexp.rb#37
  def partial_match(text, options = T.unsafe(nil)); end

  def partial_match?(_arg0); end
  def pattern; end
  def perl_classes?; end
  def posix_syntax?; end
  def program_size; end
  def scan(_arg0); end
  def source; end
  def to_s; end
  def to_str; end
  def utf8?; end
  def word_boundary?; end

  class << self
    def compile(*_arg0); end
    def escape(_arg0); end
    def match_has_endpos_argument?; end
    def quote(_arg0); end
  end
end

class RE2::Regexp::UnsupportedError < ::StandardError; end

# source://re2//lib/re2/scanner.rb#11
class RE2::Scanner
  include ::Prelude::Enumerator
  include ::Enumerable

  # source://re2//lib/re2/scanner.rb#14
  def each; end

  def eof?; end
  def regexp; end
  def rewind; end
  def scan; end
  def string; end
end

class RE2::Set
  def initialize(*_arg0); end

  def add(_arg0); end
  def compile; end
  def match(*_arg0); end

  class << self
    def match_raises_errors?; end
  end
end

class RE2::Set::MatchError < ::StandardError; end
class RE2::Set::UnsupportedError < ::StandardError; end

# source://re2//lib/re2/version.rb#13
RE2::VERSION = T.let(T.unsafe(nil), String)
