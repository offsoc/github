# frozen_string_literal: true

require "failbot/backtrace"

module Failbot
  module ExceptionFormat
    # A newer exception format , based on the one sentry uses.  Aside from
    # different names and locations for things, the notable difference from
    # haystack is that backtrace data has more structure.
    class Structured
      EMPTY_ARRAY = [].freeze

      # Format an exception.
      def self.call(e)
        message = e.message.to_s
        class_name = e.class.to_s
        begin
          Failbot.backtrace_parser.call(e)
        rescue => ex
          message += "\nUnable to parse backtrace (#{ex.inspect})\nDon't put non-backtrace text in Exception#backtrace please!\nSo-called backtrace follows:\n#{e.backtrace.join("\n")}"
          class_name += " (backtrace failed to parse)"
          EMPTY_ARRAY
        end
        {
          "platform" => "ruby",
          "exception_detail" => exception_details(e),
          "ruby" => RUBY_DESCRIPTION,
          "created_at" => Time.now.utc.iso8601(6)
        }
      end

      FURTHER_CAUSES_WERE_OMITTED = {
        "type" => "Notice",
        "value" => "further Exception#cause values were omitted",
        "stacktrace" => EMPTY_ARRAY
      }.freeze

      def self.exception_details(e)
        result = []
        depth = 0

        loop do
          message = e.message.to_s
          class_name = e.class.to_s
          stacktrace = begin
            Failbot.backtrace_parser.call(e)
          rescue => ex
            message += "\nUnable to parse backtrace (#{ex.inspect})\nDon't put non-backtrace text in Exception#backtrace please!\nSo-called backtrace follows:\n#{e.backtrace.join("\n")}"
            class_name += " (backtrace failed to parse)"
            EMPTY_ARRAY
          end
          result.unshift({
            "type" => class_name,
            "value" => message,
            "stacktrace" => stacktrace
          })
          depth += 1
          break unless (e=e.cause)
          if depth > MAXIMUM_CAUSE_DEPTH
            result.unshift(FURTHER_CAUSES_WERE_OMITTED)
            break
          end
        end
        result
      end

      # given a hash generated by this class, return the exception message.
      def self.exception_message_from_hash(hash)
        hash.dig("exception_detail", 0, "value")
      end

      # given a hash generated by this class, return the exception class name.
      def self.exception_classname_from_hash(hash)
        hash.dig("exception_detail", 0, "type")
      end
    end
  end
end
