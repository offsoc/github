# typed: true

# DO NOT EDIT MANUALLY
# This is an autogenerated file for types exported from the `org-ruby` gem.
# Please instead update this file by running `bin/tapioca gem org-ruby`.

# source://org-ruby//lib/org-ruby/version.rb#1
module OrgRuby
  class << self
    # Utility method used to require all files ending in .rb that lie in the
    # directory below this file that has the same name as the filename passed
    # in. Optionally, a specific _directory_ name can be passed in such that
    # the _filename_ does not have to be equivalent to the directory.
    #
    # source://org-ruby//lib/org-ruby.rb#41
    def require_all_libs_relative_to(fname, dir = T.unsafe(nil)); end

    # Returns the version string for the library.
    #
    # source://org-ruby//lib/org-ruby.rb#32
    def version; end
  end
end

# :stopdoc:
#
# source://org-ruby//lib/org-ruby.rb#26
OrgRuby::LIBPATH = T.let(T.unsafe(nil), String)

# source://org-ruby//lib/org-ruby.rb#27
OrgRuby::PATH = T.let(T.unsafe(nil), String)

# source://org-ruby//lib/org-ruby/version.rb#2
OrgRuby::VERSION = T.let(T.unsafe(nil), String)

# Autogenerated by util/gen-special-replace.el
#
# source://org-ruby//lib/org-ruby/parser.rb#5
module Orgmode
  class << self
    # source://org-ruby//lib/org-ruby/html_symbol_replace.rb#351
    def special_symbols_to_html(str); end

    # source://org-ruby//lib/org-ruby/textile_symbol_replace.rb#352
    def special_symbols_to_textile(str); end
  end
end

# Represents a headline in an orgmode file.
#
# source://org-ruby//lib/org-ruby/headline.rb#4
class Orgmode::Headline < ::Orgmode::Line
  # @return [Headline] a new instance of Headline
  #
  # source://org-ruby//lib/org-ruby/headline.rb#48
  def initialize(line, parser = T.unsafe(nil), offset = T.unsafe(nil)); end

  # This contains the lines that "belong" to the headline.
  #
  # source://org-ruby//lib/org-ruby/headline.rb#14
  def body_lines; end

  # Determines if a headline has the COMMENT keyword.
  #
  # @return [Boolean]
  #
  # source://org-ruby//lib/org-ruby/headline.rb#82
  def comment_headline?; end

  # The export state of this headline. See +ValidExportStates+.
  #
  # source://org-ruby//lib/org-ruby/headline.rb#29
  def export_state; end

  # The export state of this headline. See +ValidExportStates+.
  #
  # source://org-ruby//lib/org-ruby/headline.rb#29
  def export_state=(_arg0); end

  # This is the headline text -- the part of the headline minus the leading
  # asterisks, the keywords, and the tags.
  #
  # source://org-ruby//lib/org-ruby/headline.rb#11
  def headline_text; end

  # Optional keyword found at the beginning of the headline.
  #
  # source://org-ruby//lib/org-ruby/headline.rb#20
  def keyword; end

  # This is the "level" of the headline
  #
  # source://org-ruby//lib/org-ruby/headline.rb#7
  def level; end

  # Override Line.output_text. For a heading, @headline_text
  # is what we should output.
  #
  # source://org-ruby//lib/org-ruby/headline.rb#71
  def output_text; end

  # Overrides Line.paragraph_type.
  #
  # source://org-ruby//lib/org-ruby/headline.rb#87
  def paragraph_type; end

  # Include the property drawer items found for the headline
  #
  # source://org-ruby//lib/org-ruby/headline.rb#32
  def property_drawer; end

  # Include the property drawer items found for the headline
  #
  # source://org-ruby//lib/org-ruby/headline.rb#32
  def property_drawer=(_arg0); end

  # These are the headline tags
  #
  # source://org-ruby//lib/org-ruby/headline.rb#17
  def tags; end

  private

  # source://org-ruby//lib/org-ruby/headline.rb#94
  def parse_keywords; end

  class << self
    # Determines if a line is an orgmode "headline":
    # A headline begins with one or more asterisks.
    #
    # @return [Boolean]
    #
    # source://org-ruby//lib/org-ruby/headline.rb#77
    def headline?(line); end
  end
end

# This matches a headline marked as COMMENT
#
# source://org-ruby//lib/org-ruby/headline.rb#46
Orgmode::Headline::CommentHeadlineRegexp = T.let(T.unsafe(nil), Regexp)

# Special keywords allowed at the start of a line.
#
# source://org-ruby//lib/org-ruby/headline.rb#41
Orgmode::Headline::Keywords = T.let(T.unsafe(nil), Array)

# source://org-ruby//lib/org-ruby/headline.rb#43
Orgmode::Headline::KeywordsRegexp = T.let(T.unsafe(nil), Regexp)

# This is the regex that matches a line
#
# source://org-ruby//lib/org-ruby/headline.rb#35
Orgmode::Headline::LineRegexp = T.let(T.unsafe(nil), Regexp)

# This matches the tags on a headline
#
# source://org-ruby//lib/org-ruby/headline.rb#38
Orgmode::Headline::TagsRegexp = T.let(T.unsafe(nil), Regexp)

# Valid states for partial export.
# exclude::       The entire subtree from this heading should be excluded.
# headline_only:: The headline should be exported, but not the body.
# all::           Everything should be exported, headline/body/children.
#
# source://org-ruby//lib/org-ruby/headline.rb#26
Orgmode::Headline::ValidExportStates = T.let(T.unsafe(nil), Array)

# source://org-ruby//lib/org-ruby/html_symbol_replace.rb#4
Orgmode::HtmlEntities = T.let(T.unsafe(nil), Hash)

# source://org-ruby//lib/org-ruby/html_output_buffer.rb#5
class Orgmode::HtmlOutputBuffer < ::Orgmode::OutputBuffer
  # @return [HtmlOutputBuffer] a new instance of HtmlOutputBuffer
  #
  # source://org-ruby//lib/org-ruby/html_output_buffer.rb#33
  def initialize(output, opts = T.unsafe(nil)); end

  # source://org-ruby//lib/org-ruby/html_output_buffer.rb#199
  def add_line_attributes(headline); end

  # source://org-ruby//lib/org-ruby/html_output_buffer.rb#115
  def flush!; end

  # Returns the value of attribute options.
  #
  # source://org-ruby//lib/org-ruby/html_output_buffer.rb#31
  def options; end

  # source://org-ruby//lib/org-ruby/html_output_buffer.rb#211
  def output_footnotes!; end

  # We are leaving a mode. Close any tags that were opened when
  # entering this mode.
  #
  # source://org-ruby//lib/org-ruby/html_output_buffer.rb#101
  def pop_mode(mode = T.unsafe(nil)); end

  # Test if we're in an output mode in which whitespace is significant.
  #
  # @return [Boolean]
  #
  # source://org-ruby//lib/org-ruby/html_output_buffer.rb#232
  def preserve_whitespace?; end

  # Output buffer is entering a new mode. Use this opportunity to
  # write out one of the block tags in the HtmlBlockTag constant to
  # put this information in the HTML stream.
  #
  # source://org-ruby//lib/org-ruby/html_output_buffer.rb#64
  def push_mode(mode, indent, properties = T.unsafe(nil)); end

  private

  # source://org-ruby//lib/org-ruby/html_output_buffer.rb#275
  def add_paragraph; end

  # source://org-ruby//lib/org-ruby/html_output_buffer.rb#270
  def buffer_indentation; end

  # source://org-ruby//lib/org-ruby/html_output_buffer.rb#428
  def escapeHTML(string); end

  # Escapes any HTML content in string
  #
  # source://org-ruby//lib/org-ruby/html_output_buffer.rb#253
  def escape_string!(str); end

  # Applies inline formatting rules to a string.
  #
  # source://org-ruby//lib/org-ruby/html_output_buffer.rb#291
  def inline_formatting(str); end

  # @return [Boolean]
  #
  # source://org-ruby//lib/org-ruby/html_output_buffer.rb#248
  def mode_is_ol?(mode); end

  # @return [Boolean]
  #
  # source://org-ruby//lib/org-ruby/html_output_buffer.rb#243
  def mode_is_table?(mode); end

  # source://org-ruby//lib/org-ruby/html_output_buffer.rb#370
  def normalize_lang(lang); end

  # source://org-ruby//lib/org-ruby/html_output_buffer.rb#266
  def quote_tags(str); end

  # Helper method taken from Rails
  # https://github.com/rails/rails/blob/c2c8ef57d6f00d1c22743dc43746f95704d67a95/activesupport/lib/active_support/core_ext/kernel/reporting.rb#L10
  #
  # source://org-ruby//lib/org-ruby/html_output_buffer.rb#387
  def silence_warnings; end

  # @return [Boolean]
  #
  # source://org-ruby//lib/org-ruby/html_output_buffer.rb#239
  def skip_tables?; end

  # source://org-ruby//lib/org-ruby/html_output_buffer.rb#395
  def strip_code_block!; end
end

# source://org-ruby//lib/org-ruby/html_output_buffer.rb#7
Orgmode::HtmlOutputBuffer::HtmlBlockTag = T.let(T.unsafe(nil), Hash)

# The CGI::escapeHTML function backported from the Ruby standard library
# as of commit fd2fc885b43283aa3d76820b2dfa9de19a77012f
#
# Implementation of the cgi module can change among Ruby versions
# so stabilizing on a single one here to avoid surprises.
#
# https://github.com/ruby/ruby/blob/trunk/lib/cgi/util.rb
#
# The set of special characters and their escaped values
#
# source://org-ruby//lib/org-ruby/html_output_buffer.rb#417
Orgmode::HtmlOutputBuffer::TABLE_FOR_ESCAPE_HTML__ = T.let(T.unsafe(nil), Hash)

# source://org-ruby//lib/org-ruby/html_output_buffer.rb#280
Orgmode::HtmlOutputBuffer::Tags = T.let(T.unsafe(nil), Hash)

# Represents a single line of an orgmode file.
#
# source://org-ruby//lib/org-ruby/line.rb#4
class Orgmode::Line
  # @return [Line] a new instance of Line
  #
  # source://org-ruby//lib/org-ruby/line.rb#30
  def initialize(line, parser = T.unsafe(nil), assigned_paragraph_type = T.unsafe(nil)); end

  # A line can have its type assigned instead of inferred from its
  # content. For example, something that parses as a "table" on its
  # own ("| one | two|\n") may just be a paragraph if it's inside
  # #+BEGIN_EXAMPLE. Set this property on the line to assign its
  # type. This will then affect the value of +paragraph_type+.
  #
  # source://org-ruby//lib/org-ruby/line.rb#25
  def assigned_paragraph_type; end

  # A line can have its type assigned instead of inferred from its
  # content. For example, something that parses as a "table" on its
  # own ("| one | two|\n") may just be a paragraph if it's inside
  # #+BEGIN_EXAMPLE. Set this property on the line to assign its
  # type. This will then affect the value of +paragraph_type+.
  #
  # source://org-ruby//lib/org-ruby/line.rb#25
  def assigned_paragraph_type=(_arg0); end

  # @return [Boolean]
  #
  # source://org-ruby//lib/org-ruby/line.rb#191
  def begin_block?; end

  # @return [Boolean]
  #
  # source://org-ruby//lib/org-ruby/line.rb#89
  def blank?; end

  # source://org-ruby//lib/org-ruby/line.rb#215
  def block_header_arguments; end

  # source://org-ruby//lib/org-ruby/line.rb#203
  def block_lang; end

  # TODO: COMMENT block should be considered here
  #
  # @return [Boolean]
  #
  # source://org-ruby//lib/org-ruby/line.rb#233
  def block_should_be_exported?; end

  # source://org-ruby//lib/org-ruby/line.rb#211
  def block_switches; end

  # source://org-ruby//lib/org-ruby/line.rb#199
  def block_type; end

  # @return [Boolean]
  #
  # source://org-ruby//lib/org-ruby/line.rb#207
  def code_block?; end

  # Tests if a line is a comment.
  #
  # @return [Boolean]
  #
  # source://org-ruby//lib/org-ruby/line.rb#48
  def comment?; end

  # @return [Boolean]
  #
  # source://org-ruby//lib/org-ruby/line.rb#109
  def definition_list?; end

  # source://org-ruby//lib/org-ruby/line.rb#382
  def determine_major_mode; end

  # Determines the paragraph type of the current line.
  #
  # source://org-ruby//lib/org-ruby/line.rb#334
  def determine_paragraph_type; end

  # @return [Boolean]
  #
  # source://org-ruby//lib/org-ruby/line.rb#195
  def end_block?; end

  # source://org-ruby//lib/org-ruby/line.rb#129
  def extract_properties; end

  # @return [Boolean]
  #
  # source://org-ruby//lib/org-ruby/line.rb#142
  def horizontal_rule?; end

  # call-seq:
  #     line.in_buffer_setting?         => boolean
  #     line.in_buffer_setting? { |key, value| ... }
  #
  # Called without a block, this method determines if the line
  # contains an in-buffer setting. Called with a block, the block
  # will get called if the line contains an in-buffer setting with
  # the key and value for the setting.
  #
  # @return [Boolean]
  #
  # source://org-ruby//lib/org-ruby/line.rb#286
  def in_buffer_setting?; end

  # @return [Boolean]
  #
  # source://org-ruby//lib/org-ruby/line.rb#321
  def include_file?; end

  # source://org-ruby//lib/org-ruby/line.rb#329
  def include_file_options; end

  # source://org-ruby//lib/org-ruby/line.rb#325
  def include_file_path; end

  # The indent level of this line. this is important to properly translate
  # nested lists from orgmode to textile.
  # TODO 2009-12-20 bdewey: Handle tabs
  #
  # source://org-ruby//lib/org-ruby/line.rb#9
  def indent; end

  # Test if the line matches the "inline example" case:
  # the first character on the line is a colon.
  #
  # @return [Boolean]
  #
  # source://org-ruby//lib/org-ruby/line.rb#257
  def inline_example?; end

  # @return [Boolean]
  #
  # source://org-ruby//lib/org-ruby/line.rb#311
  def link_abbrev?; end

  # source://org-ruby//lib/org-ruby/line.rb#315
  def link_abbrev_data; end

  # Major modes associate paragraphs with a table, list and so on.
  #
  # source://org-ruby//lib/org-ruby/line.rb#18
  def major_mode; end

  # Tests if a line contains metadata instead of actual content.
  #
  # @return [Boolean]
  #
  # source://org-ruby//lib/org-ruby/line.rb#81
  def metadata?; end

  # @return [Boolean]
  #
  # source://org-ruby//lib/org-ruby/line.rb#85
  def nonprinting?; end

  # @return [Boolean]
  #
  # source://org-ruby//lib/org-ruby/line.rb#115
  def ordered_list?; end

  # Extracts meaningful text and excludes org-mode markup,
  # like identifiers for lists or headings.
  #
  # source://org-ruby//lib/org-ruby/line.rb#148
  def output_text; end

  # Paragraph type determined for the line.
  #
  # source://org-ruby//lib/org-ruby/line.rb#15
  def paragraph_type; end

  # Backpointer to the parser that owns this line.
  #
  # source://org-ruby//lib/org-ruby/line.rb#12
  def parser; end

  # @return [Boolean]
  #
  # source://org-ruby//lib/org-ruby/line.rb#93
  def plain_list?; end

  # @return [Boolean]
  #
  # source://org-ruby//lib/org-ruby/line.rb#156
  def plain_text?; end

  # In case more contextual info is needed we can put here
  #
  # source://org-ruby//lib/org-ruby/line.rb#28
  def properties; end

  # In case more contextual info is needed we can put here
  #
  # source://org-ruby//lib/org-ruby/line.rb#28
  def properties=(_arg0); end

  # @return [Boolean]
  #
  # source://org-ruby//lib/org-ruby/line.rb#64
  def property_drawer?; end

  # @return [Boolean]
  #
  # source://org-ruby//lib/org-ruby/line.rb#56
  def property_drawer_begin_block?; end

  # @return [Boolean]
  #
  # source://org-ruby//lib/org-ruby/line.rb#60
  def property_drawer_end_block?; end

  # source://org-ruby//lib/org-ruby/line.rb#74
  def property_drawer_item; end

  # @return [Boolean]
  #
  # source://org-ruby//lib/org-ruby/line.rb#70
  def property_drawer_item?; end

  # Checks if this line is raw text.
  #
  # @return [Boolean]
  #
  # source://org-ruby//lib/org-ruby/line.rb#264
  def raw_text?; end

  # source://org-ruby//lib/org-ruby/line.rb#268
  def raw_text_tag; end

  # @return [Boolean]
  #
  # source://org-ruby//lib/org-ruby/line.rb#243
  def results_block_should_be_exported?; end

  # @return [Boolean]
  #
  # source://org-ruby//lib/org-ruby/line.rb#305
  def start_of_results_code_block?; end

  # source://org-ruby//lib/org-ruby/line.rb#121
  def strip_ordered_list_tag; end

  # source://org-ruby//lib/org-ruby/line.rb#272
  def strip_raw_text_tag; end

  # source://org-ruby//lib/org-ruby/line.rb#103
  def strip_unordered_list_tag; end

  # @return [Boolean]
  #
  # source://org-ruby//lib/org-ruby/line.rb#179
  def table?; end

  # Checks if this line is a table header.
  #
  # @return [Boolean]
  #
  # source://org-ruby//lib/org-ruby/line.rb#175
  def table_header?; end

  # @return [Boolean]
  #
  # source://org-ruby//lib/org-ruby/line.rb#160
  def table_row?; end

  # @return [Boolean]
  #
  # source://org-ruby//lib/org-ruby/line.rb#166
  def table_separator?; end

  # #+TITLE: is special because even though that it can be
  # written many times in the document, its value will be that of the last one
  #
  # @return [Boolean]
  #
  # source://org-ruby//lib/org-ruby/line.rb#299
  def title?; end

  # source://org-ruby//lib/org-ruby/line.rb#43
  def to_s; end

  # @return [Boolean]
  #
  # source://org-ruby//lib/org-ruby/line.rb#99
  def unordered_list?; end

  private

  # This function is an internal helper for determining the paragraph
  # type of a line... for instance, if the line is a comment or contains
  # metadata. It's used in routines like blank?, plain_list?, etc.
  #
  # What's tricky is lines can have assigned types, so you need to check
  # the assigned type, if present, or see if the characteristic regexp
  # for the paragraph type matches if not present.
  #
  # call-seq:
  #     check_assignment_or_regexp(assignment, regexp) => boolean
  #
  # assignment:: if the paragraph has an assigned type, it will be
  #              checked to see if it equals +assignment+.
  # regexp::     If the paragraph does not have an assigned type,
  #              the contents of the paragraph will be checked against
  #              this regexp.
  #
  # source://org-ruby//lib/org-ruby/line.rb#415
  def check_assignment_or_regexp(assignment, regexp); end
end

# 1) block delimiters
# 2) block type (src, example, html...)
# 3) switches (e.g. -n -r -l "asdf")
# 4) header arguments (:hello world)
#
# source://org-ruby//lib/org-ruby/line.rb#189
Orgmode::Line::BlockRegexp = T.let(T.unsafe(nil), Regexp)

# source://org-ruby//lib/org-ruby/line.rb#119
Orgmode::Line::ContinuedOrderedListRegexp = T.let(T.unsafe(nil), Regexp)

# source://org-ruby//lib/org-ruby/line.rb#107
Orgmode::Line::DefinitionListRegexp = T.let(T.unsafe(nil), Regexp)

# source://org-ruby//lib/org-ruby/line.rb#140
Orgmode::Line::HorizontalRuleRegexp = T.let(T.unsafe(nil), Regexp)

# source://org-ruby//lib/org-ruby/line.rb#276
Orgmode::Line::InBufferSettingRegexp = T.let(T.unsafe(nil), Regexp)

# source://org-ruby//lib/org-ruby/line.rb#319
Orgmode::Line::IncludeFileRegexp = T.let(T.unsafe(nil), Regexp)

# source://org-ruby//lib/org-ruby/line.rb#253
Orgmode::Line::InlineExampleRegexp = T.let(T.unsafe(nil), Regexp)

# source://org-ruby//lib/org-ruby/line.rb#309
Orgmode::Line::LinkAbbrevRegexp = T.let(T.unsafe(nil), Regexp)

# source://org-ruby//lib/org-ruby/line.rb#113
Orgmode::Line::OrderedListRegexp = T.let(T.unsafe(nil), Regexp)

# source://org-ruby//lib/org-ruby/line.rb#68
Orgmode::Line::PropertyDrawerItemRegexp = T.let(T.unsafe(nil), Regexp)

# source://org-ruby//lib/org-ruby/line.rb#54
Orgmode::Line::PropertyDrawerRegexp = T.let(T.unsafe(nil), Regexp)

# source://org-ruby//lib/org-ruby/line.rb#261
Orgmode::Line::RawTextRegexp = T.let(T.unsafe(nil), Regexp)

# source://org-ruby//lib/org-ruby/line.rb#303
Orgmode::Line::ResultsBlockStartsRegexp = T.let(T.unsafe(nil), Regexp)

# source://org-ruby//lib/org-ruby/line.rb#97
Orgmode::Line::UnorderedListRegexp = T.let(T.unsafe(nil), Regexp)

# source://org-ruby//lib/org-ruby/markdown_output_buffer.rb#5
class Orgmode::MarkdownOutputBuffer < ::Orgmode::OutputBuffer
  # @return [MarkdownOutputBuffer] a new instance of MarkdownOutputBuffer
  #
  # source://org-ruby//lib/org-ruby/markdown_output_buffer.rb#7
  def initialize(output, opts = T.unsafe(nil)); end

  # source://org-ruby//lib/org-ruby/markdown_output_buffer.rb#111
  def add_line_attributes(headline); end

  # Flushes the current buffer
  #
  # source://org-ruby//lib/org-ruby/markdown_output_buffer.rb#78
  def flush!; end

  # Handles inline formatting for markdown.
  #
  # source://org-ruby//lib/org-ruby/markdown_output_buffer.rb#39
  def inline_formatting(input); end

  # TODO: Implement this
  #
  # source://org-ruby//lib/org-ruby/markdown_output_buffer.rb#73
  def output_footnotes!; end

  # source://org-ruby//lib/org-ruby/markdown_output_buffer.rb#22
  def pop_mode(mode = T.unsafe(nil)); end

  # source://org-ruby//lib/org-ruby/markdown_output_buffer.rb#18
  def push_mode(mode, indent, properties = T.unsafe(nil)); end
end

# Maps org markup to markdown markup.
#
# source://org-ruby//lib/org-ruby/markdown_output_buffer.rb#29
Orgmode::MarkdownOutputBuffer::MarkdownMap = T.let(T.unsafe(nil), Hash)

# The OutputBuffer is used to accumulate multiple lines of orgmode
# text, and then emit them to the output all in one go. The class
# will do the final textile substitution for inline formatting and
# add a newline character prior emitting the output.
#
# source://org-ruby//lib/org-ruby/output_buffer.rb#11
class Orgmode::OutputBuffer
  # Creates a new OutputBuffer object that is bound to an output object.
  # The output will get flushed to =output=.
  #
  # @return [OutputBuffer] a new instance of OutputBuffer
  #
  # source://org-ruby//lib/org-ruby/output_buffer.rb#21
  def initialize(output); end

  # source://org-ruby//lib/org-ruby/output_buffer.rb#47
  def current_mode; end

  # source://org-ruby//lib/org-ruby/output_buffer.rb#141
  def do_custom_markup; end

  # Gets the next headline number for a given level. The intent is
  # this function is called sequentially for each headline that
  # needs to get numbered. It does standard outline numbering.
  #
  # source://org-ruby//lib/org-ruby/output_buffer.rb#118
  def get_next_headline_number(level); end

  # source://org-ruby//lib/org-ruby/output_buffer.rb#63
  def insert(line); end

  # Gets the current list indent level.
  #
  # source://org-ruby//lib/org-ruby/output_buffer.rb#132
  def list_indent_level; end

  # source://org-ruby//lib/org-ruby/output_buffer.rb#154
  def load_custom_markup; end

  # source://org-ruby//lib/org-ruby/output_buffer.rb#172
  def no_custom_markup_file_exists; end

  # source://org-ruby//lib/org-ruby/output_buffer.rb#166
  def no_valid_markup_found; end

  # This is the overall output buffer
  #
  # source://org-ruby//lib/org-ruby/output_buffer.rb#14
  def output; end

  # This is the current type of output being accumulated.
  #
  # source://org-ruby//lib/org-ruby/output_buffer.rb#17
  def output_type; end

  # This is the current type of output being accumulated.
  #
  # source://org-ruby//lib/org-ruby/output_buffer.rb#17
  def output_type=(_arg0); end

  # source://org-ruby//lib/org-ruby/output_buffer.rb#57
  def pop_mode(mode = T.unsafe(nil)); end

  # Test if we're in an output mode in which whitespace is significant.
  #
  # @return [Boolean]
  #
  # source://org-ruby//lib/org-ruby/output_buffer.rb#137
  def preserve_whitespace?; end

  # source://org-ruby//lib/org-ruby/output_buffer.rb#52
  def push_mode(mode, indent, properties = T.unsafe(nil)); end

  # source://org-ruby//lib/org-ruby/output_buffer.rb#160
  def set_custom_markup; end

  private

  # source://org-ruby//lib/org-ruby/output_buffer.rb#249
  def add_line_attributes(headline); end

  # @return [Boolean]
  #
  # source://org-ruby//lib/org-ruby/output_buffer.rb#193
  def boundary_of_block?(line); end

  # source://org-ruby//lib/org-ruby/output_buffer.rb#293
  def buffer_indentation; end

  # source://org-ruby//lib/org-ruby/output_buffer.rb#294
  def flush!; end

  # source://org-ruby//lib/org-ruby/output_buffer.rb#201
  def maintain_mode_stack(line); end

  # @return [Boolean]
  #
  # source://org-ruby//lib/org-ruby/output_buffer.rb#185
  def mode_is_block?(mode); end

  # @return [Boolean]
  #
  # source://org-ruby//lib/org-ruby/output_buffer.rb#189
  def mode_is_code?(mode); end

  # @return [Boolean]
  #
  # source://org-ruby//lib/org-ruby/output_buffer.rb#180
  def mode_is_heading?(mode); end

  # source://org-ruby//lib/org-ruby/output_buffer.rb#295
  def output_footnotes!; end

  # Tests if the current line should be accumulated in the current
  # output buffer.
  #
  # @return [Boolean]
  #
  # source://org-ruby//lib/org-ruby/output_buffer.rb#259
  def should_accumulate_output?(line); end
end

# Simple routines for loading / saving an ORG file.
#
# source://org-ruby//lib/org-ruby/parser.rb#11
class Orgmode::Parser
  # I can construct a parser object either with an array of lines
  # or with a single string that I will split along \n boundaries.
  #
  # @return [Parser] a new instance of Parser
  #
  # source://org-ruby//lib/org-ruby/parser.rb#86
  def initialize(lines, parser_options = T.unsafe(nil)); end

  # Check include file availability and permissions
  #
  # source://org-ruby//lib/org-ruby/parser.rb#133
  def check_include_file(file_path); end

  # Regexp that recognizes words in custom_keywords.
  #
  # source://org-ruby//lib/org-ruby/parser.rb#33
  def custom_keyword_regexp; end

  # Array of custom keywords.
  #
  # source://org-ruby//lib/org-ruby/parser.rb#30
  def custom_keywords; end

  # A set of tags that, if present on any headlines in the org-file, means
  # that subtree will not get exported.
  #
  # source://org-ruby//lib/org-ruby/parser.rb#47
  def export_exclude_tags; end

  # Returns true if we are to export footnotes
  #
  # @return [Boolean]
  #
  # source://org-ruby//lib/org-ruby/parser.rb#58
  def export_footnotes?; end

  # Returns true if we are to export heading numbers.
  #
  # @return [Boolean]
  #
  # source://org-ruby//lib/org-ruby/parser.rb#63
  def export_heading_number?; end

  # A set of tags that, if present on any headlines in the org-file, means
  # only those headings will get exported.
  #
  # source://org-ruby//lib/org-ruby/parser.rb#40
  def export_select_tags; end

  # Should we export tables? Defaults to true, must be overridden
  # with an explicit "nil"
  #
  # @return [Boolean]
  #
  # source://org-ruby//lib/org-ruby/parser.rb#74
  def export_tables?; end

  # Returns true if we are to export todo keywords on headings.
  #
  # @return [Boolean]
  #
  # source://org-ruby//lib/org-ruby/parser.rb#53
  def export_todo?; end

  # Get include data, when #+INCLUDE tag is used
  #
  # source://org-ruby//lib/org-ruby/parser.rb#242
  def get_include_data(line); end

  # These are any lines before the first headline
  #
  # source://org-ruby//lib/org-ruby/parser.rb#20
  def header_lines; end

  # All of the headlines in the org file
  #
  # source://org-ruby//lib/org-ruby/parser.rb#17
  def headlines; end

  # This contains any in-buffer settings from the org-mode file.
  # See http://orgmode.org/manual/In_002dbuffer-settings.html#In_002dbuffer-settings
  #
  # source://org-ruby//lib/org-ruby/parser.rb#24
  def in_buffer_settings; end

  # All of the lines of the orgmode file
  #
  # source://org-ruby//lib/org-ruby/parser.rb#14
  def lines; end

  # This contains in-buffer options; a special case of in-buffer settings.
  #
  # source://org-ruby//lib/org-ruby/parser.rb#27
  def options; end

  # source://org-ruby//lib/org-ruby/parser.rb#150
  def parse_lines(lines); end

  # source://org-ruby//lib/org-ruby/parser.rb#289
  def set_mode_for_results_block_contents(previous_line, line); end

  # source://org-ruby//lib/org-ruby/parser.rb#283
  def set_name_for_code_block(previous_line, line); end

  # Should we skip exporting text before the first heading?
  #
  # @return [Boolean]
  #
  # source://org-ruby//lib/org-ruby/parser.rb#68
  def skip_header_lines?; end

  # Converts the loaded org-mode file to HTML.
  #
  # source://org-ruby//lib/org-ruby/parser.rb#341
  def to_html; end

  # Exports the Org mode content into Markdown format
  #
  # source://org-ruby//lib/org-ruby/parser.rb#317
  def to_markdown; end

  # Saves the loaded orgmode file as a textile file.
  #
  # source://org-ruby//lib/org-ruby/parser.rb#305
  def to_textile; end

  # Should we export sub/superscripts? (_{foo}/^{foo})
  # only {} mode is currently supported.
  #
  # @return [Boolean]
  #
  # source://org-ruby//lib/org-ruby/parser.rb#80
  def use_sub_superscripts?; end

  private

  # Uses export_select_tags and export_exclude_tags to determine
  # which parts of the org-file to export.
  #
  # source://org-ruby//lib/org-ruby/parser.rb#403
  def mark_trees_for_export; end

  # Stores an in-buffer setting.
  #
  # source://org-ruby//lib/org-ruby/parser.rb#454
  def store_in_buffer_setting(key, value); end

  # Converts an array of lines to the appropriate format.
  # Writes the output to +output_buffer+.
  #
  # source://org-ruby//lib/org-ruby/parser.rb#392
  def translate(lines, output_buffer); end

  class << self
    # Creates a new parser from the data in a given file
    #
    # source://org-ruby//lib/org-ruby/parser.rb#299
    def load(fname, opts = T.unsafe(nil)); end
  end
end

# = Summary
#
# This class contains helper routines to deal with the Regexp "black
# magic" you need to properly parse org-mode files.
#
# = Key methods
#
# * Use +rewrite_emphasis+ to replace org-mode emphasis strings (e.g.,
#   \/italic/) with the suitable markup for the output.
#
# * Use +rewrite_links+ to get a chance to rewrite all org-mode
#   links with suitable markup for the output.
#
# * Use +rewrite_images+ to rewrite all inline image links with suitable
#   markup for the output.
#
# source://org-ruby//lib/org-ruby/regexp_helper.rb#20
class Orgmode::RegexpHelper
  # @return [RegexpHelper] a new instance of RegexpHelper
  #
  # source://org-ruby//lib/org-ruby/regexp_helper.rb#45
  def initialize; end

  # Finds all emphasis matches in a string.
  # Supply a block that will get the marker and body as parameters.
  #
  # source://org-ruby//lib/org-ruby/regexp_helper.rb#67
  def match_all(str); end

  # EMPHASIS
  #
  # I figure it's best to stick as closely to the elisp implementation
  # as possible for emphasis. org.el defines the regular expression that
  # is used to apply "emphasis" (in my terminology, inline formatting
  # instead of block formatting). Here's the documentation from org.el.
  #
  # Terminology: In an emphasis string like " *strong word* ", we
  # call the initial space PREMATCH, the final space POSTMATCH, the
  # stars MARKERS, "s" and "d" are BORDER characters and "trong wor"
  # is the body.  The different components in this variable specify
  # what is allowed/forbidden in each part:
  #
  # pre          Chars allowed as prematch.  Line beginning allowed, too.
  # post         Chars allowed as postmatch.  Line end will be allowed too.
  # border       The chars *forbidden* as border characters.
  # body-regexp  A regexp like \".\" to match a body character.  Don't use
  #              non-shy groups here, and don't allow newline here.
  # newline      The maximum number of newlines allowed in an emphasis exp.
  #
  # source://org-ruby//lib/org-ruby/regexp_helper.rb#43
  def org_image_file_regexp; end

  # source://org-ruby//lib/org-ruby/regexp_helper.rb#170
  def restore_code_snippets(str); end

  # Compute replacements for all matching emphasized phrases.
  # Supply a block that will get the marker and body as parameters;
  # return the replacement string from your block.
  #
  # = Example
  #
  #   re = RegexpHelper.new
  #   result = re.rewrite_emphasis("*bold*, /italic/, =code=") do |marker, body|
  #       "<#{map[marker]}>#{body}</#{map[marker]}>"
  #   end
  #
  # In this example, the block body will get called three times:
  #
  # 1. Marker: "*", body: "bold"
  # 2. Marker: "/", body: "italic"
  # 3. Marker: "=", body: "code"
  #
  # The return from this block is a string that will be used to
  # replace "*bold*", "/italic/", and "=code=",
  # respectively. (Clearly this sample string will use HTML-like
  # syntax, assuming +map+ is defined appropriately.)
  #
  # source://org-ruby//lib/org-ruby/regexp_helper.rb#94
  def rewrite_emphasis(str); end

  # rewrite footnotes
  #
  # source://org-ruby//lib/org-ruby/regexp_helper.rb#122
  def rewrite_footnote(str); end

  # source://org-ruby//lib/org-ruby/regexp_helper.rb#128
  def rewrite_footnote_definition(str); end

  # = Summary
  #
  # Rewrite org-mode links in a string to markup suitable to the
  # output format.
  #
  # = Usage
  #
  # Give this a block that expect the link and optional friendly
  # text. Return how that link should get formatted.
  #
  # = Example
  #
  #   re = RegexpHelper.new
  #   result = re.rewrite_links("[[http://www.bing.com]] and [[http://www.hotmail.com][Hotmail]]") do |link, text}
  #       text ||= link
  #       "<a href=\"#{link}\">#{text}</a>"
  #    end
  #
  # In this example, the block body will get called two times. In the
  # first instance, +text+ will be nil (the org-mode markup gives no
  # friendly text for the link +http://www.bing.com+. In the second
  # instance, the block will get text of *Hotmail* and the link
  # +http://www.hotmail.com+. In both cases, the block returns an
  # HTML-style link, and that is how things will get recorded in
  # +result+.
  #
  # source://org-ruby//lib/org-ruby/regexp_helper.rb#159
  def rewrite_links(str); end

  # rewrite subscript and superscript (_{foo} and ^{bar})
  #
  # source://org-ruby//lib/org-ruby/regexp_helper.rb#115
  def rewrite_subp(str); end

  private

  # source://org-ruby//lib/org-ruby/regexp_helper.rb#178
  def build_org_emphasis_regexp; end

  # source://org-ruby//lib/org-ruby/regexp_helper.rb#188
  def build_org_link_regexp; end
end

# source://org-ruby//lib/org-ruby/textile_symbol_replace.rb#5
Orgmode::TextileEntities = T.let(T.unsafe(nil), Hash)

# source://org-ruby//lib/org-ruby/textile_output_buffer.rb#5
class Orgmode::TextileOutputBuffer < ::Orgmode::OutputBuffer
  # @return [TextileOutputBuffer] a new instance of TextileOutputBuffer
  #
  # source://org-ruby//lib/org-ruby/textile_output_buffer.rb#7
  def initialize(output); end

  # source://org-ruby//lib/org-ruby/textile_output_buffer.rb#150
  def add_line_attributes(headline); end

  # Flushes the current buffer
  #
  # source://org-ruby//lib/org-ruby/textile_output_buffer.rb#113
  def flush!; end

  # Handles inline formatting for textile.
  #
  # source://org-ruby//lib/org-ruby/textile_output_buffer.rb#44
  def inline_formatting(input); end

  # source://org-ruby//lib/org-ruby/textile_output_buffer.rb#101
  def output_footnotes!; end

  # source://org-ruby//lib/org-ruby/textile_output_buffer.rb#23
  def pop_mode(mode = T.unsafe(nil)); end

  # source://org-ruby//lib/org-ruby/textile_output_buffer.rb#14
  def push_mode(mode, indent, properties = T.unsafe(nil)); end
end

# Maps org markup to textile markup.
#
# source://org-ruby//lib/org-ruby/textile_output_buffer.rb#34
Orgmode::TextileOutputBuffer::TextileMap = T.let(T.unsafe(nil), Hash)

# source://org-ruby//lib/org-ruby/tilt.rb#4
module Tilt
  class << self
    # source://tilt/2.0.11/lib/tilt.rb#47
    def [](file); end

    # source://tilt/2.0.11/lib/tilt.rb#69
    def current_template; end

    # source://tilt/2.0.11/lib/tilt.rb#12
    def default_mapping; end

    # source://tilt/2.0.11/lib/tilt.rb#17
    def lazy_map; end

    # source://tilt/2.0.11/lib/tilt.rb#42
    def new(file, line = T.unsafe(nil), options = T.unsafe(nil), &block); end

    # source://tilt/2.0.11/lib/tilt.rb#32
    def prefer(template_class, *extensions); end

    # source://tilt/2.0.11/lib/tilt.rb#22
    def register(template_class, *extensions); end

    # source://tilt/2.0.11/lib/tilt.rb#27
    def register_lazy(class_name, file, *extensions); end

    # source://tilt/2.0.11/lib/tilt.rb#37
    def registered?(ext); end

    # source://tilt/2.0.11/lib/tilt.rb#52
    def template_for(file); end

    # source://tilt/2.0.11/lib/tilt.rb#57
    def templates_for(file); end
  end
end

# source://org-ruby//lib/org-ruby/tilt.rb#5
class Tilt::OrgTemplate < ::Tilt::Template
  # source://org-ruby//lib/org-ruby/tilt.rb#19
  def evaluate(scope, locals, &block); end

  # source://org-ruby//lib/org-ruby/tilt.rb#10
  def initialize_engine; end

  # source://org-ruby//lib/org-ruby/tilt.rb#14
  def prepare; end

  class << self
    # source://org-ruby//lib/org-ruby/tilt.rb#6
    def engine_initialized?; end
  end
end
