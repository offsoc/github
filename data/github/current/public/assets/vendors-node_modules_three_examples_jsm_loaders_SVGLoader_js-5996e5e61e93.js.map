{"version":3,"file":"vendors-node_modules_three_examples_jsm_loaders_SVGLoader_js-xxxxxxxxxxxx.js","mappings":"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","sources":["node_modules/three/examples/jsm/loaders/SVGLoader.js"],"sourcesContent":["import {\n\tBox2,\n\tBufferGeometry,\n\tFileLoader,\n\tFloat32BufferAttribute,\n\tLoader,\n\tMatrix3,\n\tPath,\n\tShape,\n\tShapePath,\n\tShapeUtils,\n\tVector2,\n\tVector3\n} from 'three';\n\nclass SVGLoader extends Loader {\n\n\tconstructor( manager ) {\n\n\t\tsuper( manager );\n\n\t\t// Default dots per inch\n\t\tthis.defaultDPI = 90;\n\n\t\t// Accepted units: 'mm', 'cm', 'in', 'pt', 'pc', 'px'\n\t\tthis.defaultUnit = 'px';\n\n\t}\n\n\tload( url, onLoad, onProgress, onError ) {\n\n\t\tconst scope = this;\n\n\t\tconst loader = new FileLoader( scope.manager );\n\t\tloader.setPath( scope.path );\n\t\tloader.setRequestHeader( scope.requestHeader );\n\t\tloader.setWithCredentials( scope.withCredentials );\n\t\tloader.load( url, function ( text ) {\n\n\t\t\ttry {\n\n\t\t\t\tonLoad( scope.parse( text ) );\n\n\t\t\t} catch ( e ) {\n\n\t\t\t\tif ( onError ) {\n\n\t\t\t\t\tonError( e );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tconsole.error( e );\n\n\t\t\t\t}\n\n\t\t\t\tscope.manager.itemError( url );\n\n\t\t\t}\n\n\t\t}, onProgress, onError );\n\n\t}\n\n\tparse( text ) {\n\n\t\tconst scope = this;\n\n\t\tfunction parseNode( node, style ) {\n\n\t\t\tif ( node.nodeType !== 1 ) return;\n\n\t\t\tconst transform = getNodeTransform( node );\n\n\t\t\tlet isDefsNode = false;\n\n\t\t\tlet path = null;\n\n\t\t\tswitch ( node.nodeName ) {\n\n\t\t\t\tcase 'svg':\n\t\t\t\t\tstyle = parseStyle( node, style );\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'style':\n\t\t\t\t\tparseCSSStylesheet( node );\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'g':\n\t\t\t\t\tstyle = parseStyle( node, style );\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'path':\n\t\t\t\t\tstyle = parseStyle( node, style );\n\t\t\t\t\tif ( node.hasAttribute( 'd' ) ) path = parsePathNode( node );\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'rect':\n\t\t\t\t\tstyle = parseStyle( node, style );\n\t\t\t\t\tpath = parseRectNode( node );\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'polygon':\n\t\t\t\t\tstyle = parseStyle( node, style );\n\t\t\t\t\tpath = parsePolygonNode( node );\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'polyline':\n\t\t\t\t\tstyle = parseStyle( node, style );\n\t\t\t\t\tpath = parsePolylineNode( node );\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'circle':\n\t\t\t\t\tstyle = parseStyle( node, style );\n\t\t\t\t\tpath = parseCircleNode( node );\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'ellipse':\n\t\t\t\t\tstyle = parseStyle( node, style );\n\t\t\t\t\tpath = parseEllipseNode( node );\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'line':\n\t\t\t\t\tstyle = parseStyle( node, style );\n\t\t\t\t\tpath = parseLineNode( node );\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'defs':\n\t\t\t\t\tisDefsNode = true;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'use':\n\t\t\t\t\tstyle = parseStyle( node, style );\n\n\t\t\t\t\tconst href = node.getAttributeNS( 'http://www.w3.org/1999/xlink', 'href' ) || '';\n\t\t\t\t\tconst usedNodeId = href.substring( 1 );\n\t\t\t\t\tconst usedNode = node.viewportElement.getElementById( usedNodeId );\n\t\t\t\t\tif ( usedNode ) {\n\n\t\t\t\t\t\tparseNode( usedNode, style );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tconsole.warn( 'SVGLoader: \\'use node\\' references non-existent node id: ' + usedNodeId );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tdefault:\n\t\t\t\t\t// console.log( node );\n\n\t\t\t}\n\n\t\t\tif ( path ) {\n\n\t\t\t\tif ( style.fill !== undefined && style.fill !== 'none' ) {\n\n\t\t\t\t\tpath.color.setStyle( style.fill );\n\n\t\t\t\t}\n\n\t\t\t\ttransformPath( path, currentTransform );\n\n\t\t\t\tpaths.push( path );\n\n\t\t\t\tpath.userData = { node: node, style: style };\n\n\t\t\t}\n\n\t\t\tconst childNodes = node.childNodes;\n\n\t\t\tfor ( let i = 0; i < childNodes.length; i ++ ) {\n\n\t\t\t\tconst node = childNodes[ i ];\n\n\t\t\t\tif ( isDefsNode && node.nodeName !== 'style' && node.nodeName !== 'defs' ) {\n\n\t\t\t\t\t// Ignore everything in defs except CSS style definitions\n\t\t\t\t\t// and nested defs, because it is OK by the standard to have\n\t\t\t\t\t// <style/> there.\n\t\t\t\t\tcontinue;\n\n\t\t\t\t}\n\n\t\t\t\tparseNode( node, style );\n\n\t\t\t}\n\n\n\t\t\tif ( transform ) {\n\n\t\t\t\ttransformStack.pop();\n\n\t\t\t\tif ( transformStack.length > 0 ) {\n\n\t\t\t\t\tcurrentTransform.copy( transformStack[ transformStack.length - 1 ] );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tcurrentTransform.identity();\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tfunction parsePathNode( node ) {\n\n\t\t\tconst path = new ShapePath();\n\n\t\t\tconst point = new Vector2();\n\t\t\tconst control = new Vector2();\n\n\t\t\tconst firstPoint = new Vector2();\n\t\t\tlet isFirstPoint = true;\n\t\t\tlet doSetFirstPoint = false;\n\n\t\t\tconst d = node.getAttribute( 'd' );\n\n\t\t\t// console.log( d );\n\n\t\t\tconst commands = d.match( /[a-df-z][^a-df-z]*/ig );\n\n\t\t\tfor ( let i = 0, l = commands.length; i < l; i ++ ) {\n\n\t\t\t\tconst command = commands[ i ];\n\n\t\t\t\tconst type = command.charAt( 0 );\n\t\t\t\tconst data = command.slice( 1 ).trim();\n\n\t\t\t\tif ( isFirstPoint === true ) {\n\n\t\t\t\t\tdoSetFirstPoint = true;\n\t\t\t\t\tisFirstPoint = false;\n\n\t\t\t\t}\n\n\t\t\t\tlet numbers;\n\n\t\t\t\tswitch ( type ) {\n\n\t\t\t\t\tcase 'M':\n\t\t\t\t\t\tnumbers = parseFloats( data );\n\t\t\t\t\t\tfor ( let j = 0, jl = numbers.length; j < jl; j += 2 ) {\n\n\t\t\t\t\t\t\tpoint.x = numbers[ j + 0 ];\n\t\t\t\t\t\t\tpoint.y = numbers[ j + 1 ];\n\t\t\t\t\t\t\tcontrol.x = point.x;\n\t\t\t\t\t\t\tcontrol.y = point.y;\n\n\t\t\t\t\t\t\tif ( j === 0 ) {\n\n\t\t\t\t\t\t\t\tpath.moveTo( point.x, point.y );\n\n\t\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t\tpath.lineTo( point.x, point.y );\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tif ( j === 0 ) firstPoint.copy( point );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'H':\n\t\t\t\t\t\tnumbers = parseFloats( data );\n\n\t\t\t\t\t\tfor ( let j = 0, jl = numbers.length; j < jl; j ++ ) {\n\n\t\t\t\t\t\t\tpoint.x = numbers[ j ];\n\t\t\t\t\t\t\tcontrol.x = point.x;\n\t\t\t\t\t\t\tcontrol.y = point.y;\n\t\t\t\t\t\t\tpath.lineTo( point.x, point.y );\n\n\t\t\t\t\t\t\tif ( j === 0 && doSetFirstPoint === true ) firstPoint.copy( point );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'V':\n\t\t\t\t\t\tnumbers = parseFloats( data );\n\n\t\t\t\t\t\tfor ( let j = 0, jl = numbers.length; j < jl; j ++ ) {\n\n\t\t\t\t\t\t\tpoint.y = numbers[ j ];\n\t\t\t\t\t\t\tcontrol.x = point.x;\n\t\t\t\t\t\t\tcontrol.y = point.y;\n\t\t\t\t\t\t\tpath.lineTo( point.x, point.y );\n\n\t\t\t\t\t\t\tif ( j === 0 && doSetFirstPoint === true ) firstPoint.copy( point );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'L':\n\t\t\t\t\t\tnumbers = parseFloats( data );\n\n\t\t\t\t\t\tfor ( let j = 0, jl = numbers.length; j < jl; j += 2 ) {\n\n\t\t\t\t\t\t\tpoint.x = numbers[ j + 0 ];\n\t\t\t\t\t\t\tpoint.y = numbers[ j + 1 ];\n\t\t\t\t\t\t\tcontrol.x = point.x;\n\t\t\t\t\t\t\tcontrol.y = point.y;\n\t\t\t\t\t\t\tpath.lineTo( point.x, point.y );\n\n\t\t\t\t\t\t\tif ( j === 0 && doSetFirstPoint === true ) firstPoint.copy( point );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'C':\n\t\t\t\t\t\tnumbers = parseFloats( data );\n\n\t\t\t\t\t\tfor ( let j = 0, jl = numbers.length; j < jl; j += 6 ) {\n\n\t\t\t\t\t\t\tpath.bezierCurveTo(\n\t\t\t\t\t\t\t\tnumbers[ j + 0 ],\n\t\t\t\t\t\t\t\tnumbers[ j + 1 ],\n\t\t\t\t\t\t\t\tnumbers[ j + 2 ],\n\t\t\t\t\t\t\t\tnumbers[ j + 3 ],\n\t\t\t\t\t\t\t\tnumbers[ j + 4 ],\n\t\t\t\t\t\t\t\tnumbers[ j + 5 ]\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\tcontrol.x = numbers[ j + 2 ];\n\t\t\t\t\t\t\tcontrol.y = numbers[ j + 3 ];\n\t\t\t\t\t\t\tpoint.x = numbers[ j + 4 ];\n\t\t\t\t\t\t\tpoint.y = numbers[ j + 5 ];\n\n\t\t\t\t\t\t\tif ( j === 0 && doSetFirstPoint === true ) firstPoint.copy( point );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'S':\n\t\t\t\t\t\tnumbers = parseFloats( data );\n\n\t\t\t\t\t\tfor ( let j = 0, jl = numbers.length; j < jl; j += 4 ) {\n\n\t\t\t\t\t\t\tpath.bezierCurveTo(\n\t\t\t\t\t\t\t\tgetReflection( point.x, control.x ),\n\t\t\t\t\t\t\t\tgetReflection( point.y, control.y ),\n\t\t\t\t\t\t\t\tnumbers[ j + 0 ],\n\t\t\t\t\t\t\t\tnumbers[ j + 1 ],\n\t\t\t\t\t\t\t\tnumbers[ j + 2 ],\n\t\t\t\t\t\t\t\tnumbers[ j + 3 ]\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\tcontrol.x = numbers[ j + 0 ];\n\t\t\t\t\t\t\tcontrol.y = numbers[ j + 1 ];\n\t\t\t\t\t\t\tpoint.x = numbers[ j + 2 ];\n\t\t\t\t\t\t\tpoint.y = numbers[ j + 3 ];\n\n\t\t\t\t\t\t\tif ( j === 0 && doSetFirstPoint === true ) firstPoint.copy( point );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'Q':\n\t\t\t\t\t\tnumbers = parseFloats( data );\n\n\t\t\t\t\t\tfor ( let j = 0, jl = numbers.length; j < jl; j += 4 ) {\n\n\t\t\t\t\t\t\tpath.quadraticCurveTo(\n\t\t\t\t\t\t\t\tnumbers[ j + 0 ],\n\t\t\t\t\t\t\t\tnumbers[ j + 1 ],\n\t\t\t\t\t\t\t\tnumbers[ j + 2 ],\n\t\t\t\t\t\t\t\tnumbers[ j + 3 ]\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\tcontrol.x = numbers[ j + 0 ];\n\t\t\t\t\t\t\tcontrol.y = numbers[ j + 1 ];\n\t\t\t\t\t\t\tpoint.x = numbers[ j + 2 ];\n\t\t\t\t\t\t\tpoint.y = numbers[ j + 3 ];\n\n\t\t\t\t\t\t\tif ( j === 0 && doSetFirstPoint === true ) firstPoint.copy( point );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'T':\n\t\t\t\t\t\tnumbers = parseFloats( data );\n\n\t\t\t\t\t\tfor ( let j = 0, jl = numbers.length; j < jl; j += 2 ) {\n\n\t\t\t\t\t\t\tconst rx = getReflection( point.x, control.x );\n\t\t\t\t\t\t\tconst ry = getReflection( point.y, control.y );\n\t\t\t\t\t\t\tpath.quadraticCurveTo(\n\t\t\t\t\t\t\t\trx,\n\t\t\t\t\t\t\t\try,\n\t\t\t\t\t\t\t\tnumbers[ j + 0 ],\n\t\t\t\t\t\t\t\tnumbers[ j + 1 ]\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\tcontrol.x = rx;\n\t\t\t\t\t\t\tcontrol.y = ry;\n\t\t\t\t\t\t\tpoint.x = numbers[ j + 0 ];\n\t\t\t\t\t\t\tpoint.y = numbers[ j + 1 ];\n\n\t\t\t\t\t\t\tif ( j === 0 && doSetFirstPoint === true ) firstPoint.copy( point );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'A':\n\t\t\t\t\t\tnumbers = parseFloats( data, [ 3, 4 ], 7 );\n\n\t\t\t\t\t\tfor ( let j = 0, jl = numbers.length; j < jl; j += 7 ) {\n\n\t\t\t\t\t\t\t// skip command if start point == end point\n\t\t\t\t\t\t\tif ( numbers[ j + 5 ] == point.x && numbers[ j + 6 ] == point.y ) continue;\n\n\t\t\t\t\t\t\tconst start = point.clone();\n\t\t\t\t\t\t\tpoint.x = numbers[ j + 5 ];\n\t\t\t\t\t\t\tpoint.y = numbers[ j + 6 ];\n\t\t\t\t\t\t\tcontrol.x = point.x;\n\t\t\t\t\t\t\tcontrol.y = point.y;\n\t\t\t\t\t\t\tparseArcCommand(\n\t\t\t\t\t\t\t\tpath, numbers[ j ], numbers[ j + 1 ], numbers[ j + 2 ], numbers[ j + 3 ], numbers[ j + 4 ], start, point\n\t\t\t\t\t\t\t);\n\n\t\t\t\t\t\t\tif ( j === 0 && doSetFirstPoint === true ) firstPoint.copy( point );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'm':\n\t\t\t\t\t\tnumbers = parseFloats( data );\n\n\t\t\t\t\t\tfor ( let j = 0, jl = numbers.length; j < jl; j += 2 ) {\n\n\t\t\t\t\t\t\tpoint.x += numbers[ j + 0 ];\n\t\t\t\t\t\t\tpoint.y += numbers[ j + 1 ];\n\t\t\t\t\t\t\tcontrol.x = point.x;\n\t\t\t\t\t\t\tcontrol.y = point.y;\n\n\t\t\t\t\t\t\tif ( j === 0 ) {\n\n\t\t\t\t\t\t\t\tpath.moveTo( point.x, point.y );\n\n\t\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t\tpath.lineTo( point.x, point.y );\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tif ( j === 0 ) firstPoint.copy( point );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'h':\n\t\t\t\t\t\tnumbers = parseFloats( data );\n\n\t\t\t\t\t\tfor ( let j = 0, jl = numbers.length; j < jl; j ++ ) {\n\n\t\t\t\t\t\t\tpoint.x += numbers[ j ];\n\t\t\t\t\t\t\tcontrol.x = point.x;\n\t\t\t\t\t\t\tcontrol.y = point.y;\n\t\t\t\t\t\t\tpath.lineTo( point.x, point.y );\n\n\t\t\t\t\t\t\tif ( j === 0 && doSetFirstPoint === true ) firstPoint.copy( point );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'v':\n\t\t\t\t\t\tnumbers = parseFloats( data );\n\n\t\t\t\t\t\tfor ( let j = 0, jl = numbers.length; j < jl; j ++ ) {\n\n\t\t\t\t\t\t\tpoint.y += numbers[ j ];\n\t\t\t\t\t\t\tcontrol.x = point.x;\n\t\t\t\t\t\t\tcontrol.y = point.y;\n\t\t\t\t\t\t\tpath.lineTo( point.x, point.y );\n\n\t\t\t\t\t\t\tif ( j === 0 && doSetFirstPoint === true ) firstPoint.copy( point );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'l':\n\t\t\t\t\t\tnumbers = parseFloats( data );\n\n\t\t\t\t\t\tfor ( let j = 0, jl = numbers.length; j < jl; j += 2 ) {\n\n\t\t\t\t\t\t\tpoint.x += numbers[ j + 0 ];\n\t\t\t\t\t\t\tpoint.y += numbers[ j + 1 ];\n\t\t\t\t\t\t\tcontrol.x = point.x;\n\t\t\t\t\t\t\tcontrol.y = point.y;\n\t\t\t\t\t\t\tpath.lineTo( point.x, point.y );\n\n\t\t\t\t\t\t\tif ( j === 0 && doSetFirstPoint === true ) firstPoint.copy( point );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'c':\n\t\t\t\t\t\tnumbers = parseFloats( data );\n\n\t\t\t\t\t\tfor ( let j = 0, jl = numbers.length; j < jl; j += 6 ) {\n\n\t\t\t\t\t\t\tpath.bezierCurveTo(\n\t\t\t\t\t\t\t\tpoint.x + numbers[ j + 0 ],\n\t\t\t\t\t\t\t\tpoint.y + numbers[ j + 1 ],\n\t\t\t\t\t\t\t\tpoint.x + numbers[ j + 2 ],\n\t\t\t\t\t\t\t\tpoint.y + numbers[ j + 3 ],\n\t\t\t\t\t\t\t\tpoint.x + numbers[ j + 4 ],\n\t\t\t\t\t\t\t\tpoint.y + numbers[ j + 5 ]\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\tcontrol.x = point.x + numbers[ j + 2 ];\n\t\t\t\t\t\t\tcontrol.y = point.y + numbers[ j + 3 ];\n\t\t\t\t\t\t\tpoint.x += numbers[ j + 4 ];\n\t\t\t\t\t\t\tpoint.y += numbers[ j + 5 ];\n\n\t\t\t\t\t\t\tif ( j === 0 && doSetFirstPoint === true ) firstPoint.copy( point );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 's':\n\t\t\t\t\t\tnumbers = parseFloats( data );\n\n\t\t\t\t\t\tfor ( let j = 0, jl = numbers.length; j < jl; j += 4 ) {\n\n\t\t\t\t\t\t\tpath.bezierCurveTo(\n\t\t\t\t\t\t\t\tgetReflection( point.x, control.x ),\n\t\t\t\t\t\t\t\tgetReflection( point.y, control.y ),\n\t\t\t\t\t\t\t\tpoint.x + numbers[ j + 0 ],\n\t\t\t\t\t\t\t\tpoint.y + numbers[ j + 1 ],\n\t\t\t\t\t\t\t\tpoint.x + numbers[ j + 2 ],\n\t\t\t\t\t\t\t\tpoint.y + numbers[ j + 3 ]\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\tcontrol.x = point.x + numbers[ j + 0 ];\n\t\t\t\t\t\t\tcontrol.y = point.y + numbers[ j + 1 ];\n\t\t\t\t\t\t\tpoint.x += numbers[ j + 2 ];\n\t\t\t\t\t\t\tpoint.y += numbers[ j + 3 ];\n\n\t\t\t\t\t\t\tif ( j === 0 && doSetFirstPoint === true ) firstPoint.copy( point );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'q':\n\t\t\t\t\t\tnumbers = parseFloats( data );\n\n\t\t\t\t\t\tfor ( let j = 0, jl = numbers.length; j < jl; j += 4 ) {\n\n\t\t\t\t\t\t\tpath.quadraticCurveTo(\n\t\t\t\t\t\t\t\tpoint.x + numbers[ j + 0 ],\n\t\t\t\t\t\t\t\tpoint.y + numbers[ j + 1 ],\n\t\t\t\t\t\t\t\tpoint.x + numbers[ j + 2 ],\n\t\t\t\t\t\t\t\tpoint.y + numbers[ j + 3 ]\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\tcontrol.x = point.x + numbers[ j + 0 ];\n\t\t\t\t\t\t\tcontrol.y = point.y + numbers[ j + 1 ];\n\t\t\t\t\t\t\tpoint.x += numbers[ j + 2 ];\n\t\t\t\t\t\t\tpoint.y += numbers[ j + 3 ];\n\n\t\t\t\t\t\t\tif ( j === 0 && doSetFirstPoint === true ) firstPoint.copy( point );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 't':\n\t\t\t\t\t\tnumbers = parseFloats( data );\n\n\t\t\t\t\t\tfor ( let j = 0, jl = numbers.length; j < jl; j += 2 ) {\n\n\t\t\t\t\t\t\tconst rx = getReflection( point.x, control.x );\n\t\t\t\t\t\t\tconst ry = getReflection( point.y, control.y );\n\t\t\t\t\t\t\tpath.quadraticCurveTo(\n\t\t\t\t\t\t\t\trx,\n\t\t\t\t\t\t\t\try,\n\t\t\t\t\t\t\t\tpoint.x + numbers[ j + 0 ],\n\t\t\t\t\t\t\t\tpoint.y + numbers[ j + 1 ]\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\tcontrol.x = rx;\n\t\t\t\t\t\t\tcontrol.y = ry;\n\t\t\t\t\t\t\tpoint.x = point.x + numbers[ j + 0 ];\n\t\t\t\t\t\t\tpoint.y = point.y + numbers[ j + 1 ];\n\n\t\t\t\t\t\t\tif ( j === 0 && doSetFirstPoint === true ) firstPoint.copy( point );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'a':\n\t\t\t\t\t\tnumbers = parseFloats( data, [ 3, 4 ], 7 );\n\n\t\t\t\t\t\tfor ( let j = 0, jl = numbers.length; j < jl; j += 7 ) {\n\n\t\t\t\t\t\t\t// skip command if no displacement\n\t\t\t\t\t\t\tif ( numbers[ j + 5 ] == 0 && numbers[ j + 6 ] == 0 ) continue;\n\n\t\t\t\t\t\t\tconst start = point.clone();\n\t\t\t\t\t\t\tpoint.x += numbers[ j + 5 ];\n\t\t\t\t\t\t\tpoint.y += numbers[ j + 6 ];\n\t\t\t\t\t\t\tcontrol.x = point.x;\n\t\t\t\t\t\t\tcontrol.y = point.y;\n\t\t\t\t\t\t\tparseArcCommand(\n\t\t\t\t\t\t\t\tpath, numbers[ j ], numbers[ j + 1 ], numbers[ j + 2 ], numbers[ j + 3 ], numbers[ j + 4 ], start, point\n\t\t\t\t\t\t\t);\n\n\t\t\t\t\t\t\tif ( j === 0 && doSetFirstPoint === true ) firstPoint.copy( point );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase 'Z':\n\t\t\t\t\tcase 'z':\n\t\t\t\t\t\tpath.currentPath.autoClose = true;\n\n\t\t\t\t\t\tif ( path.currentPath.curves.length > 0 ) {\n\n\t\t\t\t\t\t\t// Reset point to beginning of Path\n\t\t\t\t\t\t\tpoint.copy( firstPoint );\n\t\t\t\t\t\t\tpath.currentPath.currentPoint.copy( point );\n\t\t\t\t\t\t\tisFirstPoint = true;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tconsole.warn( command );\n\n\t\t\t\t}\n\n\t\t\t\t// console.log( type, parseFloats( data ), parseFloats( data ).length  )\n\n\t\t\t\tdoSetFirstPoint = false;\n\n\t\t\t}\n\n\t\t\treturn path;\n\n\t\t}\n\n\t\tfunction parseCSSStylesheet( node ) {\n\n\t\t\tif ( ! node.sheet || ! node.sheet.cssRules || ! node.sheet.cssRules.length ) return;\n\n\t\t\tfor ( let i = 0; i < node.sheet.cssRules.length; i ++ ) {\n\n\t\t\t\tconst stylesheet = node.sheet.cssRules[ i ];\n\n\t\t\t\tif ( stylesheet.type !== 1 ) continue;\n\n\t\t\t\tconst selectorList = stylesheet.selectorText\n\t\t\t\t\t.split( /,/gm )\n\t\t\t\t\t.filter( Boolean )\n\t\t\t\t\t.map( i => i.trim() );\n\n\t\t\t\tfor ( let j = 0; j < selectorList.length; j ++ ) {\n\n\t\t\t\t\t// Remove empty rules\n\t\t\t\t\tconst definitions = Object.fromEntries(\n\t\t\t\t\t\tObject.entries( stylesheet.style ).filter( ( [ , v ] ) => v !== '' )\n\t\t\t\t\t);\n\n\t\t\t\t\tstylesheets[ selectorList[ j ] ] = Object.assign(\n\t\t\t\t\t\tstylesheets[ selectorList[ j ] ] || {},\n\t\t\t\t\t\tdefinitions\n\t\t\t\t\t);\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\t/**\n\t\t * https://www.w3.org/TR/SVG/implnote.html#ArcImplementationNotes\n\t\t * https://mortoray.com/2017/02/16/rendering-an-svg-elliptical-arc-as-bezier-curves/ Appendix: Endpoint to center arc conversion\n\t\t * From\n\t\t * rx ry x-axis-rotation large-arc-flag sweep-flag x y\n\t\t * To\n\t\t * aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation\n\t\t */\n\n\t\tfunction parseArcCommand( path, rx, ry, x_axis_rotation, large_arc_flag, sweep_flag, start, end ) {\n\n\t\t\tif ( rx == 0 || ry == 0 ) {\n\n\t\t\t\t// draw a line if either of the radii == 0\n\t\t\t\tpath.lineTo( end.x, end.y );\n\t\t\t\treturn;\n\n\t\t\t}\n\n\t\t\tx_axis_rotation = x_axis_rotation * Math.PI / 180;\n\n\t\t\t// Ensure radii are positive\n\t\t\trx = Math.abs( rx );\n\t\t\try = Math.abs( ry );\n\n\t\t\t// Compute (x1', y1')\n\t\t\tconst dx2 = ( start.x - end.x ) / 2.0;\n\t\t\tconst dy2 = ( start.y - end.y ) / 2.0;\n\t\t\tconst x1p = Math.cos( x_axis_rotation ) * dx2 + Math.sin( x_axis_rotation ) * dy2;\n\t\t\tconst y1p = - Math.sin( x_axis_rotation ) * dx2 + Math.cos( x_axis_rotation ) * dy2;\n\n\t\t\t// Compute (cx', cy')\n\t\t\tlet rxs = rx * rx;\n\t\t\tlet rys = ry * ry;\n\t\t\tconst x1ps = x1p * x1p;\n\t\t\tconst y1ps = y1p * y1p;\n\n\t\t\t// Ensure radii are large enough\n\t\t\tconst cr = x1ps / rxs + y1ps / rys;\n\n\t\t\tif ( cr > 1 ) {\n\n\t\t\t\t// scale up rx,ry equally so cr == 1\n\t\t\t\tconst s = Math.sqrt( cr );\n\t\t\t\trx = s * rx;\n\t\t\t\try = s * ry;\n\t\t\t\trxs = rx * rx;\n\t\t\t\trys = ry * ry;\n\n\t\t\t}\n\n\t\t\tconst dq = ( rxs * y1ps + rys * x1ps );\n\t\t\tconst pq = ( rxs * rys - dq ) / dq;\n\t\t\tlet q = Math.sqrt( Math.max( 0, pq ) );\n\t\t\tif ( large_arc_flag === sweep_flag ) q = - q;\n\t\t\tconst cxp = q * rx * y1p / ry;\n\t\t\tconst cyp = - q * ry * x1p / rx;\n\n\t\t\t// Step 3: Compute (cx, cy) from (cx', cy')\n\t\t\tconst cx = Math.cos( x_axis_rotation ) * cxp - Math.sin( x_axis_rotation ) * cyp + ( start.x + end.x ) / 2;\n\t\t\tconst cy = Math.sin( x_axis_rotation ) * cxp + Math.cos( x_axis_rotation ) * cyp + ( start.y + end.y ) / 2;\n\n\t\t\t// Step 4: Compute θ1 and Δθ\n\t\t\tconst theta = svgAngle( 1, 0, ( x1p - cxp ) / rx, ( y1p - cyp ) / ry );\n\t\t\tconst delta = svgAngle( ( x1p - cxp ) / rx, ( y1p - cyp ) / ry, ( - x1p - cxp ) / rx, ( - y1p - cyp ) / ry ) % ( Math.PI * 2 );\n\n\t\t\tpath.currentPath.absellipse( cx, cy, rx, ry, theta, theta + delta, sweep_flag === 0, x_axis_rotation );\n\n\t\t}\n\n\t\tfunction svgAngle( ux, uy, vx, vy ) {\n\n\t\t\tconst dot = ux * vx + uy * vy;\n\t\t\tconst len = Math.sqrt( ux * ux + uy * uy ) * Math.sqrt( vx * vx + vy * vy );\n\t\t\tlet ang = Math.acos( Math.max( - 1, Math.min( 1, dot / len ) ) ); // floating point precision, slightly over values appear\n\t\t\tif ( ( ux * vy - uy * vx ) < 0 ) ang = - ang;\n\t\t\treturn ang;\n\n\t\t}\n\n\t\t/*\n\t\t* According to https://www.w3.org/TR/SVG/shapes.html#RectElementRXAttribute\n\t\t* rounded corner should be rendered to elliptical arc, but bezier curve does the job well enough\n\t\t*/\n\t\tfunction parseRectNode( node ) {\n\n\t\t\tconst x = parseFloatWithUnits( node.getAttribute( 'x' ) || 0 );\n\t\t\tconst y = parseFloatWithUnits( node.getAttribute( 'y' ) || 0 );\n\t\t\tconst rx = parseFloatWithUnits( node.getAttribute( 'rx' ) || node.getAttribute( 'ry' ) || 0 );\n\t\t\tconst ry = parseFloatWithUnits( node.getAttribute( 'ry' ) || node.getAttribute( 'rx' ) || 0 );\n\t\t\tconst w = parseFloatWithUnits( node.getAttribute( 'width' ) );\n\t\t\tconst h = parseFloatWithUnits( node.getAttribute( 'height' ) );\n\n\t\t\t// Ellipse arc to Bezier approximation Coefficient (Inversed). See:\n\t\t\t// https://spencermortensen.com/articles/bezier-circle/\n\t\t\tconst bci = 1 - 0.551915024494;\n\n\t\t\tconst path = new ShapePath();\n\n\t\t\t// top left\n\t\t\tpath.moveTo( x + rx, y );\n\n\t\t\t// top right\n\t\t\tpath.lineTo( x + w - rx, y );\n\t\t\tif ( rx !== 0 || ry !== 0 ) {\n\n\t\t\t\tpath.bezierCurveTo(\n\t\t\t\t\tx + w - rx * bci,\n\t\t\t\t\ty,\n\t\t\t\t\tx + w,\n\t\t\t\t\ty + ry * bci,\n\t\t\t\t\tx + w,\n\t\t\t\t\ty + ry\n\t\t\t\t);\n\n\t\t\t}\n\n\t\t\t// bottom right\n\t\t\tpath.lineTo( x + w, y + h - ry );\n\t\t\tif ( rx !== 0 || ry !== 0 ) {\n\n\t\t\t\tpath.bezierCurveTo(\n\t\t\t\t\tx + w,\n\t\t\t\t\ty + h - ry * bci,\n\t\t\t\t\tx + w - rx * bci,\n\t\t\t\t\ty + h,\n\t\t\t\t\tx + w - rx,\n\t\t\t\t\ty + h\n\t\t\t\t);\n\n\t\t\t}\n\n\t\t\t// bottom left\n\t\t\tpath.lineTo( x + rx, y + h );\n\t\t\tif ( rx !== 0 || ry !== 0 ) {\n\n\t\t\t\tpath.bezierCurveTo(\n\t\t\t\t\tx + rx * bci,\n\t\t\t\t\ty + h,\n\t\t\t\t\tx,\n\t\t\t\t\ty + h - ry * bci,\n\t\t\t\t\tx,\n\t\t\t\t\ty + h - ry\n\t\t\t\t);\n\n\t\t\t}\n\n\t\t\t// back to top left\n\t\t\tpath.lineTo( x, y + ry );\n\t\t\tif ( rx !== 0 || ry !== 0 ) {\n\n\t\t\t\tpath.bezierCurveTo( x, y + ry * bci, x + rx * bci, y, x + rx, y );\n\n\t\t\t}\n\n\t\t\treturn path;\n\n\t\t}\n\n\t\tfunction parsePolygonNode( node ) {\n\n\t\t\tfunction iterator( match, a, b ) {\n\n\t\t\t\tconst x = parseFloatWithUnits( a );\n\t\t\t\tconst y = parseFloatWithUnits( b );\n\n\t\t\t\tif ( index === 0 ) {\n\n\t\t\t\t\tpath.moveTo( x, y );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tpath.lineTo( x, y );\n\n\t\t\t\t}\n\n\t\t\t\tindex ++;\n\n\t\t\t}\n\n\t\t\tconst regex = /(-?[\\d\\.?]+)[,|\\s](-?[\\d\\.?]+)/g;\n\n\t\t\tconst path = new ShapePath();\n\n\t\t\tlet index = 0;\n\n\t\t\tnode.getAttribute( 'points' ).replace( regex, iterator );\n\n\t\t\tpath.currentPath.autoClose = true;\n\n\t\t\treturn path;\n\n\t\t}\n\n\t\tfunction parsePolylineNode( node ) {\n\n\t\t\tfunction iterator( match, a, b ) {\n\n\t\t\t\tconst x = parseFloatWithUnits( a );\n\t\t\t\tconst y = parseFloatWithUnits( b );\n\n\t\t\t\tif ( index === 0 ) {\n\n\t\t\t\t\tpath.moveTo( x, y );\n\n\t\t\t\t} else {\n\n\t\t\t\t\tpath.lineTo( x, y );\n\n\t\t\t\t}\n\n\t\t\t\tindex ++;\n\n\t\t\t}\n\n\t\t\tconst regex = /(-?[\\d\\.?]+)[,|\\s](-?[\\d\\.?]+)/g;\n\n\t\t\tconst path = new ShapePath();\n\n\t\t\tlet index = 0;\n\n\t\t\tnode.getAttribute( 'points' ).replace( regex, iterator );\n\n\t\t\tpath.currentPath.autoClose = false;\n\n\t\t\treturn path;\n\n\t\t}\n\n\t\tfunction parseCircleNode( node ) {\n\n\t\t\tconst x = parseFloatWithUnits( node.getAttribute( 'cx' ) || 0 );\n\t\t\tconst y = parseFloatWithUnits( node.getAttribute( 'cy' ) || 0 );\n\t\t\tconst r = parseFloatWithUnits( node.getAttribute( 'r' ) || 0 );\n\n\t\t\tconst subpath = new Path();\n\t\t\tsubpath.absarc( x, y, r, 0, Math.PI * 2 );\n\n\t\t\tconst path = new ShapePath();\n\t\t\tpath.subPaths.push( subpath );\n\n\t\t\treturn path;\n\n\t\t}\n\n\t\tfunction parseEllipseNode( node ) {\n\n\t\t\tconst x = parseFloatWithUnits( node.getAttribute( 'cx' ) || 0 );\n\t\t\tconst y = parseFloatWithUnits( node.getAttribute( 'cy' ) || 0 );\n\t\t\tconst rx = parseFloatWithUnits( node.getAttribute( 'rx' ) || 0 );\n\t\t\tconst ry = parseFloatWithUnits( node.getAttribute( 'ry' ) || 0 );\n\n\t\t\tconst subpath = new Path();\n\t\t\tsubpath.absellipse( x, y, rx, ry, 0, Math.PI * 2 );\n\n\t\t\tconst path = new ShapePath();\n\t\t\tpath.subPaths.push( subpath );\n\n\t\t\treturn path;\n\n\t\t}\n\n\t\tfunction parseLineNode( node ) {\n\n\t\t\tconst x1 = parseFloatWithUnits( node.getAttribute( 'x1' ) || 0 );\n\t\t\tconst y1 = parseFloatWithUnits( node.getAttribute( 'y1' ) || 0 );\n\t\t\tconst x2 = parseFloatWithUnits( node.getAttribute( 'x2' ) || 0 );\n\t\t\tconst y2 = parseFloatWithUnits( node.getAttribute( 'y2' ) || 0 );\n\n\t\t\tconst path = new ShapePath();\n\t\t\tpath.moveTo( x1, y1 );\n\t\t\tpath.lineTo( x2, y2 );\n\t\t\tpath.currentPath.autoClose = false;\n\n\t\t\treturn path;\n\n\t\t}\n\n\t\t//\n\n\t\tfunction parseStyle( node, style ) {\n\n\t\t\tstyle = Object.assign( {}, style ); // clone style\n\n\t\t\tlet stylesheetStyles = {};\n\n\t\t\tif ( node.hasAttribute( 'class' ) ) {\n\n\t\t\t\tconst classSelectors = node.getAttribute( 'class' )\n\t\t\t\t\t.split( /\\s/ )\n\t\t\t\t\t.filter( Boolean )\n\t\t\t\t\t.map( i => i.trim() );\n\n\t\t\t\tfor ( let i = 0; i < classSelectors.length; i ++ ) {\n\n\t\t\t\t\tstylesheetStyles = Object.assign( stylesheetStyles, stylesheets[ '.' + classSelectors[ i ] ] );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tif ( node.hasAttribute( 'id' ) ) {\n\n\t\t\t\tstylesheetStyles = Object.assign( stylesheetStyles, stylesheets[ '#' + node.getAttribute( 'id' ) ] );\n\n\t\t\t}\n\n\t\t\tfunction addStyle( svgName, jsName, adjustFunction ) {\n\n\t\t\t\tif ( adjustFunction === undefined ) adjustFunction = function copy( v ) {\n\n\t\t\t\t\tif ( v.startsWith( 'url' ) ) console.warn( 'SVGLoader: url access in attributes is not implemented.' );\n\n\t\t\t\t\treturn v;\n\n\t\t\t\t};\n\n\t\t\t\tif ( node.hasAttribute( svgName ) ) style[ jsName ] = adjustFunction( node.getAttribute( svgName ) );\n\t\t\t\tif ( stylesheetStyles[ svgName ] ) style[ jsName ] = adjustFunction( stylesheetStyles[ svgName ] );\n\t\t\t\tif ( node.style && node.style[ svgName ] !== '' ) style[ jsName ] = adjustFunction( node.style[ svgName ] );\n\n\t\t\t}\n\n\t\t\tfunction clamp( v ) {\n\n\t\t\t\treturn Math.max( 0, Math.min( 1, parseFloatWithUnits( v ) ) );\n\n\t\t\t}\n\n\t\t\tfunction positive( v ) {\n\n\t\t\t\treturn Math.max( 0, parseFloatWithUnits( v ) );\n\n\t\t\t}\n\n\t\t\taddStyle( 'fill', 'fill' );\n\t\t\taddStyle( 'fill-opacity', 'fillOpacity', clamp );\n\t\t\taddStyle( 'fill-rule', 'fillRule' );\n\t\t\taddStyle( 'opacity', 'opacity', clamp );\n\t\t\taddStyle( 'stroke', 'stroke' );\n\t\t\taddStyle( 'stroke-opacity', 'strokeOpacity', clamp );\n\t\t\taddStyle( 'stroke-width', 'strokeWidth', positive );\n\t\t\taddStyle( 'stroke-linejoin', 'strokeLineJoin' );\n\t\t\taddStyle( 'stroke-linecap', 'strokeLineCap' );\n\t\t\taddStyle( 'stroke-miterlimit', 'strokeMiterLimit', positive );\n\t\t\taddStyle( 'visibility', 'visibility' );\n\n\t\t\treturn style;\n\n\t\t}\n\n\t\t// http://www.w3.org/TR/SVG11/implnote.html#PathElementImplementationNotes\n\n\t\tfunction getReflection( a, b ) {\n\n\t\t\treturn a - ( b - a );\n\n\t\t}\n\n\t\t// from https://github.com/ppvg/svg-numbers (MIT License)\n\n\t\tfunction parseFloats( input, flags, stride ) {\n\n\t\t\tif ( typeof input !== 'string' ) {\n\n\t\t\t\tthrow new TypeError( 'Invalid input: ' + typeof input );\n\n\t\t\t}\n\n\t\t\t// Character groups\n\t\t\tconst RE = {\n\t\t\t\tSEPARATOR: /[ \\t\\r\\n\\,.\\-+]/,\n\t\t\t\tWHITESPACE: /[ \\t\\r\\n]/,\n\t\t\t\tDIGIT: /[\\d]/,\n\t\t\t\tSIGN: /[-+]/,\n\t\t\t\tPOINT: /\\./,\n\t\t\t\tCOMMA: /,/,\n\t\t\t\tEXP: /e/i,\n\t\t\t\tFLAGS: /[01]/\n\t\t\t};\n\n\t\t\t// States\n\t\t\tconst SEP = 0;\n\t\t\tconst INT = 1;\n\t\t\tconst FLOAT = 2;\n\t\t\tconst EXP = 3;\n\n\t\t\tlet state = SEP;\n\t\t\tlet seenComma = true;\n\t\t\tlet number = '', exponent = '';\n\t\t\tconst result = [];\n\n\t\t\tfunction throwSyntaxError( current, i, partial ) {\n\n\t\t\t\tconst error = new SyntaxError( 'Unexpected character \"' + current + '\" at index ' + i + '.' );\n\t\t\t\terror.partial = partial;\n\t\t\t\tthrow error;\n\n\t\t\t}\n\n\t\t\tfunction newNumber() {\n\n\t\t\t\tif ( number !== '' ) {\n\n\t\t\t\t\tif ( exponent === '' ) result.push( Number( number ) );\n\t\t\t\t\telse result.push( Number( number ) * Math.pow( 10, Number( exponent ) ) );\n\n\t\t\t\t}\n\n\t\t\t\tnumber = '';\n\t\t\t\texponent = '';\n\n\t\t\t}\n\n\t\t\tlet current;\n\t\t\tconst length = input.length;\n\n\t\t\tfor ( let i = 0; i < length; i ++ ) {\n\n\t\t\t\tcurrent = input[ i ];\n\n\t\t\t\t// check for flags\n\t\t\t\tif ( Array.isArray( flags ) && flags.includes( result.length % stride ) && RE.FLAGS.test( current ) ) {\n\n\t\t\t\t\tstate = INT;\n\t\t\t\t\tnumber = current;\n\t\t\t\t\tnewNumber();\n\t\t\t\t\tcontinue;\n\n\t\t\t\t}\n\n\t\t\t\t// parse until next number\n\t\t\t\tif ( state === SEP ) {\n\n\t\t\t\t\t// eat whitespace\n\t\t\t\t\tif ( RE.WHITESPACE.test( current ) ) {\n\n\t\t\t\t\t\tcontinue;\n\n\t\t\t\t\t}\n\n\t\t\t\t\t// start new number\n\t\t\t\t\tif ( RE.DIGIT.test( current ) || RE.SIGN.test( current ) ) {\n\n\t\t\t\t\t\tstate = INT;\n\t\t\t\t\t\tnumber = current;\n\t\t\t\t\t\tcontinue;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( RE.POINT.test( current ) ) {\n\n\t\t\t\t\t\tstate = FLOAT;\n\t\t\t\t\t\tnumber = current;\n\t\t\t\t\t\tcontinue;\n\n\t\t\t\t\t}\n\n\t\t\t\t\t// throw on double commas (e.g. \"1, , 2\")\n\t\t\t\t\tif ( RE.COMMA.test( current ) ) {\n\n\t\t\t\t\t\tif ( seenComma ) {\n\n\t\t\t\t\t\t\tthrowSyntaxError( current, i, result );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tseenComma = true;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\t// parse integer part\n\t\t\t\tif ( state === INT ) {\n\n\t\t\t\t\tif ( RE.DIGIT.test( current ) ) {\n\n\t\t\t\t\t\tnumber += current;\n\t\t\t\t\t\tcontinue;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( RE.POINT.test( current ) ) {\n\n\t\t\t\t\t\tnumber += current;\n\t\t\t\t\t\tstate = FLOAT;\n\t\t\t\t\t\tcontinue;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( RE.EXP.test( current ) ) {\n\n\t\t\t\t\t\tstate = EXP;\n\t\t\t\t\t\tcontinue;\n\n\t\t\t\t\t}\n\n\t\t\t\t\t// throw on double signs (\"-+1\"), but not on sign as separator (\"-1-2\")\n\t\t\t\t\tif ( RE.SIGN.test( current )\n\t\t\t\t\t\t\t&& number.length === 1\n\t\t\t\t\t\t\t&& RE.SIGN.test( number[ 0 ] ) ) {\n\n\t\t\t\t\t\tthrowSyntaxError( current, i, result );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\t// parse decimal part\n\t\t\t\tif ( state === FLOAT ) {\n\n\t\t\t\t\tif ( RE.DIGIT.test( current ) ) {\n\n\t\t\t\t\t\tnumber += current;\n\t\t\t\t\t\tcontinue;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( RE.EXP.test( current ) ) {\n\n\t\t\t\t\t\tstate = EXP;\n\t\t\t\t\t\tcontinue;\n\n\t\t\t\t\t}\n\n\t\t\t\t\t// throw on double decimal points (e.g. \"1..2\")\n\t\t\t\t\tif ( RE.POINT.test( current ) && number[ number.length - 1 ] === '.' ) {\n\n\t\t\t\t\t\tthrowSyntaxError( current, i, result );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\t// parse exponent part\n\t\t\t\tif ( state === EXP ) {\n\n\t\t\t\t\tif ( RE.DIGIT.test( current ) ) {\n\n\t\t\t\t\t\texponent += current;\n\t\t\t\t\t\tcontinue;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tif ( RE.SIGN.test( current ) ) {\n\n\t\t\t\t\t\tif ( exponent === '' ) {\n\n\t\t\t\t\t\t\texponent += current;\n\t\t\t\t\t\t\tcontinue;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif ( exponent.length === 1 && RE.SIGN.test( exponent ) ) {\n\n\t\t\t\t\t\t\tthrowSyntaxError( current, i, result );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\n\t\t\t\t// end of number\n\t\t\t\tif ( RE.WHITESPACE.test( current ) ) {\n\n\t\t\t\t\tnewNumber();\n\t\t\t\t\tstate = SEP;\n\t\t\t\t\tseenComma = false;\n\n\t\t\t\t} else if ( RE.COMMA.test( current ) ) {\n\n\t\t\t\t\tnewNumber();\n\t\t\t\t\tstate = SEP;\n\t\t\t\t\tseenComma = true;\n\n\t\t\t\t} else if ( RE.SIGN.test( current ) ) {\n\n\t\t\t\t\tnewNumber();\n\t\t\t\t\tstate = INT;\n\t\t\t\t\tnumber = current;\n\n\t\t\t\t} else if ( RE.POINT.test( current ) ) {\n\n\t\t\t\t\tnewNumber();\n\t\t\t\t\tstate = FLOAT;\n\t\t\t\t\tnumber = current;\n\n\t\t\t\t} else {\n\n\t\t\t\t\tthrowSyntaxError( current, i, result );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t// add the last number found (if any)\n\t\t\tnewNumber();\n\n\t\t\treturn result;\n\n\t\t}\n\n\t\t// Units\n\n\t\tconst units = [ 'mm', 'cm', 'in', 'pt', 'pc', 'px' ];\n\n\t\t// Conversion: [ fromUnit ][ toUnit ] (-1 means dpi dependent)\n\t\tconst unitConversion = {\n\n\t\t\t'mm': {\n\t\t\t\t'mm': 1,\n\t\t\t\t'cm': 0.1,\n\t\t\t\t'in': 1 / 25.4,\n\t\t\t\t'pt': 72 / 25.4,\n\t\t\t\t'pc': 6 / 25.4,\n\t\t\t\t'px': - 1\n\t\t\t},\n\t\t\t'cm': {\n\t\t\t\t'mm': 10,\n\t\t\t\t'cm': 1,\n\t\t\t\t'in': 1 / 2.54,\n\t\t\t\t'pt': 72 / 2.54,\n\t\t\t\t'pc': 6 / 2.54,\n\t\t\t\t'px': - 1\n\t\t\t},\n\t\t\t'in': {\n\t\t\t\t'mm': 25.4,\n\t\t\t\t'cm': 2.54,\n\t\t\t\t'in': 1,\n\t\t\t\t'pt': 72,\n\t\t\t\t'pc': 6,\n\t\t\t\t'px': - 1\n\t\t\t},\n\t\t\t'pt': {\n\t\t\t\t'mm': 25.4 / 72,\n\t\t\t\t'cm': 2.54 / 72,\n\t\t\t\t'in': 1 / 72,\n\t\t\t\t'pt': 1,\n\t\t\t\t'pc': 6 / 72,\n\t\t\t\t'px': - 1\n\t\t\t},\n\t\t\t'pc': {\n\t\t\t\t'mm': 25.4 / 6,\n\t\t\t\t'cm': 2.54 / 6,\n\t\t\t\t'in': 1 / 6,\n\t\t\t\t'pt': 72 / 6,\n\t\t\t\t'pc': 1,\n\t\t\t\t'px': - 1\n\t\t\t},\n\t\t\t'px': {\n\t\t\t\t'px': 1\n\t\t\t}\n\n\t\t};\n\n\t\tfunction parseFloatWithUnits( string ) {\n\n\t\t\tlet theUnit = 'px';\n\n\t\t\tif ( typeof string === 'string' || string instanceof String ) {\n\n\t\t\t\tfor ( let i = 0, n = units.length; i < n; i ++ ) {\n\n\t\t\t\t\tconst u = units[ i ];\n\n\t\t\t\t\tif ( string.endsWith( u ) ) {\n\n\t\t\t\t\t\ttheUnit = u;\n\t\t\t\t\t\tstring = string.substring( 0, string.length - u.length );\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tlet scale = undefined;\n\n\t\t\tif ( theUnit === 'px' && scope.defaultUnit !== 'px' ) {\n\n\t\t\t\t// Conversion scale from  pixels to inches, then to default units\n\n\t\t\t\tscale = unitConversion[ 'in' ][ scope.defaultUnit ] / scope.defaultDPI;\n\n\t\t\t} else {\n\n\t\t\t\tscale = unitConversion[ theUnit ][ scope.defaultUnit ];\n\n\t\t\t\tif ( scale < 0 ) {\n\n\t\t\t\t\t// Conversion scale to pixels\n\n\t\t\t\t\tscale = unitConversion[ theUnit ][ 'in' ] * scope.defaultDPI;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn scale * parseFloat( string );\n\n\t\t}\n\n\t\t// Transforms\n\n\t\tfunction getNodeTransform( node ) {\n\n\t\t\tif ( ! ( node.hasAttribute( 'transform' ) || ( node.nodeName === 'use' && ( node.hasAttribute( 'x' ) || node.hasAttribute( 'y' ) ) ) ) ) {\n\n\t\t\t\treturn null;\n\n\t\t\t}\n\n\t\t\tconst transform = parseNodeTransform( node );\n\n\t\t\tif ( transformStack.length > 0 ) {\n\n\t\t\t\ttransform.premultiply( transformStack[ transformStack.length - 1 ] );\n\n\t\t\t}\n\n\t\t\tcurrentTransform.copy( transform );\n\t\t\ttransformStack.push( transform );\n\n\t\t\treturn transform;\n\n\t\t}\n\n\t\tfunction parseNodeTransform( node ) {\n\n\t\t\tconst transform = new Matrix3();\n\t\t\tconst currentTransform = tempTransform0;\n\n\t\t\tif ( node.nodeName === 'use' && ( node.hasAttribute( 'x' ) || node.hasAttribute( 'y' ) ) ) {\n\n\t\t\t\tconst tx = parseFloatWithUnits( node.getAttribute( 'x' ) );\n\t\t\t\tconst ty = parseFloatWithUnits( node.getAttribute( 'y' ) );\n\n\t\t\t\ttransform.translate( tx, ty );\n\n\t\t\t}\n\n\t\t\tif ( node.hasAttribute( 'transform' ) ) {\n\n\t\t\t\tconst transformsTexts = node.getAttribute( 'transform' ).split( ')' );\n\n\t\t\t\tfor ( let tIndex = transformsTexts.length - 1; tIndex >= 0; tIndex -- ) {\n\n\t\t\t\t\tconst transformText = transformsTexts[ tIndex ].trim();\n\n\t\t\t\t\tif ( transformText === '' ) continue;\n\n\t\t\t\t\tconst openParPos = transformText.indexOf( '(' );\n\t\t\t\t\tconst closeParPos = transformText.length;\n\n\t\t\t\t\tif ( openParPos > 0 && openParPos < closeParPos ) {\n\n\t\t\t\t\t\tconst transformType = transformText.slice( 0, openParPos );\n\n\t\t\t\t\t\tconst array = parseFloats( transformText.slice( openParPos + 1 ) );\n\n\t\t\t\t\t\tcurrentTransform.identity();\n\n\t\t\t\t\t\tswitch ( transformType ) {\n\n\t\t\t\t\t\t\tcase 'translate':\n\n\t\t\t\t\t\t\t\tif ( array.length >= 1 ) {\n\n\t\t\t\t\t\t\t\t\tconst tx = array[ 0 ];\n\t\t\t\t\t\t\t\t\tlet ty = 0;\n\n\t\t\t\t\t\t\t\t\tif ( array.length >= 2 ) {\n\n\t\t\t\t\t\t\t\t\t\tty = array[ 1 ];\n\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\tcurrentTransform.translate( tx, ty );\n\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\tcase 'rotate':\n\n\t\t\t\t\t\t\t\tif ( array.length >= 1 ) {\n\n\t\t\t\t\t\t\t\t\tlet angle = 0;\n\t\t\t\t\t\t\t\t\tlet cx = 0;\n\t\t\t\t\t\t\t\t\tlet cy = 0;\n\n\t\t\t\t\t\t\t\t\t// Angle\n\t\t\t\t\t\t\t\t\tangle = array[ 0 ] * Math.PI / 180;\n\n\t\t\t\t\t\t\t\t\tif ( array.length >= 3 ) {\n\n\t\t\t\t\t\t\t\t\t\t// Center x, y\n\t\t\t\t\t\t\t\t\t\tcx = array[ 1 ];\n\t\t\t\t\t\t\t\t\t\tcy = array[ 2 ];\n\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t// Rotate around center (cx, cy)\n\t\t\t\t\t\t\t\t\ttempTransform1.makeTranslation( - cx, - cy );\n\t\t\t\t\t\t\t\t\ttempTransform2.makeRotation( angle );\n\t\t\t\t\t\t\t\t\ttempTransform3.multiplyMatrices( tempTransform2, tempTransform1 );\n\t\t\t\t\t\t\t\t\ttempTransform1.makeTranslation( cx, cy );\n\t\t\t\t\t\t\t\t\tcurrentTransform.multiplyMatrices( tempTransform1, tempTransform3 );\n\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\tcase 'scale':\n\n\t\t\t\t\t\t\t\tif ( array.length >= 1 ) {\n\n\t\t\t\t\t\t\t\t\tconst scaleX = array[ 0 ];\n\t\t\t\t\t\t\t\t\tlet scaleY = scaleX;\n\n\t\t\t\t\t\t\t\t\tif ( array.length >= 2 ) {\n\n\t\t\t\t\t\t\t\t\t\tscaleY = array[ 1 ];\n\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\tcurrentTransform.scale( scaleX, scaleY );\n\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\tcase 'skewX':\n\n\t\t\t\t\t\t\t\tif ( array.length === 1 ) {\n\n\t\t\t\t\t\t\t\t\tcurrentTransform.set(\n\t\t\t\t\t\t\t\t\t\t1, Math.tan( array[ 0 ] * Math.PI / 180 ), 0,\n\t\t\t\t\t\t\t\t\t\t0, 1, 0,\n\t\t\t\t\t\t\t\t\t\t0, 0, 1\n\t\t\t\t\t\t\t\t\t);\n\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\tcase 'skewY':\n\n\t\t\t\t\t\t\t\tif ( array.length === 1 ) {\n\n\t\t\t\t\t\t\t\t\tcurrentTransform.set(\n\t\t\t\t\t\t\t\t\t\t1, 0, 0,\n\t\t\t\t\t\t\t\t\t\tMath.tan( array[ 0 ] * Math.PI / 180 ), 1, 0,\n\t\t\t\t\t\t\t\t\t\t0, 0, 1\n\t\t\t\t\t\t\t\t\t);\n\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\tcase 'matrix':\n\n\t\t\t\t\t\t\t\tif ( array.length === 6 ) {\n\n\t\t\t\t\t\t\t\t\tcurrentTransform.set(\n\t\t\t\t\t\t\t\t\t\tarray[ 0 ], array[ 2 ], array[ 4 ],\n\t\t\t\t\t\t\t\t\t\tarray[ 1 ], array[ 3 ], array[ 5 ],\n\t\t\t\t\t\t\t\t\t\t0, 0, 1\n\t\t\t\t\t\t\t\t\t);\n\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t\ttransform.premultiply( currentTransform );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn transform;\n\n\t\t}\n\n\t\tfunction transformPath( path, m ) {\n\n\t\t\tfunction transfVec2( v2 ) {\n\n\t\t\t\ttempV3.set( v2.x, v2.y, 1 ).applyMatrix3( m );\n\n\t\t\t\tv2.set( tempV3.x, tempV3.y );\n\n\t\t\t}\n\n\t\t\tfunction transfEllipseGeneric( curve ) {\n\n\t\t\t\t// For math description see:\n\t\t\t\t// https://math.stackexchange.com/questions/4544164\n\n\t\t\t\tconst a = curve.xRadius;\n\t\t\t\tconst b = curve.yRadius;\n\n\t\t\t\tconst cosTheta = Math.cos( curve.aRotation );\n\t\t\t\tconst sinTheta = Math.sin( curve.aRotation );\n\n\t\t\t\tconst v1 = new Vector3( a * cosTheta, a * sinTheta, 0 );\n\t\t\t\tconst v2 = new Vector3( -b * sinTheta, b * cosTheta, 0 );\n\n\t\t\t\tconst f1 = v1.applyMatrix3( m );\n\t\t\t\tconst f2 = v2.applyMatrix3( m );\n\n\t\t\t\tconst mF = tempTransform0.set(\n\t\t\t\t\tf1.x, f2.x, 0,\n\t\t\t\t\tf1.y, f2.y, 0,\n\t\t\t\t\t0,    0,    1,\n\t\t\t\t);\n\n\t\t\t\tconst mFInv = tempTransform1.copy( mF ).invert();\n\t\t\t\tconst mFInvT = tempTransform2.copy( mFInv ).transpose();\n\t\t\t\tconst mQ = mFInvT.multiply( mFInv );\n\t\t\t\tconst mQe = mQ.elements;\n\n\t\t\t\tconst ed = eigenDecomposition( mQe[0], mQe[1], mQe[4] );\n\t\t\t\tconst rt1sqrt = Math.sqrt( ed.rt1 );\n\t\t\t\tconst rt2sqrt = Math.sqrt( ed.rt2 );\n\n\t\t\t\tcurve.xRadius = 1 / rt1sqrt;\n\t\t\t\tcurve.yRadius = 1 / rt2sqrt;\n\t\t\t\tcurve.aRotation = Math.atan2( ed.sn, ed.cs );\n\n\t\t\t\tconst isFullEllipse =\n\t\t\t\t\t( curve.aEndAngle - curve.aStartAngle ) % ( 2 * Math.PI ) < Number.EPSILON;\n\n\t\t\t\t// Do not touch angles of a full ellipse because after transformation they\n\t\t\t\t// would converge to a sinle value effectively removing the whole curve\n\n\t\t\t\tif ( !isFullEllipse ) {\n\n\t\t\t\t\tconst mDsqrt = tempTransform1.set(\n\t\t\t\t\t\trt1sqrt, 0, 0,\n\t\t\t\t\t\t0, rt2sqrt, 0,\n\t\t\t\t\t\t0, 0,       1,\n\t\t\t\t\t);\n\n\t\t\t\t\tconst mRT = tempTransform2.set(\n\t\t\t\t\t\ted.cs,  ed.sn, 0,\n\t\t\t\t\t\t-ed.sn, ed.cs, 0,\n\t\t\t\t\t\t0,      0,     1,\n\t\t\t\t\t);\n\n\t\t\t\t\tconst mDRF = mDsqrt.multiply( mRT ).multiply( mF );\n\n\t\t\t\t\tconst transformAngle = phi => {\n\n\t\t\t\t\t\tconst { x: cosR, y: sinR } =\n\t\t\t\t\t\t\tnew Vector3( Math.cos( phi ), Math.sin( phi ), 0 ).applyMatrix3( mDRF );\n\n\t\t\t\t\t\treturn Math.atan2( sinR, cosR );\n\n\t\t\t\t\t};\n\n\t\t\t\t\tcurve.aStartAngle = transformAngle( curve.aStartAngle );\n\t\t\t\t\tcurve.aEndAngle = transformAngle( curve.aEndAngle );\n\n\t\t\t\t\tif ( isTransformFlipped( m ) ) {\n\n\t\t\t\t\t\tcurve.aClockwise = !curve.aClockwise;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tfunction transfEllipseNoSkew( curve ) {\n\n\t\t\t\t// Faster shortcut if no skew is applied\n\t\t\t\t// (e.g, a euclidean transform of a group containing the ellipse)\n\n\t\t\t\tconst sx = getTransformScaleX( m );\n\t\t\t\tconst sy = getTransformScaleY( m );\n\n\t\t\t\tcurve.xRadius *= sx;\n\t\t\t\tcurve.yRadius *= sy;\n\n\t\t\t\t// Extract rotation angle from the matrix of form:\n\t\t\t\t//\n\t\t\t\t//  | cosθ sx   -sinθ sy |\n\t\t\t\t//  | sinθ sx    cosθ sy |\n\t\t\t\t//\n\t\t\t\t// Remembering that tanθ = sinθ / cosθ; and that\n\t\t\t\t// `sx`, `sy`, or both might be zero.\n\t\t\t\tconst theta =\n\t\t\t\t\tsx > Number.EPSILON\n\t\t\t\t\t? Math.atan2( m.elements[ 1 ], m.elements[ 0 ] )\n\t\t\t\t\t: Math.atan2( - m.elements[ 3 ], m.elements[ 4 ] );\n\n\t\t\t\tcurve.aRotation += theta;\n\n\t\t\t\tif ( isTransformFlipped( m ) ) {\n\n\t\t\t\t\tcurve.aStartAngle *= -1;\n\t\t\t\t\tcurve.aEndAngle *= -1;\n\t\t\t\t\tcurve.aClockwise = !curve.aClockwise;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tconst subPaths = path.subPaths;\n\n\t\t\tfor ( let i = 0, n = subPaths.length; i < n; i ++ ) {\n\n\t\t\t\tconst subPath = subPaths[ i ];\n\t\t\t\tconst curves = subPath.curves;\n\n\t\t\t\tfor ( let j = 0; j < curves.length; j ++ ) {\n\n\t\t\t\t\tconst curve = curves[ j ];\n\n\t\t\t\t\tif ( curve.isLineCurve ) {\n\n\t\t\t\t\t\ttransfVec2( curve.v1 );\n\t\t\t\t\t\ttransfVec2( curve.v2 );\n\n\t\t\t\t\t} else if ( curve.isCubicBezierCurve ) {\n\n\t\t\t\t\t\ttransfVec2( curve.v0 );\n\t\t\t\t\t\ttransfVec2( curve.v1 );\n\t\t\t\t\t\ttransfVec2( curve.v2 );\n\t\t\t\t\t\ttransfVec2( curve.v3 );\n\n\t\t\t\t\t} else if ( curve.isQuadraticBezierCurve ) {\n\n\t\t\t\t\t\ttransfVec2( curve.v0 );\n\t\t\t\t\t\ttransfVec2( curve.v1 );\n\t\t\t\t\t\ttransfVec2( curve.v2 );\n\n\t\t\t\t\t} else if ( curve.isEllipseCurve ) {\n\n\t\t\t\t\t\t// Transform ellipse center point\n\n\t\t\t\t\t\ttempV2.set( curve.aX, curve.aY );\n\t\t\t\t\t\ttransfVec2( tempV2 );\n\t\t\t\t\t\tcurve.aX = tempV2.x;\n\t\t\t\t\t\tcurve.aY = tempV2.y;\n\n\t\t\t\t\t\t// Transform ellipse shape parameters\n\n\t\t\t\t\t\tif ( isTransformSkewed( m ) ) {\n\n\t\t\t\t\t\t\ttransfEllipseGeneric( curve );\n\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\ttransfEllipseNoSkew( curve );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tfunction isTransformFlipped( m ) {\n\n\t\t\tconst te = m.elements;\n\t\t\treturn te[ 0 ] * te[ 4 ] - te[ 1 ] * te[ 3 ] < 0;\n\n\t\t}\n\n\t\tfunction isTransformSkewed( m ) {\n\n\t\t\tconst te = m.elements;\n\t\t\tconst basisDot = te[ 0 ] * te[ 3 ] + te[ 1 ] * te[ 4 ];\n\n\t\t\t// Shortcut for trivial rotations and transformations\n\t\t\tif ( basisDot === 0 ) return false;\n\n\t\t\tconst sx = getTransformScaleX( m );\n\t\t\tconst sy = getTransformScaleY( m );\n\n\t\t\treturn Math.abs( basisDot / ( sx * sy ) ) > Number.EPSILON;\n\n\t\t}\n\n\t\tfunction getTransformScaleX( m ) {\n\n\t\t\tconst te = m.elements;\n\t\t\treturn Math.sqrt( te[ 0 ] * te[ 0 ] + te[ 1 ] * te[ 1 ] );\n\n\t\t}\n\n\t\tfunction getTransformScaleY( m ) {\n\n\t\t\tconst te = m.elements;\n\t\t\treturn Math.sqrt( te[ 3 ] * te[ 3 ] + te[ 4 ] * te[ 4 ] );\n\n\t\t}\n\n\t\t// Calculates the eigensystem of a real symmetric 2x2 matrix\n\t\t//    [ A  B ]\n\t\t//    [ B  C ]\n\t\t// in the form\n\t\t//    [ A  B ]  =  [ cs  -sn ] [ rt1   0  ] [  cs  sn ]\n\t\t//    [ B  C ]     [ sn   cs ] [  0   rt2 ] [ -sn  cs ]\n\t\t// where rt1 >= rt2.\n\t\t//\n\t\t// Adapted from: https://www.mpi-hd.mpg.de/personalhomes/globes/3x3/index.html\n\t\t// -> Algorithms for real symmetric matrices -> Analytical (2x2 symmetric)\n\t\tfunction eigenDecomposition( A, B, C ) {\n\n\t\t\tlet rt1, rt2, cs, sn, t;\n\t\t\tconst sm = A + C;\n\t\t\tconst df = A - C;\n\t\t\tconst rt = Math.sqrt( df * df + 4 * B * B );\n\n\t\t\tif ( sm > 0 ) {\n\n\t\t\t\trt1 = 0.5 * ( sm + rt );\n\t\t\t\tt = 1 / rt1;\n\t\t\t\trt2 = A * t * C - B * t * B;\n\n\t\t\t} else if ( sm < 0 ) {\n\n\t\t\t\trt2 = 0.5 * ( sm - rt );\n\n\t\t\t} else {\n\n\t\t\t\t// This case needs to be treated separately to avoid div by 0\n\n\t\t\t\trt1 = 0.5 * rt;\n\t\t\t\trt2 = -0.5 * rt;\n\n\t\t\t}\n\n\t\t\t// Calculate eigenvectors\n\n\t\t\tif ( df > 0 ) {\n\n\t\t\t\tcs = df + rt;\n\n\t\t\t} else {\n\n\t\t\t\tcs = df - rt;\n\n\t\t\t}\n\n\t\t\tif ( Math.abs( cs ) > 2 * Math.abs( B ) ) {\n\n\t\t\t\tt = -2 * B / cs;\n\t\t\t\tsn = 1 / Math.sqrt( 1 + t * t );\n\t\t\t\tcs = t * sn;\n\n\t\t\t} else if ( Math.abs( B ) === 0 ) {\n\n\t\t\t\tcs = 1;\n\t\t\t\tsn = 0;\n\n\t\t\t} else {\n\n\t\t\t\tt = -0.5 * cs / B;\n\t\t\t\tcs = 1 / Math.sqrt( 1 + t * t );\n\t\t\t\tsn = t * cs;\n\n\t\t\t}\n\n\t\t\tif ( df > 0 ) {\n\n\t\t\t\tt = cs;\n\t\t\t\tcs = -sn;\n\t\t\t\tsn = t;\n\n\t\t\t}\n\n\t\t\treturn { rt1, rt2, cs, sn };\n\n\t\t}\n\n\t\t//\n\n\t\tconst paths = [];\n\t\tconst stylesheets = {};\n\n\t\tconst transformStack = [];\n\n\t\tconst tempTransform0 = new Matrix3();\n\t\tconst tempTransform1 = new Matrix3();\n\t\tconst tempTransform2 = new Matrix3();\n\t\tconst tempTransform3 = new Matrix3();\n\t\tconst tempV2 = new Vector2();\n\t\tconst tempV3 = new Vector3();\n\n\t\tconst currentTransform = new Matrix3();\n\n\t\tconst xml = new DOMParser().parseFromString( text, 'image/svg+xml' ); // application/xml\n\n\t\tparseNode( xml.documentElement, {\n\t\t\tfill: '#000',\n\t\t\tfillOpacity: 1,\n\t\t\tstrokeOpacity: 1,\n\t\t\tstrokeWidth: 1,\n\t\t\tstrokeLineJoin: 'miter',\n\t\t\tstrokeLineCap: 'butt',\n\t\t\tstrokeMiterLimit: 4\n\t\t} );\n\n\t\tconst data = { paths: paths, xml: xml.documentElement };\n\n\t\t// console.log( paths );\n\t\treturn data;\n\n\t}\n\n\tstatic createShapes( shapePath ) {\n\n\t\t// Param shapePath: a shapepath as returned by the parse function of this class\n\t\t// Returns Shape object\n\n\t\tconst BIGNUMBER = 999999999;\n\n\t\tconst IntersectionLocationType = {\n\t\t\tORIGIN: 0,\n\t\t\tDESTINATION: 1,\n\t\t\tBETWEEN: 2,\n\t\t\tLEFT: 3,\n\t\t\tRIGHT: 4,\n\t\t\tBEHIND: 5,\n\t\t\tBEYOND: 6\n\t\t};\n\n\t\tconst classifyResult = {\n\t\t\tloc: IntersectionLocationType.ORIGIN,\n\t\t\tt: 0\n\t\t};\n\n\t\tfunction findEdgeIntersection( a0, a1, b0, b1 ) {\n\n\t\t\tconst x1 = a0.x;\n\t\t\tconst x2 = a1.x;\n\t\t\tconst x3 = b0.x;\n\t\t\tconst x4 = b1.x;\n\t\t\tconst y1 = a0.y;\n\t\t\tconst y2 = a1.y;\n\t\t\tconst y3 = b0.y;\n\t\t\tconst y4 = b1.y;\n\t\t\tconst nom1 = ( x4 - x3 ) * ( y1 - y3 ) - ( y4 - y3 ) * ( x1 - x3 );\n\t\t\tconst nom2 = ( x2 - x1 ) * ( y1 - y3 ) - ( y2 - y1 ) * ( x1 - x3 );\n\t\t\tconst denom = ( y4 - y3 ) * ( x2 - x1 ) - ( x4 - x3 ) * ( y2 - y1 );\n\t\t\tconst t1 = nom1 / denom;\n\t\t\tconst t2 = nom2 / denom;\n\n\t\t\tif ( ( ( denom === 0 ) && ( nom1 !== 0 ) ) || ( t1 <= 0 ) || ( t1 >= 1 ) || ( t2 < 0 ) || ( t2 > 1 ) ) {\n\n\t\t\t\t//1. lines are parallel or edges don't intersect\n\n\t\t\t\treturn null;\n\n\t\t\t} else if ( ( nom1 === 0 ) && ( denom === 0 ) ) {\n\n\t\t\t\t//2. lines are colinear\n\n\t\t\t\t//check if endpoints of edge2 (b0-b1) lies on edge1 (a0-a1)\n\t\t\t\tfor ( let i = 0; i < 2; i ++ ) {\n\n\t\t\t\t\tclassifyPoint( i === 0 ? b0 : b1, a0, a1 );\n\t\t\t\t\t//find position of this endpoints relatively to edge1\n\t\t\t\t\tif ( classifyResult.loc == IntersectionLocationType.ORIGIN ) {\n\n\t\t\t\t\t\tconst point = ( i === 0 ? b0 : b1 );\n\t\t\t\t\t\treturn { x: point.x, y: point.y, t: classifyResult.t };\n\n\t\t\t\t\t} else if ( classifyResult.loc == IntersectionLocationType.BETWEEN ) {\n\n\t\t\t\t\t\tconst x = + ( ( x1 + classifyResult.t * ( x2 - x1 ) ).toPrecision( 10 ) );\n\t\t\t\t\t\tconst y = + ( ( y1 + classifyResult.t * ( y2 - y1 ) ).toPrecision( 10 ) );\n\t\t\t\t\t\treturn { x: x, y: y, t: classifyResult.t, };\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\treturn null;\n\n\t\t\t} else {\n\n\t\t\t\t//3. edges intersect\n\n\t\t\t\tfor ( let i = 0; i < 2; i ++ ) {\n\n\t\t\t\t\tclassifyPoint( i === 0 ? b0 : b1, a0, a1 );\n\n\t\t\t\t\tif ( classifyResult.loc == IntersectionLocationType.ORIGIN ) {\n\n\t\t\t\t\t\tconst point = ( i === 0 ? b0 : b1 );\n\t\t\t\t\t\treturn { x: point.x, y: point.y, t: classifyResult.t };\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tconst x = + ( ( x1 + t1 * ( x2 - x1 ) ).toPrecision( 10 ) );\n\t\t\t\tconst y = + ( ( y1 + t1 * ( y2 - y1 ) ).toPrecision( 10 ) );\n\t\t\t\treturn { x: x, y: y, t: t1 };\n\n\t\t\t}\n\n\t\t}\n\n\t\tfunction classifyPoint( p, edgeStart, edgeEnd ) {\n\n\t\t\tconst ax = edgeEnd.x - edgeStart.x;\n\t\t\tconst ay = edgeEnd.y - edgeStart.y;\n\t\t\tconst bx = p.x - edgeStart.x;\n\t\t\tconst by = p.y - edgeStart.y;\n\t\t\tconst sa = ax * by - bx * ay;\n\n\t\t\tif ( ( p.x === edgeStart.x ) && ( p.y === edgeStart.y ) ) {\n\n\t\t\t\tclassifyResult.loc = IntersectionLocationType.ORIGIN;\n\t\t\t\tclassifyResult.t = 0;\n\t\t\t\treturn;\n\n\t\t\t}\n\n\t\t\tif ( ( p.x === edgeEnd.x ) && ( p.y === edgeEnd.y ) ) {\n\n\t\t\t\tclassifyResult.loc = IntersectionLocationType.DESTINATION;\n\t\t\t\tclassifyResult.t = 1;\n\t\t\t\treturn;\n\n\t\t\t}\n\n\t\t\tif ( sa < - Number.EPSILON ) {\n\n\t\t\t\tclassifyResult.loc = IntersectionLocationType.LEFT;\n\t\t\t\treturn;\n\n\t\t\t}\n\n\t\t\tif ( sa > Number.EPSILON ) {\n\n\t\t\t\tclassifyResult.loc = IntersectionLocationType.RIGHT;\n\t\t\t\treturn;\n\n\n\t\t\t}\n\n\t\t\tif ( ( ( ax * bx ) < 0 ) || ( ( ay * by ) < 0 ) ) {\n\n\t\t\t\tclassifyResult.loc = IntersectionLocationType.BEHIND;\n\t\t\t\treturn;\n\n\t\t\t}\n\n\t\t\tif ( ( Math.sqrt( ax * ax + ay * ay ) ) < ( Math.sqrt( bx * bx + by * by ) ) ) {\n\n\t\t\t\tclassifyResult.loc = IntersectionLocationType.BEYOND;\n\t\t\t\treturn;\n\n\t\t\t}\n\n\t\t\tlet t;\n\n\t\t\tif ( ax !== 0 ) {\n\n\t\t\t\tt = bx / ax;\n\n\t\t\t} else {\n\n\t\t\t\tt = by / ay;\n\n\t\t\t}\n\n\t\t\tclassifyResult.loc = IntersectionLocationType.BETWEEN;\n\t\t\tclassifyResult.t = t;\n\n\t\t}\n\n\t\tfunction getIntersections( path1, path2 ) {\n\n\t\t\tconst intersectionsRaw = [];\n\t\t\tconst intersections = [];\n\n\t\t\tfor ( let index = 1; index < path1.length; index ++ ) {\n\n\t\t\t\tconst path1EdgeStart = path1[ index - 1 ];\n\t\t\t\tconst path1EdgeEnd = path1[ index ];\n\n\t\t\t\tfor ( let index2 = 1; index2 < path2.length; index2 ++ ) {\n\n\t\t\t\t\tconst path2EdgeStart = path2[ index2 - 1 ];\n\t\t\t\t\tconst path2EdgeEnd = path2[ index2 ];\n\n\t\t\t\t\tconst intersection = findEdgeIntersection( path1EdgeStart, path1EdgeEnd, path2EdgeStart, path2EdgeEnd );\n\n\t\t\t\t\tif ( intersection !== null && intersectionsRaw.find( i => i.t <= intersection.t + Number.EPSILON && i.t >= intersection.t - Number.EPSILON ) === undefined ) {\n\n\t\t\t\t\t\tintersectionsRaw.push( intersection );\n\t\t\t\t\t\tintersections.push( new Vector2( intersection.x, intersection.y ) );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\treturn intersections;\n\n\t\t}\n\n\t\tfunction getScanlineIntersections( scanline, boundingBox, paths ) {\n\n\t\t\tconst center = new Vector2();\n\t\t\tboundingBox.getCenter( center );\n\n\t\t\tconst allIntersections = [];\n\n\t\t\tpaths.forEach( path => {\n\n\t\t\t\t// check if the center of the bounding box is in the bounding box of the paths.\n\t\t\t\t// this is a pruning method to limit the search of intersections in paths that can't envelop of the current path.\n\t\t\t\t// if a path envelops another path. The center of that oter path, has to be inside the bounding box of the enveloping path.\n\t\t\t\tif ( path.boundingBox.containsPoint( center ) ) {\n\n\t\t\t\t\tconst intersections = getIntersections( scanline, path.points );\n\n\t\t\t\t\tintersections.forEach( p => {\n\n\t\t\t\t\t\tallIntersections.push( { identifier: path.identifier, isCW: path.isCW, point: p } );\n\n\t\t\t\t\t} );\n\n\t\t\t\t}\n\n\t\t\t} );\n\n\t\t\tallIntersections.sort( ( i1, i2 ) => {\n\n\t\t\t\treturn i1.point.x - i2.point.x;\n\n\t\t\t} );\n\n\t\t\treturn allIntersections;\n\n\t\t}\n\n\t\tfunction isHoleTo( simplePath, allPaths, scanlineMinX, scanlineMaxX, _fillRule ) {\n\n\t\t\tif ( _fillRule === null || _fillRule === undefined || _fillRule === '' ) {\n\n\t\t\t\t_fillRule = 'nonzero';\n\n\t\t\t}\n\n\t\t\tconst centerBoundingBox = new Vector2();\n\t\t\tsimplePath.boundingBox.getCenter( centerBoundingBox );\n\n\t\t\tconst scanline = [ new Vector2( scanlineMinX, centerBoundingBox.y ), new Vector2( scanlineMaxX, centerBoundingBox.y ) ];\n\n\t\t\tconst scanlineIntersections = getScanlineIntersections( scanline, simplePath.boundingBox, allPaths );\n\n\t\t\tscanlineIntersections.sort( ( i1, i2 ) => {\n\n\t\t\t\treturn i1.point.x - i2.point.x;\n\n\t\t\t} );\n\n\t\t\tconst baseIntersections = [];\n\t\t\tconst otherIntersections = [];\n\n\t\t\tscanlineIntersections.forEach( i => {\n\n\t\t\t\tif ( i.identifier === simplePath.identifier ) {\n\n\t\t\t\t\tbaseIntersections.push( i );\n\n\t\t\t\t} else {\n\n\t\t\t\t\totherIntersections.push( i );\n\n\t\t\t\t}\n\n\t\t\t} );\n\n\t\t\tconst firstXOfPath = baseIntersections[ 0 ].point.x;\n\n\t\t\t// build up the path hierarchy\n\t\t\tconst stack = [];\n\t\t\tlet i = 0;\n\n\t\t\twhile ( i < otherIntersections.length && otherIntersections[ i ].point.x < firstXOfPath ) {\n\n\t\t\t\tif ( stack.length > 0 && stack[ stack.length - 1 ] === otherIntersections[ i ].identifier ) {\n\n\t\t\t\t\tstack.pop();\n\n\t\t\t\t} else {\n\n\t\t\t\t\tstack.push( otherIntersections[ i ].identifier );\n\n\t\t\t\t}\n\n\t\t\t\ti ++;\n\n\t\t\t}\n\n\t\t\tstack.push( simplePath.identifier );\n\n\t\t\tif ( _fillRule === 'evenodd' ) {\n\n\t\t\t\tconst isHole = stack.length % 2 === 0 ? true : false;\n\t\t\t\tconst isHoleFor = stack[ stack.length - 2 ];\n\n\t\t\t\treturn { identifier: simplePath.identifier, isHole: isHole, for: isHoleFor };\n\n\t\t\t} else if ( _fillRule === 'nonzero' ) {\n\n\t\t\t\t// check if path is a hole by counting the amount of paths with alternating rotations it has to cross.\n\t\t\t\tlet isHole = true;\n\t\t\t\tlet isHoleFor = null;\n\t\t\t\tlet lastCWValue = null;\n\n\t\t\t\tfor ( let i = 0; i < stack.length; i ++ ) {\n\n\t\t\t\t\tconst identifier = stack[ i ];\n\t\t\t\t\tif ( isHole ) {\n\n\t\t\t\t\t\tlastCWValue = allPaths[ identifier ].isCW;\n\t\t\t\t\t\tisHole = false;\n\t\t\t\t\t\tisHoleFor = identifier;\n\n\t\t\t\t\t} else if ( lastCWValue !== allPaths[ identifier ].isCW ) {\n\n\t\t\t\t\t\tlastCWValue = allPaths[ identifier ].isCW;\n\t\t\t\t\t\tisHole = true;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\treturn { identifier: simplePath.identifier, isHole: isHole, for: isHoleFor };\n\n\t\t\t} else {\n\n\t\t\t\tconsole.warn( 'fill-rule: \"' + _fillRule + '\" is currently not implemented.' );\n\n\t\t\t}\n\n\t\t}\n\n\t\t// check for self intersecting paths\n\t\t// TODO\n\n\t\t// check intersecting paths\n\t\t// TODO\n\n\t\t// prepare paths for hole detection\n\t\tlet scanlineMinX = BIGNUMBER;\n\t\tlet scanlineMaxX = - BIGNUMBER;\n\n\t\tlet simplePaths = shapePath.subPaths.map( p => {\n\n\t\t\tconst points = p.getPoints();\n\t\t\tlet maxY = - BIGNUMBER;\n\t\t\tlet minY = BIGNUMBER;\n\t\t\tlet maxX = - BIGNUMBER;\n\t\t\tlet minX = BIGNUMBER;\n\n\t      \t//points.forEach(p => p.y *= -1);\n\n\t\t\tfor ( let i = 0; i < points.length; i ++ ) {\n\n\t\t\t\tconst p = points[ i ];\n\n\t\t\t\tif ( p.y > maxY ) {\n\n\t\t\t\t\tmaxY = p.y;\n\n\t\t\t\t}\n\n\t\t\t\tif ( p.y < minY ) {\n\n\t\t\t\t\tminY = p.y;\n\n\t\t\t\t}\n\n\t\t\t\tif ( p.x > maxX ) {\n\n\t\t\t\t\tmaxX = p.x;\n\n\t\t\t\t}\n\n\t\t\t\tif ( p.x < minX ) {\n\n\t\t\t\t\tminX = p.x;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t//\n\t\t\tif ( scanlineMaxX <= maxX ) {\n\n\t\t\t\tscanlineMaxX = maxX + 1;\n\n\t\t\t}\n\n\t\t\tif ( scanlineMinX >= minX ) {\n\n\t\t\t\tscanlineMinX = minX - 1;\n\n\t\t\t}\n\n\t\t\treturn { curves: p.curves, points: points, isCW: ShapeUtils.isClockWise( points ), identifier: -1, boundingBox: new Box2( new Vector2( minX, minY ), new Vector2( maxX, maxY ) ) };\n\n\t\t} );\n\n\t\tsimplePaths = simplePaths.filter( sp => sp.points.length > 1 );\n\n\t\tfor ( let identifier = 0; identifier < simplePaths.length; identifier++ ) {\n\n\t\t\tsimplePaths[identifier].identifier = identifier;\n\n\t\t}\n\n\t\t// check if path is solid or a hole\n\t\tconst isAHole = simplePaths.map( p => isHoleTo( p, simplePaths, scanlineMinX, scanlineMaxX, shapePath.userData?.style.fillRule ) );\n\n\n\t\tconst shapesToReturn = [];\n\t\tsimplePaths.forEach( p => {\n\n\t\t\tconst amIAHole = isAHole[ p.identifier ];\n\n\t\t\tif ( ! amIAHole.isHole ) {\n\n\t\t\t\tconst shape = new Shape();\n\t\t\t\tshape.curves = p.curves;\n\t\t\t\tconst holes = isAHole.filter( h => h.isHole && h.for === p.identifier );\n\t\t\t\tholes.forEach( h => {\n\n\t\t\t\t\tconst hole = simplePaths[ h.identifier ];\n\t\t\t\t\tconst path = new Path();\n\t\t\t\t\tpath.curves = hole.curves;\n\t\t\t\t\tshape.holes.push( path );\n\n\t\t\t\t} );\n\t\t\t\tshapesToReturn.push( shape );\n\n\t\t\t}\n\n\t\t} );\n\n\t\treturn shapesToReturn;\n\n\t}\n\n\tstatic getStrokeStyle( width, color, lineJoin, lineCap, miterLimit ) {\n\n\t\t// Param width: Stroke width\n\t\t// Param color: As returned by THREE.Color.getStyle()\n\t\t// Param lineJoin: One of \"round\", \"bevel\", \"miter\" or \"miter-limit\"\n\t\t// Param lineCap: One of \"round\", \"square\" or \"butt\"\n\t\t// Param miterLimit: Maximum join length, in multiples of the \"width\" parameter (join is truncated if it exceeds that distance)\n\t\t// Returns style object\n\n\t\twidth = width !== undefined ? width : 1;\n\t\tcolor = color !== undefined ? color : '#000';\n\t\tlineJoin = lineJoin !== undefined ? lineJoin : 'miter';\n\t\tlineCap = lineCap !== undefined ? lineCap : 'butt';\n\t\tmiterLimit = miterLimit !== undefined ? miterLimit : 4;\n\n\t\treturn {\n\t\t\tstrokeColor: color,\n\t\t\tstrokeWidth: width,\n\t\t\tstrokeLineJoin: lineJoin,\n\t\t\tstrokeLineCap: lineCap,\n\t\t\tstrokeMiterLimit: miterLimit\n\t\t};\n\n\t}\n\n\tstatic pointsToStroke( points, style, arcDivisions, minDistance ) {\n\n\t\t// Generates a stroke with some witdh around the given path.\n\t\t// The path can be open or closed (last point equals to first point)\n\t\t// Param points: Array of Vector2D (the path). Minimum 2 points.\n\t\t// Param style: Object with SVG properties as returned by SVGLoader.getStrokeStyle(), or SVGLoader.parse() in the path.userData.style object\n\t\t// Params arcDivisions: Arc divisions for round joins and endcaps. (Optional)\n\t\t// Param minDistance: Points closer to this distance will be merged. (Optional)\n\t\t// Returns BufferGeometry with stroke triangles (In plane z = 0). UV coordinates are generated ('u' along path. 'v' across it, from left to right)\n\n\t\tconst vertices = [];\n\t\tconst normals = [];\n\t\tconst uvs = [];\n\n\t\tif ( SVGLoader.pointsToStrokeWithBuffers( points, style, arcDivisions, minDistance, vertices, normals, uvs ) === 0 ) {\n\n\t\t\treturn null;\n\n\t\t}\n\n\t\tconst geometry = new BufferGeometry();\n\t\tgeometry.setAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );\n\t\tgeometry.setAttribute( 'normal', new Float32BufferAttribute( normals, 3 ) );\n\t\tgeometry.setAttribute( 'uv', new Float32BufferAttribute( uvs, 2 ) );\n\n\t\treturn geometry;\n\n\t}\n\n\tstatic pointsToStrokeWithBuffers( points, style, arcDivisions, minDistance, vertices, normals, uvs, vertexOffset ) {\n\n\t\t// This function can be called to update existing arrays or buffers.\n\t\t// Accepts same parameters as pointsToStroke, plus the buffers and optional offset.\n\t\t// Param vertexOffset: Offset vertices to start writing in the buffers (3 elements/vertex for vertices and normals, and 2 elements/vertex for uvs)\n\t\t// Returns number of written vertices / normals / uvs pairs\n\t\t// if 'vertices' parameter is undefined no triangles will be generated, but the returned vertices count will still be valid (useful to preallocate the buffers)\n\t\t// 'normals' and 'uvs' buffers are optional\n\n\t\tconst tempV2_1 = new Vector2();\n\t\tconst tempV2_2 = new Vector2();\n\t\tconst tempV2_3 = new Vector2();\n\t\tconst tempV2_4 = new Vector2();\n\t\tconst tempV2_5 = new Vector2();\n\t\tconst tempV2_6 = new Vector2();\n\t\tconst tempV2_7 = new Vector2();\n\t\tconst lastPointL = new Vector2();\n\t\tconst lastPointR = new Vector2();\n\t\tconst point0L = new Vector2();\n\t\tconst point0R = new Vector2();\n\t\tconst currentPointL = new Vector2();\n\t\tconst currentPointR = new Vector2();\n\t\tconst nextPointL = new Vector2();\n\t\tconst nextPointR = new Vector2();\n\t\tconst innerPoint = new Vector2();\n\t\tconst outerPoint = new Vector2();\n\n\t\tarcDivisions = arcDivisions !== undefined ? arcDivisions : 12;\n\t\tminDistance = minDistance !== undefined ? minDistance : 0.001;\n\t\tvertexOffset = vertexOffset !== undefined ? vertexOffset : 0;\n\n\t\t// First ensure there are no duplicated points\n\t\tpoints = removeDuplicatedPoints( points );\n\n\t\tconst numPoints = points.length;\n\n\t\tif ( numPoints < 2 ) return 0;\n\n\t\tconst isClosed = points[ 0 ].equals( points[ numPoints - 1 ] );\n\n\t\tlet currentPoint;\n\t\tlet previousPoint = points[ 0 ];\n\t\tlet nextPoint;\n\n\t\tconst strokeWidth2 = style.strokeWidth / 2;\n\n\t\tconst deltaU = 1 / ( numPoints - 1 );\n\t\tlet u0 = 0, u1;\n\n\t\tlet innerSideModified;\n\t\tlet joinIsOnLeftSide;\n\t\tlet isMiter;\n\t\tlet initialJoinIsOnLeftSide = false;\n\n\t\tlet numVertices = 0;\n\t\tlet currentCoordinate = vertexOffset * 3;\n\t\tlet currentCoordinateUV = vertexOffset * 2;\n\n\t\t// Get initial left and right stroke points\n\t\tgetNormal( points[ 0 ], points[ 1 ], tempV2_1 ).multiplyScalar( strokeWidth2 );\n\t\tlastPointL.copy( points[ 0 ] ).sub( tempV2_1 );\n\t\tlastPointR.copy( points[ 0 ] ).add( tempV2_1 );\n\t\tpoint0L.copy( lastPointL );\n\t\tpoint0R.copy( lastPointR );\n\n\t\tfor ( let iPoint = 1; iPoint < numPoints; iPoint ++ ) {\n\n\t\t\tcurrentPoint = points[ iPoint ];\n\n\t\t\t// Get next point\n\t\t\tif ( iPoint === numPoints - 1 ) {\n\n\t\t\t\tif ( isClosed ) {\n\n\t\t\t\t\t// Skip duplicated initial point\n\t\t\t\t\tnextPoint = points[ 1 ];\n\n\t\t\t\t} else nextPoint = undefined;\n\n\t\t\t} else {\n\n\t\t\t\tnextPoint = points[ iPoint + 1 ];\n\n\t\t\t}\n\n\t\t\t// Normal of previous segment in tempV2_1\n\t\t\tconst normal1 = tempV2_1;\n\t\t\tgetNormal( previousPoint, currentPoint, normal1 );\n\n\t\t\ttempV2_3.copy( normal1 ).multiplyScalar( strokeWidth2 );\n\t\t\tcurrentPointL.copy( currentPoint ).sub( tempV2_3 );\n\t\t\tcurrentPointR.copy( currentPoint ).add( tempV2_3 );\n\n\t\t\tu1 = u0 + deltaU;\n\n\t\t\tinnerSideModified = false;\n\n\t\t\tif ( nextPoint !== undefined ) {\n\n\t\t\t\t// Normal of next segment in tempV2_2\n\t\t\t\tgetNormal( currentPoint, nextPoint, tempV2_2 );\n\n\t\t\t\ttempV2_3.copy( tempV2_2 ).multiplyScalar( strokeWidth2 );\n\t\t\t\tnextPointL.copy( currentPoint ).sub( tempV2_3 );\n\t\t\t\tnextPointR.copy( currentPoint ).add( tempV2_3 );\n\n\t\t\t\tjoinIsOnLeftSide = true;\n\t\t\t\ttempV2_3.subVectors( nextPoint, previousPoint );\n\t\t\t\tif ( normal1.dot( tempV2_3 ) < 0 ) {\n\n\t\t\t\t\tjoinIsOnLeftSide = false;\n\n\t\t\t\t}\n\n\t\t\t\tif ( iPoint === 1 ) initialJoinIsOnLeftSide = joinIsOnLeftSide;\n\n\t\t\t\ttempV2_3.subVectors( nextPoint, currentPoint );\n\t\t\t\ttempV2_3.normalize();\n\t\t\t\tconst dot = Math.abs( normal1.dot( tempV2_3 ) );\n\n\t\t\t\t// If path is straight, don't create join\n\t\t\t\tif ( dot > Number.EPSILON ) {\n\n\t\t\t\t\t// Compute inner and outer segment intersections\n\t\t\t\t\tconst miterSide = strokeWidth2 / dot;\n\t\t\t\t\ttempV2_3.multiplyScalar( - miterSide );\n\t\t\t\t\ttempV2_4.subVectors( currentPoint, previousPoint );\n\t\t\t\t\ttempV2_5.copy( tempV2_4 ).setLength( miterSide ).add( tempV2_3 );\n\t\t\t\t\tinnerPoint.copy( tempV2_5 ).negate();\n\t\t\t\t\tconst miterLength2 = tempV2_5.length();\n\t\t\t\t\tconst segmentLengthPrev = tempV2_4.length();\n\t\t\t\t\ttempV2_4.divideScalar( segmentLengthPrev );\n\t\t\t\t\ttempV2_6.subVectors( nextPoint, currentPoint );\n\t\t\t\t\tconst segmentLengthNext = tempV2_6.length();\n\t\t\t\t\ttempV2_6.divideScalar( segmentLengthNext );\n\t\t\t\t\t// Check that previous and next segments doesn't overlap with the innerPoint of intersection\n\t\t\t\t\tif ( tempV2_4.dot( innerPoint ) < segmentLengthPrev && tempV2_6.dot( innerPoint ) < segmentLengthNext ) {\n\n\t\t\t\t\t\tinnerSideModified = true;\n\n\t\t\t\t\t}\n\n\t\t\t\t\touterPoint.copy( tempV2_5 ).add( currentPoint );\n\t\t\t\t\tinnerPoint.add( currentPoint );\n\n\t\t\t\t\tisMiter = false;\n\n\t\t\t\t\tif ( innerSideModified ) {\n\n\t\t\t\t\t\tif ( joinIsOnLeftSide ) {\n\n\t\t\t\t\t\t\tnextPointR.copy( innerPoint );\n\t\t\t\t\t\t\tcurrentPointR.copy( innerPoint );\n\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\tnextPointL.copy( innerPoint );\n\t\t\t\t\t\t\tcurrentPointL.copy( innerPoint );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\t// The segment triangles are generated here if there was overlapping\n\n\t\t\t\t\t\tmakeSegmentTriangles();\n\n\t\t\t\t\t}\n\n\t\t\t\t\tswitch ( style.strokeLineJoin ) {\n\n\t\t\t\t\t\tcase 'bevel':\n\n\t\t\t\t\t\t\tmakeSegmentWithBevelJoin( joinIsOnLeftSide, innerSideModified, u1 );\n\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase 'round':\n\n\t\t\t\t\t\t\t// Segment triangles\n\n\t\t\t\t\t\t\tcreateSegmentTrianglesWithMiddleSection( joinIsOnLeftSide, innerSideModified );\n\n\t\t\t\t\t\t\t// Join triangles\n\n\t\t\t\t\t\t\tif ( joinIsOnLeftSide ) {\n\n\t\t\t\t\t\t\t\tmakeCircularSector( currentPoint, currentPointL, nextPointL, u1, 0 );\n\n\t\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t\tmakeCircularSector( currentPoint, nextPointR, currentPointR, u1, 1 );\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\tcase 'miter':\n\t\t\t\t\t\tcase 'miter-clip':\n\t\t\t\t\t\tdefault:\n\n\t\t\t\t\t\t\tconst miterFraction = ( strokeWidth2 * style.strokeMiterLimit ) / miterLength2;\n\n\t\t\t\t\t\t\tif ( miterFraction < 1 ) {\n\n\t\t\t\t\t\t\t\t// The join miter length exceeds the miter limit\n\n\t\t\t\t\t\t\t\tif ( style.strokeLineJoin !== 'miter-clip' ) {\n\n\t\t\t\t\t\t\t\t\tmakeSegmentWithBevelJoin( joinIsOnLeftSide, innerSideModified, u1 );\n\t\t\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t\t\t// Segment triangles\n\n\t\t\t\t\t\t\t\t\tcreateSegmentTrianglesWithMiddleSection( joinIsOnLeftSide, innerSideModified );\n\n\t\t\t\t\t\t\t\t\t// Miter-clip join triangles\n\n\t\t\t\t\t\t\t\t\tif ( joinIsOnLeftSide ) {\n\n\t\t\t\t\t\t\t\t\t\ttempV2_6.subVectors( outerPoint, currentPointL ).multiplyScalar( miterFraction ).add( currentPointL );\n\t\t\t\t\t\t\t\t\t\ttempV2_7.subVectors( outerPoint, nextPointL ).multiplyScalar( miterFraction ).add( nextPointL );\n\n\t\t\t\t\t\t\t\t\t\taddVertex( currentPointL, u1, 0 );\n\t\t\t\t\t\t\t\t\t\taddVertex( tempV2_6, u1, 0 );\n\t\t\t\t\t\t\t\t\t\taddVertex( currentPoint, u1, 0.5 );\n\n\t\t\t\t\t\t\t\t\t\taddVertex( currentPoint, u1, 0.5 );\n\t\t\t\t\t\t\t\t\t\taddVertex( tempV2_6, u1, 0 );\n\t\t\t\t\t\t\t\t\t\taddVertex( tempV2_7, u1, 0 );\n\n\t\t\t\t\t\t\t\t\t\taddVertex( currentPoint, u1, 0.5 );\n\t\t\t\t\t\t\t\t\t\taddVertex( tempV2_7, u1, 0 );\n\t\t\t\t\t\t\t\t\t\taddVertex( nextPointL, u1, 0 );\n\n\t\t\t\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t\t\t\ttempV2_6.subVectors( outerPoint, currentPointR ).multiplyScalar( miterFraction ).add( currentPointR );\n\t\t\t\t\t\t\t\t\t\ttempV2_7.subVectors( outerPoint, nextPointR ).multiplyScalar( miterFraction ).add( nextPointR );\n\n\t\t\t\t\t\t\t\t\t\taddVertex( currentPointR, u1, 1 );\n\t\t\t\t\t\t\t\t\t\taddVertex( tempV2_6, u1, 1 );\n\t\t\t\t\t\t\t\t\t\taddVertex( currentPoint, u1, 0.5 );\n\n\t\t\t\t\t\t\t\t\t\taddVertex( currentPoint, u1, 0.5 );\n\t\t\t\t\t\t\t\t\t\taddVertex( tempV2_6, u1, 1 );\n\t\t\t\t\t\t\t\t\t\taddVertex( tempV2_7, u1, 1 );\n\n\t\t\t\t\t\t\t\t\t\taddVertex( currentPoint, u1, 0.5 );\n\t\t\t\t\t\t\t\t\t\taddVertex( tempV2_7, u1, 1 );\n\t\t\t\t\t\t\t\t\t\taddVertex( nextPointR, u1, 1 );\n\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t\t// Miter join segment triangles\n\n\t\t\t\t\t\t\t\tif ( innerSideModified ) {\n\n\t\t\t\t\t\t\t\t\t// Optimized segment + join triangles\n\n\t\t\t\t\t\t\t\t\tif ( joinIsOnLeftSide ) {\n\n\t\t\t\t\t\t\t\t\t\taddVertex( lastPointR, u0, 1 );\n\t\t\t\t\t\t\t\t\t\taddVertex( lastPointL, u0, 0 );\n\t\t\t\t\t\t\t\t\t\taddVertex( outerPoint, u1, 0 );\n\n\t\t\t\t\t\t\t\t\t\taddVertex( lastPointR, u0, 1 );\n\t\t\t\t\t\t\t\t\t\taddVertex( outerPoint, u1, 0 );\n\t\t\t\t\t\t\t\t\t\taddVertex( innerPoint, u1, 1 );\n\n\t\t\t\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t\t\t\taddVertex( lastPointR, u0, 1 );\n\t\t\t\t\t\t\t\t\t\taddVertex( lastPointL, u0, 0 );\n\t\t\t\t\t\t\t\t\t\taddVertex( outerPoint, u1, 1 );\n\n\t\t\t\t\t\t\t\t\t\taddVertex( lastPointL, u0, 0 );\n\t\t\t\t\t\t\t\t\t\taddVertex( innerPoint, u1, 0 );\n\t\t\t\t\t\t\t\t\t\taddVertex( outerPoint, u1, 1 );\n\n\t\t\t\t\t\t\t\t\t}\n\n\n\t\t\t\t\t\t\t\t\tif ( joinIsOnLeftSide ) {\n\n\t\t\t\t\t\t\t\t\t\tnextPointL.copy( outerPoint );\n\n\t\t\t\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t\t\t\tnextPointR.copy( outerPoint );\n\n\t\t\t\t\t\t\t\t\t}\n\n\n\t\t\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t\t\t// Add extra miter join triangles\n\n\t\t\t\t\t\t\t\t\tif ( joinIsOnLeftSide ) {\n\n\t\t\t\t\t\t\t\t\t\taddVertex( currentPointL, u1, 0 );\n\t\t\t\t\t\t\t\t\t\taddVertex( outerPoint, u1, 0 );\n\t\t\t\t\t\t\t\t\t\taddVertex( currentPoint, u1, 0.5 );\n\n\t\t\t\t\t\t\t\t\t\taddVertex( currentPoint, u1, 0.5 );\n\t\t\t\t\t\t\t\t\t\taddVertex( outerPoint, u1, 0 );\n\t\t\t\t\t\t\t\t\t\taddVertex( nextPointL, u1, 0 );\n\n\t\t\t\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t\t\t\taddVertex( currentPointR, u1, 1 );\n\t\t\t\t\t\t\t\t\t\taddVertex( outerPoint, u1, 1 );\n\t\t\t\t\t\t\t\t\t\taddVertex( currentPoint, u1, 0.5 );\n\n\t\t\t\t\t\t\t\t\t\taddVertex( currentPoint, u1, 0.5 );\n\t\t\t\t\t\t\t\t\t\taddVertex( outerPoint, u1, 1 );\n\t\t\t\t\t\t\t\t\t\taddVertex( nextPointR, u1, 1 );\n\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\tisMiter = true;\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t}\n\n\t\t\t\t} else {\n\n\t\t\t\t\t// The segment triangles are generated here when two consecutive points are collinear\n\n\t\t\t\t\tmakeSegmentTriangles();\n\n\t\t\t\t}\n\n\t\t\t} else {\n\n\t\t\t\t// The segment triangles are generated here if it is the ending segment\n\n\t\t\t\tmakeSegmentTriangles();\n\n\t\t\t}\n\n\t\t\tif ( ! isClosed && iPoint === numPoints - 1 ) {\n\n\t\t\t\t// Start line endcap\n\t\t\t\taddCapGeometry( points[ 0 ], point0L, point0R, joinIsOnLeftSide, true, u0 );\n\n\t\t\t}\n\n\t\t\t// Increment loop variables\n\n\t\t\tu0 = u1;\n\n\t\t\tpreviousPoint = currentPoint;\n\n\t\t\tlastPointL.copy( nextPointL );\n\t\t\tlastPointR.copy( nextPointR );\n\n\t\t}\n\n\t\tif ( ! isClosed ) {\n\n\t\t\t// Ending line endcap\n\t\t\taddCapGeometry( currentPoint, currentPointL, currentPointR, joinIsOnLeftSide, false, u1 );\n\n\t\t} else if ( innerSideModified && vertices ) {\n\n\t\t\t// Modify path first segment vertices to adjust to the segments inner and outer intersections\n\n\t\t\tlet lastOuter = outerPoint;\n\t\t\tlet lastInner = innerPoint;\n\n\t\t\tif ( initialJoinIsOnLeftSide !== joinIsOnLeftSide ) {\n\n\t\t\t\tlastOuter = innerPoint;\n\t\t\t\tlastInner = outerPoint;\n\n\t\t\t}\n\n\t\t\tif ( joinIsOnLeftSide ) {\n\n\t\t\t\tif ( isMiter || initialJoinIsOnLeftSide ) {\n\n\t\t\t\t\tlastInner.toArray( vertices, 0 * 3 );\n\t\t\t\t\tlastInner.toArray( vertices, 3 * 3 );\n\n\t\t\t\t\tif ( isMiter ) {\n\n\t\t\t\t\t\tlastOuter.toArray( vertices, 1 * 3 );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t} else {\n\n\t\t\t\tif ( isMiter || ! initialJoinIsOnLeftSide ) {\n\n\t\t\t\t\tlastInner.toArray( vertices, 1 * 3 );\n\t\t\t\t\tlastInner.toArray( vertices, 3 * 3 );\n\n\t\t\t\t\tif ( isMiter ) {\n\n\t\t\t\t\t\tlastOuter.toArray( vertices, 0 * 3 );\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\treturn numVertices;\n\n\t\t// -- End of algorithm\n\n\t\t// -- Functions\n\n\t\tfunction getNormal( p1, p2, result ) {\n\n\t\t\tresult.subVectors( p2, p1 );\n\t\t\treturn result.set( - result.y, result.x ).normalize();\n\n\t\t}\n\n\t\tfunction addVertex( position, u, v ) {\n\n\t\t\tif ( vertices ) {\n\n\t\t\t\tvertices[ currentCoordinate ] = position.x;\n\t\t\t\tvertices[ currentCoordinate + 1 ] = position.y;\n\t\t\t\tvertices[ currentCoordinate + 2 ] = 0;\n\n\t\t\t\tif ( normals ) {\n\n\t\t\t\t\tnormals[ currentCoordinate ] = 0;\n\t\t\t\t\tnormals[ currentCoordinate + 1 ] = 0;\n\t\t\t\t\tnormals[ currentCoordinate + 2 ] = 1;\n\n\t\t\t\t}\n\n\t\t\t\tcurrentCoordinate += 3;\n\n\t\t\t\tif ( uvs ) {\n\n\t\t\t\t\tuvs[ currentCoordinateUV ] = u;\n\t\t\t\t\tuvs[ currentCoordinateUV + 1 ] = v;\n\n\t\t\t\t\tcurrentCoordinateUV += 2;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tnumVertices += 3;\n\n\t\t}\n\n\t\tfunction makeCircularSector( center, p1, p2, u, v ) {\n\n\t\t\t// param p1, p2: Points in the circle arc.\n\t\t\t// p1 and p2 are in clockwise direction.\n\n\t\t\ttempV2_1.copy( p1 ).sub( center ).normalize();\n\t\t\ttempV2_2.copy( p2 ).sub( center ).normalize();\n\n\t\t\tlet angle = Math.PI;\n\t\t\tconst dot = tempV2_1.dot( tempV2_2 );\n\t\t\tif ( Math.abs( dot ) < 1 ) angle = Math.abs( Math.acos( dot ) );\n\n\t\t\tangle /= arcDivisions;\n\n\t\t\ttempV2_3.copy( p1 );\n\n\t\t\tfor ( let i = 0, il = arcDivisions - 1; i < il; i ++ ) {\n\n\t\t\t\ttempV2_4.copy( tempV2_3 ).rotateAround( center, angle );\n\n\t\t\t\taddVertex( tempV2_3, u, v );\n\t\t\t\taddVertex( tempV2_4, u, v );\n\t\t\t\taddVertex( center, u, 0.5 );\n\n\t\t\t\ttempV2_3.copy( tempV2_4 );\n\n\t\t\t}\n\n\t\t\taddVertex( tempV2_4, u, v );\n\t\t\taddVertex( p2, u, v );\n\t\t\taddVertex( center, u, 0.5 );\n\n\t\t}\n\n\t\tfunction makeSegmentTriangles() {\n\n\t\t\taddVertex( lastPointR, u0, 1 );\n\t\t\taddVertex( lastPointL, u0, 0 );\n\t\t\taddVertex( currentPointL, u1, 0 );\n\n\t\t\taddVertex( lastPointR, u0, 1 );\n\t\t\taddVertex( currentPointL, u1, 1 );\n\t\t\taddVertex( currentPointR, u1, 0 );\n\n\t\t}\n\n\t\tfunction makeSegmentWithBevelJoin( joinIsOnLeftSide, innerSideModified, u ) {\n\n\t\t\tif ( innerSideModified ) {\n\n\t\t\t\t// Optimized segment + bevel triangles\n\n\t\t\t\tif ( joinIsOnLeftSide ) {\n\n\t\t\t\t\t// Path segments triangles\n\n\t\t\t\t\taddVertex( lastPointR, u0, 1 );\n\t\t\t\t\taddVertex( lastPointL, u0, 0 );\n\t\t\t\t\taddVertex( currentPointL, u1, 0 );\n\n\t\t\t\t\taddVertex( lastPointR, u0, 1 );\n\t\t\t\t\taddVertex( currentPointL, u1, 0 );\n\t\t\t\t\taddVertex( innerPoint, u1, 1 );\n\n\t\t\t\t\t// Bevel join triangle\n\n\t\t\t\t\taddVertex( currentPointL, u, 0 );\n\t\t\t\t\taddVertex( nextPointL, u, 0 );\n\t\t\t\t\taddVertex( innerPoint, u, 0.5 );\n\n\t\t\t\t} else {\n\n\t\t\t\t\t// Path segments triangles\n\n\t\t\t\t\taddVertex( lastPointR, u0, 1 );\n\t\t\t\t\taddVertex( lastPointL, u0, 0 );\n\t\t\t\t\taddVertex( currentPointR, u1, 1 );\n\n\t\t\t\t\taddVertex( lastPointL, u0, 0 );\n\t\t\t\t\taddVertex( innerPoint, u1, 0 );\n\t\t\t\t\taddVertex( currentPointR, u1, 1 );\n\n\t\t\t\t\t// Bevel join triangle\n\n\t\t\t\t\taddVertex( currentPointR, u, 1 );\n\t\t\t\t\taddVertex( nextPointR, u, 0 );\n\t\t\t\t\taddVertex( innerPoint, u, 0.5 );\n\n\t\t\t\t}\n\n\t\t\t} else {\n\n\t\t\t\t// Bevel join triangle. The segment triangles are done in the main loop\n\n\t\t\t\tif ( joinIsOnLeftSide ) {\n\n\t\t\t\t\taddVertex( currentPointL, u, 0 );\n\t\t\t\t\taddVertex( nextPointL, u, 0 );\n\t\t\t\t\taddVertex( currentPoint, u, 0.5 );\n\n\t\t\t\t} else {\n\n\t\t\t\t\taddVertex( currentPointR, u, 1 );\n\t\t\t\t\taddVertex( nextPointR, u, 0 );\n\t\t\t\t\taddVertex( currentPoint, u, 0.5 );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tfunction createSegmentTrianglesWithMiddleSection( joinIsOnLeftSide, innerSideModified ) {\n\n\t\t\tif ( innerSideModified ) {\n\n\t\t\t\tif ( joinIsOnLeftSide ) {\n\n\t\t\t\t\taddVertex( lastPointR, u0, 1 );\n\t\t\t\t\taddVertex( lastPointL, u0, 0 );\n\t\t\t\t\taddVertex( currentPointL, u1, 0 );\n\n\t\t\t\t\taddVertex( lastPointR, u0, 1 );\n\t\t\t\t\taddVertex( currentPointL, u1, 0 );\n\t\t\t\t\taddVertex( innerPoint, u1, 1 );\n\n\t\t\t\t\taddVertex( currentPointL, u0, 0 );\n\t\t\t\t\taddVertex( currentPoint, u1, 0.5 );\n\t\t\t\t\taddVertex( innerPoint, u1, 1 );\n\n\t\t\t\t\taddVertex( currentPoint, u1, 0.5 );\n\t\t\t\t\taddVertex( nextPointL, u0, 0 );\n\t\t\t\t\taddVertex( innerPoint, u1, 1 );\n\n\t\t\t\t} else {\n\n\t\t\t\t\taddVertex( lastPointR, u0, 1 );\n\t\t\t\t\taddVertex( lastPointL, u0, 0 );\n\t\t\t\t\taddVertex( currentPointR, u1, 1 );\n\n\t\t\t\t\taddVertex( lastPointL, u0, 0 );\n\t\t\t\t\taddVertex( innerPoint, u1, 0 );\n\t\t\t\t\taddVertex( currentPointR, u1, 1 );\n\n\t\t\t\t\taddVertex( currentPointR, u0, 1 );\n\t\t\t\t\taddVertex( innerPoint, u1, 0 );\n\t\t\t\t\taddVertex( currentPoint, u1, 0.5 );\n\n\t\t\t\t\taddVertex( currentPoint, u1, 0.5 );\n\t\t\t\t\taddVertex( innerPoint, u1, 0 );\n\t\t\t\t\taddVertex( nextPointR, u0, 1 );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tfunction addCapGeometry( center, p1, p2, joinIsOnLeftSide, start, u ) {\n\n\t\t\t// param center: End point of the path\n\t\t\t// param p1, p2: Left and right cap points\n\n\t\t\tswitch ( style.strokeLineCap ) {\n\n\t\t\t\tcase 'round':\n\n\t\t\t\t\tif ( start ) {\n\n\t\t\t\t\t\tmakeCircularSector( center, p2, p1, u, 0.5 );\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\tmakeCircularSector( center, p1, p2, u, 0.5 );\n\n\t\t\t\t\t}\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'square':\n\n\t\t\t\t\tif ( start ) {\n\n\t\t\t\t\t\ttempV2_1.subVectors( p1, center );\n\t\t\t\t\t\ttempV2_2.set( tempV2_1.y, - tempV2_1.x );\n\n\t\t\t\t\t\ttempV2_3.addVectors( tempV2_1, tempV2_2 ).add( center );\n\t\t\t\t\t\ttempV2_4.subVectors( tempV2_2, tempV2_1 ).add( center );\n\n\t\t\t\t\t\t// Modify already existing vertices\n\t\t\t\t\t\tif ( joinIsOnLeftSide ) {\n\n\t\t\t\t\t\t\ttempV2_3.toArray( vertices, 1 * 3 );\n\t\t\t\t\t\t\ttempV2_4.toArray( vertices, 0 * 3 );\n\t\t\t\t\t\t\ttempV2_4.toArray( vertices, 3 * 3 );\n\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\ttempV2_3.toArray( vertices, 1 * 3 );\n\t\t\t\t\t\t\ttempV2_3.toArray( vertices, 3 * 3 );\n\t\t\t\t\t\t\ttempV2_4.toArray( vertices, 0 * 3 );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t} else {\n\n\t\t\t\t\t\ttempV2_1.subVectors( p2, center );\n\t\t\t\t\t\ttempV2_2.set( tempV2_1.y, - tempV2_1.x );\n\n\t\t\t\t\t\ttempV2_3.addVectors( tempV2_1, tempV2_2 ).add( center );\n\t\t\t\t\t\ttempV2_4.subVectors( tempV2_2, tempV2_1 ).add( center );\n\n\t\t\t\t\t\tconst vl = vertices.length;\n\n\t\t\t\t\t\t// Modify already existing vertices\n\t\t\t\t\t\tif ( joinIsOnLeftSide ) {\n\n\t\t\t\t\t\t\ttempV2_3.toArray( vertices, vl - 1 * 3 );\n\t\t\t\t\t\t\ttempV2_4.toArray( vertices, vl - 2 * 3 );\n\t\t\t\t\t\t\ttempV2_4.toArray( vertices, vl - 4 * 3 );\n\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\ttempV2_3.toArray( vertices, vl - 2 * 3 );\n\t\t\t\t\t\t\ttempV2_4.toArray( vertices, vl - 1 * 3 );\n\t\t\t\t\t\t\ttempV2_4.toArray( vertices, vl - 4 * 3 );\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase 'butt':\n\t\t\t\tdefault:\n\n\t\t\t\t\t// Nothing to do here\n\t\t\t\t\tbreak;\n\n\t\t\t}\n\n\t\t}\n\n\t\tfunction removeDuplicatedPoints( points ) {\n\n\t\t\t// Creates a new array if necessary with duplicated points removed.\n\t\t\t// This does not remove duplicated initial and ending points of a closed path.\n\n\t\t\tlet dupPoints = false;\n\t\t\tfor ( let i = 1, n = points.length - 1; i < n; i ++ ) {\n\n\t\t\t\tif ( points[ i ].distanceTo( points[ i + 1 ] ) < minDistance ) {\n\n\t\t\t\t\tdupPoints = true;\n\t\t\t\t\tbreak;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tif ( ! dupPoints ) return points;\n\n\t\t\tconst newPoints = [];\n\t\t\tnewPoints.push( points[ 0 ] );\n\n\t\t\tfor ( let i = 1, n = points.length - 1; i < n; i ++ ) {\n\n\t\t\t\tif ( points[ i ].distanceTo( points[ i + 1 ] ) >= minDistance ) {\n\n\t\t\t\t\tnewPoints.push( points[ i ] );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tnewPoints.push( points[ points.length - 1 ] );\n\n\t\t\treturn newPoints;\n\n\t\t}\n\n\t}\n\n\n}\n\nexport { SVGLoader };\n"],"names":["SVGLoader","constructor","manager","defaultDPI","defaultUnit","load","url","onLoad","onProgress","onError","scope","loader","setPath","path","setRequestHeader","requestHeader","setWithCredentials","withCredentials","text","parse","e","console","error","itemError","parseArcCommand","rx","ry","x_axis_rotation","large_arc_flag","sweep_flag","start","end","lineTo","x","y","Math","PI","abs","dx2","dy2","x1p","cos","sin","y1p","rxs","rys","x1ps","y1ps","cr","s","sqrt","dq","q","max","cxp","cyp","cx","cy","theta","svgAngle","delta","currentPath","absellipse","ux","uy","vx","vy","len","ang","acos","min","dot","parseStyle","node","style","Object","assign","stylesheetStyles","hasAttribute","classSelectors","getAttribute","split","filter","Boolean","map","i","trim","length","stylesheets","addStyle","svgName","jsName","adjustFunction","undefined","v","startsWith","warn","clamp","parseFloatWithUnits","positive","parseFloats","input","flags","stride","current","RE","WHITESPACE","DIGIT","SIGN","POINT","COMMA","EXP","FLAGS","state","seenComma","number","exponent","result","throwSyntaxError","partial","newNumber","push","Number","pow","Array","isArray","includes","test","units","unitConversion","string","scale","theUnit","String","n","u","endsWith","substring","parseFloat","isTransformFlipped","m","te","elements","getTransformScaleX","getTransformScaleY","paths","transformStack","tempTransform0","tempTransform1","tempTransform2","tempTransform3","tempV2","tempV3","currentTransform","xml","DOMParser","parseFromString","parseNode","nodeType","transform","getNodeTransform","nodeName","parseNodeTransform","tx","ty","translate","transformsTexts","tIndex","transformText","openParPos","indexOf","closeParPos","transformType","slice","array","identity","angle","makeTranslation","makeRotation","multiplyMatrices","scaleX","scaleY","set","tan","premultiply","copy","isDefsNode","parseCSSStylesheet","sheet","cssRules","stylesheet","type","selectorList","selectorText","j","definitions","fromEntries","entries","parsePathNode","point","control","firstPoint","isFirstPoint","doSetFirstPoint","commands","d","match","l","a","numbers","command","charAt","data","jl","moveTo","bezierCurveTo","b","quadraticCurveTo","clone","autoClose","curves","currentPoint","parseRectNode","w","h","parsePolygonNode","index","replace","parsePolylineNode","parseCircleNode","r","subpath","absarc","subPaths","parseEllipseNode","parseLineNode","x1","y1","x2","y2","usedNodeId","href","getAttributeNS","usedNode","viewportElement","getElementById","fill","color","setStyle","transformPath","transfVec2","v2","applyMatrix3","subPath","curve","isLineCurve","v1","isCubicBezierCurve","v0","v3","isQuadraticBezierCurve","isEllipseCurve","aX","aY","isTransformSkewed","basisDot","sx","EPSILON","transfEllipseGeneric","xRadius","yRadius","cosTheta","aRotation","sinTheta","f1","f2","mF","mFInv","invert","mQe","mQ","transpose","multiply","ed","eigenDecomposition","A","B","C","rt1","rt2","cs","sn","t","sm","df","rt","rt1sqrt","rt2sqrt","atan2","aEndAngle","aStartAngle","mDsqrt","mRT","mDRF","transformAngle","phi","cosR","sinR","aClockwise","transfEllipseNoSkew","sy","userData","childNodes","pop","documentElement","fillOpacity","strokeOpacity","strokeWidth","strokeLineJoin","strokeLineCap","strokeMiterLimit","createShapes","shapePath","IntersectionLocationType","ORIGIN","DESTINATION","BETWEEN","LEFT","RIGHT","BEHIND","BEYOND","classifyResult","loc","classifyPoint","p","edgeStart","edgeEnd","ax","ay","bx","by","sa","scanlineMinX","scanlineMaxX","simplePaths","points","getPoints","maxY","minY","maxX","minX","isCW","isClockWise","identifier","boundingBox","sp","isAHole","isHoleTo","simplePath","allPaths","_fillRule","centerBoundingBox","getCenter","scanlineIntersections","getScanlineIntersections","scanline","center","allIntersections","forEach","containsPoint","intersections","path1","path2","intersectionsRaw","path1EdgeStart","path1EdgeEnd","index2","intersection","findEdgeIntersection","a0","a1","b0","b1","x3","x4","y3","y4","nom1","denom","t1","t2","nom2","toPrecision","find","sort","i1","i2","baseIntersections","otherIntersections","firstXOfPath","stack","isHole","isHoleFor","for","lastCWValue","fillRule","shapesToReturn","amIAHole","shape","holes","hole","getStrokeStyle","width","lineJoin","lineCap","miterLimit","strokeColor","pointsToStroke","arcDivisions","minDistance","vertices","normals","uvs","pointsToStrokeWithBuffers","geometry","setAttribute","vertexOffset","nextPoint","innerSideModified","joinIsOnLeftSide","isMiter","tempV2_1","tempV2_2","tempV2_3","tempV2_4","tempV2_5","tempV2_6","tempV2_7","lastPointL","lastPointR","point0L","point0R","currentPointL","currentPointR","nextPointL","nextPointR","innerPoint","outerPoint","numPoints","removeDuplicatedPoints","dupPoints","distanceTo","newPoints","isClosed","equals","previousPoint","strokeWidth2","deltaU","u0","u1","initialJoinIsOnLeftSide","numVertices","currentCoordinate","currentCoordinateUV","getNormal","multiplyScalar","sub","add","iPoint","subVectors","normal1","normalize","miterSide","setLength","negate","miterLength2","segmentLengthPrev","divideScalar","segmentLengthNext","makeSegmentTriangles","makeSegmentWithBevelJoin","createSegmentTrianglesWithMiddleSection","makeCircularSector","miterFraction","addVertex","addCapGeometry","lastOuter","lastInner","toArray","p1","p2","position","il","rotateAround","addVectors","vl"],"sourceRoot":""}