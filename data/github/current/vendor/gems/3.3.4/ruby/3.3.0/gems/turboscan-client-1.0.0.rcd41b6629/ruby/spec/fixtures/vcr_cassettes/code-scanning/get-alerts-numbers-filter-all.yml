# generated by turbocassette ts/cassettes/sessions/get_alerts_numbers_filter_test.go
---
http_interactions:
  - request:
      method: post
      uri: http://localhost:8888/twirp/github.turboscan.Results/GetAlerts
      body:
        encoding: UTF-8
        string: |-
          {
            "numbers": [
              1,
              2,
              3,
              4,
              5,
              6
            ],
            "repositoryId": "351",
            "state": "ALERT_STATE_FILTER_ALL"
          }
      headers:
        Content-Type:
          - application/json
    response:
      status:
        code: 200
        message: null
      headers:
        Content-Length:
          - "41665"
        Content-Type:
          - application/json
      body:
        encoding: UTF-8
        string: |-
          {
            "analysisExists": true,
            "nextCursor": "",
            "openCount": "3",
            "prevCursor": "",
            "resolvedCount": "3",
            "results": [
              {
                "createdAt": "0001-01-01T00:00:00Z",
                "fixedAt": null,
                "guid": "11111111-2222-3333-4444-000000000000",
                "isFixed": false,
                "messageMarkdown": "",
                "messageText": "JNDI lookup might include name from [this user input](1).",
                "mostRecentInstance": {
                  "analysisKey": {
                    "analysisKey": ".github/workflows/w1.yml:java",
                    "category": ".github/workflows/w1.yml:java",
                    "commitOid": "b000000000000000000000000000000000000000",
                    "environment": "{}",
                    "id": "1",
                    "tool": "CodeQL"
                  },
                  "classification": [],
                  "commitOid": "b000000000000000000000000000000000000000",
                  "createdAt": "0001-01-01T00:00:00Z",
                  "hasFileClassification": false,
                  "isFixed": false,
                  "isOutdated": false,
                  "location": {
                    "endColumn": 36,
                    "endLine": 29,
                    "filePath": "app3/src/main/java/org/example/app3/App3Controller.java",
                    "startColumn": 33,
                    "startLine": 29
                  },
                  "messageText": "JNDI lookup might include name from [this user input](1).",
                  "refNameBytes": "cmVmcy9oZWFkcy9tYWlu"
                },
                "number": 1,
                "resolution": "WONT_FIX",
                "resolutionNote": "",
                "resolvedAt": "0001-01-01T00:00:00Z",
                "resolverId": 1,
                "rule": {
                  "fullDescription": "Performing a JNDI lookup with a user-controlled name can lead to the download of an untrusted object and to execution of arbitrary code.",
                  "help": "# JNDI lookup with user-controlled name\nThe Java Naming and Directory Interface (JNDI) is a Java API for a directory service that allows Java software clients to discover and look up data and resources (in the form of Java objects) via a name. If the name being used to look up the data is controlled by the user, it can point to a malicious server, which can return an arbitrary object. In the worst case, this can allow remote code execution.\n\n\n## Recommendation\nThe general recommendation is to avoid passing untrusted data to the `InitialContext.lookup ` method. If the name being used to look up the object must be provided by the user, make sure that it's not in the form of an absolute URL or that it's the URL pointing to a trusted server.\n\n\n## Example\nIn the following examples, the code accepts a name from the user, which it uses to look up an object.\n\nIn the first example, the user provided name is used to look up an object.\n\nThe second example validates the name before using it to look up an object.\n\n\n```java\nimport javax.naming.Context;\nimport javax.naming.InitialContext;\n\npublic void jndiLookup(HttpServletRequest request) throws NamingException {\n  String name = request.getParameter(\"name\");\n\n  Hashtable\u003cString, String\u003e env = new Hashtable\u003cString, String\u003e();\n  env.put(Context.INITIAL_CONTEXT_FACTORY, \"com.sun.jndi.rmi.registry.RegistryContextFactory\");\n  env.put(Context.PROVIDER_URL, \"rmi://trusted-server:1099\");\n  InitialContext ctx = new InitialContext(env);\n\n  // BAD: User input used in lookup\n  ctx.lookup(name);\n\n  // GOOD: The name is validated before being used in lookup\n  if (isValid(name)) {\n    ctx.lookup(name);\n  } else {\n    // Reject the request\n  }\n}\n```\n\n## References\n* Oracle: [Java Naming and Directory Interface (JNDI)](https://docs.oracle.com/javase/8/docs/technotes/guides/jndi/).\n* Black Hat materials: [A Journey from JNDI/LDAP Manipulation to Remote Code Execution Dream Land](https://www.blackhat.com/docs/us-16/materials/us-16-Munoz-A-Journey-From-JNDI-LDAP-Manipulation-To-RCE-wp.pdf).\n* Veracode: [Exploiting JNDI Injections in Java](https://www.veracode.com/blog/research/exploiting-jndi-injections-java).\n* Common Weakness Enumeration: [CWE-74](https://cwe.mitre.org/data/definitions/74.html).\n",
                  "helpUri": "",
                  "name": "java/jndi-injection",
                  "queryUri": "https://github.com/github/codeql/blob/0000000000000000000000000000000000000000/java/ql/src/Security/CWE/CWE-074/JndiInjection.ql",
                  "sarifIdentifier": "java/jndi-injection",
                  "severity": "ERROR",
                  "shortDescription": "JNDI lookup with user-controlled name",
                  "tags": [
                    "external/cwe/cwe-074",
                    "security"
                  ]
                },
                "ruleSeverity": "ERROR",
                "securitySeverity": "CRITICAL",
                "tool": {
                  "alertCount": "0",
                  "guid": "",
                  "name": "CodeQL",
                  "version": ""
                },
                "updatedAt": "0001-01-01T00:00:00Z"
              },
              {
                "createdAt": "0001-01-01T00:00:00Z",
                "fixedAt": "0001-01-01T00:00:00Z",
                "guid": "11111111-2222-3333-4444-000000000000",
                "isFixed": true,
                "messageMarkdown": "",
                "messageText": "Cross-site scripting vulnerability due to [user-provided value](1).",
                "mostRecentInstance": {
                  "analysisKey": {
                    "analysisKey": ".github/workflows/w1.yml:javascript",
                    "category": ".github/workflows/w1.yml:javascript",
                    "commitOid": "b000000000000000000000000000000000000000",
                    "environment": "{}",
                    "id": "3",
                    "tool": "CodeQL"
                  },
                  "classification": [],
                  "commitOid": "b000000000000000000000000000000000000000",
                  "createdAt": "0001-01-01T00:00:00Z",
                  "hasFileClassification": false,
                  "isFixed": true,
                  "isOutdated": false,
                  "location": {
                    "endColumn": 38,
                    "endLine": 5,
                    "filePath": "app2/src/main/resources/app.js",
                    "startColumn": 16,
                    "startLine": 5
                  },
                  "messageText": "Cross-site scripting vulnerability due to [user-provided value](1).",
                  "refNameBytes": "cmVmcy9oZWFkcy9tYWlu"
                },
                "number": 6,
                "resolution": "NO_RESOLUTION",
                "resolutionNote": "",
                "resolvedAt": null,
                "resolverId": 0,
                "rule": {
                  "fullDescription": "Writing user input directly to the DOM allows for a cross-site scripting vulnerability.",
                  "help": "# Client-side cross-site scripting\nDirectly writing user input (for example, a URL query parameter) to a webpage without properly sanitizing the input first, allows for a cross-site scripting vulnerability.\n\nThis kind of vulnerability is also called *DOM-based* cross-site scripting, to distinguish it from other types of cross-site scripting.\n\n\n## Recommendation\nTo guard against cross-site scripting, consider using contextual output encoding/escaping before writing user input to the page, or one of the other solutions that are mentioned in the references.\n\n\n## Example\nThe following example shows part of the page URL being written directly to the document, leaving the website vulnerable to cross-site scripting.\n\n\n```javascript\nfunction setLanguageOptions() {\n    var href = document.location.href,\n        deflt = href.substring(href.indexOf(\"default=\")+8);\n    document.write(\"\u003cOPTION value=1\u003e\"+deflt+\"\u003c/OPTION\u003e\");\n    document.write(\"\u003cOPTION value=2\u003eEnglish\u003c/OPTION\u003e\");\n}\n\n```\n\n## References\n* OWASP: [DOM based XSS Prevention Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/DOM_based_XSS_Prevention_Cheat_Sheet.html).\n* OWASP: [XSS (Cross Site Scripting) Prevention Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Cross_Site_Scripting_Prevention_Cheat_Sheet.html).\n* OWASP [DOM Based XSS](https://www.owasp.org/index.php/DOM_Based_XSS).\n* OWASP [Types of Cross-Site Scripting](https://www.owasp.org/index.php/Types_of_Cross-Site_Scripting).\n* Wikipedia: [Cross-site scripting](http://en.wikipedia.org/wiki/Cross-site_scripting).\n* Common Weakness Enumeration: [CWE-79](https://cwe.mitre.org/data/definitions/79.html).\n* Common Weakness Enumeration: [CWE-116](https://cwe.mitre.org/data/definitions/116.html).\n",
                  "helpUri": "",
                  "name": "js/xss",
                  "queryUri": "https://github.com/github/codeql/blob/0000000000000000000000000000000000000000/javascript/ql/src/Security/CWE-079/Xss.ql",
                  "sarifIdentifier": "js/xss",
                  "severity": "ERROR",
                  "shortDescription": "Client-side cross-site scripting",
                  "tags": [
                    "external/cwe/cwe-079",
                    "external/cwe/cwe-116",
                    "security"
                  ]
                },
                "ruleSeverity": "ERROR",
                "securitySeverity": "HIGH",
                "tool": {
                  "alertCount": "0",
                  "guid": "",
                  "name": "CodeQL",
                  "version": "1.0.0"
                },
                "updatedAt": "0001-01-01T00:00:00Z"
              },
              {
                "createdAt": "0001-01-01T00:00:00Z",
                "fixedAt": "0001-01-01T00:00:00Z",
                "guid": "11111111-2222-3333-4444-000000000000",
                "isFixed": true,
                "messageMarkdown": "",
                "messageText": "Cross-site scripting vulnerability due to [user-provided value](1).",
                "mostRecentInstance": {
                  "analysisKey": {
                    "analysisKey": ".github/workflows/w1.yml:javascript",
                    "category": ".github/workflows/w1.yml:javascript",
                    "commitOid": "b000000000000000000000000000000000000000",
                    "environment": "{}",
                    "id": "3",
                    "tool": "CodeQL"
                  },
                  "classification": [],
                  "commitOid": "b000000000000000000000000000000000000000",
                  "createdAt": "0001-01-01T00:00:00Z",
                  "hasFileClassification": false,
                  "isFixed": true,
                  "isOutdated": false,
                  "location": {
                    "endColumn": 38,
                    "endLine": 1,
                    "filePath": "app1/src/main/resources/main.js",
                    "startColumn": 16,
                    "startLine": 1
                  },
                  "messageText": "Cross-site scripting vulnerability due to [user-provided value](1).",
                  "refNameBytes": "cmVmcy9oZWFkcy9tYWlu"
                },
                "number": 5,
                "resolution": "NO_RESOLUTION",
                "resolutionNote": "",
                "resolvedAt": null,
                "resolverId": 0,
                "rule": {
                  "fullDescription": "Writing user input directly to the DOM allows for a cross-site scripting vulnerability.",
                  "help": "# Client-side cross-site scripting\nDirectly writing user input (for example, a URL query parameter) to a webpage without properly sanitizing the input first, allows for a cross-site scripting vulnerability.\n\nThis kind of vulnerability is also called *DOM-based* cross-site scripting, to distinguish it from other types of cross-site scripting.\n\n\n## Recommendation\nTo guard against cross-site scripting, consider using contextual output encoding/escaping before writing user input to the page, or one of the other solutions that are mentioned in the references.\n\n\n## Example\nThe following example shows part of the page URL being written directly to the document, leaving the website vulnerable to cross-site scripting.\n\n\n```javascript\nfunction setLanguageOptions() {\n    var href = document.location.href,\n        deflt = href.substring(href.indexOf(\"default=\")+8);\n    document.write(\"\u003cOPTION value=1\u003e\"+deflt+\"\u003c/OPTION\u003e\");\n    document.write(\"\u003cOPTION value=2\u003eEnglish\u003c/OPTION\u003e\");\n}\n\n```\n\n## References\n* OWASP: [DOM based XSS Prevention Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/DOM_based_XSS_Prevention_Cheat_Sheet.html).\n* OWASP: [XSS (Cross Site Scripting) Prevention Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Cross_Site_Scripting_Prevention_Cheat_Sheet.html).\n* OWASP [DOM Based XSS](https://www.owasp.org/index.php/DOM_Based_XSS).\n* OWASP [Types of Cross-Site Scripting](https://www.owasp.org/index.php/Types_of_Cross-Site_Scripting).\n* Wikipedia: [Cross-site scripting](http://en.wikipedia.org/wiki/Cross-site_scripting).\n* Common Weakness Enumeration: [CWE-79](https://cwe.mitre.org/data/definitions/79.html).\n* Common Weakness Enumeration: [CWE-116](https://cwe.mitre.org/data/definitions/116.html).\n",
                  "helpUri": "",
                  "name": "js/xss",
                  "queryUri": "https://github.com/github/codeql/blob/0000000000000000000000000000000000000000/javascript/ql/src/Security/CWE-079/Xss.ql",
                  "sarifIdentifier": "js/xss",
                  "severity": "ERROR",
                  "shortDescription": "Client-side cross-site scripting",
                  "tags": [
                    "external/cwe/cwe-079",
                    "external/cwe/cwe-116",
                    "security"
                  ]
                },
                "ruleSeverity": "ERROR",
                "securitySeverity": "HIGH",
                "tool": {
                  "alertCount": "0",
                  "guid": "",
                  "name": "CodeQL",
                  "version": "1.0.0"
                },
                "updatedAt": "0001-01-01T00:00:00Z"
              },
              {
                "createdAt": "0001-01-01T00:00:00Z",
                "fixedAt": null,
                "guid": "11111111-2222-3333-4444-000000000000",
                "isFixed": false,
                "messageMarkdown": "",
                "messageText": "This query depends on a [user-provided value](1).",
                "mostRecentInstance": {
                  "analysisKey": {
                    "analysisKey": ".github/workflows/w1.yml:java",
                    "category": ".github/workflows/w1.yml:java",
                    "commitOid": "b000000000000000000000000000000000000000",
                    "environment": "{}",
                    "id": "1",
                    "tool": "CodeQL"
                  },
                  "classification": [],
                  "commitOid": "b000000000000000000000000000000000000000",
                  "createdAt": "0001-01-01T00:00:00Z",
                  "hasFileClassification": false,
                  "isFixed": false,
                  "isOutdated": false,
                  "location": {
                    "endColumn": 57,
                    "endLine": 19,
                    "filePath": "app3/src/main/java/org/example/app3/App3Controller.java",
                    "startColumn": 30,
                    "startLine": 19
                  },
                  "messageText": "This query depends on a [user-provided value](1).",
                  "refNameBytes": "cmVmcy9oZWFkcy9tYWlu"
                },
                "number": 4,
                "resolution": "NO_RESOLUTION",
                "resolutionNote": "",
                "resolvedAt": null,
                "resolverId": 0,
                "rule": {
                  "fullDescription": "Building a SQL or Java Persistence query from user-controlled sources is vulnerable to insertion of malicious code by the user.",
                  "help": "# Query built from user-controlled sources\nIf a database query is built using string concatenation, and the components of the concatenation include user input, a user is likely to be able to run malicious database queries. This applies to various database query languages, including SQL and the Java Persistence Query Language.\n\n\n## Recommendation\nUsually, it is better to use a SQL prepared statement than to build a complete SQL query with string concatenation. A prepared statement can include a wildcard, written as a question mark (?), for each part of the SQL query that is expected to be filled in by a different value each time it is run. When the query is later executed, a value must be supplied for each wildcard in the query.\n\nIn the Java Persistence Query Language, it is better to use queries with parameters than to build a complete query with string concatenation. A Java Persistence query can include a parameter placeholder for each part of the query that is expected to be filled in by a different value when run. A parameter placeholder may be indicated by a colon (:) followed by a parameter name, or by a question mark (?) followed by an integer position. When the query is later executed, a value must be supplied for each parameter in the query, using the `setParameter` method. Specifying the query using the `@NamedQuery` annotation introduces an additional level of safety: the query must be a constant string literal, preventing construction by string concatenation, and the only way to fill in values for parts of the query is by setting positional parameters.\n\nIt is good practice to use prepared statements (in SQL) or query parameters (in the Java Persistence Query Language) for supplying parameter values to a query, whether or not any of the parameters are directly traceable to user input. Doing so avoids any need to worry about quoting and escaping.\n\n\n## Example\nIn the following example, the code runs a simple SQL query in two different ways.\n\nThe first way involves building a query, `query1`, by concatenating an environment variable with some string literals. The environment variable can include special characters, so this code allows for SQL injection attacks.\n\nThe second way, which shows good practice, involves building a query, `query2`, with a single string literal that includes a wildcard (`?`). The wildcard is then given a value by calling `setString`. This version is immune to injection attacks, because any special characters in the environment variable are not given any special treatment.\n\n\n```java\n{\n    // BAD: the category might have SQL special characters in it\n    String category = System.getenv(\"ITEM_CATEGORY\");\n    Statement statement = connection.createStatement();\n    String query1 = \"SELECT ITEM,PRICE FROM PRODUCT WHERE ITEM_CATEGORY='\"\n        + category + \"' ORDER BY PRICE\";\n    ResultSet results = statement.executeQuery(query1);\n}\n\n{\n    // GOOD: use a prepared query\n    String category = System.getenv(\"ITEM_CATEGORY\");\n    String query2 = \"SELECT ITEM,PRICE FROM PRODUCT WHERE ITEM_CATEGORY=? ORDER BY PRICE\";\n    PreparedStatement statement = connection.prepareStatement(query2);\n    statement.setString(1, category);\n    ResultSet results = statement.executeQuery();\n}\n```\n\n## Example\nThe following code shows several different ways to run a Java Persistence query.\n\nThe first example involves building a query, `query1`, by concatenating an environment variable with some string literals. Just like the SQL example, the environment variable can include special characters, so this code allows for Java Persistence query injection attacks.\n\nThe remaining examples demonstrate different methods for safely building a Java Persistence query with user-supplied values:\n\n1. `query2` uses a single string literal that includes a placeholder for a parameter, indicated by a colon (`:`) and parameter name (`category`).\n1. `query3` uses a single string literal that includes a placeholder for a parameter, indicated by a question mark (`?`) and position number (`1`).\n1. `namedQuery1` is defined using the `@NamedQuery` annotation, whose `query` attribute is a string literal that includes a placeholder for a parameter, indicated by a colon (`:`) and parameter name (`category`).\n1. `namedQuery2` is defined using the `@NamedQuery` annotation, whose `query` attribute includes a placeholder for a parameter, indicated by a question mark (`?`) and position number (`1`).\nThe parameter is then given a value by calling `setParameter`. These versions are immune to injection attacks, because any special characters in the environment variable or user-supplied value are not given any special treatment.\n\n\n```java\n{\n    // BAD: the category might have Java Persistence Query Language special characters in it\n    String category = System.getenv(\"ITEM_CATEGORY\");\n    Statement statement = connection.createStatement();\n    String query1 = \"SELECT p FROM Product p WHERE p.category LIKE '\"\n        + category + \"' ORDER BY p.price\";\n    Query q = entityManager.createQuery(query1);\n}\n\n{\n    // GOOD: use a named parameter and set its value\n    String category = System.getenv(\"ITEM_CATEGORY\");\n    String query2 = \"SELECT p FROM Product p WHERE p.category LIKE :category ORDER BY p.price\"\n    Query q = entityManager.createQuery(query2);\n    q.setParameter(\"category\", category);\n}\n\n{\n    // GOOD: use a positional parameter and set its value\n    String category = System.getenv(\"ITEM_CATEGORY\");\n    String query3 = \"SELECT p FROM Product p WHERE p.category LIKE ?1 ORDER BY p.price\"\n    Query q = entityManager.createQuery(query3);\n    q.setParameter(1, category);\n}\n\n{\n    // GOOD: use a named query with a named parameter and set its value\n    @NamedQuery(\n            name=\"lookupByCategory\",\n            query=\"SELECT p FROM Product p WHERE p.category LIKE :category ORDER BY p.price\")\n    private static class NQ {}\n    ...\n    String category = System.getenv(\"ITEM_CATEGORY\");\n    Query namedQuery1 = entityManager.createNamedQuery(\"lookupByCategory\");\n    namedQuery1.setParameter(\"category\", category);\n}\n\n{\n    // GOOD: use a named query with a positional parameter and set its value\n    @NamedQuery(\n            name=\"lookupByCategory\",\n            query=\"SELECT p FROM Product p WHERE p.category LIKE ?1 ORDER BY p.price\")\n    private static class NQ {}\n    ...\n    String category = System.getenv(\"ITEM_CATEGORY\");\n    Query namedQuery2 = entityManager.createNamedQuery(\"lookupByCategory\");\n    namedQuery2.setParameter(1, category);\n}\n```\n\n## References\n* OWASP: [SQL Injection Prevention Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/SQL_Injection_Prevention_Cheat_Sheet.html).\n* SEI CERT Oracle Coding Standard for Java: [IDS00-J. Prevent SQL injection](https://wiki.sei.cmu.edu/confluence/display/java/IDS00-J.+Prevent+SQL+injection).\n* The Java Tutorials: [Using Prepared Statements](https://docs.oracle.com/javase/tutorial/jdbc/basics/prepared.html).\n* The Java EE Tutorial: [The Java Persistence Query Language](https://docs.oracle.com/javaee/7/tutorial/persistence-querylanguage.htm).\n* Common Weakness Enumeration: [CWE-89](https://cwe.mitre.org/data/definitions/89.html).\n* Common Weakness Enumeration: [CWE-564](https://cwe.mitre.org/data/definitions/564.html).\n",
                  "helpUri": "",
                  "name": "java/sql-injection",
                  "queryUri": "https://github.com/github/codeql/blob/0000000000000000000000000000000000000000/java/ql/src/Security/CWE/CWE-089/SqlTainted.ql",
                  "sarifIdentifier": "java/sql-injection",
                  "severity": "ERROR",
                  "shortDescription": "Query built from user-controlled sources",
                  "tags": [
                    "external/cwe/cwe-089",
                    "external/cwe/cwe-564",
                    "security"
                  ]
                },
                "ruleSeverity": "ERROR",
                "securitySeverity": "HIGH",
                "tool": {
                  "alertCount": "0",
                  "guid": "",
                  "name": "CodeQL",
                  "version": ""
                },
                "updatedAt": "0001-01-01T00:00:00Z"
              },
              {
                "createdAt": "0001-01-01T00:00:00Z",
                "fixedAt": null,
                "guid": "11111111-2222-3333-4444-000000000000",
                "isFixed": false,
                "messageMarkdown": "",
                "messageText": "This query depends on a [user-provided value](1).",
                "mostRecentInstance": {
                  "analysisKey": {
                    "analysisKey": ".github/workflows/w1.yml:java",
                    "category": ".github/workflows/w1.yml:java",
                    "commitOid": "b000000000000000000000000000000000000000",
                    "environment": "{}",
                    "id": "1",
                    "tool": "CodeQL"
                  },
                  "classification": [],
                  "commitOid": "b000000000000000000000000000000000000000",
                  "createdAt": "0001-01-01T00:00:00Z",
                  "hasFileClassification": false,
                  "isFixed": false,
                  "isOutdated": false,
                  "location": {
                    "endColumn": 56,
                    "endLine": 15,
                    "filePath": "app2/src/main/java/org/example/app2/App2Controller.java",
                    "startColumn": 29,
                    "startLine": 15
                  },
                  "messageText": "This query depends on a [user-provided value](1).",
                  "refNameBytes": "cmVmcy9oZWFkcy9tYWlu"
                },
                "number": 3,
                "resolution": "NO_RESOLUTION",
                "resolutionNote": "",
                "resolvedAt": null,
                "resolverId": 0,
                "rule": {
                  "fullDescription": "Building a SQL or Java Persistence query from user-controlled sources is vulnerable to insertion of malicious code by the user.",
                  "help": "# Query built from user-controlled sources\nIf a database query is built using string concatenation, and the components of the concatenation include user input, a user is likely to be able to run malicious database queries. This applies to various database query languages, including SQL and the Java Persistence Query Language.\n\n\n## Recommendation\nUsually, it is better to use a SQL prepared statement than to build a complete SQL query with string concatenation. A prepared statement can include a wildcard, written as a question mark (?), for each part of the SQL query that is expected to be filled in by a different value each time it is run. When the query is later executed, a value must be supplied for each wildcard in the query.\n\nIn the Java Persistence Query Language, it is better to use queries with parameters than to build a complete query with string concatenation. A Java Persistence query can include a parameter placeholder for each part of the query that is expected to be filled in by a different value when run. A parameter placeholder may be indicated by a colon (:) followed by a parameter name, or by a question mark (?) followed by an integer position. When the query is later executed, a value must be supplied for each parameter in the query, using the `setParameter` method. Specifying the query using the `@NamedQuery` annotation introduces an additional level of safety: the query must be a constant string literal, preventing construction by string concatenation, and the only way to fill in values for parts of the query is by setting positional parameters.\n\nIt is good practice to use prepared statements (in SQL) or query parameters (in the Java Persistence Query Language) for supplying parameter values to a query, whether or not any of the parameters are directly traceable to user input. Doing so avoids any need to worry about quoting and escaping.\n\n\n## Example\nIn the following example, the code runs a simple SQL query in two different ways.\n\nThe first way involves building a query, `query1`, by concatenating an environment variable with some string literals. The environment variable can include special characters, so this code allows for SQL injection attacks.\n\nThe second way, which shows good practice, involves building a query, `query2`, with a single string literal that includes a wildcard (`?`). The wildcard is then given a value by calling `setString`. This version is immune to injection attacks, because any special characters in the environment variable are not given any special treatment.\n\n\n```java\n{\n    // BAD: the category might have SQL special characters in it\n    String category = System.getenv(\"ITEM_CATEGORY\");\n    Statement statement = connection.createStatement();\n    String query1 = \"SELECT ITEM,PRICE FROM PRODUCT WHERE ITEM_CATEGORY='\"\n        + category + \"' ORDER BY PRICE\";\n    ResultSet results = statement.executeQuery(query1);\n}\n\n{\n    // GOOD: use a prepared query\n    String category = System.getenv(\"ITEM_CATEGORY\");\n    String query2 = \"SELECT ITEM,PRICE FROM PRODUCT WHERE ITEM_CATEGORY=? ORDER BY PRICE\";\n    PreparedStatement statement = connection.prepareStatement(query2);\n    statement.setString(1, category);\n    ResultSet results = statement.executeQuery();\n}\n```\n\n## Example\nThe following code shows several different ways to run a Java Persistence query.\n\nThe first example involves building a query, `query1`, by concatenating an environment variable with some string literals. Just like the SQL example, the environment variable can include special characters, so this code allows for Java Persistence query injection attacks.\n\nThe remaining examples demonstrate different methods for safely building a Java Persistence query with user-supplied values:\n\n1. `query2` uses a single string literal that includes a placeholder for a parameter, indicated by a colon (`:`) and parameter name (`category`).\n1. `query3` uses a single string literal that includes a placeholder for a parameter, indicated by a question mark (`?`) and position number (`1`).\n1. `namedQuery1` is defined using the `@NamedQuery` annotation, whose `query` attribute is a string literal that includes a placeholder for a parameter, indicated by a colon (`:`) and parameter name (`category`).\n1. `namedQuery2` is defined using the `@NamedQuery` annotation, whose `query` attribute includes a placeholder for a parameter, indicated by a question mark (`?`) and position number (`1`).\nThe parameter is then given a value by calling `setParameter`. These versions are immune to injection attacks, because any special characters in the environment variable or user-supplied value are not given any special treatment.\n\n\n```java\n{\n    // BAD: the category might have Java Persistence Query Language special characters in it\n    String category = System.getenv(\"ITEM_CATEGORY\");\n    Statement statement = connection.createStatement();\n    String query1 = \"SELECT p FROM Product p WHERE p.category LIKE '\"\n        + category + \"' ORDER BY p.price\";\n    Query q = entityManager.createQuery(query1);\n}\n\n{\n    // GOOD: use a named parameter and set its value\n    String category = System.getenv(\"ITEM_CATEGORY\");\n    String query2 = \"SELECT p FROM Product p WHERE p.category LIKE :category ORDER BY p.price\"\n    Query q = entityManager.createQuery(query2);\n    q.setParameter(\"category\", category);\n}\n\n{\n    // GOOD: use a positional parameter and set its value\n    String category = System.getenv(\"ITEM_CATEGORY\");\n    String query3 = \"SELECT p FROM Product p WHERE p.category LIKE ?1 ORDER BY p.price\"\n    Query q = entityManager.createQuery(query3);\n    q.setParameter(1, category);\n}\n\n{\n    // GOOD: use a named query with a named parameter and set its value\n    @NamedQuery(\n            name=\"lookupByCategory\",\n            query=\"SELECT p FROM Product p WHERE p.category LIKE :category ORDER BY p.price\")\n    private static class NQ {}\n    ...\n    String category = System.getenv(\"ITEM_CATEGORY\");\n    Query namedQuery1 = entityManager.createNamedQuery(\"lookupByCategory\");\n    namedQuery1.setParameter(\"category\", category);\n}\n\n{\n    // GOOD: use a named query with a positional parameter and set its value\n    @NamedQuery(\n            name=\"lookupByCategory\",\n            query=\"SELECT p FROM Product p WHERE p.category LIKE ?1 ORDER BY p.price\")\n    private static class NQ {}\n    ...\n    String category = System.getenv(\"ITEM_CATEGORY\");\n    Query namedQuery2 = entityManager.createNamedQuery(\"lookupByCategory\");\n    namedQuery2.setParameter(1, category);\n}\n```\n\n## References\n* OWASP: [SQL Injection Prevention Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/SQL_Injection_Prevention_Cheat_Sheet.html).\n* SEI CERT Oracle Coding Standard for Java: [IDS00-J. Prevent SQL injection](https://wiki.sei.cmu.edu/confluence/display/java/IDS00-J.+Prevent+SQL+injection).\n* The Java Tutorials: [Using Prepared Statements](https://docs.oracle.com/javase/tutorial/jdbc/basics/prepared.html).\n* The Java EE Tutorial: [The Java Persistence Query Language](https://docs.oracle.com/javaee/7/tutorial/persistence-querylanguage.htm).\n* Common Weakness Enumeration: [CWE-89](https://cwe.mitre.org/data/definitions/89.html).\n* Common Weakness Enumeration: [CWE-564](https://cwe.mitre.org/data/definitions/564.html).\n",
                  "helpUri": "",
                  "name": "java/sql-injection",
                  "queryUri": "https://github.com/github/codeql/blob/0000000000000000000000000000000000000000/java/ql/src/Security/CWE/CWE-089/SqlTainted.ql",
                  "sarifIdentifier": "java/sql-injection",
                  "severity": "ERROR",
                  "shortDescription": "Query built from user-controlled sources",
                  "tags": [
                    "external/cwe/cwe-089",
                    "external/cwe/cwe-564",
                    "security"
                  ]
                },
                "ruleSeverity": "ERROR",
                "securitySeverity": "HIGH",
                "tool": {
                  "alertCount": "0",
                  "guid": "",
                  "name": "CodeQL",
                  "version": ""
                },
                "updatedAt": "0001-01-01T00:00:00Z"
              },
              {
                "createdAt": "0001-01-01T00:00:00Z",
                "fixedAt": null,
                "guid": "11111111-2222-3333-4444-000000000000",
                "isFixed": false,
                "messageMarkdown": "",
                "messageText": "This query depends on a [user-provided value](1).",
                "mostRecentInstance": {
                  "analysisKey": {
                    "analysisKey": ".github/workflows/w1.yml:java",
                    "category": ".github/workflows/w1.yml:java",
                    "commitOid": "b000000000000000000000000000000000000000",
                    "environment": "{}",
                    "id": "1",
                    "tool": "CodeQL"
                  },
                  "classification": [],
                  "commitOid": "b000000000000000000000000000000000000000",
                  "createdAt": "0001-01-01T00:00:00Z",
                  "hasFileClassification": false,
                  "isFixed": false,
                  "isOutdated": false,
                  "location": {
                    "endColumn": 56,
                    "endLine": 15,
                    "filePath": "app1/src/main/java/org/example/app1/App1Controller.java",
                    "startColumn": 29,
                    "startLine": 15
                  },
                  "messageText": "This query depends on a [user-provided value](1).",
                  "refNameBytes": "cmVmcy9oZWFkcy9tYWlu"
                },
                "number": 2,
                "resolution": "NO_RESOLUTION",
                "resolutionNote": "",
                "resolvedAt": null,
                "resolverId": 0,
                "rule": {
                  "fullDescription": "Building a SQL or Java Persistence query from user-controlled sources is vulnerable to insertion of malicious code by the user.",
                  "help": "# Query built from user-controlled sources\nIf a database query is built using string concatenation, and the components of the concatenation include user input, a user is likely to be able to run malicious database queries. This applies to various database query languages, including SQL and the Java Persistence Query Language.\n\n\n## Recommendation\nUsually, it is better to use a SQL prepared statement than to build a complete SQL query with string concatenation. A prepared statement can include a wildcard, written as a question mark (?), for each part of the SQL query that is expected to be filled in by a different value each time it is run. When the query is later executed, a value must be supplied for each wildcard in the query.\n\nIn the Java Persistence Query Language, it is better to use queries with parameters than to build a complete query with string concatenation. A Java Persistence query can include a parameter placeholder for each part of the query that is expected to be filled in by a different value when run. A parameter placeholder may be indicated by a colon (:) followed by a parameter name, or by a question mark (?) followed by an integer position. When the query is later executed, a value must be supplied for each parameter in the query, using the `setParameter` method. Specifying the query using the `@NamedQuery` annotation introduces an additional level of safety: the query must be a constant string literal, preventing construction by string concatenation, and the only way to fill in values for parts of the query is by setting positional parameters.\n\nIt is good practice to use prepared statements (in SQL) or query parameters (in the Java Persistence Query Language) for supplying parameter values to a query, whether or not any of the parameters are directly traceable to user input. Doing so avoids any need to worry about quoting and escaping.\n\n\n## Example\nIn the following example, the code runs a simple SQL query in two different ways.\n\nThe first way involves building a query, `query1`, by concatenating an environment variable with some string literals. The environment variable can include special characters, so this code allows for SQL injection attacks.\n\nThe second way, which shows good practice, involves building a query, `query2`, with a single string literal that includes a wildcard (`?`). The wildcard is then given a value by calling `setString`. This version is immune to injection attacks, because any special characters in the environment variable are not given any special treatment.\n\n\n```java\n{\n    // BAD: the category might have SQL special characters in it\n    String category = System.getenv(\"ITEM_CATEGORY\");\n    Statement statement = connection.createStatement();\n    String query1 = \"SELECT ITEM,PRICE FROM PRODUCT WHERE ITEM_CATEGORY='\"\n        + category + \"' ORDER BY PRICE\";\n    ResultSet results = statement.executeQuery(query1);\n}\n\n{\n    // GOOD: use a prepared query\n    String category = System.getenv(\"ITEM_CATEGORY\");\n    String query2 = \"SELECT ITEM,PRICE FROM PRODUCT WHERE ITEM_CATEGORY=? ORDER BY PRICE\";\n    PreparedStatement statement = connection.prepareStatement(query2);\n    statement.setString(1, category);\n    ResultSet results = statement.executeQuery();\n}\n```\n\n## Example\nThe following code shows several different ways to run a Java Persistence query.\n\nThe first example involves building a query, `query1`, by concatenating an environment variable with some string literals. Just like the SQL example, the environment variable can include special characters, so this code allows for Java Persistence query injection attacks.\n\nThe remaining examples demonstrate different methods for safely building a Java Persistence query with user-supplied values:\n\n1. `query2` uses a single string literal that includes a placeholder for a parameter, indicated by a colon (`:`) and parameter name (`category`).\n1. `query3` uses a single string literal that includes a placeholder for a parameter, indicated by a question mark (`?`) and position number (`1`).\n1. `namedQuery1` is defined using the `@NamedQuery` annotation, whose `query` attribute is a string literal that includes a placeholder for a parameter, indicated by a colon (`:`) and parameter name (`category`).\n1. `namedQuery2` is defined using the `@NamedQuery` annotation, whose `query` attribute includes a placeholder for a parameter, indicated by a question mark (`?`) and position number (`1`).\nThe parameter is then given a value by calling `setParameter`. These versions are immune to injection attacks, because any special characters in the environment variable or user-supplied value are not given any special treatment.\n\n\n```java\n{\n    // BAD: the category might have Java Persistence Query Language special characters in it\n    String category = System.getenv(\"ITEM_CATEGORY\");\n    Statement statement = connection.createStatement();\n    String query1 = \"SELECT p FROM Product p WHERE p.category LIKE '\"\n        + category + \"' ORDER BY p.price\";\n    Query q = entityManager.createQuery(query1);\n}\n\n{\n    // GOOD: use a named parameter and set its value\n    String category = System.getenv(\"ITEM_CATEGORY\");\n    String query2 = \"SELECT p FROM Product p WHERE p.category LIKE :category ORDER BY p.price\"\n    Query q = entityManager.createQuery(query2);\n    q.setParameter(\"category\", category);\n}\n\n{\n    // GOOD: use a positional parameter and set its value\n    String category = System.getenv(\"ITEM_CATEGORY\");\n    String query3 = \"SELECT p FROM Product p WHERE p.category LIKE ?1 ORDER BY p.price\"\n    Query q = entityManager.createQuery(query3);\n    q.setParameter(1, category);\n}\n\n{\n    // GOOD: use a named query with a named parameter and set its value\n    @NamedQuery(\n            name=\"lookupByCategory\",\n            query=\"SELECT p FROM Product p WHERE p.category LIKE :category ORDER BY p.price\")\n    private static class NQ {}\n    ...\n    String category = System.getenv(\"ITEM_CATEGORY\");\n    Query namedQuery1 = entityManager.createNamedQuery(\"lookupByCategory\");\n    namedQuery1.setParameter(\"category\", category);\n}\n\n{\n    // GOOD: use a named query with a positional parameter and set its value\n    @NamedQuery(\n            name=\"lookupByCategory\",\n            query=\"SELECT p FROM Product p WHERE p.category LIKE ?1 ORDER BY p.price\")\n    private static class NQ {}\n    ...\n    String category = System.getenv(\"ITEM_CATEGORY\");\n    Query namedQuery2 = entityManager.createNamedQuery(\"lookupByCategory\");\n    namedQuery2.setParameter(1, category);\n}\n```\n\n## References\n* OWASP: [SQL Injection Prevention Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/SQL_Injection_Prevention_Cheat_Sheet.html).\n* SEI CERT Oracle Coding Standard for Java: [IDS00-J. Prevent SQL injection](https://wiki.sei.cmu.edu/confluence/display/java/IDS00-J.+Prevent+SQL+injection).\n* The Java Tutorials: [Using Prepared Statements](https://docs.oracle.com/javase/tutorial/jdbc/basics/prepared.html).\n* The Java EE Tutorial: [The Java Persistence Query Language](https://docs.oracle.com/javaee/7/tutorial/persistence-querylanguage.htm).\n* Common Weakness Enumeration: [CWE-89](https://cwe.mitre.org/data/definitions/89.html).\n* Common Weakness Enumeration: [CWE-564](https://cwe.mitre.org/data/definitions/564.html).\n",
                  "helpUri": "",
                  "name": "java/sql-injection",
                  "queryUri": "https://github.com/github/codeql/blob/0000000000000000000000000000000000000000/java/ql/src/Security/CWE/CWE-089/SqlTainted.ql",
                  "sarifIdentifier": "java/sql-injection",
                  "severity": "ERROR",
                  "shortDescription": "Query built from user-controlled sources",
                  "tags": [
                    "external/cwe/cwe-089",
                    "external/cwe/cwe-564",
                    "security"
                  ]
                },
                "ruleSeverity": "ERROR",
                "securitySeverity": "HIGH",
                "tool": {
                  "alertCount": "0",
                  "guid": "",
                  "name": "CodeQL",
                  "version": ""
                },
                "updatedAt": "0001-01-01T00:00:00Z"
              }
            ],
            "searchStatus": "STATUS_OK",
            "totalCount": "6"
          }
      http_version: null
    recorded_at: Wed, 22 May 2024 11:59:06 GMT
recorded_with: VCR 5.1.0
