# typed: true

# DO NOT EDIT MANUALLY
# This is an autogenerated file for types exported from the `dnsruby` gem.
# Please instead update this file by running `bin/tapioca gem dnsruby`.

# source://dnsruby//lib/dnsruby/resource/NSEC3.rb#17
module Base32
  private

  # source://dnsruby//lib/dnsruby/resource/NSEC3.rb#33
  def decode32hex(str); end

  # source://dnsruby//lib/dnsruby/resource/NSEC3.rb#19
  def encode32hex(str); end

  class << self
    # source://dnsruby//lib/dnsruby/resource/NSEC3.rb#33
    def decode32hex(str); end

    # source://dnsruby//lib/dnsruby/resource/NSEC3.rb#19
    def encode32hex(str); end
  end
end

# source://dnsruby//lib/dnsruby/resource/NSEC3.rb#32
Base32::HEX = T.let(T.unsafe(nil), String)

# == Bugs
# * NIS is not supported.
# * /etc/nsswitch.conf is not supported.
# * NSEC3 validation still TBD
#
# source://dnsruby//lib/dnsruby/code_mappers.rb#1
module Dnsruby
  private

  # Logs (error level) and raises an error.
  #
  # source://dnsruby//lib/dnsruby.rb#147
  def log_and_raise(object, error_class = T.unsafe(nil)); end

  class << self
    # Get the log for Dnsruby
    # Use this to set the log level
    # e.g. Dnsruby.log.level = Logger::INFO
    #
    # source://dnsruby//lib/dnsruby.rb#141
    def log; end

    # Logs (error level) and raises an error.
    #
    # source://dnsruby//lib/dnsruby.rb#147
    def log_and_raise(object, error_class = T.unsafe(nil)); end

    # source://dnsruby//lib/dnsruby.rb#132
    def version; end
  end
end

# http://www.iana.org/assignments/dns-sec-alg-numbers/
#
# source://dnsruby//lib/dnsruby/code_mappers.rb#271
class Dnsruby::Algorithms < ::Dnsruby::CodeMapper; end

# source://dnsruby//lib/dnsruby/code_mappers.rb#274
Dnsruby::Algorithms::DH = T.let(T.unsafe(nil), Integer)

# source://dnsruby//lib/dnsruby/code_mappers.rb#275
Dnsruby::Algorithms::DSA = T.let(T.unsafe(nil), Integer)

# source://dnsruby//lib/dnsruby/code_mappers.rb#279
Dnsruby::Algorithms::ECDSAP256SHA256 = T.let(T.unsafe(nil), Integer)

# source://dnsruby//lib/dnsruby/code_mappers.rb#280
Dnsruby::Algorithms::ECDSAP384SHA384 = T.let(T.unsafe(nil), Integer)

# source://dnsruby//lib/dnsruby/code_mappers.rb#281
Dnsruby::Algorithms::INDIRECT = T.let(T.unsafe(nil), Integer)

# source://dnsruby//lib/dnsruby/code_mappers.rb#282
Dnsruby::Algorithms::PRIVATEDNS = T.let(T.unsafe(nil), Integer)

# source://dnsruby//lib/dnsruby/code_mappers.rb#283
Dnsruby::Algorithms::PRIVATEOID = T.let(T.unsafe(nil), Integer)

# source://dnsruby//lib/dnsruby/code_mappers.rb#272
Dnsruby::Algorithms::RESERVED = T.let(T.unsafe(nil), Integer)

# source://dnsruby//lib/dnsruby/code_mappers.rb#273
Dnsruby::Algorithms::RSAMD5 = T.let(T.unsafe(nil), Integer)

# source://dnsruby//lib/dnsruby/code_mappers.rb#276
Dnsruby::Algorithms::RSASHA1 = T.let(T.unsafe(nil), Integer)

# source://dnsruby//lib/dnsruby/code_mappers.rb#277
Dnsruby::Algorithms::RSASHA256 = T.let(T.unsafe(nil), Integer)

# source://dnsruby//lib/dnsruby/code_mappers.rb#278
Dnsruby::Algorithms::RSASHA512 = T.let(T.unsafe(nil), Integer)

# Provides methods for converting between the various representations
# of a bitmap: number, binary encoded string, array, and sparse array.
#
# Where an array is used to represent bits, the first element (#0) will be the
# low (1) bit and the last bit will be the high bit.
#
# source://dnsruby//lib/dnsruby/bit_mapping.rb#12
module Dnsruby::BitMapping
  private

  # If number is negative, raises an ArgumentError; else does nothing.
  #
  # source://dnsruby//lib/dnsruby/bit_mapping.rb#120
  def assert_non_negative(number); end

  # Converts a binary string to an array of bit values, e.g. "\x0C" => [1, 1, 0, 0]
  #
  # source://dnsruby//lib/dnsruby/bit_mapping.rb#113
  def binary_string_to_bit_array(string, minimum_binary_places = T.unsafe(nil)); end

  # Converts from a binary string to a number, e.g. "\x01\x00" => 256
  #
  # source://dnsruby//lib/dnsruby/bit_mapping.rb#17
  def binary_string_to_number(string); end

  # Converts an array of bit values, e.g. [1, 0, 0, 1], to a number, e.g. 9
  #
  # source://dnsruby//lib/dnsruby/bit_mapping.rb#76
  def bit_array_to_number(bit_array); end

  # Converts a number to a binary encoded string, e.g. 256 => "\x01\x00"
  #
  # source://dnsruby//lib/dnsruby/bit_mapping.rb#26
  def number_to_binary_string(number, min_length = T.unsafe(nil)); end

  # Converts a number to an array of bit values, e.g. 9 => [1, 0, 0, 1]
  #
  # source://dnsruby//lib/dnsruby/bit_mapping.rb#61
  def number_to_bit_array(number, minimum_binary_places = T.unsafe(nil)); end

  # Converts a number to an array of place values, e.g. 9 => [8, 0, 0, 1]
  #
  # source://dnsruby//lib/dnsruby/bit_mapping.rb#41
  def number_to_place_value_array(number); end

  # Converts a number to a sparse array containing bit positions that are set/true/1.
  # Note that these are bit positions, e.g. 76543210, and not bit column values
  # such as 128/64/32/16/8/4/2/1.
  #
  # source://dnsruby//lib/dnsruby/bit_mapping.rb#90
  def number_to_set_bit_positions_array(number); end

  # Converts from a value array to a number, e.g. [8, 0, 0, 1] => 9
  #
  # source://dnsruby//lib/dnsruby/bit_mapping.rb#55
  def place_value_array_to_number(place_value_array); end

  # Reverses a binary string.  Note that it is not enough to reverse
  # the string itself because although the bytes would be reversed,
  # the bits within each byte would not.
  #
  # source://dnsruby//lib/dnsruby/bit_mapping.rb#131
  def reverse_binary_string_bits(binary_string); end

  # Converts an array of bit position numbers to a numeric value, e.g. [0, 2] => 5
  #
  # source://dnsruby//lib/dnsruby/bit_mapping.rb#104
  def set_bit_position_array_to_number(position_array); end

  class << self
    # If number is negative, raises an ArgumentError; else does nothing.
    #
    # source://dnsruby//lib/dnsruby/bit_mapping.rb#120
    def assert_non_negative(number); end

    # Converts a binary string to an array of bit values, e.g. "\x0C" => [1, 1, 0, 0]
    #
    # source://dnsruby//lib/dnsruby/bit_mapping.rb#113
    def binary_string_to_bit_array(string, minimum_binary_places = T.unsafe(nil)); end

    # Converts from a binary string to a number, e.g. "\x01\x00" => 256
    #
    # source://dnsruby//lib/dnsruby/bit_mapping.rb#17
    def binary_string_to_number(string); end

    # Converts an array of bit values, e.g. [1, 0, 0, 1], to a number, e.g. 9
    #
    # source://dnsruby//lib/dnsruby/bit_mapping.rb#76
    def bit_array_to_number(bit_array); end

    # Converts a number to a binary encoded string, e.g. 256 => "\x01\x00"
    #
    # source://dnsruby//lib/dnsruby/bit_mapping.rb#26
    def number_to_binary_string(number, min_length = T.unsafe(nil)); end

    # Converts a number to an array of bit values, e.g. 9 => [1, 0, 0, 1]
    #
    # source://dnsruby//lib/dnsruby/bit_mapping.rb#61
    def number_to_bit_array(number, minimum_binary_places = T.unsafe(nil)); end

    # Converts a number to an array of place values, e.g. 9 => [8, 0, 0, 1]
    #
    # source://dnsruby//lib/dnsruby/bit_mapping.rb#41
    def number_to_place_value_array(number); end

    # Converts a number to a sparse array containing bit positions that are set/true/1.
    # Note that these are bit positions, e.g. 76543210, and not bit column values
    # such as 128/64/32/16/8/4/2/1.
    #
    # source://dnsruby//lib/dnsruby/bit_mapping.rb#90
    def number_to_set_bit_positions_array(number); end

    # Converts from a value array to a number, e.g. [8, 0, 0, 1] => 9
    #
    # source://dnsruby//lib/dnsruby/bit_mapping.rb#55
    def place_value_array_to_number(place_value_array); end

    # Reverses a binary string.  Note that it is not enough to reverse
    # the string itself because although the bytes would be reversed,
    # the bits within each byte would not.
    #
    # source://dnsruby//lib/dnsruby/bit_mapping.rb#131
    def reverse_binary_string_bits(binary_string); end

    # Converts an array of bit position numbers to a numeric value, e.g. [0, 2] => 5
    #
    # source://dnsruby//lib/dnsruby/bit_mapping.rb#104
    def set_bit_position_array_to_number(position_array); end
  end
end

# Instances of this class can be created that will hold on to bitmap data and be used
# to test bits and convert to other formats.
#
# Where an array is used to represent bits, the first element (#0) will be the
# high bit and the last element will be the low (1's column) bit.
#
# source://dnsruby//lib/dnsruby/bitmap.rb#21
class Dnsruby::Bitmap
  extend ::Forwardable

  # @return [Bitmap] a new instance of Bitmap
  #
  # source://dnsruby//lib/dnsruby/bitmap.rb#99
  def initialize(number); end

  # source://forwardable/1.3.3/forwardable.rb#231
  def &(*args, **_arg1, &block); end

  # source://dnsruby//lib/dnsruby/bitmap.rb#104
  def ==(other); end

  # source://forwardable/1.3.3/forwardable.rb#231
  def ^(*args, **_arg1, &block); end

  # source://forwardable/1.3.3/forwardable.rb#231
  def hash(*args, **_arg1, &block); end

  # This is the internal representation of the bitmap value:
  #
  # source://dnsruby//lib/dnsruby/bitmap.rb#26
  def number; end

  # Set a new value to number, validating first that it is nonnegative.
  #
  # source://dnsruby//lib/dnsruby/bitmap.rb#34
  def number=(new_number); end

  # Returns the instance's value as a binary string (e.g. "\x0C")
  #
  # source://dnsruby//lib/dnsruby/bitmap.rb#80
  def to_binary_string(min_length = T.unsafe(nil)); end

  # Returns the instance's value as an array of bit column place values (e.g. [8, 0, 0, 1])
  #
  # source://dnsruby//lib/dnsruby/bitmap.rb#90
  def to_bit_array; end

  # Returns the instance's value as an array of bit column values (e.g. [8, 0, 0, 1])
  #
  # source://dnsruby//lib/dnsruby/bitmap.rb#85
  def to_place_value_array; end

  # Returns the instance's value as an array of positions for the bits that are set (e.g. [0, 3])
  #
  # source://dnsruby//lib/dnsruby/bitmap.rb#95
  def to_set_bit_position_array; end

  # source://forwardable/1.3.3/forwardable.rb#231
  def |(*args, **_arg1, &block); end

  class << self
    # Creates an instance from a binary string (e.g. "\x0C").
    #
    # source://dnsruby//lib/dnsruby/bitmap.rb#58
    def from_binary_string(string); end

    # Creates an instance from a bit array (e.g. [1, 0, 0, 1])
    #
    # source://dnsruby//lib/dnsruby/bitmap.rb#68
    def from_bit_array(array); end

    # Creates an instance from a nonnegative number.
    #
    # source://dnsruby//lib/dnsruby/bitmap.rb#53
    def from_number(number); end

    # Creates an instance from a value array (e.g. [8, 0, 0, 1])
    #
    # source://dnsruby//lib/dnsruby/bitmap.rb#63
    def from_place_value_array(array); end

    # Creates an instance from an array of positions for the bits that are set (e.g. [0, 3])
    #
    # source://dnsruby//lib/dnsruby/bitmap.rb#73
    def from_set_bit_position_array(array); end

    private

    def new(*_arg0); end
  end
end

# source://dnsruby//lib/dnsruby/cache.rb#31
class Dnsruby::Cache
  # @return [Cache] a new instance of Cache
  #
  # source://dnsruby//lib/dnsruby/cache.rb#32
  def initialize; end

  # source://dnsruby//lib/dnsruby/cache.rb#51
  def add(message); end

  # source://dnsruby//lib/dnsruby/cache.rb#37
  def cache; end

  # source://dnsruby//lib/dnsruby/cache.rb#40
  def clear; end

  # This method "fixes up" the response, so that the header and ttls are OK
  #  The resolver will still need to copy the flags and ID across from the query
  #
  # source://dnsruby//lib/dnsruby/cache.rb#70
  def find(qname, qtype, qclass = T.unsafe(nil)); end

  # source://dnsruby//lib/dnsruby/cache.rb#45
  def length; end

  class << self
    # source://dnsruby//lib/dnsruby/cache.rb#91
    def delete(qname, qtype, qclass = T.unsafe(nil)); end

    # source://dnsruby//lib/dnsruby/cache.rb#48
    def max_size=(length); end
  end
end

# source://dnsruby//lib/dnsruby/cache.rb#116
class Dnsruby::Cache::CacheData
  # @return [CacheData] a new instance of CacheData
  #
  # source://dnsruby//lib/dnsruby/cache.rb#151
  def initialize(*args); end

  # Returns the value of attribute expiration.
  #
  # source://dnsruby//lib/dnsruby/cache.rb#117
  def expiration; end

  # source://dnsruby//lib/dnsruby/cache.rb#136
  def get_expiration(m); end

  # source://dnsruby//lib/dnsruby/cache.rb#123
  def message; end

  # source://dnsruby//lib/dnsruby/cache.rb#118
  def message=(m); end

  # source://dnsruby//lib/dnsruby/cache.rb#156
  def to_s; end
end

# source://dnsruby//lib/dnsruby/cache.rb#97
class Dnsruby::Cache::CacheKey
  # @return [CacheKey] a new instance of CacheKey
  #
  # source://dnsruby//lib/dnsruby/cache.rb#99
  def initialize(*args); end

  # Returns the value of attribute qclass.
  #
  # source://dnsruby//lib/dnsruby/cache.rb#98
  def qclass; end

  # Sets the attribute qclass
  #
  # @param value the value to set the attribute qclass to.
  #
  # source://dnsruby//lib/dnsruby/cache.rb#98
  def qclass=(_arg0); end

  # Returns the value of attribute qname.
  #
  # source://dnsruby//lib/dnsruby/cache.rb#98
  def qname; end

  # Sets the attribute qname
  #
  # @param value the value to set the attribute qname to.
  #
  # source://dnsruby//lib/dnsruby/cache.rb#98
  def qname=(_arg0); end

  # Returns the value of attribute qtype.
  #
  # source://dnsruby//lib/dnsruby/cache.rb#98
  def qtype; end

  # Sets the attribute qtype
  #
  # @param value the value to set the attribute qtype to.
  #
  # source://dnsruby//lib/dnsruby/cache.rb#98
  def qtype=(_arg0); end

  # source://dnsruby//lib/dnsruby/cache.rb#112
  def to_s; end
end

# source://dnsruby//lib/dnsruby/resource/resource.rb#17
Dnsruby::ClassHash = T.let(T.unsafe(nil), Hash)

# source://dnsruby//lib/dnsruby/code_mappers.rb#44
class Dnsruby::Classes < ::Dnsruby::CodeMapper
  # source://dnsruby//lib/dnsruby/code_mappers.rb#63
  def unknown_code(arg); end

  # source://dnsruby//lib/dnsruby/code_mappers.rb#54
  def unknown_string(arg); end

  class << self
    # classesbyval and classesbyname functions are wrappers around the
    #  similarly named hashes. They are used for 'unknown' DNS RR classess
    #  (RFC3597)
    #  See typesbyval and typesbyname, these beasts have the same functionality
    #
    # source://dnsruby//lib/dnsruby/code_mappers.rb#72
    def classesbyname(name); end

    # @raise [ArgumentError]
    #
    # source://dnsruby//lib/dnsruby/code_mappers.rb#92
    def classesbyval(val); end
  end
end

# RFC 2136
#
# source://dnsruby//lib/dnsruby/code_mappers.rb#51
Dnsruby::Classes::ANY = T.let(T.unsafe(nil), Integer)

# RFC 1035
#
# source://dnsruby//lib/dnsruby/code_mappers.rb#46
Dnsruby::Classes::CH = T.let(T.unsafe(nil), Integer)

# CHAOS        = 3       # RFC 1035
#
# source://dnsruby//lib/dnsruby/code_mappers.rb#48
Dnsruby::Classes::HS = T.let(T.unsafe(nil), Integer)

# RFC 1035
#
# source://dnsruby//lib/dnsruby/code_mappers.rb#45
Dnsruby::Classes::IN = T.let(T.unsafe(nil), Integer)

# HESIOD        = 4       # RFC 1035
#
# source://dnsruby//lib/dnsruby/code_mappers.rb#50
Dnsruby::Classes::NONE = T.let(T.unsafe(nil), Integer)

# CodeMapper superclass looks after String to code mappings (e.g. OpCode, RCode, etc.)
#
#  Subclasses simply define a mapping of codes to variable names, and CodeMapper provides utility methods.
#
#  All strings will come out as upper case
#
#  Example :
#    Types::AAAA or Types.AAAA
#    rcode.string or rcode.code
#
# source://dnsruby//lib/dnsruby/code_mapper.rb#26
class Dnsruby::CodeMapper
  include ::Comparable

  # @return [CodeMapper] a new instance of CodeMapper
  #
  # source://dnsruby//lib/dnsruby/code_mapper.rb#95
  def initialize(arg); end

  # source://dnsruby//lib/dnsruby/code_mapper.rb#156
  def <=>(other); end

  # source://dnsruby//lib/dnsruby/code_mapper.rb#164
  def ==(other); end

  # Returns the value of attribute code.
  #
  # source://dnsruby//lib/dnsruby/code_mapper.rb#31
  def code; end

  # Sets the attribute code
  #
  # @param value the value to set the attribute code to.
  #
  # source://dnsruby//lib/dnsruby/code_mapper.rb#31
  def code=(_arg0); end

  # source://dnsruby//lib/dnsruby/code_mapper.rb#164
  def eql?(other); end

  # source://dnsruby//lib/dnsruby/code_mapper.rb#132
  def hash; end

  # source://dnsruby//lib/dnsruby/code_mapper.rb#136
  def inspect; end

  # source://dnsruby//lib/dnsruby/code_mapper.rb#127
  def set_code(arg); end

  # source://dnsruby//lib/dnsruby/code_mapper.rb#121
  def set_string(arg); end

  # Returns the value of attribute string.
  #
  # source://dnsruby//lib/dnsruby/code_mapper.rb#31
  def string; end

  # Sets the attribute string
  #
  # @param value the value to set the attribute string to.
  #
  # source://dnsruby//lib/dnsruby/code_mapper.rb#31
  def string=(_arg0); end

  # Returns the value of attribute code.
  #
  # source://dnsruby//lib/dnsruby/code_mapper.rb#31
  def to_code; end

  # Returns the value of attribute code.
  #
  # source://dnsruby//lib/dnsruby/code_mapper.rb#31
  def to_i; end

  # Returns the value of attribute string.
  #
  # source://dnsruby//lib/dnsruby/code_mapper.rb#31
  def to_s; end

  # Returns the value of attribute string.
  #
  # source://dnsruby//lib/dnsruby/code_mapper.rb#31
  def to_string; end

  # source://dnsruby//lib/dnsruby/code_mapper.rb#83
  def unknown_code(arg); end

  # @raise [ArgumentError]
  #
  # source://dnsruby//lib/dnsruby/code_mapper.rb#79
  def unknown_string(arg); end

  class << self
    # Add new a code to the CodeMapper
    #
    # source://dnsruby//lib/dnsruby/code_mapper.rb#71
    def add_pair(string, code); end

    # source://dnsruby//lib/dnsruby/code_mapper.rb#90
    def method_missing(methId); end

    # Return a regular expression which matches any codes or strings from the CodeMapper.
    #
    # source://dnsruby//lib/dnsruby/code_mapper.rb#174
    def regexp; end

    # source://dnsruby//lib/dnsruby/code_mapper.rb#47
    def strings; end

    # source://dnsruby//lib/dnsruby/code_mapper.rb#148
    def to_code(arg); end

    # source://dnsruby//lib/dnsruby/code_mapper.rb#140
    def to_string(arg); end

    # Creates the CodeMapper from the defined constants
    #
    # source://dnsruby//lib/dnsruby/code_mapper.rb#54
    def update; end
  end
end

# source://dnsruby//lib/dnsruby/code_mapper.rb#37
class Dnsruby::CodeMapper::Arrays
  # @return [Arrays] a new instance of Arrays
  #
  # source://dnsruby//lib/dnsruby/code_mapper.rb#39
  def initialize; end

  # Returns the value of attribute maxcode.
  #
  # source://dnsruby//lib/dnsruby/code_mapper.rb#38
  def maxcode; end

  # Sets the attribute maxcode
  #
  # @param value the value to set the attribute maxcode to.
  #
  # source://dnsruby//lib/dnsruby/code_mapper.rb#38
  def maxcode=(_arg0); end

  # Returns the value of attribute strings.
  #
  # source://dnsruby//lib/dnsruby/code_mapper.rb#38
  def strings; end

  # Sets the attribute strings
  #
  # @param value the value to set the attribute strings to.
  #
  # source://dnsruby//lib/dnsruby/code_mapper.rb#38
  def strings=(_arg0); end

  # Returns the value of attribute stringsdown.
  #
  # source://dnsruby//lib/dnsruby/code_mapper.rb#38
  def stringsdown; end

  # Sets the attribute stringsdown
  #
  # @param value the value to set the attribute stringsdown to.
  #
  # source://dnsruby//lib/dnsruby/code_mapper.rb#38
  def stringsdown=(_arg0); end

  # Returns the value of attribute values.
  #
  # source://dnsruby//lib/dnsruby/code_mapper.rb#38
  def values; end

  # Sets the attribute values
  #
  # @param value the value to set the attribute values to.
  #
  # source://dnsruby//lib/dnsruby/code_mapper.rb#38
  def values=(_arg0); end
end

# == Description
#  The Config class determines the system configuration for DNS.
#  In particular, it determines the nameserver to target queries to.
#
#
#  It also specifies whether and how the search list and default
#  domain should be applied to queries, according to the following
#  algorithm :
#
# *     If the name is absolute, then it is used as is.
#
# *     If the name is not absolute, then :
#
#          If apply_domain is true, and ndots is greater than the number
#          of labels in the name, then the default domain is added to the name.
#
#          If apply_search_list is true, then each member of the search list
#          is appended to the name.
#
#  The Config class has now been modified for lazy loading. Previously, the config
#  was loaded when a Resolver was instantiated. Now, the config is only loaded if
#  a query is performed (or a config parameter requested on) a Resolver which has
#  not yet been configured.
#
# source://dnsruby//lib/dnsruby/config.rb#40
class Dnsruby::Config
  # Create a new Config with system default values
  #
  # @return [Config] a new instance of Config
  #
  # source://dnsruby//lib/dnsruby/config.rb#85
  def initialize; end

  # Add a nameserver to the list of nameservers.
  #
  #  Can take either a single String or an array of Strings.
  #  The new nameservers are added at a higher priority.
  #
  # source://dnsruby//lib/dnsruby/config.rb#230
  def add_nameserver(ns); end

  # Should the default domain be applied?
  #
  # source://dnsruby//lib/dnsruby/config.rb#59
  def apply_domain; end

  # Should the default domain be applied?
  #
  # source://dnsruby//lib/dnsruby/config.rb#59
  def apply_domain=(_arg0); end

  # Should the search list be applied?
  #
  # source://dnsruby//lib/dnsruby/config.rb#57
  def apply_search_list; end

  # Should the search list be applied?
  #
  # source://dnsruby//lib/dnsruby/config.rb#57
  def apply_search_list=(_arg0); end

  # source://dnsruby//lib/dnsruby/config.rb#201
  def check_ns(ns); end

  # Return the default domain
  #
  # source://dnsruby//lib/dnsruby/config.rb#421
  def domain; end

  # Set the default domain
  #
  # source://dnsruby//lib/dnsruby/config.rb#145
  def domain=(dom); end

  # source://dnsruby//lib/dnsruby/config.rb#445
  def generate_candidates(name_in); end

  # source://dnsruby//lib/dnsruby/config.rb#439
  def get_ready; end

  # source://dnsruby//lib/dnsruby/config.rb#361
  def inspect; end

  # The list of nameservers to query
  #
  # source://dnsruby//lib/dnsruby/config.rb#50
  def nameserver; end

  # Set the config to point to a single nameserver
  #
  # source://dnsruby//lib/dnsruby/config.rb#244
  def nameserver=(ns); end

  # The minimum number of labels in the query name (if it is not absolute) before it is considered complete
  #
  # source://dnsruby//lib/dnsruby/config.rb#61
  def ndots; end

  # Set ndots
  #
  # source://dnsruby//lib/dnsruby/config.rb#158
  def ndots=(nd); end

  # source://dnsruby//lib/dnsruby/config.rb#97
  def parse_config(config_info = T.unsafe(nil)); end

  # Set port
  #
  # source://dnsruby//lib/dnsruby/config.rb#167
  def port=(p); end

  # Return the search path
  #
  # source://dnsruby//lib/dnsruby/config.rb#409
  def search; end

  # Set the default search path
  #
  # source://dnsruby//lib/dnsruby/config.rb#176
  def search=(s); end

  # Set the config. Parameter can be :
  #
  #  * A String containing the name of the config file to load
  #         e.g. /etc/resolv.conf
  #
  #  * A hash with the following elements :
  #         nameserver (String)
  #         domain (String)
  #         search (String)
  #         ndots (Integer)
  #
  #  This method should not normally be called by client code.
  #
  # source://dnsruby//lib/dnsruby/config.rb#80
  def set_config_info(config_info); end

  # @return [Boolean]
  #
  # source://dnsruby//lib/dnsruby/config.rb#431
  def single?; end

  # source://dnsruby//lib/dnsruby/config.rb#365
  def to_s; end

  class << self
    # source://dnsruby//lib/dnsruby/config.rb#382
    def default_config_hash(filename = T.unsafe(nil)); end

    # source://dnsruby//lib/dnsruby/config.rb#314
    def parse_resolv_conf(filename); end

    # Reset the config to default values
    #
    # source://dnsruby//lib/dnsruby/config.rb#91
    def reset; end

    # source://dnsruby//lib/dnsruby/config.rb#253
    def resolve_server(ns); end
  end
end

# source://dnsruby//lib/dnsruby/config.rb#41
Dnsruby::Config::DEFAULT_PORT = T.let(T.unsafe(nil), Integer)

# == Dnsruby::DNS class
# Resolv::DNS performs DNS queries.
#
# === class methods
# * Dnsruby::DNS.new(config_info=nil)
#
#     ((|config_info|)) should be nil, a string or a hash.
#     If nil is given, /etc/resolv.conf and platform specific information is used.
#     If a string is given, it should be a filename which format is same as /etc/resolv.conf.
#     If a hash is given, it may contains information for nameserver, search and ndots as follows.
#
#       Dnsruby::DNS.new({:nameserver=>["210.251.121.21"], :search=>["ruby-lang.org"], :ndots=>1})
#
# * Dnsruby::DNS.open(config_info=nil)
# * Dnsruby::Resolv::DNS.open(config_info=nil) {|dns| ...}
#
# === methods
# * Dnsruby::DNS#close
#
# * Dnsruby::DNS#getaddress(name)
# * Dnsruby::DNS#getaddresses(name)
# * Dnsruby::DNS#each_address(name) {|address| ...}
#     address lookup methods.
#
#     ((|name|)) must be an instance of Dnsruby::Name or String.  Resultant
#     address is represented as an instance of Dnsruby::IPv4 or Dnsruby::IPv6.
#
# * Dnsruby::DNS#getname(address)
# * Dnsruby::DNS#getnames(address)
# * Dnsruby::DNS#each_name(address) {|name| ...}
#     These methods lookup hostnames .
#
#     ((|address|)) must be an instance of Dnsruby::IPv4, Dnsruby::IPv6 or String.
#     Resultant name is represented as an instance of Dnsruby::Name.
#
# * Dnsruby::DNS#getresource(name, type, class)
# * Dnsruby::DNS#getresources(name, type, class)
# * Dnsruby::DNS#each_resource(name, type, class) {|resource| ...}
#     These methods lookup DNS resources of ((|name|)).
#     ((|name|)) must be a instance of Dnsruby::Name or String.
#
#     ((|type|)) must be a member of Dnsruby::Types
#     ((|class|)) must be a member of Dnsruby::Classes
#
#     Resultant resource is represented as an instance of (a subclass of)
#     Dnsruby::RR.
#     (Dnsruby::RR::IN::A, etc.)
#
# The searchlist and other Config info is applied to the domain name if appropriate. All the nameservers
# are tried (if there is no timely answer from the first).
#
# This class uses Resolver to perform the queries.
#
# Information taken from the following places :
# * STD0013
# * RFC 1035, etc.
# * ftp://ftp.isi.edu/in-notes/iana/assignments/dns-parameters
# * etc.
#
# source://dnsruby//lib/dnsruby/DNS.rb#79
class Dnsruby::DNS
  # Creates a new DNS resolver
  #
  # +config_info+ can be:
  #
  # * nil:: Uses platform default (e.g. /etc/resolv.conf)
  # * String:: Path to a file using /etc/resolv.conf's format
  # * Hash:: Must contain :nameserver, :search and :ndots keys
  #    example :
  #
  #     Dnsruby::DNS.new({:nameserver => ['210.251.121.21'],
  #                       :search => ['ruby-lang.org'],
  #                       :ndots => 1})
  #
  # @return [DNS] a new instance of DNS
  #
  # source://dnsruby//lib/dnsruby/DNS.rb#118
  def initialize(config_info = T.unsafe(nil)); end

  # Closes the resolver
  #
  # source://dnsruby//lib/dnsruby/DNS.rb#97
  def close; end

  # Returns the value of attribute config.
  #
  # source://dnsruby//lib/dnsruby/DNS.rb#128
  def config; end

  # Returns the value of attribute do_caching.
  #
  # source://dnsruby//lib/dnsruby/DNS.rb#81
  def do_caching; end

  # Sets the attribute do_caching
  #
  # @param value the value to set the attribute do_caching to.
  #
  # source://dnsruby//lib/dnsruby/DNS.rb#81
  def do_caching=(_arg0); end

  # Iterates over all IP addresses of +name+ retrieved from the DNS resolver
  #
  # +name+ can be a Dnsruby::Name or a String. Retrieved address will be a
  # Dnsruby::IPv4 or a Dnsruby::IPv6
  #
  # source://dnsruby//lib/dnsruby/DNS.rb#153
  def each_address(name); end

  # Iterates over all hostnames for +address+ retrieved from the DNS resolver
  #
  # +address+ must be a Dnsruby::IPv4, Dnsruby::IPv6 or a String. Retrieved
  # name will be a Dnsruby::Name.
  #
  # source://dnsruby//lib/dnsruby/DNS.rb#180
  def each_name(address); end

  # Iterates over all +type+, +klass+ resources for +name+
  #
  # +type+ defaults to Dnsruby::Types.A
  # +klass+ defaults to Dnsruby::Classes.IN
  #
  # Yielded resource is represented as a Dnsruby::RR instance, e.g.
  # Dnsruby::RR::IN::A
  #
  # source://dnsruby//lib/dnsruby/DNS.rb#228
  def each_resource(name, type = T.unsafe(nil), klass = T.unsafe(nil), &proc); end

  # source://dnsruby//lib/dnsruby/DNS.rb#245
  def extract_resources(msg, name, type, klass); end

  # Gets the first IP address of +name+ from the DNS resolver
  #
  # +name+ can be a Dnsruby::Name or a String. Retrieved address will be a
  # Dnsruby::IPv4 or a Dnsruby::IPv6
  #
  # @raise [ResolvError]
  #
  # source://dnsruby//lib/dnsruby/DNS.rb#134
  def getaddress(name); end

  # Gets all IP addresses of +name+ from the DNS resolver
  #
  # +name+ can be a Dnsruby::Name or a String. Retrieved address will be a
  # Dnsruby::IPv4 or a Dnsruby::IPv6
  #
  # source://dnsruby//lib/dnsruby/DNS.rb#143
  def getaddresses(name); end

  # Gets the first hostname for +address+ from the DNS resolver
  #
  # +address+ must be a Dnsruby::IPv4, Dnsruby::IPv6 or a String. Retrieved
  # name will be a Dnsruby::Name.
  #
  # @raise [ResolvError]
  #
  # source://dnsruby//lib/dnsruby/DNS.rb#161
  def getname(address); end

  # Gets all hostnames for +address+ from the DNS resolver
  #
  # +address+ must be a Dnsruby::IPv4, Dnsruby::IPv6 or a String. Retrieved
  # name will be a Dnsruby::Name.
  #
  # source://dnsruby//lib/dnsruby/DNS.rb#170
  def getnames(address); end

  # Look up the first +type+, +klass+ resource for +name+
  #
  # +type+ defaults to Dnsruby::Types.A
  # +klass+ defaults to Dnsruby::Classes.IN
  #
  # Returned resource is represented as a Dnsruby::RR instance, e.g.
  # Dnsruby::RR::IN::A
  #
  # @raise [ResolvError]
  #
  # source://dnsruby//lib/dnsruby/DNS.rb#203
  def getresource(name, type = T.unsafe(nil), klass = T.unsafe(nil)); end

  # Look up all +type+, +klass+ resources for +name+
  #
  # +type+ defaults to Dnsruby::Types.A
  # +klass+ defaults to Dnsruby::Classes.IN
  #
  # Returned resource is represented as a Dnsruby::RR instance, e.g.
  # Dnsruby::RR::IN::A
  #
  # source://dnsruby//lib/dnsruby/DNS.rb#215
  def getresources(name, type = T.unsafe(nil), klass = T.unsafe(nil)); end

  # source://dnsruby//lib/dnsruby/DNS.rb#280
  def send_query(name, type = T.unsafe(nil), klass = T.unsafe(nil)); end

  # source://dnsruby//lib/dnsruby/DNS.rb#102
  def to_s; end

  class << self
    # Creates a new DNS resolver. See Resolv::DNS.new for argument details.
    #
    # Yields the created DNS resolver to the block, if given, otherwise returns it.
    #
    # source://dnsruby//lib/dnsruby/DNS.rb#86
    def open(*args); end
  end
end

# Indicates an error in decoding an incoming DNS message
#
# source://dnsruby//lib/dnsruby.rb#226
class Dnsruby::DecodeError < ::Dnsruby::ResolvError
  # Returns the value of attribute partial_message.
  #
  # source://dnsruby//lib/dnsruby.rb#227
  def partial_message; end

  # Sets the attribute partial_message
  #
  # @param value the value to set the attribute partial_message to.
  #
  # source://dnsruby//lib/dnsruby.rb#227
  def partial_message=(_arg0); end
end

# RFC4033, section 7
#    "There is one more step that a security-aware stub resolver can take
#    if, for whatever reason, it is not able to establish a useful trust
#    relationship with the recursive name servers that it uses: it can
#    perform its own signature validation by setting the Checking Disabled
#    (CD) bit in its query messages.  A validating stub resolver is thus
#    able to treat the DNSSEC signatures as trust relationships between
#    the zone administrators and the stub resolver itself. "
#
#  Dnsruby is configured to validate responses by default. However, it is not
#  configured with any trusted keys by default. Applications may use the
#  verify() method to perform verification with of RRSets of Messages with
#  given keys. Alternatively, trusted keys may be added to this class (either
#  directly, or by loading the IANA TAR or the DLV ISC ZSK). Validation will then
#  be performed from these keys (or the DLV registry, if configured). Negative
#  and positive responses are validation.
#
#  Messages are tagged with the current security_level (Message::SecurityLevel).
#  UNCHECKED means Dnsruby has not attempted to validate the response.
#  BOGUS means the response has been checked, and is bogus.
#  INSECURE means the response has been validated to be insecure (e.g. in an unsigned zone)
#  SECURE means that the response has been verfied to be correct.
#
#  Several validators are provided, with each maintaining its own cache of trusted keys.
#  If validators are added or removed, the caches of the other validators are not affected.
#
# source://dnsruby//lib/dnsruby/dnssec.rb#47
class Dnsruby::Dnssec
  class << self
    # Add a trusted Key Signing Key for the ISC DLV registry.
    #
    # source://dnsruby//lib/dnsruby/dnssec.rb#95
    def add_dlv_key(dlv_key); end

    # Add a new trust anchor
    #
    # source://dnsruby//lib/dnsruby/dnssec.rb#99
    def add_trust_anchor(t); end

    # Add the trusted key with the given expiration time
    #
    # source://dnsruby//lib/dnsruby/dnssec.rb#104
    def add_trust_anchor_with_expiration(k, expiration); end

    # source://dnsruby//lib/dnsruby/dnssec.rb#302
    def anchor_verifier; end

    # Wipes the cache of trusted keys
    #
    # source://dnsruby//lib/dnsruby/dnssec.rb#113
    def clear_trust_anchors; end

    # source://dnsruby//lib/dnsruby/dnssec.rb#121
    def clear_trusted_keys; end

    # source://dnsruby//lib/dnsruby/dnssec.rb#176
    def default_resolver; end

    # This method overrides the system default resolver configuration for validation
    #  If default_resolver is set, then it will be used to follow the chain of trust.
    #  If it is not, then the default system resolver will be used (unless do_validation_with_recursor
    #  is set.
    #
    # source://dnsruby//lib/dnsruby/dnssec.rb#173
    def default_resolver=(res); end

    # source://dnsruby//lib/dnsruby/dnssec.rb#305
    def dlv_verifier; end

    # This method defines the choice of Resolver or Recursor, when the validator
    #  is checking responses.
    #  If set to true, then a Recursor will be used to query for the DNSSEC records.
    #  Otherwise, the default system resolver will be used.
    #
    # source://dnsruby//lib/dnsruby/dnssec.rb#163
    def do_validation_with_recursor(on); end

    # @return [Boolean]
    #
    # source://dnsruby//lib/dnsruby/dnssec.rb#166
    def do_validation_with_recursor?; end

    # @return [Boolean]
    #
    # source://dnsruby//lib/dnsruby/dnssec.rb#146
    def no_keys?; end

    # Remove the trusted key
    #
    # source://dnsruby//lib/dnsruby/dnssec.rb#109
    def remove_trust_anchor(t); end

    # source://dnsruby//lib/dnsruby/dnssec.rb#127
    def reset; end

    # source://dnsruby//lib/dnsruby/dnssec.rb#308
    def root_verifier; end

    # source://dnsruby//lib/dnsruby/dnssec.rb#141
    def set_hints(hints); end

    # source://dnsruby//lib/dnsruby/dnssec.rb#117
    def trust_anchors; end

    # source://dnsruby//lib/dnsruby/dnssec.rb#265
    def try_validation(last_level, last_error, last_error_level, proc, msg, query); end

    # Returns true for secure/insecure, false otherwise
    #  This method will set the security_level on msg to the appropriate value.
    #  Could be : secure, insecure, bogus or indeterminate
    #  If an error is encountered during verification, then the thrown exception
    #  will define the error.
    #
    # source://dnsruby//lib/dnsruby/dnssec.rb#185
    def validate(msg); end

    # source://dnsruby//lib/dnsruby/dnssec.rb#278
    def validate_with_anchors(msg, query); end

    # source://dnsruby//lib/dnsruby/dnssec.rb#286
    def validate_with_dlv(msg, query); end

    # source://dnsruby//lib/dnsruby/dnssec.rb#191
    def validate_with_query(query, msg); end

    # source://dnsruby//lib/dnsruby/dnssec.rb#282
    def validate_with_root(msg, query); end

    # source://dnsruby//lib/dnsruby/dnssec.rb#74
    def validation_policy; end

    # source://dnsruby//lib/dnsruby/dnssec.rb#68
    def validation_policy=(p); end

    # source://dnsruby//lib/dnsruby/dnssec.rb#290
    def verify(msg, keys = T.unsafe(nil)); end

    # source://dnsruby//lib/dnsruby/dnssec.rb#315
    def verify_rrset(rrset, keys = T.unsafe(nil)); end
  end
end

# source://dnsruby//lib/dnsruby/dnssec.rb#51
class Dnsruby::Dnssec::ValidationPolicy; end

# * Always use local trust anchors and ignore the root.
#
# source://dnsruby//lib/dnsruby/dnssec.rb#64
Dnsruby::Dnssec::ValidationPolicy::ALWAYS_LOCAL_ANCHORS_ONLY = T.let(T.unsafe(nil), Integer)

# * Always use the root and ignore local trust anchors.
#
# source://dnsruby//lib/dnsruby/dnssec.rb#58
Dnsruby::Dnssec::ValidationPolicy::ALWAYS_ROOT_ONLY = T.let(T.unsafe(nil), Integer)

# * Use local trust anchors if available, otherwise use root.
#
# source://dnsruby//lib/dnsruby/dnssec.rb#62
Dnsruby::Dnssec::ValidationPolicy::LOCAL_ANCHORS_THEN_ROOT = T.let(T.unsafe(nil), Integer)

# * Use the root if successful, otherwise try local anchors.
#
# source://dnsruby//lib/dnsruby/dnssec.rb#60
Dnsruby::Dnssec::ValidationPolicy::ROOT_THEN_LOCAL_ANCHORS = T.let(T.unsafe(nil), Integer)

# Indicates an error encoding a DNS message for transmission
#
# source://dnsruby//lib/dnsruby.rb#231
class Dnsruby::EncodeError < ::Dnsruby::ResolvError; end

# source://dnsruby//lib/dnsruby/code_mappers.rb#39
class Dnsruby::ExtendedRCode < ::Dnsruby::CodeMapper; end

# source://dnsruby//lib/dnsruby/code_mappers.rb#40
Dnsruby::ExtendedRCode::BADVERS = T.let(T.unsafe(nil), Integer)

# A format error in a received DNS message
#
# source://dnsruby//lib/dnsruby.rb#173
class Dnsruby::FormErr < ::Dnsruby::ResolvError; end

# The header portion of a DNS packet
#
# RFC 1035 Section 4.1.1
#
# source://dnsruby//lib/dnsruby/message/header.rb#6
class Dnsruby::Header
  # @return [Header] a new instance of Header
  #
  # source://dnsruby//lib/dnsruby/message/header.rb#64
  def initialize(*args); end

  # source://dnsruby//lib/dnsruby/message/header.rb#133
  def ==(other); end

  # Authoritative answer flag
  #
  # source://dnsruby//lib/dnsruby/message/header.rb#16
  def aa; end

  # Authoritative answer flag
  #
  # source://dnsruby//lib/dnsruby/message/header.rb#16
  def aa=(_arg0); end

  # The Authenticated Data flag
  #  Relevant in DNSSEC context.
  #  (The AD bit is only set on answers where signatures have been
  #  cryptographically verified or the server is authoritative for the data
  #  and is allowed to set the bit by policy.)
  #
  # source://dnsruby//lib/dnsruby/message/header.rb#32
  def ad; end

  # The Authenticated Data flag
  #  Relevant in DNSSEC context.
  #  (The AD bit is only set on answers where signatures have been
  #  cryptographically verified or the server is authoritative for the data
  #  and is allowed to set the bit by policy.)
  #
  # source://dnsruby//lib/dnsruby/message/header.rb#32
  def ad=(_arg0); end

  # The number of records in the additional record section og the message
  #
  # source://dnsruby//lib/dnsruby/message/header.rb#62
  def adcount; end

  # The number of records in the additional record section og the message
  #
  # source://dnsruby//lib/dnsruby/message/header.rb#62
  def adcount=(_arg0); end

  # The number of records in the answer section of the message
  #
  # source://dnsruby//lib/dnsruby/message/header.rb#60
  def ancount; end

  # The number of records in the answer section of the message
  #
  # source://dnsruby//lib/dnsruby/message/header.rb#60
  def ancount=(_arg0); end

  # The number of records in the additional record section og the message
  #
  # source://dnsruby//lib/dnsruby/message/header.rb#62
  def arcount; end

  # The number of records in the additional record section og the message
  #
  # source://dnsruby//lib/dnsruby/message/header.rb#62
  def arcount=(_arg0); end

  # The Checking Disabled flag
  #
  # source://dnsruby//lib/dnsruby/message/header.rb#25
  def cd; end

  # The Checking Disabled flag
  #
  # source://dnsruby//lib/dnsruby/message/header.rb#25
  def cd=(_arg0); end

  # source://dnsruby//lib/dnsruby/message/header.rb#99
  def data; end

  # source://dnsruby//lib/dnsruby/message/header.rb#222
  def decode(msg); end

  # source://dnsruby//lib/dnsruby/message/header.rb#103
  def encode(msg); end

  # This new get_header_rcode method is intended for use only by the Message class.
  #  This is because the Message OPT section may contain an extended rcode (see
  #  RFC 2671 section 4.6). Using the header rcode only ignores this extension, and
  #  is not recommended.
  #
  # source://dnsruby//lib/dnsruby/message/header.rb#48
  def get_header_rcode; end

  # The header ID
  #
  # source://dnsruby//lib/dnsruby/message/header.rb#10
  def id; end

  # The header ID
  #
  # source://dnsruby//lib/dnsruby/message/header.rb#10
  def id=(_arg0); end

  # The number of records in the authoriy section of the message
  #
  # source://dnsruby//lib/dnsruby/message/header.rb#58
  def nscount; end

  # The number of records in the authoriy section of the message
  #
  # source://dnsruby//lib/dnsruby/message/header.rb#58
  def nscount=(_arg0); end

  # source://dnsruby//lib/dnsruby/message/header.rb#149
  def old_to_s; end

  # source://dnsruby//lib/dnsruby/message/header.rb#189
  def old_to_s_with_rcode(rcode); end

  # The header opcode
  #
  # source://dnsruby//lib/dnsruby/message/header.rb#53
  def opcode; end

  # source://dnsruby//lib/dnsruby/message/header.rb#85
  def opcode=(op); end

  # The number of records in the answer section of the message
  #
  # source://dnsruby//lib/dnsruby/message/header.rb#60
  def prcount; end

  # The number of records in the answer section of the message
  #
  # source://dnsruby//lib/dnsruby/message/header.rb#60
  def prcount=(_arg0); end

  # The number of records in the question section of the message
  #
  # source://dnsruby//lib/dnsruby/message/header.rb#56
  def qdcount; end

  # The number of records in the question section of the message
  #
  # source://dnsruby//lib/dnsruby/message/header.rb#56
  def qdcount=(_arg0); end

  # The query response flag
  #
  # source://dnsruby//lib/dnsruby/message/header.rb#35
  def qr; end

  # The query response flag
  #
  # source://dnsruby//lib/dnsruby/message/header.rb#35
  def qr=(_arg0); end

  # Recursion available flag
  #
  # source://dnsruby//lib/dnsruby/message/header.rb#38
  def ra; end

  # Recursion available flag
  #
  # source://dnsruby//lib/dnsruby/message/header.rb#38
  def ra=(_arg0); end

  # source://dnsruby//lib/dnsruby/message/header.rb#89
  def rcode=(rcode); end

  # Recursion Desired flag
  #
  # source://dnsruby//lib/dnsruby/message/header.rb#22
  def rd; end

  # Recursion Desired flag
  #
  # source://dnsruby//lib/dnsruby/message/header.rb#22
  def rd=(_arg0); end

  # Truncated flag
  #
  # source://dnsruby//lib/dnsruby/message/header.rb#19
  def tc; end

  # Truncated flag
  #
  # source://dnsruby//lib/dnsruby/message/header.rb#19
  def tc=(_arg0); end

  # source://dnsruby//lib/dnsruby/message/header.rb#145
  def to_s; end

  # source://dnsruby//lib/dnsruby/message/header.rb#153
  def to_s_with_rcode(rcode); end

  # The number of records in the authoriy section of the message
  #
  # source://dnsruby//lib/dnsruby/message/header.rb#58
  def upcount; end

  # The number of records in the authoriy section of the message
  #
  # source://dnsruby//lib/dnsruby/message/header.rb#58
  def upcount=(_arg0); end

  # The number of records in the question section of the message
  #
  # source://dnsruby//lib/dnsruby/message/header.rb#56
  def zocount; end

  # The number of records in the question section of the message
  #
  # source://dnsruby//lib/dnsruby/message/header.rb#56
  def zocount=(_arg0); end

  class << self
    # source://dnsruby//lib/dnsruby/message/header.rb#121
    def decrement_arcount_encoded(bytes); end

    # source://dnsruby//lib/dnsruby/message/header.rb#93
    def new_from_data(data); end
  end
end

# source://dnsruby//lib/dnsruby/message/header.rb#7
Dnsruby::Header::MAX_ID = T.let(T.unsafe(nil), Integer)

# hostnames lookup methods.
#
# source://dnsruby//lib/dnsruby/hosts.rb#34
class Dnsruby::Hosts
  # Creates a new Dnsruby::Hosts using +filename+ for its data source
  #
  # @return [Hosts] a new instance of Hosts
  #
  # source://dnsruby//lib/dnsruby/hosts.rb#43
  def initialize(filename = T.unsafe(nil)); end

  # Iterates over all IP addresses for +name+ retrieved from the hosts file
  #
  # source://dnsruby//lib/dnsruby/hosts.rb#102
  def each_address(name, &proc); end

  # Iterates over all hostnames for +address+ retrieved from the hosts file
  #
  # source://dnsruby//lib/dnsruby/hosts.rb#123
  def each_name(address, &proc); end

  # Gets the first IP address for +name+ from the hosts file
  #
  # @raise [ResolvError]
  #
  # source://dnsruby//lib/dnsruby/hosts.rb#89
  def getaddress(name); end

  # Gets all IP addresses for +name+ from the hosts file
  #
  # source://dnsruby//lib/dnsruby/hosts.rb#95
  def getaddresses(name); end

  # Gets the first hostname of +address+ from the hosts file
  #
  # @raise [ResolvError]
  #
  # source://dnsruby//lib/dnsruby/hosts.rb#110
  def getname(address); end

  # Gets all hostnames for +address+ from the hosts file
  #
  # source://dnsruby//lib/dnsruby/hosts.rb#116
  def getnames(address); end

  # source://dnsruby//lib/dnsruby/hosts.rb#49
  def lazy_initialize; end
end

# source://dnsruby//lib/dnsruby/hosts.rb#39
Dnsruby::Hosts::DefaultFileName = T.let(T.unsafe(nil), String)

# source://dnsruby//lib/dnsruby/ipv4.rb#17
class Dnsruby::IPv4
  # @return [IPv4] a new instance of IPv4
  #
  # source://dnsruby//lib/dnsruby/ipv4.rb#39
  def initialize(address); end

  # source://dnsruby//lib/dnsruby/ipv4.rb#62
  def ==(other); end

  # A String representation of the IPv4 address.
  #
  # source://dnsruby//lib/dnsruby/ipv4.rb#47
  def address; end

  # @return [Boolean]
  #
  # source://dnsruby//lib/dnsruby/ipv4.rb#66
  def eql?(other); end

  # source://dnsruby//lib/dnsruby/ipv4.rb#70
  def hash; end

  # source://dnsruby//lib/dnsruby/ipv4.rb#53
  def inspect; end

  # source://dnsruby//lib/dnsruby/ipv4.rb#57
  def to_name; end

  # source://dnsruby//lib/dnsruby/ipv4.rb#49
  def to_s; end

  class << self
    # source://dnsruby//lib/dnsruby/ipv4.rb#21
    def create(arg); end
  end
end

# Regular expression IPv4 addresses must match
#
# source://dnsruby//lib/dnsruby/ipv4.rb#19
Dnsruby::IPv4::Regex = T.let(T.unsafe(nil), Regexp)

# Dnsruby::IPv6 class
#
# source://dnsruby//lib/dnsruby/ipv6.rb#18
class Dnsruby::IPv6
  # @return [IPv6] a new instance of IPv6
  #
  # source://dnsruby//lib/dnsruby/ipv6.rb#101
  def initialize(address); end

  # source://dnsruby//lib/dnsruby/ipv6.rb#132
  def ==(other); end

  # The raw IPv6 address as a String
  #
  # source://dnsruby//lib/dnsruby/ipv6.rb#109
  def address; end

  # @return [Boolean]
  #
  # source://dnsruby//lib/dnsruby/ipv6.rb#136
  def eql?(other); end

  # source://dnsruby//lib/dnsruby/ipv6.rb#140
  def hash; end

  # source://dnsruby//lib/dnsruby/ipv6.rb#119
  def inspect; end

  # Turns this IPv6 address into a Dnsruby::Name
  # --
  #  ip6.arpa should be searched too. [RFC3152]
  #
  # source://dnsruby//lib/dnsruby/ipv6.rb#126
  def to_name; end

  # source://dnsruby//lib/dnsruby/ipv6.rb#111
  def to_s; end

  class << self
    # Created a new IPv6 address from +arg+ which may be:
    #
    # * IPv6:: returns +arg+
    # * String:: +arg+ must match one of the IPv6::Regex* constants
    #
    # source://dnsruby//lib/dnsruby/ipv6.rb#55
    def create(arg); end
  end
end

# A composite IPv6 address RegExp
#
# source://dnsruby//lib/dnsruby/ipv6.rb#45
Dnsruby::IPv6::Regex = T.let(T.unsafe(nil), Regexp)

# IPv4 mapped IPv6 address format a:b:c:d:e:f:w.x.y.z
#
# source://dnsruby//lib/dnsruby/ipv6.rb#32
Dnsruby::IPv6::Regex_6Hex4Dec = T.let(T.unsafe(nil), Regexp)

# IPv6 address format a:b:c:d:e:f:g:h
#
# source://dnsruby//lib/dnsruby/ipv6.rb#20
Dnsruby::IPv6::Regex_8Hex = T.let(T.unsafe(nil), Regexp)

# Compresses IPv6 format a::b
#
# source://dnsruby//lib/dnsruby/ipv6.rb#26
Dnsruby::IPv6::Regex_CompressedHex = T.let(T.unsafe(nil), Regexp)

# Compressed IPv4 mapped IPv6 address format a::b:w.x.y.z
#
# source://dnsruby//lib/dnsruby/ipv6.rb#38
Dnsruby::IPv6::Regex_CompressedHex4Dec = T.let(T.unsafe(nil), Regexp)

# source://dnsruby//lib/dnsruby/key_cache.rb#18
class Dnsruby::KeyCache
  # Cache includes expiration time for keys
  #  Cache removes expired records
  #
  # @return [KeyCache] a new instance of KeyCache
  #
  # source://dnsruby//lib/dnsruby/key_cache.rb#21
  def initialize(keys = T.unsafe(nil)); end

  # source://dnsruby//lib/dnsruby/key_cache.rb#29
  def add(k); end

  # source://dnsruby//lib/dnsruby/key_cache.rb#26
  def add_key_with_expiration(k, expiration); end

  # source://dnsruby//lib/dnsruby/key_cache.rb#46
  def add_rrset(k); end

  # source://dnsruby//lib/dnsruby/key_cache.rb#74
  def each; end

  # source://dnsruby//lib/dnsruby/key_cache.rb#96
  def find_key_for(name); end

  # source://dnsruby//lib/dnsruby/key_cache.rb#79
  def keys; end

  # return @keys.keys
  #
  # source://dnsruby//lib/dnsruby/key_cache.rb#87
  def keys_and_expirations; end

  # source://dnsruby//lib/dnsruby/key_cache.rb#65
  def priv_add_key(k, exp); end

  # source://dnsruby//lib/dnsruby/key_cache.rb#91
  def remove_expired_keys; end
end

# ===Defines a DNS packet.
#
#  RFC 1035 Section 4.1, RFC 2136 Section 2, RFC 2845
#
#  ===Sections
#  Message objects have five sections:
#
# * The header section, a Dnsruby::Header object.
#
#       msg.header=Header.new(...)
#       header = msg.header
#
# * The question section, an array of Dnsruby::Question objects.
#
#       msg.add_question(Question.new(domain, type, klass))
#       msg.each_question do |question|  ....   end
#
# * The answer section, an array of Dnsruby::RR objects.
#
#       msg.add_answer(RR.create({:name    => 'a2.example.com',
# 		      :type    => 'A', :address => '10.0.0.2'}))
#       msg.each_answer {|answer| ... }
#
# * The authority section, an array of Dnsruby::RR objects.
#
#       msg.add_authority(rr)
#       msg.each_authority {|rr| ... }
#
# * The additional section, an array of Dnsruby::RR objects.
#
#       msg.add_additional(rr)
#       msg.each_additional {|rr| ... }
#
#  In addition, each_resource iterates the answer, additional
#  and authority sections :
#
#       msg.each_resource {|rr| ... }
#
#  ===Packet format encoding
#
#       Dnsruby::Message#encode
#       Dnsruby::Message::decode(data)
#
#  ===Additional information
#  security_level records the current DNSSEC status of this Message.
#  answerfrom records the server which this Message was received from.
#  cached records whether this response came from the cache.
#
# source://dnsruby//lib/dnsruby/message/message.rb#69
class Dnsruby::Message
  # Create a new Message. Takes optional name, type and class
  #
  #  type defaults to A, and klass defaults to IN
  #
  # *  Dnsruby::Message.new('example.com') # defaults to A, IN
  # *  Dnsruby::Message.new('example.com', 'AAAA')
  # *  Dnsruby::Message.new('example.com', Dnsruby::Types.PTR, 'HS')
  #
  # @return [Message] a new instance of Message
  #
  # source://dnsruby//lib/dnsruby/message/message.rb#104
  def initialize(*args); end

  # source://dnsruby//lib/dnsruby/message/message.rb#220
  def ==(other); end

  # source://dnsruby//lib/dnsruby/message/message.rb#332
  def add_additional(rr); end

  # Adds an RR to the answer section unless it already occurs.
  #
  # source://dnsruby//lib/dnsruby/message/message.rb#300
  def add_answer(rr); end

  # When adding an RR to a Dnsruby::Message, add_answer checks to see if it already occurs,
  # and, if so, does not add it again. This method adds the record whether or not
  # it already occurs.  This is needed in order to add
  # a SOA record twice for an AXFR response.
  #
  # source://dnsruby//lib/dnsruby/message/message.rb#308
  def add_answer!(rr); end

  # source://dnsruby//lib/dnsruby/message/message.rb#319
  def add_authority(rr); end

  # Adds an RR to the answer section unless it already occurs.
  #
  # source://dnsruby//lib/dnsruby/message/message.rb#300
  def add_pre(rr); end

  # Adds an RR to the answer section unless it already occurs.
  #
  # source://dnsruby//lib/dnsruby/message/message.rb#300
  def add_prerequisite(rr); end

  # Add a new Question to the Message. Takes either a Question,
  #  or a name, and an optional type and class.
  #
  # * msg.add_question(Question.new('example.com', 'MX'))
  # * msg.add_question('example.com') # defaults to Types.A, Classes.IN
  # * msg.add_question('example.com', Types.LOC)
  #
  # source://dnsruby//lib/dnsruby/message/message.rb#271
  def add_question(question, type = T.unsafe(nil), klass = T.unsafe(nil)); end

  # source://dnsruby//lib/dnsruby/message/message.rb#319
  def add_update(rr); end

  # Add a new Question to the Message. Takes either a Question,
  #  or a name, and an optional type and class.
  #
  # * msg.add_question(Question.new('example.com', 'MX'))
  # * msg.add_question('example.com') # defaults to Types.A, Classes.IN
  # * msg.add_question('example.com', Types.LOC)
  #
  # source://dnsruby//lib/dnsruby/message/message.rb#271
  def add_zone(question, type = T.unsafe(nil), klass = T.unsafe(nil)); end

  # The additional section, an array of Dnsruby::RR objects.
  #
  # source://dnsruby//lib/dnsruby/message/message.rb#144
  def additional; end

  # The answer section, an array of Dnsruby::RR objects.
  #
  # source://dnsruby//lib/dnsruby/message/message.rb#140
  def answer; end

  # If this Message is a response from a server, then answerfrom contains the address of the server
  #
  # source://dnsruby//lib/dnsruby/message/message.rb#149
  def answerfrom; end

  # If this Message is a response from a server, then answerfrom contains the address of the server
  #
  # source://dnsruby//lib/dnsruby/message/message.rb#149
  def answerfrom=(_arg0); end

  # If this Message is a response from a server, then answerfrom contains the IP address of the server
  #
  # source://dnsruby//lib/dnsruby/message/message.rb#152
  def answerip; end

  # If this Message is a response from a server, then answerfrom contains the IP address of the server
  #
  # source://dnsruby//lib/dnsruby/message/message.rb#152
  def answerip=(_arg0); end

  # If this Message is a response from a server, then answersize contains the size of the response
  #
  # source://dnsruby//lib/dnsruby/message/message.rb#155
  def answersize; end

  # If this Message is a response from a server, then answersize contains the size of the response
  #
  # source://dnsruby//lib/dnsruby/message/message.rb#155
  def answersize=(_arg0); end

  # The authority section, an array of Dnsruby::RR objects.
  #
  # source://dnsruby//lib/dnsruby/message/message.rb#142
  def authority; end

  # If the Message was returned from the cache, the cached flag will be set
  #  true. It will be false otherwise.
  #
  # source://dnsruby//lib/dnsruby/message/message.rb#92
  def cached; end

  # If the Message was returned from the cache, the cached flag will be set
  #  true. It will be false otherwise.
  #
  # source://dnsruby//lib/dnsruby/message/message.rb#92
  def cached=(_arg0); end

  # source://dnsruby//lib/dnsruby/message/message.rb#604
  def clone; end

  # do_caching is set by default. If you do not wish dnsruby to inspect the
  # cache before sending the query, nor cache the result of the query, then
  # set do_caching to false.
  #
  # source://dnsruby//lib/dnsruby/message/message.rb#190
  def do_caching; end

  # do_caching is set by default. If you do not wish dnsruby to inspect the
  # cache before sending the query, nor cache the result of the query, then
  # set do_caching to false.
  #
  # source://dnsruby//lib/dnsruby/message/message.rb#190
  def do_caching=(_arg0); end

  # do_validation is set by default. If you do not wish dnsruby to validate
  # this message (on a Resolver with @dnssec==true), then set do_validation
  # to false. This option does not affect caching, or the header options
  #
  # source://dnsruby//lib/dnsruby/message/message.rb#185
  def do_validation; end

  # do_validation is set by default. If you do not wish dnsruby to validate
  # this message (on a Resolver with @dnssec==true), then set do_validation
  # to false. This option does not affect caching, or the header options
  #
  # source://dnsruby//lib/dnsruby/message/message.rb#185
  def do_validation=(_arg0); end

  # source://dnsruby//lib/dnsruby/message/message.rb#339
  def each_additional; end

  # source://dnsruby//lib/dnsruby/message/message.rb#313
  def each_answer; end

  # source://dnsruby//lib/dnsruby/message/message.rb#326
  def each_authority; end

  # source://dnsruby//lib/dnsruby/message/message.rb#313
  def each_pre; end

  # source://dnsruby//lib/dnsruby/message/message.rb#313
  def each_prerequisite; end

  # source://dnsruby//lib/dnsruby/message/message.rb#279
  def each_question; end

  # Calls each_answer, each_authority, each_additional
  #
  # source://dnsruby//lib/dnsruby/message/message.rb#349
  def each_resource; end

  # Yields each section (question, answer, authority, additional)
  #
  # source://dnsruby//lib/dnsruby/message/message.rb#344
  def each_section; end

  # source://dnsruby//lib/dnsruby/message/message.rb#326
  def each_update; end

  # source://dnsruby//lib/dnsruby/message/message.rb#279
  def each_zone; end

  # Return the encoded form of the message
  #  If there is a TSIG record present and the record has not been signed
  #  then sign it
  #
  # source://dnsruby//lib/dnsruby/message/message.rb#541
  def encode(canonical = T.unsafe(nil)); end

  # source://dnsruby//lib/dnsruby/message/message.rb#192
  def get_exception; end

  # source://dnsruby//lib/dnsruby/message/message.rb#396
  def get_opt; end

  # The header section, a Dnsruby::Header object.
  #
  # source://dnsruby//lib/dnsruby/message/message.rb#146
  def header; end

  # The header section, a Dnsruby::Header object.
  #
  # source://dnsruby//lib/dnsruby/message/message.rb#146
  def header=(_arg0); end

  # source://dnsruby//lib/dnsruby/message/message.rb#459
  def old_to_s; end

  # The answer section, an array of Dnsruby::RR objects.
  #  In dynamic update packets, the answer section is known as pre or
  #  prerequisite and specifies the RRs or RRsets which must or
  #  must not preexist.
  #
  # source://dnsruby//lib/dnsruby/message/message.rb#140
  def pre; end

  # The answer section, an array of Dnsruby::RR objects.
  #  In dynamic update packets, the answer section is known as pre or
  #  prerequisite and specifies the RRs or RRsets which must or
  #  must not preexist.
  #  In dynamic update packets, the answer section is known as pre or
  #  prerequisite and specifies the RRs or RRsets which must or
  #  must not preexist.
  #
  # source://dnsruby//lib/dnsruby/message/message.rb#140
  def prerequisite; end

  # The question section, an array of Dnsruby::Question objects.
  #
  # source://dnsruby//lib/dnsruby/message/message.rb#137
  def question; end

  # source://dnsruby//lib/dnsruby/message/message.rb#400
  def rcode; end

  # source://dnsruby//lib/dnsruby/message/message.rb#229
  def remove_additional; end

  # Return the first rrset of the specified attributes in the message
  #
  # source://dnsruby//lib/dnsruby/message/message.rb#235
  def rrset(name, type, klass = T.unsafe(nil)); end

  # Return the rrsets of the specified type in the message
  #
  # source://dnsruby//lib/dnsruby/message/message.rb#245
  def rrsets(type, klass = T.unsafe(nil)); end

  # Return a hash, with the section as key, and the RRSets in that
  #  section as the data : {section => section_rrs}
  #
  # source://dnsruby//lib/dnsruby/message/message.rb#257
  def section_rrsets(type = T.unsafe(nil), include_opt = T.unsafe(nil)); end

  # If there was a problem verifying this message with DNSSEC, then securiy_error
  #  will hold a description of the problem. It defaults to ''
  #
  # source://dnsruby//lib/dnsruby/message/message.rb#88
  def security_error; end

  # If there was a problem verifying this message with DNSSEC, then securiy_error
  #  will hold a description of the problem. It defaults to ''
  #
  # source://dnsruby//lib/dnsruby/message/message.rb#88
  def security_error=(_arg0); end

  # If dnssec is set on, then each message will have the security level set
  #  To find the precise error (if any), call Dnsruby::Dnssec::validate(msg) -
  #  the resultant exception will define the error.
  #
  # source://dnsruby//lib/dnsruby/message/message.rb#84
  def security_level; end

  # If dnssec is set on, then each message will have the security level set
  #  To find the precise error (if any), call Dnsruby::Dnssec::validate(msg) -
  #  the resultant exception will define the error.
  #
  # source://dnsruby//lib/dnsruby/message/message.rb#84
  def security_level=(_arg0); end

  # Set send_raw if you wish to send and receive the response to this Message
  # with no additional processing. In other words, if set, then Dnsruby will
  # not touch the Header of the outgoing Message. This option does not affect
  # caching or dnssec validation
  #
  # This option should not normally be set.
  #
  # source://dnsruby//lib/dnsruby/message/message.rb#180
  def send_raw; end

  # Set send_raw if you wish to send and receive the response to this Message
  # with no additional processing. In other words, if set, then Dnsruby will
  # not touch the Header of the outgoing Message. This option does not affect
  # caching or dnssec validation
  #
  # This option should not normally be set.
  #
  # source://dnsruby//lib/dnsruby/message/message.rb#180
  def send_raw=(_arg0); end

  # Sets the TSIG to sign this message with. Can either be a Dnsruby::RR::TSIG
  #  object, or it can be a (name, key) tuple, or it can be a hash which takes
  #  Dnsruby::RR::TSIG attributes (e.g. name, key, fudge, etc.)
  #
  # source://dnsruby//lib/dnsruby/message/message.rb#368
  def set_tsig(*args); end

  # Signs the message. If used with no arguments, then the message must have already
  #  been set (set_tsig). Otherwise, the arguments can either be a Dnsruby::RR::TSIG
  #  object, or a (name, key) tuple, or a hash which takes
  #  Dnsruby::RR::TSIG attributes (e.g. name, key, fudge, etc.)
  #
  #  NOTE that this method should only be called by the resolver, rather than the
  #  client code. To use signing from the client, call Dnsruby::Resolver#tsig=
  #
  # source://dnsruby//lib/dnsruby/message/message.rb#527
  def sign!(*args); end

  # Was this message signed by a TSIG?
  #
  # @return [Boolean]
  #
  # source://dnsruby//lib/dnsruby/message/message.rb#385
  def signed?; end

  # source://dnsruby//lib/dnsruby/message/message.rb#410
  def to_s; end

  # Returns the TSIG record from the ADDITIONAL section, if one is present.
  #
  # source://dnsruby//lib/dnsruby/message/message.rb#356
  def tsig; end

  # If this message has been verified using a TSIG RR then tsigerror contains
  # the error code returned by the TSIG verification. The error will be an RCode
  #
  # source://dnsruby//lib/dnsruby/message/message.rb#159
  def tsigerror; end

  # If this message has been verified using a TSIG RR then tsigerror contains
  # the error code returned by the TSIG verification. The error will be an RCode
  #
  # source://dnsruby//lib/dnsruby/message/message.rb#159
  def tsigerror=(_arg0); end

  # --
  #
  # source://dnsruby//lib/dnsruby/message/message.rb#171
  def tsigstart; end

  # --
  #
  # source://dnsruby//lib/dnsruby/message/message.rb#171
  def tsigstart=(_arg0); end

  # Can be
  # * :Unsigned - the default state
  # * :Signed - the outgoing message has been signed
  # * :Verified - the incoming message has been verified by TSIG
  # * :Intermediate - the incoming message is an intermediate envelope in a TCP session
  # in which only every 100th envelope must be signed
  # * :Failed - the incoming response failed verification
  #
  # source://dnsruby//lib/dnsruby/message/message.rb#168
  def tsigstate; end

  # Can be
  # * :Unsigned - the default state
  # * :Signed - the outgoing message has been signed
  # * :Verified - the incoming message has been verified by TSIG
  # * :Intermediate - the incoming message is an intermediate envelope in a TCP session
  # in which only every 100th envelope must be signed
  # * :Failed - the incoming response failed verification
  #
  # source://dnsruby//lib/dnsruby/message/message.rb#168
  def tsigstate=(_arg0); end

  # The authority section, an array of Dnsruby::RR objects.
  #  In dynamic update packets, the authority section is known as update and
  #  specifies the RRs or RRsets to be added or delted.
  #
  # source://dnsruby//lib/dnsruby/message/message.rb#142
  def update; end

  # source://dnsruby//lib/dnsruby/message/message.rb#285
  def update_counts; end

  # If this message was signed by a TSIG, was the TSIG verified?
  #
  # @return [Boolean]
  #
  # source://dnsruby//lib/dnsruby/message/message.rb#392
  def verified?; end

  # The question section, an array of Dnsruby::Question objects.
  #  In dynamic update packets, the question section is known as zone and
  #  specifies the zone to be updated.
  #
  # source://dnsruby//lib/dnsruby/message/message.rb#137
  def zone; end

  private

  # source://dnsruby//lib/dnsruby/message/message.rb#292
  def _add_answer(rr, force = T.unsafe(nil)); end

  class << self
    # Decode the encoded message
    #
    # source://dnsruby//lib/dnsruby/message/message.rb#564
    def decode(m); end
  end
end

# The security level (see RFC 4035 section 4.3)
#
# source://dnsruby//lib/dnsruby/message/message.rb#72
class Dnsruby::Message::SecurityLevel < ::Dnsruby::CodeMapper; end

# source://dnsruby//lib/dnsruby/message/message.rb#74
Dnsruby::Message::SecurityLevel::BOGUS = T.let(T.unsafe(nil), Integer)

# source://dnsruby//lib/dnsruby/message/message.rb#73
Dnsruby::Message::SecurityLevel::INDETERMINATE = T.let(T.unsafe(nil), Integer)

# source://dnsruby//lib/dnsruby/message/message.rb#76
Dnsruby::Message::SecurityLevel::INSECURE = T.let(T.unsafe(nil), Integer)

# source://dnsruby//lib/dnsruby/message/message.rb#77
Dnsruby::Message::SecurityLevel::SECURE = T.let(T.unsafe(nil), Integer)

# source://dnsruby//lib/dnsruby/message/message.rb#75
Dnsruby::Message::SecurityLevel::UNCHECKED = T.let(T.unsafe(nil), Integer)

# This class decodes a binary string containing the raw bytes of the message
# as in coming over the wire from a nameserver, and parses it into a
# Dnsruby::Message.
#
# source://dnsruby//lib/dnsruby/message/decoder.rb#6
class Dnsruby::MessageDecoder
  # Creates an instance of the decoder, optionally with code block
  # to be executed with the instance as its parameter.
  #
  # @return [MessageDecoder] a new instance of MessageDecoder
  # @yield [_self]
  # @yieldparam _self [Dnsruby::MessageDecoder] the object that the method was called on
  #
  # source://dnsruby//lib/dnsruby/message/decoder.rb#16
  def initialize(data); end

  # Asserts that the specified position is a valid position in the buffer.
  # If not, raises a DecodeError.  If so, does nothing.
  #
  # source://dnsruby//lib/dnsruby/message/decoder.rb#30
  def assert_buffer_position_valid(end_position); end

  # Keeps a running @index containing the current position (like a cursor)
  # into the binary string.  In general 'get_' methods will position @index
  # to follow the data they have read.
  #
  # source://dnsruby//lib/dnsruby/message/decoder.rb#12
  def data; end

  # Gets the byte value at the specified position
  #
  # source://dnsruby//lib/dnsruby/message/decoder.rb#37
  def get_byte_at(position); end

  # Returns the specified number of bytes from the binary string.
  # Length defaults to the remaining (not yet processed) size of the string.
  #
  # source://dnsruby//lib/dnsruby/message/decoder.rb#65
  def get_bytes(len = T.unsafe(nil)); end

  # Gets a single label.
  #
  # source://dnsruby//lib/dnsruby/message/decoder.rb#147
  def get_label; end

  # Returns labels starting at @index.
  #
  # source://dnsruby//lib/dnsruby/message/decoder.rb#118
  def get_labels(limit = T.unsafe(nil)); end

  # Gets a 16-bit length field from the binary string and yields to the block.
  # This will be the length of the next item to parse in the binary string.
  # Returns the object returned from that block.
  #
  # When this method returns, @index will point to the byte after the
  # 16-bit length field.
  #
  # source://dnsruby//lib/dnsruby/message/decoder.rb#49
  def get_length16; end

  # Gets a Name from the current @index position.
  #
  # source://dnsruby//lib/dnsruby/message/decoder.rb#113
  def get_name; end

  # Gets a question record.
  #
  # source://dnsruby//lib/dnsruby/message/decoder.rb#156
  def get_question; end

  # Gets a resource record.
  #
  # source://dnsruby//lib/dnsruby/message/decoder.rb#164
  def get_rr; end

  # Gets a string whose 1-byte length is at @index, and the string starting at @index + 1.
  #
  # source://dnsruby//lib/dnsruby/message/decoder.rb#97
  def get_string; end

  # Gets all strings from @index to the end of the binary string.
  #
  # source://dnsruby//lib/dnsruby/message/decoder.rb#106
  def get_string_list; end

  # Calls String.unpack to get numbers as specified in the template string.
  #
  # source://dnsruby//lib/dnsruby/message/decoder.rb#72
  def get_unpack(template); end

  # Has bytes remaining in the binary string to be parsed?
  #
  # @return [Boolean]
  #
  # source://dnsruby//lib/dnsruby/message/decoder.rb#24
  def has_remaining?; end

  # Keeps a running @index containing the current position (like a cursor)
  # into the binary string.  In general 'get_' methods will position @index
  # to follow the data they have read.
  #
  # source://dnsruby//lib/dnsruby/message/decoder.rb#12
  def index; end
end

# source://dnsruby//lib/dnsruby/message/encoder.rb#2
class Dnsruby::MessageEncoder
  # @return [MessageEncoder] a new instance of MessageEncoder
  # @yield [_self]
  # @yieldparam _self [Dnsruby::MessageEncoder] the object that the method was called on
  #
  # source://dnsruby//lib/dnsruby/message/encoder.rb#3
  def initialize; end

  # source://dnsruby//lib/dnsruby/message/encoder.rb#13
  def put_bytes(d); end

  # @raise [RuntimeError]
  #
  # source://dnsruby//lib/dnsruby/message/encoder.rb#76
  def put_label(d); end

  # source://dnsruby//lib/dnsruby/message/encoder.rb#61
  def put_labels(d, do_canonical); end

  # source://dnsruby//lib/dnsruby/message/encoder.rb#25
  def put_length16; end

  # source://dnsruby//lib/dnsruby/message/encoder.rb#54
  def put_name(d, canonical = T.unsafe(nil), downcase = T.unsafe(nil)); end

  # source://dnsruby//lib/dnsruby/message/encoder.rb#17
  def put_pack(template, *d); end

  # source://dnsruby//lib/dnsruby/message/encoder.rb#47
  def put_rr(rr, canonical = T.unsafe(nil)); end

  # source://dnsruby//lib/dnsruby/message/encoder.rb#34
  def put_string(d); end

  # source://dnsruby//lib/dnsruby/message/encoder.rb#43
  def put_string_list(ds); end

  # source://dnsruby//lib/dnsruby/message/encoder.rb#9
  def to_s; end
end

# source://dnsruby//lib/dnsruby/code_mappers.rb#264
class Dnsruby::MetaTypes < ::Dnsruby::CodeMapper; end

# RFC 2671
#
# source://dnsruby//lib/dnsruby/code_mappers.rb#267
Dnsruby::MetaTypes::OPT = T.let(T.unsafe(nil), Integer)

# Transaction Key   [RFC2930]
#
# source://dnsruby//lib/dnsruby/code_mappers.rb#265
Dnsruby::MetaTypes::TKEY = T.let(T.unsafe(nil), Integer)

# Transaction Signature  [RFC2845]
#
# source://dnsruby//lib/dnsruby/code_mappers.rb#266
Dnsruby::MetaTypes::TSIG = T.let(T.unsafe(nil), Integer)

# source://dnsruby//lib/dnsruby/resource/TKEY.rb#18
class Dnsruby::Modes < ::Dnsruby::CodeMapper; end

# The key should be deleted
#
# source://dnsruby//lib/dnsruby/resource/TKEY.rb#32
Dnsruby::Modes::DELETE = T.let(T.unsafe(nil), Integer)

# The key is computed using a Diffie-Hellman key exchange
#
# source://dnsruby//lib/dnsruby/resource/TKEY.rb#23
Dnsruby::Modes::DIFFIEHELLMAN = T.let(T.unsafe(nil), Integer)

# The key is computed using GSS_API (unimplemented)
#
# source://dnsruby//lib/dnsruby/resource/TKEY.rb#26
Dnsruby::Modes::GSSAPI = T.let(T.unsafe(nil), Integer)

# The key is assigned by the resolver (unimplemented)
#
# source://dnsruby//lib/dnsruby/resource/TKEY.rb#29
Dnsruby::Modes::RESOLVERASSIGNED = T.let(T.unsafe(nil), Integer)

# The key is assigned by the server (unimplemented)
#
# source://dnsruby//lib/dnsruby/resource/TKEY.rb#20
Dnsruby::Modes::SERVERASSIGNED = T.let(T.unsafe(nil), Integer)

# The requested domain does not exist
#
# source://dnsruby//lib/dnsruby.rb#169
class Dnsruby::NXDomain < ::Dnsruby::ResolvError; end

# Some RRSet that ought not to exist, does exist (in dynamic update)
#
# source://dnsruby//lib/dnsruby.rb#201
class Dnsruby::NXRRSet < ::Dnsruby::ResolvError; end

# source://dnsruby//lib/dnsruby/name.rb#31
class Dnsruby::Name
  include ::Comparable

  # This method should only be called internally.
  # Use Name::create to create a new Name
  #
  # @return [Name] a new instance of Name
  #
  # source://dnsruby//lib/dnsruby/name.rb#95
  def initialize(labels, absolute = T.unsafe(nil)); end

  # source://dnsruby//lib/dnsruby/name.rb#151
  def <=>(other); end

  # source://dnsruby//lib/dnsruby/name.rb#190
  def ==(other); end

  # source://dnsruby//lib/dnsruby/name.rb#226
  def [](i); end

  # source://dnsruby//lib/dnsruby/name.rb#125
  def absolute=(on); end

  # Returns true if this Name is absolute
  #
  # @return [Boolean]
  #
  # source://dnsruby//lib/dnsruby/name.rb#121
  def absolute?; end

  # Return the canonical form of this name (RFC 4034 section 6.2)
  #
  # source://dnsruby//lib/dnsruby/name.rb#143
  def canonical; end

  # source://dnsruby//lib/dnsruby/name.rb#160
  def canonically_before(n); end

  # source://dnsruby//lib/dnsruby/name.rb#110
  def downcase; end

  # source://dnsruby//lib/dnsruby/name.rb#190
  def eql?(other); end

  # source://dnsruby//lib/dnsruby/name.rb#214
  def hash; end

  # source://dnsruby//lib/dnsruby/name.rb#116
  def inspect; end

  # Returns the value of attribute labels.
  #
  # source://dnsruby//lib/dnsruby/name.rb#91
  def labels; end

  # Sets the attribute labels
  #
  # @param value the value to set the attribute labels to.
  #
  # source://dnsruby//lib/dnsruby/name.rb#91
  def labels=(_arg0); end

  # source://dnsruby//lib/dnsruby/name.rb#222
  def length; end

  # source://dnsruby//lib/dnsruby/name.rb#129
  def strip_label; end

  # Tests subdomain-of relation : returns true if this name
  #  is a subdomain of +other+.
  #
  #    domain = Resolv::Name.create("y.z")
  #    p Resolv::Name.create("w.x.y.z").subdomain_of?(domain) #=> true
  #    p Resolv::Name.create("x.y.z").subdomain_of?(domain) #=> true
  #    p Resolv::Name.create("y.z").subdomain_of?(domain) #=> false
  #    p Resolv::Name.create("z").subdomain_of?(domain) #=> false
  #    p Resolv::Name.create("x.y.z.").subdomain_of?(domain) #=> false
  #    p Resolv::Name.create("w.z").subdomain_of?(domain) #=> false
  #
  # @raise [ArgumentError]
  # @return [Boolean]
  #
  # source://dnsruby//lib/dnsruby/name.rb#206
  def subdomain_of?(other); end

  # source://dnsruby//lib/dnsruby/name.rb#218
  def to_a; end

  # returns the domain name as a string.
  #
  #  The domain name doesn't have a trailing dot even if the name object is
  #  absolute.
  #
  #  Example :
  #
  #    p Resolv::Name.create("x.y.z.").to_s #=> "x.y.z"
  #    p Resolv::Name.create("x.y.z").to_s #=> "x.y.z"
  #
  # source://dnsruby//lib/dnsruby/name.rb#240
  def to_s(include_absolute = T.unsafe(nil)); end

  # source://dnsruby//lib/dnsruby/name.rb#248
  def to_str(labels); end

  # Is this name a wildcard?
  #
  # @return [Boolean]
  #
  # source://dnsruby//lib/dnsruby/name.rb#135
  def wild?; end

  class << self
    # --
    #  A Name is a collection of Labels. Each label is presentation-formatted
    #  When a Name is wire-encoded, the label array is walked, and each label is wire-encoded.
    #  When a Name is unencoded, each label is unencoded, and added to the Name collection of labels.
    #  When a Name is made from a string, the Name is split into Labels.
    # ++
    # Creates a new Dnsruby::Name from +arg+. +arg+ can be :
    #
    # * Name:: returns +arg+
    # * String:: returns a new Name
    #
    # source://dnsruby//lib/dnsruby/name.rb#44
    def create(arg); end

    # source://dnsruby//lib/dnsruby/name.rb#282
    def decode(wire); end

    # wire,leftover=presentation2wire(leftover)
    #  Will parse the input presentation format and return everything before
    #  the first non-escaped "." in the first element of the return array and
    #  all that has not been parsed yet in the 2nd argument.
    #
    # source://dnsruby//lib/dnsruby/name.rb#328
    def encode(presentation); end

    # Utility function
    #
    #  name2labels to translate names from presentation format into an
    #  array of "wire-format" labels.
    #  in: dName a string with a domain name in presentation format (1035
    #  sect 5.1)
    #  out: an array of labels in wire format.
    #
    # source://dnsruby//lib/dnsruby/name.rb#262
    def name2encodedlabels(dName); end

    # Convert IDN domain from Unicode UTF-8 to ASCII punycode
    #
    # @example
    #   Dnsruby::Name.punycode('.cf')
    #   => "xn--en8h.cf"
    # @param d [Object|String] Unicode domain with emoji inside
    # @return [String] ASCII punycode domain
    #
    # source://dnsruby//lib/dnsruby/name.rb#72
    def punycode(d); end

    # source://dnsruby//lib/dnsruby/name.rb#85
    def split(name); end

    # source://dnsruby//lib/dnsruby/name.rb#80
    def split_escaped(arg); end
  end
end

# == Dnsruby::Label class
#
# (RFC1035, section 3.1)
#
# source://dnsruby//lib/dnsruby/name.rb#383
class Dnsruby::Name::Label
  include ::Comparable

  # @return [Label] a new instance of Label
  #
  # source://dnsruby//lib/dnsruby/name.rb#396
  def initialize(string); end

  # source://dnsruby//lib/dnsruby/name.rb#418
  def <=>(other); end

  # source://dnsruby//lib/dnsruby/name.rb#423
  def ==(other); end

  # Returns the value of attribute downcase.
  #
  # source://dnsruby//lib/dnsruby/name.rb#404
  def downcase; end

  # @return [Boolean]
  #
  # source://dnsruby//lib/dnsruby/name.rb#427
  def eql?(other); end

  # source://dnsruby//lib/dnsruby/name.rb#431
  def hash; end

  # source://dnsruby//lib/dnsruby/name.rb#414
  def inspect; end

  # source://dnsruby//lib/dnsruby/name.rb#410
  def length; end

  # Returns the value of attribute string.
  #
  # source://dnsruby//lib/dnsruby/name.rb#404
  def string; end

  # source://dnsruby//lib/dnsruby/name.rb#406
  def to_s; end

  class << self
    # source://dnsruby//lib/dnsruby/name.rb#392
    def set_max_length(l); end

    # Split a Name into its component Labels
    #
    # source://dnsruby//lib/dnsruby/name.rb#388
    def split(arg); end
  end
end

# source://dnsruby//lib/dnsruby/name.rb#385
Dnsruby::Name::Label::MaxLabelLength = T.let(T.unsafe(nil), Integer)

# source://dnsruby//lib/dnsruby/name.rb#33
Dnsruby::Name::MaxNameLength = T.let(T.unsafe(nil), Integer)

# The nameserver is not responsible for the zone (in dynamic update)
#
# source://dnsruby//lib/dnsruby.rb#205
class Dnsruby::NotAuth < ::Dnsruby::ResolvError; end

# The requested operation is not implemented in the remote resolver
#
# source://dnsruby//lib/dnsruby.rb#181
class Dnsruby::NotImp < ::Dnsruby::ResolvError; end

# The update RR is outside the zone (in dynamic update)
#
# source://dnsruby//lib/dnsruby.rb#189
class Dnsruby::NotZone < ::Dnsruby::ResolvError; end

# http://www.iana.org/assignments/dnssec-nsec3-parameters/dnssec-nsec3-parameters.xhtml
#
# source://dnsruby//lib/dnsruby/code_mappers.rb#294
class Dnsruby::Nsec3HashAlgorithms < ::Dnsruby::CodeMapper; end

# source://dnsruby//lib/dnsruby/code_mappers.rb#295
Dnsruby::Nsec3HashAlgorithms::RESERVED = T.let(T.unsafe(nil), Integer)

# source://dnsruby//lib/dnsruby/code_mappers.rb#5
class Dnsruby::OpCode < ::Dnsruby::CodeMapper; end

# RFC 1035
#
# source://dnsruby//lib/dnsruby/code_mappers.rb#7
Dnsruby::OpCode::IQuery = T.let(T.unsafe(nil), Integer)

# RFC 1996
#
# source://dnsruby//lib/dnsruby/code_mappers.rb#9
Dnsruby::OpCode::Notify = T.let(T.unsafe(nil), Integer)

# RFC 1035
#
# source://dnsruby//lib/dnsruby/code_mappers.rb#6
Dnsruby::OpCode::Query = T.let(T.unsafe(nil), Integer)

# RFC 1035
#
# source://dnsruby//lib/dnsruby/code_mappers.rb#8
Dnsruby::OpCode::Status = T.let(T.unsafe(nil), Integer)

# RFC 2136
#
# source://dnsruby//lib/dnsruby/code_mappers.rb#10
Dnsruby::OpCode::Update = T.let(T.unsafe(nil), Integer)

# Another kind of resolver error has occurred
#
# source://dnsruby//lib/dnsruby.rb#210
class Dnsruby::OtherResolvError < ::Dnsruby::ResolvError; end

# source://dnsruby//lib/dnsruby/packet_sender.rb#21
class Dnsruby::PacketSender
  include ::Socket::Constants

  # Can take a hash with the following optional keys :
  #
  #  * :server
  #  * :port
  #  * :use_tcp
  #  * :tcp_pipelining
  #  * :tcp_pipelining_max_queries
  #  * :no_tcp
  #  * :ignore_truncation
  #  * :src_address
  #  * :src_address6
  #  * :src_port
  #  * :udp_size
  #  * :tsig
  #  * :packet_timeout
  #  * :recurse
  #
  # @return [PacketSender] a new instance of PacketSender
  #
  # source://dnsruby//lib/dnsruby/packet_sender.rb#188
  def initialize(*args); end

  # source://dnsruby//lib/dnsruby/packet_sender.rb#735
  def add_opt_rr(packet); end

  # Can be a single Integer or a Range or an Array
  #  If an invalid port is selected (one reserved by
  #  IANA), then an ArgumentError will be raised.
  #  "0" means "any valid port" - this is only a viable
  #  option if it is the only port in the list.
  #  An ArgumentError will be raised if "0" is added to
  #  an existing set of source ports.
  #
  #         res.add_src_port(60000)
  #         res.add_src_port([60001,60005,60010])
  #         res.add_src_port(60015..60115)
  #
  # source://dnsruby//lib/dnsruby/packet_sender.rb#590
  def add_src_port(p); end

  # source://dnsruby//lib/dnsruby/packet_sender.rb#236
  def check_ipv6; end

  # source://dnsruby//lib/dnsruby/packet_sender.rb#624
  def check_response(response, response_bytes, query, client_queue, client_query_id, tcp); end

  # source://dnsruby//lib/dnsruby/packet_sender.rb#679
  def check_tsig(query, response, response_bytes); end

  # source://dnsruby//lib/dnsruby/packet_sender.rb#252
  def close; end

  # Use DNSSEC for this PacketSender
  #  dnssec defaults to ON
  #
  # source://dnsruby//lib/dnsruby/packet_sender.rb#122
  def dnssec; end

  # source://dnsruby//lib/dnsruby/packet_sender.rb#151
  def dnssec=(on); end

  # source://dnsruby//lib/dnsruby/packet_sender.rb#603
  def get_next_src_port; end

  # Don't worry if the response is truncated - return it anyway.
  #
  #  Defaults to false
  #
  # source://dnsruby//lib/dnsruby/packet_sender.rb#100
  def ignore_truncation; end

  # Don't worry if the response is truncated - return it anyway.
  #
  #  Defaults to false
  #
  # source://dnsruby//lib/dnsruby/packet_sender.rb#100
  def ignore_truncation=(_arg0); end

  # source://dnsruby//lib/dnsruby/packet_sender.rb#702
  def make_query(name, type = T.unsafe(nil), klass = T.unsafe(nil), set_cd = T.unsafe(nil)); end

  # Prepare the packet for sending
  #
  # source://dnsruby//lib/dnsruby/packet_sender.rb#713
  def make_query_packet(packet, use_tcp = T.unsafe(nil)); end

  # Use UDP only - don't use TCP
  #  For test/debug purposes only
  #  Defaults to false
  #
  # source://dnsruby//lib/dnsruby/packet_sender.rb#92
  def no_tcp; end

  # Use UDP only - don't use TCP
  #  For test/debug purposes only
  #  Defaults to false
  #
  # source://dnsruby//lib/dnsruby/packet_sender.rb#92
  def no_tcp=(_arg0); end

  # Returns the value of attribute packet_timeout.
  #
  # source://dnsruby//lib/dnsruby/packet_sender.rb#69
  def packet_timeout; end

  # Sets the attribute packet_timeout
  #
  # @param value the value to set the attribute packet_timeout to.
  #
  # source://dnsruby//lib/dnsruby/packet_sender.rb#69
  def packet_timeout=(_arg0); end

  # The port on the resolver to send queries to.
  #
  #  Defaults to 53
  #
  # source://dnsruby//lib/dnsruby/packet_sender.rb#74
  def port; end

  # The port on the resolver to send queries to.
  #
  #  Defaults to 53
  #
  # source://dnsruby//lib/dnsruby/packet_sender.rb#74
  def port=(_arg0); end

  # source://dnsruby//lib/dnsruby/packet_sender.rb#746
  def prepare_for_dnssec(packet); end

  # should the Recursion Desired bit be set on queries?
  #
  #  Defaults to true
  #
  # source://dnsruby//lib/dnsruby/packet_sender.rb#110
  def recurse; end

  # should the Recursion Desired bit be set on queries?
  #
  #  Defaults to true
  #
  # source://dnsruby//lib/dnsruby/packet_sender.rb#110
  def recurse=(_arg0); end

  # Asynchronously send a Message to the server. The send can be done using just
  # Dnsruby. Support for EventMachine has been deprecated.
  #
  # == Dnsruby pure Ruby event loop :
  #
  # A client_queue is supplied by the client,
  # along with an optional client_query_id to identify the response. The client_query_id
  # is generated, if not supplied, and returned to the client.
  # When the response is known, the tuple
  # (query_id, response_message, response_exception) is put in the queue for the client to process.
  #
  # The query is sent synchronously in the caller's thread. The select thread is then used to
  # listen for and process the response (up to pushing it to the client_queue). The client thread
  # is then used to retrieve the response and deal with it.
  #
  # Takes :
  #
  # * msg - the message to send
  # * client_queue - a Queue to push the response to, when it arrives
  # * client_query_id - an optional ID to identify the query to the client
  # * use_tcp - whether to use TCP (defaults to PacketSender.use_tcp)
  #
  # Returns :
  #
  # * client_query_id - to identify the query response to the client. This ID is
  # generated if it is not passed in by the client
  #
  # If the native Dsnruby networking layer is being used, then this method returns the client_query_id
  #
  #     id = res.send_async(msg, queue)
  #     NOT SUPPORTED : id = res.send_async(msg, queue, use_tcp)
  #     id = res.send_async(msg, queue, id)
  #     id = res.send_async(msg, queue, id, use_tcp)
  #
  # Use Message#send_raw to send the packet with an untouched header.
  # Use Message#do_caching to tell dnsruby whether to check the cache before
  # sending, and update the cache upon receiving a response.
  # Use Message#do_validation to tell dnsruby whether or not to do DNSSEC
  # validation for this particular packet (assuming SingleResolver#dnssec == true)
  # Note that these options should not normally be used!
  #
  # source://dnsruby//lib/dnsruby/packet_sender.rb#297
  def send_async(*args); end

  # This method sends the packet using the built-in pure Ruby event loop, with no dependencies.
  #
  # source://dnsruby//lib/dnsruby/packet_sender.rb#438
  def send_dnsruby(query_bytes, query, client_query_id, client_queue, use_tcp); end

  # The address of the resolver to send queries to
  #
  # source://dnsruby//lib/dnsruby/packet_sender.rb#118
  def server; end

  # source://dnsruby//lib/dnsruby/packet_sender.rb#166
  def server=(server); end

  # The source address to send queries from
  #
  #  Defaults to localhost
  #
  # source://dnsruby//lib/dnsruby/packet_sender.rb#105
  def src_address; end

  # Set the source address. If the arg is nil, do nothing
  #
  # source://dnsruby//lib/dnsruby/packet_sender.rb#125
  def src_address6=(arg); end

  # Set the source address. If the arg is nil, do nothing
  #
  # source://dnsruby//lib/dnsruby/packet_sender.rb#132
  def src_address=(arg); end

  # The source port to send queries from
  #  Returns either a single Integer or an Array
  #  e.g. "0", or "[60001, 60002, 60007]"
  #
  #  Defaults to 0 - random port
  #
  # source://dnsruby//lib/dnsruby/packet_sender.rb#558
  def src_port; end

  # Can be a single Integer or a Range or an Array
  #  If an invalid port is selected (one reserved by
  #  IANA), then an ArgumentError will be raised.
  #
  #         res.src_port=0
  #         res.src_port=[60001,60005,60010]
  #         res.src_port=60015..60115
  #
  # source://dnsruby//lib/dnsruby/packet_sender.rb#573
  def src_port=(p); end

  # This method returns the current tcp socket for pipelining
  #  If this is the first time the method is called then the socket is bound to
  #  @src_address:@src_port and connected to the remote dns server @server:@port.
  #  If the connection has been closed because of an EOF on recv_nonblock (closed by server)
  #  the function will recreate of the socket (since @pipeline_socket.connect will result in a IOError
  #  exception)
  #  In general, every subsequent call the function will either return the current tcp
  #  pipeline socket or a new connected socket if the current one was closed by the server
  #
  # source://dnsruby//lib/dnsruby/packet_sender.rb#387
  def tcp_pipeline_socket(src_port); end

  # Reuse tcp connection
  #
  # Defaults to false
  #
  # source://dnsruby//lib/dnsruby/packet_sender.rb#84
  def tcp_pipelining; end

  # Reuse tcp connection
  #
  # Defaults to false
  #
  # source://dnsruby//lib/dnsruby/packet_sender.rb#84
  def tcp_pipelining=(_arg0); end

  # Limit the number of queries per pipeline
  #
  # source://dnsruby//lib/dnsruby/packet_sender.rb#87
  def tcp_pipelining_max_queries; end

  # Limit the number of queries per pipeline
  #
  # source://dnsruby//lib/dnsruby/packet_sender.rb#87
  def tcp_pipelining_max_queries=(_arg0); end

  # The TSIG record to sign/verify messages with
  #
  # source://dnsruby//lib/dnsruby/packet_sender.rb#95
  def tsig; end

  # Sets the TSIG to sign outgoing messages with.
  # Pass in either a Dnsruby::RR::TSIG, or a key_name and key (or just a key)
  # Pass in nil to stop tsig signing.
  # It is possible for client code to sign packets prior to sending - see
  # Dnsruby::RR::TSIG#apply and Dnsruby::Message#sign
  # Note that pre-signed packets will not be signed by PacketSender.
  # * res.tsig=(tsig_rr)
  # * res.tsig=(key_name, key)
  # * res.tsig=nil # Stop the resolver from signing
  #
  # source://dnsruby//lib/dnsruby/packet_sender.rb#147
  def tsig=(*args); end

  # Return the packet size to use for UDP
  #
  # source://dnsruby//lib/dnsruby/packet_sender.rb#769
  def udp_packet_size; end

  # The max UDP packet size
  #
  #  Defaults to 512
  #
  # source://dnsruby//lib/dnsruby/packet_sender.rb#115
  def udp_size; end

  # source://dnsruby//lib/dnsruby/packet_sender.rb#162
  def udp_size=(size); end

  # Use TCP rather than UDP as the transport.
  #
  #  Defaults to false
  #
  # source://dnsruby//lib/dnsruby/packet_sender.rb#79
  def use_tcp; end

  # Use TCP rather than UDP as the transport.
  #
  #  Defaults to false
  #
  # source://dnsruby//lib/dnsruby/packet_sender.rb#79
  def use_tcp=(_arg0); end

  class << self
    # source://dnsruby//lib/dnsruby/packet_sender.rb#29
    def cache(query, response); end

    # source://dnsruby//lib/dnsruby/packet_sender.rb#51
    def cache_authoritative(answer); end

    # source://dnsruby//lib/dnsruby/packet_sender.rb#56
    def cache_recursive(answer); end

    # source://dnsruby//lib/dnsruby/packet_sender.rb#60
    def clear_caches; end

    # source://dnsruby//lib/dnsruby/packet_sender.rb#65
    def recursive_cache_length; end
  end
end

# source://dnsruby//lib/dnsruby/resource/APL.rb#2
class Dnsruby::Prefix
  # @return [Prefix] a new instance of Prefix
  #
  # source://dnsruby//lib/dnsruby/resource/APL.rb#34
  def initialize(af, prefix_length, negative, address_length, address); end

  # Returns the value of attribute address.
  #
  # source://dnsruby//lib/dnsruby/resource/APL.rb#4
  def address; end

  # Returns the value of attribute address_lenght.
  #
  # source://dnsruby//lib/dnsruby/resource/APL.rb#4
  def address_lenght; end

  # Returns the value of attribute af.
  #
  # source://dnsruby//lib/dnsruby/resource/APL.rb#4
  def af; end

  # Returns the value of attribute negative.
  #
  # source://dnsruby//lib/dnsruby/resource/APL.rb#4
  def negative; end

  # Returns the value of attribute prefix_length.
  #
  # source://dnsruby//lib/dnsruby/resource/APL.rb#4
  def prefix_length; end

  # source://dnsruby//lib/dnsruby/resource/APL.rb#48
  def put_msg(msg); end

  # source://dnsruby//lib/dnsruby/resource/APL.rb#44
  def to_s; end

  class << self
    # source://dnsruby//lib/dnsruby/resource/APL.rb#6
    def create(prefix); end
  end
end

# source://dnsruby//lib/dnsruby/resource/APL.rb#3
Dnsruby::Prefix::Regex = T.let(T.unsafe(nil), Regexp)

# source://dnsruby//lib/dnsruby/resource/APL.rb#53
class Dnsruby::Prefixes
  # @return [Prefixes] a new instance of Prefixes
  #
  # source://dnsruby//lib/dnsruby/resource/APL.rb#93
  def initialize(prefixes); end

  # source://dnsruby//lib/dnsruby/resource/APL.rb#101
  def encode_rdata(msg, _canonical = T.unsafe(nil)); end

  # Returns the value of attribute prefixes.
  #
  # source://dnsruby//lib/dnsruby/resource/APL.rb#54
  def prefixes; end

  # Sets the attribute prefixes
  #
  # @param value the value to set the attribute prefixes to.
  #
  # source://dnsruby//lib/dnsruby/resource/APL.rb#54
  def prefixes=(_arg0); end

  # source://dnsruby//lib/dnsruby/resource/APL.rb#97
  def to_s; end

  class << self
    # source://dnsruby//lib/dnsruby/resource/APL.rb#56
    def create(arg); end

    # source://dnsruby//lib/dnsruby/resource/APL.rb#69
    def create_from_message(msg); end
  end
end

# source://dnsruby//lib/dnsruby/code_mappers.rb#255
class Dnsruby::QTypes < ::Dnsruby::CodeMapper; end

# all records                      [RFC1035]
#
# source://dnsruby//lib/dnsruby/code_mappers.rb#260
Dnsruby::QTypes::ANY = T.let(T.unsafe(nil), Integer)

# transfer of an entire zone          [RFC1035]
#
# source://dnsruby//lib/dnsruby/code_mappers.rb#257
Dnsruby::QTypes::AXFR = T.let(T.unsafe(nil), Integer)

# incremental transfer                [RFC1995]
#
# source://dnsruby//lib/dnsruby/code_mappers.rb#256
Dnsruby::QTypes::IXFR = T.let(T.unsafe(nil), Integer)

# mail agent RRs (Obsolete - see MX)   [RFC1035]
#
# source://dnsruby//lib/dnsruby/code_mappers.rb#259
Dnsruby::QTypes::MAILA = T.let(T.unsafe(nil), Integer)

# mailbox-related RRs (MB, MG or MR)   [RFC1035]
#
# source://dnsruby//lib/dnsruby/code_mappers.rb#258
Dnsruby::QTypes::MAILB = T.let(T.unsafe(nil), Integer)

# source://dnsruby//lib/dnsruby/message/question.rb#6
class Dnsruby::Question
  # Creates a question object from the domain, type, and class passed
  #  as arguments.
  #
  #  If a String is passed in, a Name, IPv4 or IPv6 object is created.
  #
  #  If an IPv4 or IPv6 object is used then the type is set to PTR.
  #
  # @raise [ArgumentError]
  # @return [Question] a new instance of Question
  #
  # source://dnsruby//lib/dnsruby/message/question.rb#21
  def initialize(qname, qtype = T.unsafe(nil), qclass = T.unsafe(nil)); end

  # source://dnsruby//lib/dnsruby/message/question.rb#65
  def ==(other); end

  # The Question class
  #
  # source://dnsruby//lib/dnsruby/message/question.rb#13
  def qclass; end

  # source://dnsruby//lib/dnsruby/message/question.rb#34
  def qclass=(qclass); end

  # The Question name
  #
  # source://dnsruby//lib/dnsruby/message/question.rb#9
  def qname; end

  # source://dnsruby//lib/dnsruby/message/question.rb#61
  def qname=(qname); end

  # The Question type
  #
  # source://dnsruby//lib/dnsruby/message/question.rb#11
  def qtype; end

  # source://dnsruby//lib/dnsruby/message/question.rb#30
  def qtype=(qtype); end

  # source://dnsruby//lib/dnsruby/message/question.rb#38
  def set_qname(qname, write_PTR_to_qtype_if_ip = T.unsafe(nil)); end

  # Returns a string representation of the question record.
  #
  # source://dnsruby//lib/dnsruby/message/question.rb#73
  def to_s; end

  # The Question type
  #
  # source://dnsruby//lib/dnsruby/message/question.rb#11
  def type; end

  # The Question class
  #  For Updates, the qclass field is redefined to zclass (RFC2136, section 2.3)
  #
  # source://dnsruby//lib/dnsruby/message/question.rb#13
  def zclass; end

  # The Question name
  #  For Updates, the qname field is redefined to zname (RFC2136, section 2.3)
  #
  # source://dnsruby//lib/dnsruby/message/question.rb#9
  def zname; end

  # The Question type
  #  For Updates, the qtype field is redefined to ztype (RFC2136, section 2.3)
  #
  # source://dnsruby//lib/dnsruby/message/question.rb#11
  def ztype; end
end

# source://dnsruby//lib/dnsruby/code_mappers.rb#15
class Dnsruby::RCode < ::Dnsruby::CodeMapper; end

# source://dnsruby//lib/dnsruby/code_mappers.rb#34
Dnsruby::RCode::BADALG = T.let(T.unsafe(nil), Integer)

# source://dnsruby//lib/dnsruby/code_mappers.rb#30
Dnsruby::RCode::BADKEY = T.let(T.unsafe(nil), Integer)

# source://dnsruby//lib/dnsruby/code_mappers.rb#32
Dnsruby::RCode::BADMODE = T.let(T.unsafe(nil), Integer)

# source://dnsruby//lib/dnsruby/code_mappers.rb#33
Dnsruby::RCode::BADNAME = T.let(T.unsafe(nil), Integer)

# BADVERS = 16 # an EDNS ExtendedRCode
#
# source://dnsruby//lib/dnsruby/code_mappers.rb#29
Dnsruby::RCode::BADSIG = T.let(T.unsafe(nil), Integer)

# source://dnsruby//lib/dnsruby/code_mappers.rb#31
Dnsruby::RCode::BADTIME = T.let(T.unsafe(nil), Integer)

# RFC 1035
#
# source://dnsruby//lib/dnsruby/code_mappers.rb#17
Dnsruby::RCode::FORMERR = T.let(T.unsafe(nil), Integer)

# RFC 1035
#
# source://dnsruby//lib/dnsruby/code_mappers.rb#16
Dnsruby::RCode::NOERROR = T.let(T.unsafe(nil), Integer)

# RFC 2136
#
# source://dnsruby//lib/dnsruby/code_mappers.rb#25
Dnsruby::RCode::NOTAUTH = T.let(T.unsafe(nil), Integer)

# RFC 1035
#
# source://dnsruby//lib/dnsruby/code_mappers.rb#20
Dnsruby::RCode::NOTIMP = T.let(T.unsafe(nil), Integer)

# RFC 2136
#
# source://dnsruby//lib/dnsruby/code_mappers.rb#26
Dnsruby::RCode::NOTZONE = T.let(T.unsafe(nil), Integer)

# RFC 1035
#
# source://dnsruby//lib/dnsruby/code_mappers.rb#19
Dnsruby::RCode::NXDOMAIN = T.let(T.unsafe(nil), Integer)

# RFC 2136
#
# source://dnsruby//lib/dnsruby/code_mappers.rb#24
Dnsruby::RCode::NXRRSET = T.let(T.unsafe(nil), Integer)

# RFC 1035
#
# source://dnsruby//lib/dnsruby/code_mappers.rb#21
Dnsruby::RCode::REFUSED = T.let(T.unsafe(nil), Integer)

# RFC 1035
#
# source://dnsruby//lib/dnsruby/code_mappers.rb#18
Dnsruby::RCode::SERVFAIL = T.let(T.unsafe(nil), Integer)

# RFC 2136
#
# source://dnsruby//lib/dnsruby/code_mappers.rb#22
Dnsruby::RCode::YXDOMAIN = T.let(T.unsafe(nil), Integer)

# RFC 2136
#
# source://dnsruby//lib/dnsruby/code_mappers.rb#23
Dnsruby::RCode::YXRRSET = T.let(T.unsafe(nil), Integer)

# source://dnsruby//lib/dnsruby/resource/RR.rb#19
class Dnsruby::RR
  include ::Comparable

  # @return [RR] a new instance of RR
  #
  # source://dnsruby//lib/dnsruby/resource/RR.rb#103
  def initialize(*args); end

  # source://dnsruby//lib/dnsruby/resource/RR.rb#23
  def <=>(other); end

  # source://dnsruby//lib/dnsruby/resource/RR.rb#322
  def ==(other); end

  # source://dnsruby//lib/dnsruby/resource/RR.rb#75
  def clone; end

  # @raise [EncodeError]
  #
  # source://dnsruby//lib/dnsruby/resource/RR.rb#312
  def encode_rdata(msg, canonical = T.unsafe(nil)); end

  # @return [Boolean]
  #
  # source://dnsruby//lib/dnsruby/resource/RR.rb#348
  def eql?(other); end

  # @raise [NotImplementedError]
  #
  # source://dnsruby//lib/dnsruby/resource/RR.rb#302
  def from_data(data); end

  # source://dnsruby//lib/dnsruby/resource/RR.rb#125
  def from_hash(hash); end

  # source://dnsruby//lib/dnsruby/resource/RR.rb#307
  def from_string(input); end

  # source://dnsruby//lib/dnsruby/resource/RR.rb#352
  def hash; end

  # source://dnsruby//lib/dnsruby/resource/RR.rb#98
  def init_defaults; end

  # The Resource class
  #
  # source://dnsruby//lib/dnsruby/resource/RR.rb#46
  def klass; end

  # source://dnsruby//lib/dnsruby/resource/RR.rb#67
  def klass=(klass); end

  # The Resource's domain name
  #
  # source://dnsruby//lib/dnsruby/resource/RR.rb#40
  def name; end

  # source://dnsruby//lib/dnsruby/resource/RR.rb#58
  def name=(new_name); end

  # The Resource data section
  #
  # source://dnsruby//lib/dnsruby/resource/RR.rb#52
  def rdata; end

  # The Resource data section
  #
  # source://dnsruby//lib/dnsruby/resource/RR.rb#52
  def rdata=(_arg0); end

  # Get a string representation of the data section of the RR (in zone file format)
  #
  # source://dnsruby//lib/dnsruby/resource/RR.rb#298
  def rdata_to_string; end

  # source://dnsruby//lib/dnsruby/resource/RR.rb#54
  def rdlength; end

  # The Resource type
  #
  # source://dnsruby//lib/dnsruby/resource/RR.rb#43
  def rr_type; end

  # Determines if two Records could be part of the same RRset.
  #  This compares the name, type, and class of the Records; the ttl and
  #  rdata are not compared.
  #
  # source://dnsruby//lib/dnsruby/resource/RR.rb#84
  def sameRRset(rec); end

  # Returns a string representation of the RR in zone file format
  #
  # source://dnsruby//lib/dnsruby/resource/RR.rb#292
  def to_s; end

  # The Resource Time-To-Live
  #
  # source://dnsruby//lib/dnsruby/resource/RR.rb#49
  def ttl; end

  # The Resource Time-To-Live
  #
  # source://dnsruby//lib/dnsruby/resource/RR.rb#49
  def ttl=(_arg0); end

  # The Resource type
  #
  # source://dnsruby//lib/dnsruby/resource/RR.rb#43
  def type; end

  # source://dnsruby//lib/dnsruby/resource/RR.rb#62
  def type=(type); end

  class << self
    # Create a new RR from the arguments, which can be either a String or a Hash.
    # See new_from_string and new_from_hash for details
    #
    #    a     = Dnsruby::RR.create('foo.example.com. 86400 A 10.1.2.3')
    #    mx    = Dnsruby::RR.create('example.com. 7200 MX 10 mailhost.example.com.')
    #    cname = Dnsruby::RR.create('www.example.com 300 IN CNAME www1.example.com')
    #    txt   = Dnsruby::RR.create('baz.example.com 3600 HS TXT 'text record'')
    #
    #    rr = Dnsruby::RR.create({:name => 'example.com'})
    #    rr = Dnsruby::RR.create({:name => 'example.com', :type => 'MX', :ttl => 10,
    #                                   :preference => 5, :exchange => 'mx1.example.com'})
    #
    # source://dnsruby//lib/dnsruby/resource/RR.rb#399
    def create(*args); end

    # @raise [DecodeError]
    #
    # source://dnsruby//lib/dnsruby/resource/RR.rb#317
    def decode_rdata(msg); end

    # source://dnsruby//lib/dnsruby/resource/RR.rb#359
    def find_class(type_value, class_value); end

    # Get an RR of the specified type and class
    #
    # source://dnsruby//lib/dnsruby/resource/RR.rb#373
    def get_class(type_value, class_value); end

    # source://dnsruby//lib/dnsruby/resource/RR.rb#410
    def get_num(bytes); end

    # Return an array of all the currently implemented RR types
    #
    # source://dnsruby//lib/dnsruby/resource/RR.rb#274
    def implemented_rrs; end

    # source://dnsruby//lib/dnsruby/resource/RR.rb#261
    def new_from_data(*args); end

    # Create a new RR from the hash. The name is required; all other fields are optional.
    # Type defaults to ANY and the Class defaults to IN. The TTL defaults to 0.
    #
    # If the type is specified, then it is necessary to provide ALL of the resource record fields which
    # are specific to that record; i.e. for
    # an MX record, you would need to specify the exchange and the preference
    #
    #    require 'Dnsruby'
    #    rr = Dnsruby::RR.new_from_hash({:name => "example.com"})
    #    rr = Dnsruby::RR.new_from_hash({:name => "example.com", :type => Types.MX, :ttl => 10, :preference => 5, :exchange => "mx1.example.com"})
    #
    # source://dnsruby//lib/dnsruby/resource/RR.rb#141
    def new_from_hash(inhash); end

    # Returns a Dnsruby::RR object of the appropriate type and
    # initialized from the string passed by the user.  The format of the
    # string is that used in zone files, and is compatible with the string
    # returned by Net::DNS::RR.inspect
    #
    # The name and RR type are required; all other information is optional.
    # If omitted, the TTL defaults to 0 and the RR class defaults to IN.
    #
    # All names must be fully qualified.  The trailing dot (.) is optional.
    #
    #
    #    a     = Dnsruby::RR.new_from_string("foo.example.com. 86400 A 10.1.2.3")
    #    mx    = Dnsruby::RR.new_from_string("example.com. 7200 MX 10 mailhost.example.com.")
    #    cname = Dnsruby::RR.new_from_string("www.example.com 300 IN CNAME www1.example.com")
    #    txt   = Dnsruby::RR.new_from_string('baz.example.com 3600 HS TXT "text record"')
    #
    # source://dnsruby//lib/dnsruby/resource/RR.rb#180
    def new_from_string(rrstring); end

    private

    # source://dnsruby//lib/dnsruby/resource/RR.rb#280
    def _get_subclass(name, rrtype, rrclass, ttl, rdata); end
  end
end

# ANY RR
#  A Query type requesting any RR
#
# source://dnsruby//lib/dnsruby/resource/generic.rb#122
class Dnsruby::RR::ANY < ::Dnsruby::RR
  # source://dnsruby//lib/dnsruby/resource/generic.rb#125
  def encode_rdata(msg, canonical = T.unsafe(nil)); end

  # source://dnsruby//lib/dnsruby/resource/generic.rb#131
  def from_data(data); end

  class << self
    # source://dnsruby//lib/dnsruby/resource/generic.rb#128
    def decode_rdata(msg); end
  end
end

# source://dnsruby//lib/dnsruby/resource/generic.rb#123
Dnsruby::RR::ANY::ClassValue = T.let(T.unsafe(nil), T.untyped)

# source://dnsruby//lib/dnsruby/resource/generic.rb#124
Dnsruby::RR::ANY::TypeValue = T.let(T.unsafe(nil), Integer)

# Class for CAA resource records.
# RFC 6844
#
# source://dnsruby//lib/dnsruby/resource/CAA.rb#20
class Dnsruby::RR::CAA < ::Dnsruby::RR
  # source://dnsruby//lib/dnsruby/resource/CAA.rb#56
  def encode_rdata(msg, canonical = T.unsafe(nil)); end

  # The value for the flag
  #
  # source://dnsruby//lib/dnsruby/resource/CAA.rb#41
  def flag; end

  # The value for the flag
  #
  # source://dnsruby//lib/dnsruby/resource/CAA.rb#29
  def flag=(_arg0); end

  # source://dnsruby//lib/dnsruby/resource/CAA.rb#37
  def from_data(data); end

  # source://dnsruby//lib/dnsruby/resource/CAA.rb#31
  def from_hash(hash); end

  # source://dnsruby//lib/dnsruby/resource/CAA.rb#45
  def from_string(input); end

  # The property tag for the record (issue|issuewild|iodef)
  #
  # source://dnsruby//lib/dnsruby/resource/CAA.rb#25
  def property_tag; end

  # The property tag for the record (issue|issuewild|iodef)
  #
  # source://dnsruby//lib/dnsruby/resource/CAA.rb#25
  def property_tag=(_arg0); end

  # The value for the property_tag
  #
  # source://dnsruby//lib/dnsruby/resource/CAA.rb#27
  def property_value; end

  # The value for the property_tag
  #
  # source://dnsruby//lib/dnsruby/resource/CAA.rb#27
  def property_value=(_arg0); end

  # source://dnsruby//lib/dnsruby/resource/CAA.rb#52
  def rdata_to_string; end

  class << self
    # source://dnsruby//lib/dnsruby/resource/CAA.rb#63
    def decode_rdata(msg); end
  end
end

# source://dnsruby//lib/dnsruby/resource/CAA.rb#21
Dnsruby::RR::CAA::ClassValue = T.let(T.unsafe(nil), T.untyped)

# source://dnsruby//lib/dnsruby/resource/CAA.rb#22
Dnsruby::RR::CAA::TypeValue = T.let(T.unsafe(nil), Integer)

# RFC4034, section 2
# DNSSEC uses public key cryptography to sign and authenticate DNS
# resource record sets (RRsets).  The public keys are stored in DNSKEY
# resource records and are used in the DNSSEC authentication process
# described in [RFC4035]: A zone signs its authoritative RRsets by
# using a private key and stores the corresponding public key in a
# DNSKEY RR.  A resolver can then use the public key to validate
# signatures covering the RRsets in the zone, and thus to authenticate
# them.
#
# source://dnsruby//lib/dnsruby/resource/CDNSKEY.rb#12
class Dnsruby::RR::CDNSKEY < ::Dnsruby::RR::DNSKEY; end

# source://dnsruby//lib/dnsruby/resource/CDNSKEY.rb#13
Dnsruby::RR::CDNSKEY::ClassValue = T.let(T.unsafe(nil), T.untyped)

# source://dnsruby//lib/dnsruby/resource/CDNSKEY.rb#14
Dnsruby::RR::CDNSKEY::TypeValue = T.let(T.unsafe(nil), Integer)

# RFC4034, section 4
# The DS Resource Record refers to a DNSKEY RR and is used in the DNS
# DNSKEY authentication process.  A DS RR refers to a DNSKEY RR by
# storing the key tag, algorithm number, and a digest of the DNSKEY RR.
# Note that while the digest should be sufficient to identify the
# public key, storing the key tag and key algorithm helps make the
# identification process more efficient.  By authenticating the DS
# record, a resolver can authenticate the DNSKEY RR to which the DS
# record points.  The key authentication process is described in
# [RFC4035].
#
# source://dnsruby//lib/dnsruby/resource/CDS.rb#29
class Dnsruby::RR::CDS < ::Dnsruby::RR::DS; end

# source://dnsruby//lib/dnsruby/resource/CDS.rb#31
Dnsruby::RR::CDS::ClassValue = T.let(T.unsafe(nil), T.untyped)

# source://dnsruby//lib/dnsruby/resource/CDS.rb#32
Dnsruby::RR::CDS::TypeValue = T.let(T.unsafe(nil), Integer)

# Class for DNS Certificate (CERT) resource records. (see RFC 2538)
#
# RFC 2782
#
# source://dnsruby//lib/dnsruby/resource/CERT.rb#21
class Dnsruby::RR::CERT < ::Dnsruby::RR
  # Returns the algorithm used by the certificate
  #
  # source://dnsruby//lib/dnsruby/resource/CERT.rb#30
  def alg; end

  # Returns the algorithm used by the certificate
  #
  # source://dnsruby//lib/dnsruby/resource/CERT.rb#30
  def alg=(_arg0); end

  # Returns the data comprising the certificate itself (in raw binary form)
  #
  # source://dnsruby//lib/dnsruby/resource/CERT.rb#32
  def cert; end

  # Returns the data comprising the certificate itself (in raw binary form)
  #
  # source://dnsruby//lib/dnsruby/resource/CERT.rb#32
  def cert=(_arg0); end

  # Returns the format code for the certificate
  #
  # source://dnsruby//lib/dnsruby/resource/CERT.rb#26
  def certtype; end

  # Returns the format code for the certificate
  #
  # source://dnsruby//lib/dnsruby/resource/CERT.rb#26
  def certtype=(_arg0); end

  # source://dnsruby//lib/dnsruby/resource/CERT.rb#93
  def encode_rdata(msg, canonical = T.unsafe(nil)); end

  # source://dnsruby//lib/dnsruby/resource/CERT.rb#49
  def from_data(data); end

  # source://dnsruby//lib/dnsruby/resource/CERT.rb#56
  def from_hash(hash); end

  # source://dnsruby//lib/dnsruby/resource/CERT.rb#63
  def from_string(input); end

  # Returns the key tag for the public key in the certificate
  #
  # source://dnsruby//lib/dnsruby/resource/CERT.rb#28
  def keytag; end

  # Returns the key tag for the public key in the certificate
  #
  # source://dnsruby//lib/dnsruby/resource/CERT.rb#28
  def keytag=(_arg0); end

  # source://dnsruby//lib/dnsruby/resource/CERT.rb#89
  def rdata_to_string; end

  class << self
    # source://dnsruby//lib/dnsruby/resource/CERT.rb#98
    def decode_rdata(msg); end
  end
end

# source://dnsruby//lib/dnsruby/resource/CERT.rb#34
class Dnsruby::RR::CERT::CertificateTypes < ::Dnsruby::CodeMapper; end

# Attribute Certificate
#
# source://dnsruby//lib/dnsruby/resource/CERT.rb#41
Dnsruby::RR::CERT::CertificateTypes::ACPKIX = T.let(T.unsafe(nil), Integer)

# URL of an Attribute Certificate
#
# source://dnsruby//lib/dnsruby/resource/CERT.rb#42
Dnsruby::RR::CERT::CertificateTypes::IACPKIX = T.let(T.unsafe(nil), Integer)

# Fingerprint and URL of an OpenPGP packet
#
# source://dnsruby//lib/dnsruby/resource/CERT.rb#40
Dnsruby::RR::CERT::CertificateTypes::IPGP = T.let(T.unsafe(nil), Integer)

# URL of an X.509 data object
#
# source://dnsruby//lib/dnsruby/resource/CERT.rb#38
Dnsruby::RR::CERT::CertificateTypes::IPKIX = T.let(T.unsafe(nil), Integer)

# URL of an SPKI certificate
#
# source://dnsruby//lib/dnsruby/resource/CERT.rb#39
Dnsruby::RR::CERT::CertificateTypes::ISPKI = T.let(T.unsafe(nil), Integer)

# Certificate format defined by OID
#
# source://dnsruby//lib/dnsruby/resource/CERT.rb#44
Dnsruby::RR::CERT::CertificateTypes::OID = T.let(T.unsafe(nil), Integer)

# Pretty Good Privacy
#
# source://dnsruby//lib/dnsruby/resource/CERT.rb#37
Dnsruby::RR::CERT::CertificateTypes::PGP = T.let(T.unsafe(nil), Integer)

# PKIX (X.509v3)
#
# source://dnsruby//lib/dnsruby/resource/CERT.rb#35
Dnsruby::RR::CERT::CertificateTypes::PKIX = T.let(T.unsafe(nil), Integer)

# Simple Public Key Infrastructure
#
# source://dnsruby//lib/dnsruby/resource/CERT.rb#36
Dnsruby::RR::CERT::CertificateTypes::SPKI = T.let(T.unsafe(nil), Integer)

# Certificate format defined by URI
#
# source://dnsruby//lib/dnsruby/resource/CERT.rb#43
Dnsruby::RR::CERT::CertificateTypes::URI = T.let(T.unsafe(nil), Integer)

# source://dnsruby//lib/dnsruby/resource/CERT.rb#22
Dnsruby::RR::CERT::ClassValue = T.let(T.unsafe(nil), T.untyped)

# source://dnsruby//lib/dnsruby/resource/CERT.rb#23
Dnsruby::RR::CERT::TypeValue = T.let(T.unsafe(nil), Integer)

# CNAME RR
# The canonical name for an alias
#
# source://dnsruby//lib/dnsruby/resource/generic.rb#73
class Dnsruby::RR::CNAME < ::Dnsruby::RR::DomainName
  # source://dnsruby//lib/dnsruby/resource/domain_name.rb#21
  def cname; end

  # source://dnsruby//lib/dnsruby/resource/domain_name.rb#23
  def cname=(newname); end
end

# source://dnsruby//lib/dnsruby/resource/generic.rb#74
Dnsruby::RR::CNAME::ClassValue = T.let(T.unsafe(nil), T.untyped)

# source://dnsruby//lib/dnsruby/resource/generic.rb#75
Dnsruby::RR::CNAME::TypeValue = T.let(T.unsafe(nil), Integer)

# source://dnsruby//lib/dnsruby/resource/IN.rb#18
Dnsruby::RR::ClassInsensitiveTypes = T.let(T.unsafe(nil), Hash)

# Class for DNS DHCP ID (DHCID) resource records.
# RFC 4701
#
# source://dnsruby//lib/dnsruby/resource/DHCID.rb#20
class Dnsruby::RR::DHCID < ::Dnsruby::RR
  # The opaque rdata for DHCID
  #
  # source://dnsruby//lib/dnsruby/resource/DHCID.rb#25
  def dhcid_data; end

  # The opaque rdata for DHCID
  #
  # source://dnsruby//lib/dnsruby/resource/DHCID.rb#25
  def dhcid_data=(_arg0); end

  # source://dnsruby//lib/dnsruby/resource/DHCID.rb#45
  def encode_rdata(msg, canonical = T.unsafe(nil)); end

  # source://dnsruby//lib/dnsruby/resource/DHCID.rb#31
  def from_data(data); end

  # source://dnsruby//lib/dnsruby/resource/DHCID.rb#27
  def from_hash(hash); end

  # source://dnsruby//lib/dnsruby/resource/DHCID.rb#35
  def from_string(input); end

  # source://dnsruby//lib/dnsruby/resource/DHCID.rb#41
  def rdata_to_string; end

  class << self
    # source://dnsruby//lib/dnsruby/resource/DHCID.rb#49
    def decode_rdata(msg); end
  end
end

# source://dnsruby//lib/dnsruby/resource/DHCID.rb#21
Dnsruby::RR::DHCID::ClassValue = T.let(T.unsafe(nil), T.untyped)

# source://dnsruby//lib/dnsruby/resource/DHCID.rb#22
Dnsruby::RR::DHCID::TypeValue = T.let(T.unsafe(nil), Integer)

# RFC4431 specifies that the DLV is assigned type 32769, and the
#  rdata is identical to that of the DS record.
#
# source://dnsruby//lib/dnsruby/resource/DLV.rb#22
class Dnsruby::RR::DLV < ::Dnsruby::RR::DS; end

# source://dnsruby//lib/dnsruby/resource/DLV.rb#23
Dnsruby::RR::DLV::ClassValue = T.let(T.unsafe(nil), T.untyped)

# source://dnsruby//lib/dnsruby/resource/DLV.rb#24
Dnsruby::RR::DLV::TypeValue = T.let(T.unsafe(nil), Integer)

# DNAME RR
#
# source://dnsruby//lib/dnsruby/resource/generic.rb#82
class Dnsruby::RR::DNAME < ::Dnsruby::RR::DomainName
  # source://dnsruby//lib/dnsruby/resource/domain_name.rb#21
  def dname; end

  # source://dnsruby//lib/dnsruby/resource/domain_name.rb#23
  def dname=(newname); end
end

# source://dnsruby//lib/dnsruby/resource/generic.rb#83
Dnsruby::RR::DNAME::ClassValue = T.let(T.unsafe(nil), T.untyped)

# source://dnsruby//lib/dnsruby/resource/generic.rb#84
Dnsruby::RR::DNAME::TypeValue = T.let(T.unsafe(nil), Integer)

# RFC4034, section 2
# DNSSEC uses public key cryptography to sign and authenticate DNS
# resource record sets (RRsets).  The public keys are stored in DNSKEY
# resource records and are used in the DNSSEC authentication process
# described in [RFC4035]: A zone signs its authoritative RRsets by
# using a private key and stores the corresponding public key in a
# DNSKEY RR.  A resolver can then use the public key to validate
# signatures covering the RRsets in the zone, and thus to authenticate
# them.
#
# source://dnsruby//lib/dnsruby/resource/DNSKEY.rb#27
class Dnsruby::RR::DNSKEY < ::Dnsruby::RR
  # The algorithm used for this key
  # See Dnsruby::Algorithms for permitted values
  #
  # source://dnsruby//lib/dnsruby/resource/DNSKEY.rb#47
  def algorithm; end

  # source://dnsruby//lib/dnsruby/resource/DNSKEY.rb#71
  def algorithm=(a); end

  # source://dnsruby//lib/dnsruby/resource/DNSKEY.rb#354
  def dsa_key; end

  # RFC6605, section 4
  # ECDSA public keys consist of a single value, called "Q" in FIPS
  # 186-3.  In DNSSEC keys, Q is a simple bit string that represents the
  # uncompressed form of a curve point, "x | y".
  #
  # source://dnsruby//lib/dnsruby/resource/DNSKEY.rb#387
  def ec_key(curve = T.unsafe(nil)); end

  # source://dnsruby//lib/dnsruby/resource/DNSKEY.rb#208
  def encode_rdata(msg, canonical = T.unsafe(nil)); end

  # The flags for the DNSKEY RR
  #
  # source://dnsruby//lib/dnsruby/resource/DNSKEY.rb#41
  def flags; end

  # source://dnsruby//lib/dnsruby/resource/DNSKEY.rb#125
  def flags=(f); end

  # def bad_flags?
  #         if ((@flags & ~ZONE_KEY & ~SEP_KEY) > 0)
  #           return true
  #         end
  #         return false
  #       end
  #
  # source://dnsruby//lib/dnsruby/resource/DNSKEY.rb#146
  def from_data(data); end

  # source://dnsruby//lib/dnsruby/resource/DNSKEY.rb#156
  def from_hash(hash); end

  # source://dnsruby//lib/dnsruby/resource/DNSKEY.rb#165
  def from_string(input); end

  # source://dnsruby//lib/dnsruby/resource/DNSKEY.rb#252
  def generate_key_tag(rdata, algorithm); end

  # source://dnsruby//lib/dnsruby/resource/DNSKEY.rb#233
  def get_new_key_tag; end

  # source://dnsruby//lib/dnsruby/resource/DNSKEY.rb#53
  def init_defaults; end

  # The public key
  #
  # source://dnsruby//lib/dnsruby/resource/DNSKEY.rb#49
  def key; end

  # source://dnsruby//lib/dnsruby/resource/DNSKEY.rb#293
  def key=(key_text); end

  # The length (in bits) of the key - NOT key.length
  #
  # source://dnsruby//lib/dnsruby/resource/DNSKEY.rb#51
  def key_length; end

  # Return the tag for this key
  #
  # source://dnsruby//lib/dnsruby/resource/DNSKEY.rb#244
  def key_tag; end

  # Return the the key tag this key would have had before it was revoked
  #  If the key is not revoked, then the current key_tag will be returned
  #
  # source://dnsruby//lib/dnsruby/resource/DNSKEY.rb#224
  def key_tag_pre_revoked; end

  # The protocol for this DNSKEY RR.
  # MUST be 3.
  #
  # source://dnsruby//lib/dnsruby/resource/DNSKEY.rb#44
  def protocol; end

  # source://dnsruby//lib/dnsruby/resource/DNSKEY.rb#63
  def protocol=(p); end

  # source://dnsruby//lib/dnsruby/resource/DNSKEY.rb#306
  def public_key; end

  # source://dnsruby//lib/dnsruby/resource/DNSKEY.rb#199
  def rdata_to_string; end

  # source://dnsruby//lib/dnsruby/resource/DNSKEY.rb#86
  def revoked=(on); end

  # @return [Boolean]
  #
  # source://dnsruby//lib/dnsruby/resource/DNSKEY.rb#95
  def revoked?; end

  # source://dnsruby//lib/dnsruby/resource/DNSKEY.rb#324
  def rsa_key; end

  # source://dnsruby//lib/dnsruby/resource/DNSKEY.rb#112
  def sep_key=(on); end

  # @return [Boolean]
  #
  # source://dnsruby//lib/dnsruby/resource/DNSKEY.rb#121
  def sep_key?; end

  # source://dnsruby//lib/dnsruby/resource/DNSKEY.rb#99
  def zone_key=(on); end

  # @return [Boolean]
  #
  # source://dnsruby//lib/dnsruby/resource/DNSKEY.rb#108
  def zone_key?; end

  class << self
    # source://dnsruby//lib/dnsruby/resource/DNSKEY.rb#214
    def decode_rdata(msg); end
  end
end

# source://dnsruby//lib/dnsruby/resource/DNSKEY.rb#28
Dnsruby::RR::DNSKEY::ClassValue = T.let(T.unsafe(nil), T.untyped)

# Key is revoked
#
# source://dnsruby//lib/dnsruby/resource/DNSKEY.rb#32
Dnsruby::RR::DNSKEY::REVOKED_KEY = T.let(T.unsafe(nil), Integer)

# Key is a secure entry point key
#
# source://dnsruby//lib/dnsruby/resource/DNSKEY.rb#38
Dnsruby::RR::DNSKEY::SEP_KEY = T.let(T.unsafe(nil), Integer)

# source://dnsruby//lib/dnsruby/resource/DNSKEY.rb#29
Dnsruby::RR::DNSKEY::TypeValue = T.let(T.unsafe(nil), Integer)

# Key is a zone key
#
# source://dnsruby//lib/dnsruby/resource/DNSKEY.rb#35
Dnsruby::RR::DNSKEY::ZONE_KEY = T.let(T.unsafe(nil), Integer)

# RFC4034, section 4
# The DS Resource Record refers to a DNSKEY RR and is used in the DNS
# DNSKEY authentication process.  A DS RR refers to a DNSKEY RR by
# storing the key tag, algorithm number, and a digest of the DNSKEY RR.
# Note that while the digest should be sufficient to identify the
# public key, storing the key tag and key algorithm helps make the
# identification process more efficient.  By authenticating the DS
# record, a resolver can authenticate the DNSKEY RR to which the DS
# record points.  The key authentication process is described in
# [RFC4035].
#
# source://dnsruby//lib/dnsruby/resource/DS.rb#35
class Dnsruby::RR::DS < ::Dnsruby::RR
  # The algorithm used for this key
  # See Dnsruby::Algorithms for permitted values
  #
  # source://dnsruby//lib/dnsruby/resource/DS.rb#65
  def algorithm; end

  # source://dnsruby//lib/dnsruby/resource/DS.rb#94
  def algorithm=(a); end

  # Check if the key's digest is the same as that stored in the DS record
  #
  # source://dnsruby//lib/dnsruby/resource/DS.rb#137
  def check_key(key); end

  # The DS record refers to a DNSKEY RR by including a digest of that
  # DNSKEY RR.
  #
  # source://dnsruby//lib/dnsruby/resource/DS.rb#72
  def digest; end

  # The DS record refers to a DNSKEY RR by including a digest of that
  # DNSKEY RR.
  #
  # source://dnsruby//lib/dnsruby/resource/DS.rb#72
  def digest=(_arg0); end

  # Return the digest of the specified DNSKEY RR
  #
  # source://dnsruby//lib/dnsruby/resource/DS.rb#109
  def digest_key(*args); end

  # The DS RR refers to a DNSKEY RR by including a digest of that DNSKEY
  # RR.  The Digest Type field identifies the algorithm used to construct
  # the digest.
  #
  # source://dnsruby//lib/dnsruby/resource/DS.rb#69
  def digest_type; end

  # source://dnsruby//lib/dnsruby/resource/DS.rb#75
  def digest_type=(d); end

  # Returns the value of attribute digestbin.
  #
  # source://dnsruby//lib/dnsruby/resource/DS.rb#73
  def digestbin; end

  # Sets the attribute digestbin
  #
  # @param value the value to set the attribute digestbin to.
  #
  # source://dnsruby//lib/dnsruby/resource/DS.rb#73
  def digestbin=(_arg0); end

  # source://dnsruby//lib/dnsruby/resource/DS.rb#243
  def encode_rdata(msg, canonical = T.unsafe(nil)); end

  # source://dnsruby//lib/dnsruby/resource/DS.rb#192
  def from_data(data); end

  # source://dnsruby//lib/dnsruby/resource/DS.rb#201
  def from_string(input); end

  # The Key Tag field lists the key tag of the DNSKEY RR referred to by
  # the DS record, in network byte order.
  #
  # source://dnsruby//lib/dnsruby/resource/DS.rb#62
  def key_tag; end

  # The Key Tag field lists the key tag of the DNSKEY RR referred to by
  # the DS record, in network byte order.
  #
  # source://dnsruby//lib/dnsruby/resource/DS.rb#62
  def key_tag=(_arg0); end

  # source://dnsruby//lib/dnsruby/resource/DS.rb#233
  def rdata_to_string; end

  class << self
    # source://dnsruby//lib/dnsruby/resource/DS.rb#248
    def decode_rdata(msg); end

    # source://dnsruby//lib/dnsruby/resource/DS.rb#153
    def from_key(key, digest_type); end

    # source://dnsruby//lib/dnsruby/resource/DS.rb#80
    def get_digest_type(d); end
  end
end

# source://dnsruby//lib/dnsruby/resource/DS.rb#43
Dnsruby::RR::DS::ClassValue = T.let(T.unsafe(nil), T.untyped)

# source://dnsruby//lib/dnsruby/resource/DS.rb#36
class Dnsruby::RR::DS::DigestTypes < ::Dnsruby::CodeMapper; end

# source://dnsruby//lib/dnsruby/resource/DS.rb#44
Dnsruby::RR::DS::TypeValue = T.let(T.unsafe(nil), Integer)

# Abstract superclass for RR's which have a domain name in the data section.
#
# source://dnsruby//lib/dnsruby/resource/domain_name.rb#19
class Dnsruby::RR::DomainName < ::Dnsruby::RR
  # The domain name in the RR data section.
  #
  # source://dnsruby//lib/dnsruby/resource/domain_name.rb#21
  def domainname; end

  # source://dnsruby//lib/dnsruby/resource/domain_name.rb#23
  def domainname=(newname); end

  # source://dnsruby//lib/dnsruby/resource/domain_name.rb#45
  def encode_rdata(msg, canonical = T.unsafe(nil)); end

  # source://dnsruby//lib/dnsruby/resource/domain_name.rb#33
  def from_data(data); end

  # source://dnsruby//lib/dnsruby/resource/domain_name.rb#29
  def from_hash(hash); end

  # source://dnsruby//lib/dnsruby/resource/domain_name.rb#37
  def from_string(input); end

  # source://dnsruby//lib/dnsruby/resource/domain_name.rb#41
  def rdata_to_string; end

  # source://dnsruby//lib/dnsruby/resource/domain_name.rb#23
  def set_domain_name(newname); end

  class << self
    # source://dnsruby//lib/dnsruby/resource/domain_name.rb#51
    def decode_rdata(msg); end
  end
end

# Class for Geographic Position (GPOS) resource records.
#
# RFC 1712 (https://www.ietf.org/rfc/rfc1712.txt)
#
# source://dnsruby//lib/dnsruby/resource/GPOS.rb#8
class Dnsruby::RR::GPOS < ::Dnsruby::RR
  # NOTE: these are strings, not numbers
  #
  # source://dnsruby//lib/dnsruby/resource/GPOS.rb#14
  def altitude; end

  # NOTE: these are strings, not numbers
  #
  # source://dnsruby//lib/dnsruby/resource/GPOS.rb#14
  def altitude=(_arg0); end

  # source://dnsruby//lib/dnsruby/resource/GPOS.rb#102
  def build_rdata; end

  # source://dnsruby//lib/dnsruby/resource/GPOS.rb#98
  def encode_rdata(msg, _canonical); end

  # source://dnsruby//lib/dnsruby/resource/GPOS.rb#63
  def from_data(array); end

  # source://dnsruby//lib/dnsruby/resource/GPOS.rb#75
  def from_hash(init_data); end

  # source://dnsruby//lib/dnsruby/resource/GPOS.rb#84
  def from_string(string); end

  # NOTE: these are strings, not numbers
  #
  # source://dnsruby//lib/dnsruby/resource/GPOS.rb#14
  def latitude; end

  # NOTE: these are strings, not numbers
  #
  # source://dnsruby//lib/dnsruby/resource/GPOS.rb#14
  def latitude=(_arg0); end

  # NOTE: these are strings, not numbers
  #
  # source://dnsruby//lib/dnsruby/resource/GPOS.rb#14
  def longitude; end

  # NOTE: these are strings, not numbers
  #
  # source://dnsruby//lib/dnsruby/resource/GPOS.rb#14
  def longitude=(_arg0); end

  # 'name' is used in the RR superclass, but 'owner' is the term referred to
  # in the RFC, so we'll make owner an alias for name.
  #
  # source://dnsruby//lib/dnsruby/resource/GPOS.rb#140
  def owner; end

  # 'name' is used in the RR superclass, but 'owner' is the term referred to
  # in the RFC, so we'll make owner an alias for name.
  #
  # source://dnsruby//lib/dnsruby/resource/GPOS.rb#146
  def owner=(owner_string); end

  # From the RFC:
  #    GPOS has the following format:
  # <owner> <ttl> <class> GPOS <longitude> <latitude> <altitude>
  #
  # We handle the rdata, the RR superclass does the rest.
  #
  # source://dnsruby//lib/dnsruby/resource/GPOS.rb#94
  def rdata_to_string; end

  class << self
    # source://dnsruby//lib/dnsruby/resource/GPOS.rb#106
    def build_rdata(longitude, latitude, altitude); end

    # source://dnsruby//lib/dnsruby/resource/GPOS.rb#118
    def decode_rdata(message); end

    # Create an instance from an ordered parameter list, e.g.:
    # EXAMPLE_GPOS_DATA = begin
    #   rdata = RR::GPOS.build_rdata(EXAMPLE_LONGITUDE, EXAMPLE_LATITUDE, EXAMPLE_ALTITUDE)
    #   [EXAMPLE_HOSTNAME, Types::GPOS, Classes::IN, EXAMPLE_TTL, rdata.length, rdata, 0]
    # end
    # self.from_data(*EXAMPLE_GPOS_DATA)
    #
    # source://dnsruby//lib/dnsruby/resource/GPOS.rb#58
    def new_from_data(*gpos_params_data); end

    # Create an instance from a hash of parameters, e.g.:
    #  {
    #     name:       'techhumans.com',
    #     type:       Types::GPOS,
    #     ttl:        1234,
    #     longitude:  '10.0',
    #     latitude:   '20.0',
    #     altitude:   '30.0',
    #  }
    #
    # Since the type is assumed to be GPOS, it will be assigned
    # automatially, and any other value will be overwritten.
    # Therefore, having it present in the hash is not necessary.
    #
    # source://dnsruby//lib/dnsruby/resource/GPOS.rb#39
    def new_from_hash(gpos_params_hash); end

    # Create an instance from a string containing parameters, e.g.:
    # 'a.dnsruby.com.  10800  IN  GPOS  10.0  20.0  30.0'
    #
    # source://dnsruby//lib/dnsruby/resource/GPOS.rb#47
    def new_from_string(gpos_params_string); end

    # @return [Boolean]
    #
    # source://dnsruby//lib/dnsruby/resource/GPOS.rb#150
    def valid_float?(object); end

    # source://dnsruby//lib/dnsruby/resource/GPOS.rb#159
    def validate_float_in_range(label, object, bound); end

    # source://dnsruby//lib/dnsruby/resource/GPOS.rb#175
    def validate_floats(init_data); end

    # source://dnsruby//lib/dnsruby/resource/GPOS.rb#171
    def validate_latitude(value); end

    # source://dnsruby//lib/dnsruby/resource/GPOS.rb#167
    def validate_longitude(value); end
  end
end

# source://dnsruby//lib/dnsruby/resource/GPOS.rb#11
Dnsruby::RR::GPOS::ClassValue = T.let(T.unsafe(nil), Integer)

# source://dnsruby//lib/dnsruby/resource/GPOS.rb#16
Dnsruby::RR::GPOS::REQUIRED_KEYS = T.let(T.unsafe(nil), Array)

# source://dnsruby//lib/dnsruby/resource/GPOS.rb#10
Dnsruby::RR::GPOS::TypeValue = T.let(T.unsafe(nil), Integer)

# Class to store generic RRs (RFC 3597)
#
# source://dnsruby//lib/dnsruby/resource/generic.rb#20
class Dnsruby::RR::Generic < ::Dnsruby::RR
  # data for the generic resource record
  #
  # source://dnsruby//lib/dnsruby/resource/generic.rb#21
  def data; end

  # source://dnsruby//lib/dnsruby/resource/generic.rb#38
  def encode_rdata(msg, canonical = T.unsafe(nil)); end

  # source://dnsruby//lib/dnsruby/resource/generic.rb#23
  def from_data(data); end

  # source://dnsruby//lib/dnsruby/resource/generic.rb#34
  def from_string(data); end

  # source://dnsruby//lib/dnsruby/resource/generic.rb#27
  def rdata_to_string; end

  class << self
    # source://dnsruby//lib/dnsruby/resource/generic.rb#46
    def create(type_value, class_value); end

    # source://dnsruby//lib/dnsruby/resource/generic.rb#42
    def decode_rdata(msg); end
  end
end

# Class for DNS Host Information (HINFO) resource records.
#
# source://dnsruby//lib/dnsruby/resource/HINFO.rb#19
class Dnsruby::RR::HINFO < ::Dnsruby::RR
  # The CPU type for this RR.
  #
  # source://dnsruby//lib/dnsruby/resource/HINFO.rb#24
  def cpu; end

  # The CPU type for this RR.
  #
  # source://dnsruby//lib/dnsruby/resource/HINFO.rb#24
  def cpu=(_arg0); end

  # source://dnsruby//lib/dnsruby/resource/HINFO.rb#60
  def encode_rdata(msg, canonical = T.unsafe(nil)); end

  # source://dnsruby//lib/dnsruby/resource/HINFO.rb#28
  def from_data(data); end

  # source://dnsruby//lib/dnsruby/resource/HINFO.rb#32
  def from_string(input); end

  # The operating system type for this RR.
  #
  # source://dnsruby//lib/dnsruby/resource/HINFO.rb#26
  def os; end

  # The operating system type for this RR.
  #
  # source://dnsruby//lib/dnsruby/resource/HINFO.rb#26
  def os=(_arg0); end

  # source://dnsruby//lib/dnsruby/resource/HINFO.rb#48
  def rdata_to_string; end

  class << self
    # source://dnsruby//lib/dnsruby/resource/HINFO.rb#65
    def decode_rdata(msg); end
  end
end

# source://dnsruby//lib/dnsruby/resource/HINFO.rb#20
Dnsruby::RR::HINFO::ClassValue = T.let(T.unsafe(nil), T.untyped)

# source://dnsruby//lib/dnsruby/resource/HINFO.rb#21
Dnsruby::RR::HINFO::TypeValue = T.let(T.unsafe(nil), Integer)

# source://dnsruby//lib/dnsruby/resource/HIP.rb#19
class Dnsruby::RR::HIP < ::Dnsruby::RR
  # source://dnsruby//lib/dnsruby/resource/HIP.rb#113
  def encode_rdata(msg, canonical = T.unsafe(nil)); end

  # source://dnsruby//lib/dnsruby/resource/HIP.rb#37
  def from_data(data); end

  # source://dnsruby//lib/dnsruby/resource/HIP.rb#47
  def from_hash(hash); end

  # source://dnsruby//lib/dnsruby/resource/HIP.rb#84
  def from_string(input); end

  # source://dnsruby//lib/dnsruby/resource/HIP.rb#66
  def hit_from_string(hit_text); end

  # An 8-bit length for the HIT field
  #
  # source://dnsruby//lib/dnsruby/resource/HIP.rb#25
  def hit_length; end

  # An 8-bit length for the HIT field
  #
  # source://dnsruby//lib/dnsruby/resource/HIP.rb#25
  def hit_length=(_arg0); end

  # HIT field - stored in binary : client methods should handle base16(hex) encoding
  #
  # source://dnsruby//lib/dnsruby/resource/HIP.rb#62
  def hit_string; end

  # The PK algorithm used :
  #  0 - no key present
  #  1 - DSA key present
  #  2 - RSA key present
  #
  # source://dnsruby//lib/dnsruby/resource/HIP.rb#30
  def pk_algorithm; end

  # The PK algorithm used :
  #  0 - no key present
  #  1 - DSA key present
  #  2 - RSA key present
  #
  # source://dnsruby//lib/dnsruby/resource/HIP.rb#30
  def pk_algorithm=(_arg0); end

  # An 8-bit length for the Public Key field
  #
  # source://dnsruby//lib/dnsruby/resource/HIP.rb#32
  def pk_length; end

  # An 8-bit length for the Public Key field
  #
  # source://dnsruby//lib/dnsruby/resource/HIP.rb#32
  def pk_length=(_arg0); end

  # source://dnsruby//lib/dnsruby/resource/HIP.rb#78
  def public_key_from_string(key_text); end

  # Public Key field - presentation format is base64 - public_key methods reused from IPSECKEY
  #
  # source://dnsruby//lib/dnsruby/resource/HIP.rb#74
  def public_key_string; end

  # source://dnsruby//lib/dnsruby/resource/HIP.rb#105
  def rdata_to_string; end

  # An array of Rendezvous Servers
  #
  # source://dnsruby//lib/dnsruby/resource/HIP.rb#35
  def rsvs; end

  # An array of Rendezvous Servers
  #
  # source://dnsruby//lib/dnsruby/resource/HIP.rb#35
  def rsvs=(_arg0); end

  class << self
    # source://dnsruby//lib/dnsruby/resource/HIP.rb#123
    def decode_rdata(msg); end
  end
end

# source://dnsruby//lib/dnsruby/resource/HIP.rb#21
Dnsruby::RR::HIP::ClassValue = T.let(T.unsafe(nil), T.untyped)

# source://dnsruby//lib/dnsruby/resource/HIP.rb#22
Dnsruby::RR::HIP::TypeValue = T.let(T.unsafe(nil), Integer)

# module IN contains ARPA Internet specific RRs
#
# source://dnsruby//lib/dnsruby/resource/PX.rb#18
module Dnsruby::RR::IN; end

# Class for DNS Address (A) resource records.
#
# RFC 1035 Section 3.4.1
#
# source://dnsruby//lib/dnsruby/resource/A.rb#22
class Dnsruby::RR::IN::A < ::Dnsruby::RR
  # The RR's (Resolv::IPv4) address field
  #
  # source://dnsruby//lib/dnsruby/resource/A.rb#26
  def address; end

  # The RR's (Resolv::IPv4) address field
  #
  # source://dnsruby//lib/dnsruby/resource/A.rb#26
  def address=(_arg0); end

  # source://dnsruby//lib/dnsruby/resource/A.rb#46
  def encode_rdata(msg, canonical = T.unsafe(nil)); end

  # source://dnsruby//lib/dnsruby/resource/A.rb#28
  def from_data(data); end

  # Create the RR from a hash
  #
  # source://dnsruby//lib/dnsruby/resource/A.rb#33
  def from_hash(hash); end

  # Create the RR from a standard string
  #
  # source://dnsruby//lib/dnsruby/resource/A.rb#38
  def from_string(input); end

  # source://dnsruby//lib/dnsruby/resource/A.rb#42
  def rdata_to_string; end

  class << self
    # source://dnsruby//lib/dnsruby/resource/A.rb#50
    def decode_rdata(msg); end
  end
end

# source://dnsruby//lib/dnsruby/resource/A.rb#23
Dnsruby::RR::IN::A::ClassValue = T.let(T.unsafe(nil), Integer)

# source://dnsruby//lib/dnsruby/resource/A.rb#23
Dnsruby::RR::IN::A::TypeValue = T.let(T.unsafe(nil), Integer)

# Class for DNS IPv6 Address (AAAA) resource records.
#
# RFC 1886 Section 2, RFC 1884 Sections 2.2 & 2.4.4
#
# source://dnsruby//lib/dnsruby/resource/AAAA.rb#22
class Dnsruby::RR::IN::AAAA < ::Dnsruby::RR
  # The RR's (Resolv::IPv6) address field
  #
  # source://dnsruby//lib/dnsruby/resource/AAAA.rb#26
  def address; end

  # The RR's (Resolv::IPv6) address field
  #
  # source://dnsruby//lib/dnsruby/resource/AAAA.rb#26
  def address=(_arg0); end

  # source://dnsruby//lib/dnsruby/resource/AAAA.rb#44
  def encode_rdata(msg, canonical = T.unsafe(nil)); end

  # source://dnsruby//lib/dnsruby/resource/AAAA.rb#28
  def from_data(data); end

  # source://dnsruby//lib/dnsruby/resource/AAAA.rb#32
  def from_hash(hash); end

  # source://dnsruby//lib/dnsruby/resource/AAAA.rb#36
  def from_string(input); end

  # source://dnsruby//lib/dnsruby/resource/AAAA.rb#40
  def rdata_to_string; end

  class << self
    # source://dnsruby//lib/dnsruby/resource/AAAA.rb#48
    def decode_rdata(msg); end
  end
end

# source://dnsruby//lib/dnsruby/resource/AAAA.rb#23
Dnsruby::RR::IN::AAAA::ClassValue = T.let(T.unsafe(nil), Integer)

# source://dnsruby//lib/dnsruby/resource/AAAA.rb#23
Dnsruby::RR::IN::AAAA::TypeValue = T.let(T.unsafe(nil), Integer)

# Class for DNS AFS Data Base (AFSDB) resource records.
#
# RFC 1183 Section 1
#
# source://dnsruby//lib/dnsruby/resource/AFSDB.rb#22
class Dnsruby::RR::IN::AFSDB < ::Dnsruby::RR
  # source://dnsruby//lib/dnsruby/resource/AFSDB.rb#55
  def encode_rdata(msg, canonical = T.unsafe(nil)); end

  # source://dnsruby//lib/dnsruby/resource/AFSDB.rb#36
  def from_data(data); end

  # source://dnsruby//lib/dnsruby/resource/AFSDB.rb#31
  def from_hash(hash); end

  # source://dnsruby//lib/dnsruby/resource/AFSDB.rb#40
  def from_string(input); end

  # The RR's hostname field.  See RFC 1183.
  #
  # source://dnsruby//lib/dnsruby/resource/AFSDB.rb#29
  def hostname; end

  # The RR's hostname field.  See RFC 1183.
  #
  # source://dnsruby//lib/dnsruby/resource/AFSDB.rb#29
  def hostname=(_arg0); end

  # source://dnsruby//lib/dnsruby/resource/AFSDB.rb#47
  def rdata_to_string; end

  # The RR's subtype field.  See RFC 1183.
  #
  # source://dnsruby//lib/dnsruby/resource/AFSDB.rb#26
  def subtype; end

  # The RR's subtype field.  See RFC 1183.
  #
  # source://dnsruby//lib/dnsruby/resource/AFSDB.rb#26
  def subtype=(_arg0); end

  class << self
    # source://dnsruby//lib/dnsruby/resource/AFSDB.rb#60
    def decode_rdata(msg); end
  end
end

# source://dnsruby//lib/dnsruby/resource/AFSDB.rb#23
Dnsruby::RR::IN::AFSDB::ClassValue = T.let(T.unsafe(nil), Integer)

# source://dnsruby//lib/dnsruby/resource/AFSDB.rb#23
Dnsruby::RR::IN::AFSDB::TypeValue = T.let(T.unsafe(nil), Integer)

# source://dnsruby//lib/dnsruby/resource/IN.rb#69
class Dnsruby::RR::IN::ANY < ::Dnsruby::RR::ANY; end

# source://dnsruby//lib/dnsruby/resource/IN.rb#72
Dnsruby::RR::IN::ANY::ClassValue = T.let(T.unsafe(nil), Integer)

# source://dnsruby//lib/dnsruby/resource/IN.rb#71
Dnsruby::RR::IN::ANY::TypeValue = T.let(T.unsafe(nil), Integer)

# Class for DNS Address (A) resource records.
#
# RFC 1035 Section 3.4.1
#
# source://dnsruby//lib/dnsruby/resource/APL.rb#112
class Dnsruby::RR::IN::APL < ::Dnsruby::RR
  # source://dnsruby//lib/dnsruby/resource/APL.rb#136
  def encode_rdata(msg, canonical = T.unsafe(nil)); end

  # source://dnsruby//lib/dnsruby/resource/APL.rb#118
  def from_data(data); end

  # Create the RR from a hash
  #
  # source://dnsruby//lib/dnsruby/resource/APL.rb#123
  def from_hash(hash); end

  # Create the RR from a standard string
  #
  # source://dnsruby//lib/dnsruby/resource/APL.rb#128
  def from_string(input); end

  # The RR's (Resolv::IPv4) address field
  #
  # source://dnsruby//lib/dnsruby/resource/APL.rb#116
  def prefixes; end

  # The RR's (Resolv::IPv4) address field
  #
  # source://dnsruby//lib/dnsruby/resource/APL.rb#116
  def prefixes=(_arg0); end

  # source://dnsruby//lib/dnsruby/resource/APL.rb#132
  def rdata_to_string; end

  class << self
    # source://dnsruby//lib/dnsruby/resource/APL.rb#140
    def decode_rdata(msg); end
  end
end

# source://dnsruby//lib/dnsruby/resource/APL.rb#113
Dnsruby::RR::IN::APL::ClassValue = T.let(T.unsafe(nil), Integer)

# source://dnsruby//lib/dnsruby/resource/APL.rb#113
Dnsruby::RR::IN::APL::TypeValue = T.let(T.unsafe(nil), Integer)

# source://dnsruby//lib/dnsruby/resource/IN.rb#69
class Dnsruby::RR::IN::CAA < ::Dnsruby::RR::CAA; end

# source://dnsruby//lib/dnsruby/resource/IN.rb#72
Dnsruby::RR::IN::CAA::ClassValue = T.let(T.unsafe(nil), Integer)

# source://dnsruby//lib/dnsruby/resource/IN.rb#71
Dnsruby::RR::IN::CAA::TypeValue = T.let(T.unsafe(nil), Integer)

# source://dnsruby//lib/dnsruby/resource/IN.rb#69
class Dnsruby::RR::IN::CDNSKEY < ::Dnsruby::RR::CDNSKEY; end

# source://dnsruby//lib/dnsruby/resource/IN.rb#72
Dnsruby::RR::IN::CDNSKEY::ClassValue = T.let(T.unsafe(nil), Integer)

# source://dnsruby//lib/dnsruby/resource/IN.rb#71
Dnsruby::RR::IN::CDNSKEY::TypeValue = T.let(T.unsafe(nil), Integer)

# source://dnsruby//lib/dnsruby/resource/IN.rb#69
class Dnsruby::RR::IN::CDS < ::Dnsruby::RR::CDS; end

# source://dnsruby//lib/dnsruby/resource/IN.rb#72
Dnsruby::RR::IN::CDS::ClassValue = T.let(T.unsafe(nil), Integer)

# source://dnsruby//lib/dnsruby/resource/IN.rb#71
Dnsruby::RR::IN::CDS::TypeValue = T.let(T.unsafe(nil), Integer)

# source://dnsruby//lib/dnsruby/resource/IN.rb#69
class Dnsruby::RR::IN::CERT < ::Dnsruby::RR::CERT; end

# source://dnsruby//lib/dnsruby/resource/IN.rb#72
Dnsruby::RR::IN::CERT::ClassValue = T.let(T.unsafe(nil), Integer)

# source://dnsruby//lib/dnsruby/resource/IN.rb#71
Dnsruby::RR::IN::CERT::TypeValue = T.let(T.unsafe(nil), Integer)

# source://dnsruby//lib/dnsruby/resource/IN.rb#69
class Dnsruby::RR::IN::CNAME < ::Dnsruby::RR::CNAME; end

# source://dnsruby//lib/dnsruby/resource/IN.rb#72
Dnsruby::RR::IN::CNAME::ClassValue = T.let(T.unsafe(nil), Integer)

# source://dnsruby//lib/dnsruby/resource/IN.rb#71
Dnsruby::RR::IN::CNAME::TypeValue = T.let(T.unsafe(nil), Integer)

# source://dnsruby//lib/dnsruby/resource/IN.rb#66
Dnsruby::RR::IN::ClassValue = T.let(T.unsafe(nil), Integer)

# source://dnsruby//lib/dnsruby/resource/IN.rb#69
class Dnsruby::RR::IN::DHCID < ::Dnsruby::RR::DHCID; end

# source://dnsruby//lib/dnsruby/resource/IN.rb#72
Dnsruby::RR::IN::DHCID::ClassValue = T.let(T.unsafe(nil), Integer)

# source://dnsruby//lib/dnsruby/resource/IN.rb#71
Dnsruby::RR::IN::DHCID::TypeValue = T.let(T.unsafe(nil), Integer)

# source://dnsruby//lib/dnsruby/resource/IN.rb#69
class Dnsruby::RR::IN::DLV < ::Dnsruby::RR::DLV; end

# source://dnsruby//lib/dnsruby/resource/IN.rb#72
Dnsruby::RR::IN::DLV::ClassValue = T.let(T.unsafe(nil), Integer)

# source://dnsruby//lib/dnsruby/resource/IN.rb#71
Dnsruby::RR::IN::DLV::TypeValue = T.let(T.unsafe(nil), Integer)

# source://dnsruby//lib/dnsruby/resource/IN.rb#69
class Dnsruby::RR::IN::DNAME < ::Dnsruby::RR::DNAME; end

# source://dnsruby//lib/dnsruby/resource/IN.rb#72
Dnsruby::RR::IN::DNAME::ClassValue = T.let(T.unsafe(nil), Integer)

# source://dnsruby//lib/dnsruby/resource/IN.rb#71
Dnsruby::RR::IN::DNAME::TypeValue = T.let(T.unsafe(nil), Integer)

# source://dnsruby//lib/dnsruby/resource/IN.rb#69
class Dnsruby::RR::IN::DNSKEY < ::Dnsruby::RR::DNSKEY; end

# source://dnsruby//lib/dnsruby/resource/IN.rb#72
Dnsruby::RR::IN::DNSKEY::ClassValue = T.let(T.unsafe(nil), Integer)

# source://dnsruby//lib/dnsruby/resource/IN.rb#71
Dnsruby::RR::IN::DNSKEY::TypeValue = T.let(T.unsafe(nil), Integer)

# source://dnsruby//lib/dnsruby/resource/IN.rb#69
class Dnsruby::RR::IN::DS < ::Dnsruby::RR::DS; end

# source://dnsruby//lib/dnsruby/resource/IN.rb#72
Dnsruby::RR::IN::DS::ClassValue = T.let(T.unsafe(nil), Integer)

# source://dnsruby//lib/dnsruby/resource/IN.rb#71
Dnsruby::RR::IN::DS::TypeValue = T.let(T.unsafe(nil), Integer)

# source://dnsruby//lib/dnsruby/resource/IN.rb#69
class Dnsruby::RR::IN::GPOS < ::Dnsruby::RR::GPOS; end

# source://dnsruby//lib/dnsruby/resource/IN.rb#72
Dnsruby::RR::IN::GPOS::ClassValue = T.let(T.unsafe(nil), Integer)

# source://dnsruby//lib/dnsruby/resource/IN.rb#71
Dnsruby::RR::IN::GPOS::TypeValue = T.let(T.unsafe(nil), Integer)

# source://dnsruby//lib/dnsruby/resource/IN.rb#69
class Dnsruby::RR::IN::HINFO < ::Dnsruby::RR::HINFO; end

# source://dnsruby//lib/dnsruby/resource/IN.rb#72
Dnsruby::RR::IN::HINFO::ClassValue = T.let(T.unsafe(nil), Integer)

# source://dnsruby//lib/dnsruby/resource/IN.rb#71
Dnsruby::RR::IN::HINFO::TypeValue = T.let(T.unsafe(nil), Integer)

# source://dnsruby//lib/dnsruby/resource/IN.rb#69
class Dnsruby::RR::IN::HIP < ::Dnsruby::RR::HIP; end

# source://dnsruby//lib/dnsruby/resource/IN.rb#72
Dnsruby::RR::IN::HIP::ClassValue = T.let(T.unsafe(nil), Integer)

# source://dnsruby//lib/dnsruby/resource/IN.rb#71
Dnsruby::RR::IN::HIP::TypeValue = T.let(T.unsafe(nil), Integer)

# source://dnsruby//lib/dnsruby/resource/IN.rb#69
class Dnsruby::RR::IN::IPSECKEY < ::Dnsruby::RR::IPSECKEY; end

# source://dnsruby//lib/dnsruby/resource/IN.rb#72
Dnsruby::RR::IN::IPSECKEY::ClassValue = T.let(T.unsafe(nil), Integer)

# source://dnsruby//lib/dnsruby/resource/IN.rb#71
Dnsruby::RR::IN::IPSECKEY::TypeValue = T.let(T.unsafe(nil), Integer)

# source://dnsruby//lib/dnsruby/resource/IN.rb#69
class Dnsruby::RR::IN::ISDN < ::Dnsruby::RR::ISDN; end

# source://dnsruby//lib/dnsruby/resource/IN.rb#72
Dnsruby::RR::IN::ISDN::ClassValue = T.let(T.unsafe(nil), Integer)

# source://dnsruby//lib/dnsruby/resource/IN.rb#71
Dnsruby::RR::IN::ISDN::TypeValue = T.let(T.unsafe(nil), Integer)

# source://dnsruby//lib/dnsruby/resource/IN.rb#69
class Dnsruby::RR::IN::KX < ::Dnsruby::RR::KX; end

# source://dnsruby//lib/dnsruby/resource/IN.rb#72
Dnsruby::RR::IN::KX::ClassValue = T.let(T.unsafe(nil), Integer)

# source://dnsruby//lib/dnsruby/resource/IN.rb#71
Dnsruby::RR::IN::KX::TypeValue = T.let(T.unsafe(nil), Integer)

# source://dnsruby//lib/dnsruby/resource/IN.rb#69
class Dnsruby::RR::IN::LOC < ::Dnsruby::RR::LOC; end

# source://dnsruby//lib/dnsruby/resource/IN.rb#72
Dnsruby::RR::IN::LOC::ClassValue = T.let(T.unsafe(nil), Integer)

# source://dnsruby//lib/dnsruby/resource/IN.rb#71
Dnsruby::RR::IN::LOC::TypeValue = T.let(T.unsafe(nil), Integer)

# source://dnsruby//lib/dnsruby/resource/IN.rb#69
class Dnsruby::RR::IN::MB < ::Dnsruby::RR::MB; end

# source://dnsruby//lib/dnsruby/resource/IN.rb#72
Dnsruby::RR::IN::MB::ClassValue = T.let(T.unsafe(nil), Integer)

# source://dnsruby//lib/dnsruby/resource/IN.rb#71
Dnsruby::RR::IN::MB::TypeValue = T.let(T.unsafe(nil), Integer)

# source://dnsruby//lib/dnsruby/resource/IN.rb#69
class Dnsruby::RR::IN::MG < ::Dnsruby::RR::MG; end

# source://dnsruby//lib/dnsruby/resource/IN.rb#72
Dnsruby::RR::IN::MG::ClassValue = T.let(T.unsafe(nil), Integer)

# source://dnsruby//lib/dnsruby/resource/IN.rb#71
Dnsruby::RR::IN::MG::TypeValue = T.let(T.unsafe(nil), Integer)

# source://dnsruby//lib/dnsruby/resource/IN.rb#69
class Dnsruby::RR::IN::MINFO < ::Dnsruby::RR::MINFO; end

# source://dnsruby//lib/dnsruby/resource/IN.rb#72
Dnsruby::RR::IN::MINFO::ClassValue = T.let(T.unsafe(nil), Integer)

# source://dnsruby//lib/dnsruby/resource/IN.rb#71
Dnsruby::RR::IN::MINFO::TypeValue = T.let(T.unsafe(nil), Integer)

# source://dnsruby//lib/dnsruby/resource/IN.rb#69
class Dnsruby::RR::IN::MR < ::Dnsruby::RR::MR; end

# source://dnsruby//lib/dnsruby/resource/IN.rb#72
Dnsruby::RR::IN::MR::ClassValue = T.let(T.unsafe(nil), Integer)

# source://dnsruby//lib/dnsruby/resource/IN.rb#71
Dnsruby::RR::IN::MR::TypeValue = T.let(T.unsafe(nil), Integer)

# source://dnsruby//lib/dnsruby/resource/IN.rb#69
class Dnsruby::RR::IN::MX < ::Dnsruby::RR::MX; end

# source://dnsruby//lib/dnsruby/resource/IN.rb#72
Dnsruby::RR::IN::MX::ClassValue = T.let(T.unsafe(nil), Integer)

# source://dnsruby//lib/dnsruby/resource/IN.rb#71
Dnsruby::RR::IN::MX::TypeValue = T.let(T.unsafe(nil), Integer)

# source://dnsruby//lib/dnsruby/resource/IN.rb#69
class Dnsruby::RR::IN::NAPTR < ::Dnsruby::RR::NAPTR; end

# source://dnsruby//lib/dnsruby/resource/IN.rb#72
Dnsruby::RR::IN::NAPTR::ClassValue = T.let(T.unsafe(nil), Integer)

# source://dnsruby//lib/dnsruby/resource/IN.rb#71
Dnsruby::RR::IN::NAPTR::TypeValue = T.let(T.unsafe(nil), Integer)

# source://dnsruby//lib/dnsruby/resource/IN.rb#69
class Dnsruby::RR::IN::NS < ::Dnsruby::RR::NS; end

# source://dnsruby//lib/dnsruby/resource/IN.rb#72
Dnsruby::RR::IN::NS::ClassValue = T.let(T.unsafe(nil), Integer)

# source://dnsruby//lib/dnsruby/resource/IN.rb#71
Dnsruby::RR::IN::NS::TypeValue = T.let(T.unsafe(nil), Integer)

# source://dnsruby//lib/dnsruby/resource/IN.rb#69
class Dnsruby::RR::IN::NSAP < ::Dnsruby::RR::NSAP; end

# source://dnsruby//lib/dnsruby/resource/IN.rb#72
Dnsruby::RR::IN::NSAP::ClassValue = T.let(T.unsafe(nil), Integer)

# source://dnsruby//lib/dnsruby/resource/IN.rb#71
Dnsruby::RR::IN::NSAP::TypeValue = T.let(T.unsafe(nil), Integer)

# source://dnsruby//lib/dnsruby/resource/IN.rb#69
class Dnsruby::RR::IN::NSEC < ::Dnsruby::RR::NSEC; end

# source://dnsruby//lib/dnsruby/resource/IN.rb#69
class Dnsruby::RR::IN::NSEC3 < ::Dnsruby::RR::NSEC3; end

# source://dnsruby//lib/dnsruby/resource/IN.rb#72
Dnsruby::RR::IN::NSEC3::ClassValue = T.let(T.unsafe(nil), Integer)

# source://dnsruby//lib/dnsruby/resource/IN.rb#71
Dnsruby::RR::IN::NSEC3::TypeValue = T.let(T.unsafe(nil), Integer)

# source://dnsruby//lib/dnsruby/resource/IN.rb#69
class Dnsruby::RR::IN::NSEC3PARAM < ::Dnsruby::RR::NSEC3PARAM; end

# source://dnsruby//lib/dnsruby/resource/IN.rb#72
Dnsruby::RR::IN::NSEC3PARAM::ClassValue = T.let(T.unsafe(nil), Integer)

# source://dnsruby//lib/dnsruby/resource/IN.rb#71
Dnsruby::RR::IN::NSEC3PARAM::TypeValue = T.let(T.unsafe(nil), Integer)

# source://dnsruby//lib/dnsruby/resource/IN.rb#72
Dnsruby::RR::IN::NSEC::ClassValue = T.let(T.unsafe(nil), Integer)

# source://dnsruby//lib/dnsruby/resource/IN.rb#71
Dnsruby::RR::IN::NSEC::TypeValue = T.let(T.unsafe(nil), Integer)

# source://dnsruby//lib/dnsruby/resource/IN.rb#69
class Dnsruby::RR::IN::NXT < ::Dnsruby::RR::NXT; end

# source://dnsruby//lib/dnsruby/resource/IN.rb#72
Dnsruby::RR::IN::NXT::ClassValue = T.let(T.unsafe(nil), Integer)

# source://dnsruby//lib/dnsruby/resource/IN.rb#71
Dnsruby::RR::IN::NXT::TypeValue = T.let(T.unsafe(nil), Integer)

# source://dnsruby//lib/dnsruby/resource/IN.rb#69
class Dnsruby::RR::IN::OPT < ::Dnsruby::RR::OPT; end

# source://dnsruby//lib/dnsruby/resource/IN.rb#72
Dnsruby::RR::IN::OPT::ClassValue = T.let(T.unsafe(nil), Integer)

# source://dnsruby//lib/dnsruby/resource/IN.rb#71
Dnsruby::RR::IN::OPT::TypeValue = T.let(T.unsafe(nil), Integer)

# source://dnsruby//lib/dnsruby/resource/IN.rb#69
class Dnsruby::RR::IN::PTR < ::Dnsruby::RR::PTR; end

# source://dnsruby//lib/dnsruby/resource/IN.rb#72
Dnsruby::RR::IN::PTR::ClassValue = T.let(T.unsafe(nil), Integer)

# source://dnsruby//lib/dnsruby/resource/IN.rb#71
Dnsruby::RR::IN::PTR::TypeValue = T.let(T.unsafe(nil), Integer)

# source://dnsruby//lib/dnsruby/resource/PX.rb#19
class Dnsruby::RR::IN::PX < ::Dnsruby::RR
  # source://dnsruby//lib/dnsruby/resource/PX.rb#56
  def encode_rdata(msg, canonical = T.unsafe(nil)); end

  # source://dnsruby//lib/dnsruby/resource/PX.rb#35
  def from_data(data); end

  # source://dnsruby//lib/dnsruby/resource/PX.rb#29
  def from_hash(hash); end

  # source://dnsruby//lib/dnsruby/resource/PX.rb#39
  def from_string(input); end

  # The RFC822 part of the RFC1327 mapping information.
  #
  # source://dnsruby//lib/dnsruby/resource/PX.rb#25
  def map822; end

  # The RFC822 part of the RFC1327 mapping information.
  #
  # source://dnsruby//lib/dnsruby/resource/PX.rb#25
  def map822=(_arg0); end

  # The X.400 part of the RFC1327 mapping information.
  #
  # source://dnsruby//lib/dnsruby/resource/PX.rb#27
  def mapx400; end

  # The X.400 part of the RFC1327 mapping information.
  #
  # source://dnsruby//lib/dnsruby/resource/PX.rb#27
  def mapx400=(_arg0); end

  # The preference given to this RR.
  #
  # source://dnsruby//lib/dnsruby/resource/PX.rb#23
  def preference; end

  # The preference given to this RR.
  #
  # source://dnsruby//lib/dnsruby/resource/PX.rb#23
  def preference=(_arg0); end

  # source://dnsruby//lib/dnsruby/resource/PX.rb#48
  def rdata_to_string; end

  class << self
    # source://dnsruby//lib/dnsruby/resource/PX.rb#62
    def decode_rdata(msg); end
  end
end

# source://dnsruby//lib/dnsruby/resource/PX.rb#20
Dnsruby::RR::IN::PX::ClassValue = T.let(T.unsafe(nil), Integer)

# source://dnsruby//lib/dnsruby/resource/PX.rb#20
Dnsruby::RR::IN::PX::TypeValue = T.let(T.unsafe(nil), Integer)

# source://dnsruby//lib/dnsruby/resource/IN.rb#69
class Dnsruby::RR::IN::RP < ::Dnsruby::RR::RP; end

# source://dnsruby//lib/dnsruby/resource/IN.rb#72
Dnsruby::RR::IN::RP::ClassValue = T.let(T.unsafe(nil), Integer)

# source://dnsruby//lib/dnsruby/resource/IN.rb#71
Dnsruby::RR::IN::RP::TypeValue = T.let(T.unsafe(nil), Integer)

# source://dnsruby//lib/dnsruby/resource/IN.rb#69
class Dnsruby::RR::IN::RRSIG < ::Dnsruby::RR::RRSIG; end

# source://dnsruby//lib/dnsruby/resource/IN.rb#72
Dnsruby::RR::IN::RRSIG::ClassValue = T.let(T.unsafe(nil), Integer)

# source://dnsruby//lib/dnsruby/resource/IN.rb#71
Dnsruby::RR::IN::RRSIG::TypeValue = T.let(T.unsafe(nil), Integer)

# source://dnsruby//lib/dnsruby/resource/IN.rb#69
class Dnsruby::RR::IN::RT < ::Dnsruby::RR::RT; end

# source://dnsruby//lib/dnsruby/resource/IN.rb#72
Dnsruby::RR::IN::RT::ClassValue = T.let(T.unsafe(nil), Integer)

# source://dnsruby//lib/dnsruby/resource/IN.rb#71
Dnsruby::RR::IN::RT::TypeValue = T.let(T.unsafe(nil), Integer)

# source://dnsruby//lib/dnsruby/resource/IN.rb#69
class Dnsruby::RR::IN::SOA < ::Dnsruby::RR::SOA; end

# source://dnsruby//lib/dnsruby/resource/IN.rb#72
Dnsruby::RR::IN::SOA::ClassValue = T.let(T.unsafe(nil), Integer)

# source://dnsruby//lib/dnsruby/resource/IN.rb#71
Dnsruby::RR::IN::SOA::TypeValue = T.let(T.unsafe(nil), Integer)

# source://dnsruby//lib/dnsruby/resource/IN.rb#69
class Dnsruby::RR::IN::SPF < ::Dnsruby::RR::SPF; end

# source://dnsruby//lib/dnsruby/resource/IN.rb#72
Dnsruby::RR::IN::SPF::ClassValue = T.let(T.unsafe(nil), Integer)

# source://dnsruby//lib/dnsruby/resource/IN.rb#71
Dnsruby::RR::IN::SPF::TypeValue = T.let(T.unsafe(nil), Integer)

# SRV resource record defined in RFC 2782
#
#  These records identify the hostname and port that a service is
#  available at.
#
#  The format is:
#    _Service._Proto.Name TTL Class SRV Priority Weight Port Target
#
#  The fields specific to SRV are defined in RFC 2782
#
# source://dnsruby//lib/dnsruby/resource/SRV.rb#28
class Dnsruby::RR::IN::SRV < ::Dnsruby::RR
  # source://dnsruby//lib/dnsruby/resource/SRV.rb#95
  def encode_rdata(msg, canonical = T.unsafe(nil)); end

  # source://dnsruby//lib/dnsruby/resource/SRV.rb#56
  def from_data(data); end

  # source://dnsruby//lib/dnsruby/resource/SRV.rb#60
  def from_hash(hash); end

  # source://dnsruby//lib/dnsruby/resource/SRV.rb#75
  def from_string(input); end

  # The port on this target host of this service.  The range is 0-65535.
  #
  # source://dnsruby//lib/dnsruby/resource/SRV.rb#50
  def port; end

  # The port on this target host of this service.  The range is 0-65535.
  #
  # source://dnsruby//lib/dnsruby/resource/SRV.rb#50
  def port=(_arg0); end

  # The priority of this target host.
  #  A client MUST attempt
  #  to contact the target host with the lowest-numbered priority it can
  #  reach; target hosts with the same priority SHOULD be tried in an
  #  order defined by the weight field.  The range is 0-65535.  Note that
  #  it is not widely implemented and should be set to zero.
  #
  # source://dnsruby//lib/dnsruby/resource/SRV.rb#37
  def priority; end

  # The priority of this target host.
  #  A client MUST attempt
  #  to contact the target host with the lowest-numbered priority it can
  #  reach; target hosts with the same priority SHOULD be tried in an
  #  order defined by the weight field.  The range is 0-65535.  Note that
  #  it is not widely implemented and should be set to zero.
  #
  # source://dnsruby//lib/dnsruby/resource/SRV.rb#37
  def priority=(_arg0); end

  # source://dnsruby//lib/dnsruby/resource/SRV.rb#87
  def rdata_to_string; end

  # The domain name of the target host. A target of "." means
  #  that the service is decidedly not available at this domain.
  #
  # source://dnsruby//lib/dnsruby/resource/SRV.rb#54
  def target; end

  # The domain name of the target host. A target of "." means
  #  that the service is decidedly not available at this domain.
  #
  # source://dnsruby//lib/dnsruby/resource/SRV.rb#54
  def target=(_arg0); end

  # A server selection mechanism.
  #  The weight field specifies
  #  a relative weight for entries with the same priority. Larger weights
  #  SHOULD be given a proportionately higher probability of being
  #  selected. The range of this number is 0-65535.  Domain administrators
  #  SHOULD use Weight 0 when there isn't any server selection to do, to
  #  make the RR easier to read for humans (less noisy). Note that it is
  #  not widely implemented and should be set to zero.
  #
  # source://dnsruby//lib/dnsruby/resource/SRV.rb#47
  def weight; end

  # A server selection mechanism.
  #  The weight field specifies
  #  a relative weight for entries with the same priority. Larger weights
  #  SHOULD be given a proportionately higher probability of being
  #  selected. The range of this number is 0-65535.  Domain administrators
  #  SHOULD use Weight 0 when there isn't any server selection to do, to
  #  make the RR easier to read for humans (less noisy). Note that it is
  #  not widely implemented and should be set to zero.
  #
  # source://dnsruby//lib/dnsruby/resource/SRV.rb#47
  def weight=(_arg0); end

  class << self
    # source://dnsruby//lib/dnsruby/resource/SRV.rb#102
    def decode_rdata(msg); end
  end
end

# source://dnsruby//lib/dnsruby/resource/SRV.rb#29
Dnsruby::RR::IN::SRV::ClassValue = T.let(T.unsafe(nil), Integer)

# source://dnsruby//lib/dnsruby/resource/SRV.rb#29
Dnsruby::RR::IN::SRV::TypeValue = T.let(T.unsafe(nil), Integer)

# source://dnsruby//lib/dnsruby/resource/IN.rb#69
class Dnsruby::RR::IN::SSHFP < ::Dnsruby::RR::SSHFP; end

# source://dnsruby//lib/dnsruby/resource/IN.rb#72
Dnsruby::RR::IN::SSHFP::ClassValue = T.let(T.unsafe(nil), Integer)

# source://dnsruby//lib/dnsruby/resource/IN.rb#71
Dnsruby::RR::IN::SSHFP::TypeValue = T.let(T.unsafe(nil), Integer)

# source://dnsruby//lib/dnsruby/resource/IN.rb#69
class Dnsruby::RR::IN::TKEY < ::Dnsruby::RR::TKEY; end

# source://dnsruby//lib/dnsruby/resource/IN.rb#72
Dnsruby::RR::IN::TKEY::ClassValue = T.let(T.unsafe(nil), Integer)

# source://dnsruby//lib/dnsruby/resource/IN.rb#71
Dnsruby::RR::IN::TKEY::TypeValue = T.let(T.unsafe(nil), Integer)

# Class for DNS TLSA server certificate or public key (TLSA) resource records.
#
# RFC 6698
#
# source://dnsruby//lib/dnsruby/resource/TLSA.rb#9
class Dnsruby::RR::IN::TLSA < ::Dnsruby::RR
  # source://dnsruby//lib/dnsruby/resource/TLSA.rb#70
  def cert; end

  # sec 2.1.4
  #
  # source://dnsruby//lib/dnsruby/resource/TLSA.rb#36
  def data; end

  # sec 2.1.4
  #
  # source://dnsruby//lib/dnsruby/resource/TLSA.rb#61
  def data=(data); end

  # Returns the value of attribute databin.
  #
  # source://dnsruby//lib/dnsruby/resource/TLSA.rb#37
  def databin; end

  # Sets the attribute databin
  #
  # @param value the value to set the attribute databin to.
  #
  # source://dnsruby//lib/dnsruby/resource/TLSA.rb#65
  def databin=(databin); end

  # source://dnsruby//lib/dnsruby/resource/TLSA.rb#136
  def encode_rdata(msg, _canonical = T.unsafe(nil)); end

  # source://dnsruby//lib/dnsruby/resource/TLSA.rb#47
  def from_data(data); end

  # Create the RR from a hash
  #
  # source://dnsruby//lib/dnsruby/resource/TLSA.rb#56
  def from_hash(hash); end

  # Create the RR from a standard string
  #
  # source://dnsruby//lib/dnsruby/resource/TLSA.rb#123
  def from_string(input); end

  # sec 2.3.1
  #
  # 0 Exact match on selected content
  # 1 SHA-256 hash of selected content
  # 2 SHA-512 hash of selected content
  # 3-254 Unassigned
  # 255 Private use
  #
  # source://dnsruby//lib/dnsruby/resource/TLSA.rb#34
  def matching_type; end

  # sec 2.3.1
  #
  # 0 Exact match on selected content
  # 1 SHA-256 hash of selected content
  # 2 SHA-512 hash of selected content
  # 3-254 Unassigned
  # 255 Private use
  #
  # source://dnsruby//lib/dnsruby/resource/TLSA.rb#34
  def matching_type=(_arg0); end

  # @raise [ArgumentError]
  #
  # source://dnsruby//lib/dnsruby/resource/TLSA.rb#98
  def parse_string(data); end

  # source://dnsruby//lib/dnsruby/resource/TLSA.rb#81
  def pkey; end

  # source://dnsruby//lib/dnsruby/resource/TLSA.rb#132
  def rdata_to_string; end

  # sec 2.1.2, 7.3
  #
  # 0 Full certificate
  # 1 SubjectPublicKeyInfo
  # 2-254 Unassigned
  # 255 Private use
  #
  # source://dnsruby//lib/dnsruby/resource/TLSA.rb#26
  def selector; end

  # sec 2.1.2, 7.3
  #
  # 0 Full certificate
  # 1 SubjectPublicKeyInfo
  # 2-254 Unassigned
  # 255 Private use
  #
  # source://dnsruby//lib/dnsruby/resource/TLSA.rb#26
  def selector=(_arg0); end

  # sec 2.1.1 ,7,2
  #
  # 0 CA constraint
  # 1 Service certificate constraint
  # 2 Trust anchor assertion
  # 3 Domain-issued certificate
  # 4-254 Unassigned
  # 255 Private use
  #
  # source://dnsruby//lib/dnsruby/resource/TLSA.rb#19
  def usage; end

  # sec 2.1.1 ,7,2
  #
  # 0 CA constraint
  # 1 Service certificate constraint
  # 2 Trust anchor assertion
  # 3 Domain-issued certificate
  # 4-254 Unassigned
  # 255 Private use
  #
  # source://dnsruby//lib/dnsruby/resource/TLSA.rb#19
  def usage=(_arg0); end

  # @raise [ArgumentError]
  #
  # source://dnsruby//lib/dnsruby/resource/TLSA.rb#39
  def verify; end

  class << self
    # source://dnsruby//lib/dnsruby/resource/TLSA.rb#141
    def decode_rdata(msg); end
  end
end

# source://dnsruby//lib/dnsruby/resource/TLSA.rb#10
Dnsruby::RR::IN::TLSA::ClassValue = T.let(T.unsafe(nil), Integer)

# source://dnsruby//lib/dnsruby/resource/TLSA.rb#10
Dnsruby::RR::IN::TLSA::TypeValue = T.let(T.unsafe(nil), Integer)

# source://dnsruby//lib/dnsruby/resource/IN.rb#69
class Dnsruby::RR::IN::TSIG < ::Dnsruby::RR::TSIG; end

# source://dnsruby//lib/dnsruby/resource/IN.rb#72
Dnsruby::RR::IN::TSIG::ClassValue = T.let(T.unsafe(nil), Integer)

# source://dnsruby//lib/dnsruby/resource/IN.rb#71
Dnsruby::RR::IN::TSIG::TypeValue = T.let(T.unsafe(nil), Integer)

# source://dnsruby//lib/dnsruby/resource/IN.rb#69
class Dnsruby::RR::IN::TXT < ::Dnsruby::RR::TXT; end

# source://dnsruby//lib/dnsruby/resource/IN.rb#72
Dnsruby::RR::IN::TXT::ClassValue = T.let(T.unsafe(nil), Integer)

# source://dnsruby//lib/dnsruby/resource/IN.rb#71
Dnsruby::RR::IN::TXT::TypeValue = T.let(T.unsafe(nil), Integer)

# source://dnsruby//lib/dnsruby/resource/IN.rb#69
class Dnsruby::RR::IN::URI < ::Dnsruby::RR::URI; end

# source://dnsruby//lib/dnsruby/resource/IN.rb#72
Dnsruby::RR::IN::URI::ClassValue = T.let(T.unsafe(nil), Integer)

# source://dnsruby//lib/dnsruby/resource/IN.rb#71
Dnsruby::RR::IN::URI::TypeValue = T.let(T.unsafe(nil), Integer)

# RFC 1035, Section 3.4.2 (deprecated)
#
# source://dnsruby//lib/dnsruby/resource/IN.rb#78
class Dnsruby::RR::IN::WKS < ::Dnsruby::RR
  # @return [WKS] a new instance of WKS
  #
  # source://dnsruby//lib/dnsruby/resource/IN.rb#81
  def initialize(address, protocol, bitmap); end

  # Returns the value of attribute address.
  #
  # source://dnsruby//lib/dnsruby/resource/IN.rb#86
  def address; end

  # Returns the value of attribute bitmap.
  #
  # source://dnsruby//lib/dnsruby/resource/IN.rb#86
  def bitmap; end

  # source://dnsruby//lib/dnsruby/resource/IN.rb#88
  def encode_rdata(msg, canonical = T.unsafe(nil)); end

  # Returns the value of attribute protocol.
  #
  # source://dnsruby//lib/dnsruby/resource/IN.rb#86
  def protocol; end

  class << self
    # source://dnsruby//lib/dnsruby/resource/IN.rb#94
    def decode_rdata(msg); end
  end
end

# source://dnsruby//lib/dnsruby/resource/IN.rb#79
Dnsruby::RR::IN::WKS::ClassValue = T.let(T.unsafe(nil), Integer)

# source://dnsruby//lib/dnsruby/resource/IN.rb#79
Dnsruby::RR::IN::WKS::TypeValue = T.let(T.unsafe(nil), Integer)

# source://dnsruby//lib/dnsruby/resource/IN.rb#69
class Dnsruby::RR::IN::X25 < ::Dnsruby::RR::X25; end

# source://dnsruby//lib/dnsruby/resource/IN.rb#72
Dnsruby::RR::IN::X25::ClassValue = T.let(T.unsafe(nil), Integer)

# source://dnsruby//lib/dnsruby/resource/IN.rb#71
Dnsruby::RR::IN::X25::TypeValue = T.let(T.unsafe(nil), Integer)

# source://dnsruby//lib/dnsruby/resource/IPSECKEY.rb#18
class Dnsruby::RR::IPSECKEY < ::Dnsruby::RR
  # The algorithm used by this key :
  #  0 - no key present
  #  1 - DSA key present
  #  2 - RSA key present
  #
  # source://dnsruby//lib/dnsruby/resource/IPSECKEY.rb#35
  def algorithm; end

  # The algorithm used by this key :
  #  0 - no key present
  #  1 - DSA key present
  #  2 - RSA key present
  #
  # source://dnsruby//lib/dnsruby/resource/IPSECKEY.rb#35
  def algorithm=(_arg0); end

  # source://dnsruby//lib/dnsruby/resource/IPSECKEY.rb#111
  def encode_rdata(msg, canonical = T.unsafe(nil)); end

  # source://dnsruby//lib/dnsruby/resource/IPSECKEY.rb#40
  def from_data(data); end

  # source://dnsruby//lib/dnsruby/resource/IPSECKEY.rb#53
  def from_hash(hash); end

  # source://dnsruby//lib/dnsruby/resource/IPSECKEY.rb#88
  def from_string(input); end

  # The gateway. May either be a 32-bit network order IPv4 address, or a
  # 128-bit IPv6 address, or a domain name, or may not be present.
  #
  # source://dnsruby//lib/dnsruby/resource/IPSECKEY.rb#38
  def gateway; end

  # The gateway. May either be a 32-bit network order IPv4 address, or a
  # 128-bit IPv6 address, or a domain name, or may not be present.
  #
  # source://dnsruby//lib/dnsruby/resource/IPSECKEY.rb#38
  def gateway=(_arg0); end

  # Specifies the type of gateway :
  #  0 - no gateway present
  #  1 - 4 byte IPv4 address present
  #  2 - 16 byte IPv6 address present
  #  3 - wire-encoded domain name present
  #
  # source://dnsruby//lib/dnsruby/resource/IPSECKEY.rb#30
  def gateway_type; end

  # Specifies the type of gateway :
  #  0 - no gateway present
  #  1 - 4 byte IPv4 address present
  #  2 - 16 byte IPv6 address present
  #  3 - wire-encoded domain name present
  #
  # source://dnsruby//lib/dnsruby/resource/IPSECKEY.rb#30
  def gateway_type=(_arg0); end

  # source://dnsruby//lib/dnsruby/resource/IPSECKEY.rb#61
  def load_gateway_from_string(gateway_type, s); end

  # An 8-bit precedence for this field. Lower values are preferred.
  #
  # source://dnsruby//lib/dnsruby/resource/IPSECKEY.rb#24
  def precedence; end

  # An 8-bit precedence for this field. Lower values are preferred.
  #
  # source://dnsruby//lib/dnsruby/resource/IPSECKEY.rb#24
  def precedence=(_arg0); end

  # source://dnsruby//lib/dnsruby/resource/IPSECKEY.rb#82
  def public_key_from_string(key_text); end

  # source://dnsruby//lib/dnsruby/resource/IPSECKEY.rb#78
  def public_key_string; end

  # source://dnsruby//lib/dnsruby/resource/IPSECKEY.rb#102
  def rdata_to_string; end

  class << self
    # source://dnsruby//lib/dnsruby/resource/IPSECKEY.rb#122
    def decode_rdata(msg); end
  end
end

# source://dnsruby//lib/dnsruby/resource/IPSECKEY.rb#20
Dnsruby::RR::IPSECKEY::ClassValue = T.let(T.unsafe(nil), T.untyped)

# source://dnsruby//lib/dnsruby/resource/IPSECKEY.rb#21
Dnsruby::RR::IPSECKEY::TypeValue = T.let(T.unsafe(nil), Integer)

# Net::DNS::RR::ISDN - DNS ISDN resource record
# RFC 1183 Section 3.2
#
# source://dnsruby//lib/dnsruby/resource/ISDN.rb#20
class Dnsruby::RR::ISDN < ::Dnsruby::RR
  # The RR's address field.
  #
  # source://dnsruby//lib/dnsruby/resource/ISDN.rb#25
  def address; end

  # The RR's address field.
  #
  # source://dnsruby//lib/dnsruby/resource/ISDN.rb#25
  def address=(_arg0); end

  # source://dnsruby//lib/dnsruby/resource/ISDN.rb#50
  def encode_rdata(msg, canonical = T.unsafe(nil)); end

  # source://dnsruby//lib/dnsruby/resource/ISDN.rb#30
  def from_data(data); end

  # source://dnsruby//lib/dnsruby/resource/ISDN.rb#34
  def from_string(input); end

  # source://dnsruby//lib/dnsruby/resource/ISDN.rb#46
  def rdata_to_string; end

  # The RR's sub-address field.
  #
  # source://dnsruby//lib/dnsruby/resource/ISDN.rb#28
  def subaddress; end

  # The RR's sub-address field.
  #
  # source://dnsruby//lib/dnsruby/resource/ISDN.rb#28
  def subaddress=(_arg0); end

  class << self
    # source://dnsruby//lib/dnsruby/resource/ISDN.rb#55
    def decode_rdata(msg); end
  end
end

# source://dnsruby//lib/dnsruby/resource/ISDN.rb#21
Dnsruby::RR::ISDN::ClassValue = T.let(T.unsafe(nil), T.untyped)

# source://dnsruby//lib/dnsruby/resource/ISDN.rb#22
Dnsruby::RR::ISDN::TypeValue = T.let(T.unsafe(nil), Integer)

# Class for DNS Key Exchange (KX) resource records.
# RFC 2230
#
# source://dnsruby//lib/dnsruby/resource/KX.rb#20
class Dnsruby::RR::KX < ::Dnsruby::RR
  # source://dnsruby//lib/dnsruby/resource/KX.rb#54
  def encode_rdata(msg, canonical = T.unsafe(nil)); end

  # The name of this mail exchange.
  #
  # source://dnsruby//lib/dnsruby/resource/KX.rb#27
  def exchange; end

  # The name of this mail exchange.
  #
  # source://dnsruby//lib/dnsruby/resource/KX.rb#27
  def exchange=(_arg0); end

  # source://dnsruby//lib/dnsruby/resource/KX.rb#34
  def from_data(data); end

  # source://dnsruby//lib/dnsruby/resource/KX.rb#29
  def from_hash(hash); end

  # source://dnsruby//lib/dnsruby/resource/KX.rb#38
  def from_string(input); end

  # The preference for this mail exchange.
  #
  # source://dnsruby//lib/dnsruby/resource/KX.rb#25
  def preference; end

  # The preference for this mail exchange.
  #
  # source://dnsruby//lib/dnsruby/resource/KX.rb#25
  def preference=(_arg0); end

  # source://dnsruby//lib/dnsruby/resource/KX.rb#46
  def rdata_to_string; end

  class << self
    # source://dnsruby//lib/dnsruby/resource/KX.rb#59
    def decode_rdata(msg); end
  end
end

# source://dnsruby//lib/dnsruby/resource/KX.rb#21
Dnsruby::RR::KX::ClassValue = T.let(T.unsafe(nil), T.untyped)

# source://dnsruby//lib/dnsruby/resource/KX.rb#22
Dnsruby::RR::KX::TypeValue = T.let(T.unsafe(nil), Integer)

# Class for DNS Location (LOC) resource records.  See RFC 1876 for
# details.
#
# source://dnsruby//lib/dnsruby/resource/LOC.rb#20
class Dnsruby::RR::LOC < ::Dnsruby::RR
  # The altitude of the center of the sphere described by
  # the size method, in centimeters, from a base of 100,000m
  # below the WGS 84 reference spheroid used by GPS.
  #
  # source://dnsruby//lib/dnsruby/resource/LOC.rb#48
  def altitude; end

  # The altitude of the center of the sphere described by
  # the size method, in centimeters, from a base of 100,000m
  # below the WGS 84 reference spheroid used by GPS.
  #
  # source://dnsruby//lib/dnsruby/resource/LOC.rb#48
  def altitude=(_arg0); end

  # source://dnsruby//lib/dnsruby/resource/LOC.rb#89
  def dms2latlon(deg, min, sec, hem); end

  # source://dnsruby//lib/dnsruby/resource/LOC.rb#238
  def encode_rdata(msg, canonical = T.unsafe(nil)); end

  # source://dnsruby//lib/dnsruby/resource/LOC.rb#123
  def from_data(data); end

  # source://dnsruby//lib/dnsruby/resource/LOC.rb#181
  def from_hash(hash); end

  # source://dnsruby//lib/dnsruby/resource/LOC.rb#127
  def from_string(string); end

  # The horizontal precision of the data, in centimeters.
  #
  # source://dnsruby//lib/dnsruby/resource/LOC.rb#33
  def horiz_pre; end

  # The horizontal precision of the data, in centimeters.
  #
  # source://dnsruby//lib/dnsruby/resource/LOC.rb#33
  def horiz_pre=(_arg0); end

  # The latitude of the center of the sphere described by
  # the size method, in thousandths of a second of arc.  2**31
  # represents the equator; numbers above that are north latitude.
  #
  # source://dnsruby//lib/dnsruby/resource/LOC.rb#39
  def latitude; end

  # The latitude of the center of the sphere described by
  # the size method, in thousandths of a second of arc.  2**31
  # represents the equator; numbers above that are north latitude.
  #
  # source://dnsruby//lib/dnsruby/resource/LOC.rb#39
  def latitude=(_arg0); end

  # Returns the latitude and longitude as floating-point degrees.
  # Positive numbers represent north latitude or east longitude;
  # negative numbers represent south latitude or west longitude.
  #
  #     lat, lon = rr.latlon
  #     system("xearth", "-pos", "fixed #{lat} #{lon}")
  #
  # source://dnsruby//lib/dnsruby/resource/LOC.rb#105
  def latlon; end

  # source://dnsruby//lib/dnsruby/resource/LOC.rb#116
  def latlon2deg(rawmsec); end

  # source://dnsruby//lib/dnsruby/resource/LOC.rb#71
  def latlon2dms(rawmsec, hems); end

  # The longitude of the center of the sphere described by
  # the size method, in thousandths of a second of arc.  2**31
  # represents the prime meridian; numbers above that are east
  # longitude.
  #
  # source://dnsruby//lib/dnsruby/resource/LOC.rb#44
  def longitude; end

  # The longitude of the center of the sphere described by
  # the size method, in thousandths of a second of arc.  2**31
  # represents the prime meridian; numbers above that are east
  # longitude.
  #
  # source://dnsruby//lib/dnsruby/resource/LOC.rb#44
  def longitude=(_arg0); end

  # source://dnsruby//lib/dnsruby/resource/LOC.rb#253
  def precsize_valton(val); end

  # source://dnsruby//lib/dnsruby/resource/LOC.rb#194
  def rdata_to_string; end

  # The diameter of a sphere enclosing the described entity,
  # in centimeters.
  #
  # source://dnsruby//lib/dnsruby/resource/LOC.rb#31
  def size; end

  # The diameter of a sphere enclosing the described entity,
  # in centimeters.
  #
  # source://dnsruby//lib/dnsruby/resource/LOC.rb#31
  def size=(_arg0); end

  # The version number of the representation; programs should
  # always check this.  Dnsruby currently supports only version 0.
  #
  # source://dnsruby//lib/dnsruby/resource/LOC.rb#26
  def version; end

  # The version number of the representation; programs should
  # always check this.  Dnsruby currently supports only version 0.
  #
  # source://dnsruby//lib/dnsruby/resource/LOC.rb#26
  def version=(_arg0); end

  # The vertical precision of the data, in centimeters.
  #
  # source://dnsruby//lib/dnsruby/resource/LOC.rb#35
  def vert_pre; end

  # The vertical precision of the data, in centimeters.
  #
  # source://dnsruby//lib/dnsruby/resource/LOC.rb#35
  def vert_pre=(_arg0); end

  class << self
    # source://dnsruby//lib/dnsruby/resource/LOC.rb#227
    def decode_rdata(msg); end

    # source://dnsruby//lib/dnsruby/resource/LOC.rb#247
    def precsize_ntoval(prec); end
  end
end

# source://dnsruby//lib/dnsruby/resource/LOC.rb#61
Dnsruby::RR::LOC::CONV_DEG = T.let(T.unsafe(nil), Integer)

# source://dnsruby//lib/dnsruby/resource/LOC.rb#60
Dnsruby::RR::LOC::CONV_MIN = T.let(T.unsafe(nil), Integer)

# Conversions to/from thousandths of a degree.
#
# source://dnsruby//lib/dnsruby/resource/LOC.rb#59
Dnsruby::RR::LOC::CONV_SEC = T.let(T.unsafe(nil), Integer)

# source://dnsruby//lib/dnsruby/resource/LOC.rb#21
Dnsruby::RR::LOC::ClassValue = T.let(T.unsafe(nil), T.untyped)

# source://dnsruby//lib/dnsruby/resource/LOC.rb#67
Dnsruby::RR::LOC::DEFAULT_HORIZ_PRE = T.let(T.unsafe(nil), Integer)

# Defaults (from RFC 1876, Section 3).
#
# source://dnsruby//lib/dnsruby/resource/LOC.rb#64
Dnsruby::RR::LOC::DEFAULT_MIN = T.let(T.unsafe(nil), Integer)

# source://dnsruby//lib/dnsruby/resource/LOC.rb#65
Dnsruby::RR::LOC::DEFAULT_SEC = T.let(T.unsafe(nil), Integer)

# source://dnsruby//lib/dnsruby/resource/LOC.rb#66
Dnsruby::RR::LOC::DEFAULT_SIZE = T.let(T.unsafe(nil), Integer)

# source://dnsruby//lib/dnsruby/resource/LOC.rb#68
Dnsruby::RR::LOC::DEFAULT_VERT_PRE = T.let(T.unsafe(nil), Integer)

# Powers of 10 from 0 to 9 (used to speed up calculations).
#
# source://dnsruby//lib/dnsruby/resource/LOC.rb#50
Dnsruby::RR::LOC::POWEROFTEN = T.let(T.unsafe(nil), Array)

# Reference altitude in centimeters (see RFC 1876).
#
# source://dnsruby//lib/dnsruby/resource/LOC.rb#53
Dnsruby::RR::LOC::REFERENCE_ALT = T.let(T.unsafe(nil), Integer)

# Reference lat/lon (see RFC 1876).
#
# source://dnsruby//lib/dnsruby/resource/LOC.rb#56
Dnsruby::RR::LOC::REFERENCE_LATLON = T.let(T.unsafe(nil), Integer)

# source://dnsruby//lib/dnsruby/resource/LOC.rb#22
Dnsruby::RR::LOC::TypeValue = T.let(T.unsafe(nil), Integer)

# MB RR
#
# source://dnsruby//lib/dnsruby/resource/generic.rb#91
class Dnsruby::RR::MB < ::Dnsruby::RR::DomainName
  # source://dnsruby//lib/dnsruby/resource/domain_name.rb#21
  def madname; end

  # source://dnsruby//lib/dnsruby/resource/domain_name.rb#23
  def madname=(newname); end
end

# source://dnsruby//lib/dnsruby/resource/generic.rb#92
Dnsruby::RR::MB::ClassValue = T.let(T.unsafe(nil), T.untyped)

# source://dnsruby//lib/dnsruby/resource/generic.rb#93
Dnsruby::RR::MB::TypeValue = T.let(T.unsafe(nil), Integer)

# MG RR
#
# source://dnsruby//lib/dnsruby/resource/generic.rb#99
class Dnsruby::RR::MG < ::Dnsruby::RR::DomainName
  # source://dnsruby//lib/dnsruby/resource/domain_name.rb#21
  def mgmname; end

  # source://dnsruby//lib/dnsruby/resource/domain_name.rb#23
  def mgmname=(newname); end
end

# source://dnsruby//lib/dnsruby/resource/generic.rb#100
Dnsruby::RR::MG::ClassValue = T.let(T.unsafe(nil), T.untyped)

# source://dnsruby//lib/dnsruby/resource/generic.rb#101
Dnsruby::RR::MG::TypeValue = T.let(T.unsafe(nil), Integer)

# Class for DNS Mailbox Information (MINFO) resource records.
# RFC 1035 Section 3.3.7
#
# source://dnsruby//lib/dnsruby/resource/MINFO.rb#20
class Dnsruby::RR::MINFO < ::Dnsruby::RR
  # The RR's error mailbox field.
  #
  # source://dnsruby//lib/dnsruby/resource/MINFO.rb#27
  def emailbx; end

  # The RR's error mailbox field.
  #
  # source://dnsruby//lib/dnsruby/resource/MINFO.rb#27
  def emailbx=(_arg0); end

  # source://dnsruby//lib/dnsruby/resource/MINFO.rb#58
  def encode_rdata(msg, canonical = T.unsafe(nil)); end

  # source://dnsruby//lib/dnsruby/resource/MINFO.rb#38
  def from_data(data); end

  # source://dnsruby//lib/dnsruby/resource/MINFO.rb#29
  def from_hash(hash); end

  # source://dnsruby//lib/dnsruby/resource/MINFO.rb#42
  def from_string(input); end

  # source://dnsruby//lib/dnsruby/resource/MINFO.rb#50
  def rdata_to_string; end

  # The RR's responsible mailbox field.  See RFC 1035.
  #
  # source://dnsruby//lib/dnsruby/resource/MINFO.rb#25
  def rmailbx; end

  # The RR's responsible mailbox field.  See RFC 1035.
  #
  # source://dnsruby//lib/dnsruby/resource/MINFO.rb#25
  def rmailbx=(_arg0); end

  class << self
    # source://dnsruby//lib/dnsruby/resource/MINFO.rb#63
    def decode_rdata(msg); end
  end
end

# source://dnsruby//lib/dnsruby/resource/MINFO.rb#21
Dnsruby::RR::MINFO::ClassValue = T.let(T.unsafe(nil), T.untyped)

# source://dnsruby//lib/dnsruby/resource/MINFO.rb#22
Dnsruby::RR::MINFO::TypeValue = T.let(T.unsafe(nil), Integer)

# MR RR
#
# source://dnsruby//lib/dnsruby/resource/generic.rb#107
class Dnsruby::RR::MR < ::Dnsruby::RR::DomainName
  # source://dnsruby//lib/dnsruby/resource/domain_name.rb#21
  def newname; end

  # source://dnsruby//lib/dnsruby/resource/domain_name.rb#23
  def newname=(newname); end
end

# source://dnsruby//lib/dnsruby/resource/generic.rb#108
Dnsruby::RR::MR::ClassValue = T.let(T.unsafe(nil), T.untyped)

# source://dnsruby//lib/dnsruby/resource/generic.rb#109
Dnsruby::RR::MR::TypeValue = T.let(T.unsafe(nil), Integer)

# Class for DNS Mail Exchanger (MX) resource records.
# RFC 1035 Section 3.3.9
#
# source://dnsruby//lib/dnsruby/resource/MX.rb#20
class Dnsruby::RR::MX < ::Dnsruby::RR
  # source://dnsruby//lib/dnsruby/resource/MX.rb#57
  def encode_rdata(msg, canonical = T.unsafe(nil)); end

  # The name of this mail exchange.
  #
  # source://dnsruby//lib/dnsruby/resource/MX.rb#27
  def exchange; end

  # The name of this mail exchange.
  #
  # source://dnsruby//lib/dnsruby/resource/MX.rb#27
  def exchange=(_arg0); end

  # source://dnsruby//lib/dnsruby/resource/MX.rb#34
  def from_data(data); end

  # source://dnsruby//lib/dnsruby/resource/MX.rb#29
  def from_hash(hash); end

  # source://dnsruby//lib/dnsruby/resource/MX.rb#38
  def from_string(input); end

  # The preference for this mail exchange.
  #
  # source://dnsruby//lib/dnsruby/resource/MX.rb#25
  def preference; end

  # The preference for this mail exchange.
  #
  # source://dnsruby//lib/dnsruby/resource/MX.rb#25
  def preference=(_arg0); end

  # source://dnsruby//lib/dnsruby/resource/MX.rb#49
  def rdata_to_string; end

  class << self
    # source://dnsruby//lib/dnsruby/resource/MX.rb#62
    def decode_rdata(msg); end
  end
end

# source://dnsruby//lib/dnsruby/resource/MX.rb#21
Dnsruby::RR::MX::ClassValue = T.let(T.unsafe(nil), T.untyped)

# source://dnsruby//lib/dnsruby/resource/MX.rb#22
Dnsruby::RR::MX::TypeValue = T.let(T.unsafe(nil), Integer)

# Class for DNS Naming Authority Pointer (NAPTR) resource records.
# RFC 2168
#
# source://dnsruby//lib/dnsruby/resource/NAPTR.rb#20
class Dnsruby::RR::NAPTR < ::Dnsruby::RR
  # source://dnsruby//lib/dnsruby/resource/NAPTR.rb#78
  def encode_rdata(msg, canonical = T.unsafe(nil)); end

  # The NAPTR RR flags field
  #
  # source://dnsruby//lib/dnsruby/resource/NAPTR.rb#29
  def flags; end

  # The NAPTR RR flags field
  #
  # source://dnsruby//lib/dnsruby/resource/NAPTR.rb#29
  def flags=(_arg0); end

  # source://dnsruby//lib/dnsruby/resource/NAPTR.rb#46
  def from_data(data); end

  # source://dnsruby//lib/dnsruby/resource/NAPTR.rb#37
  def from_hash(hash); end

  # source://dnsruby//lib/dnsruby/resource/NAPTR.rb#54
  def from_string(input); end

  # The NAPTR RR order field
  #
  # source://dnsruby//lib/dnsruby/resource/NAPTR.rb#25
  def order; end

  # The NAPTR RR order field
  #
  # source://dnsruby//lib/dnsruby/resource/NAPTR.rb#25
  def order=(_arg0); end

  # The NAPTR RR preference field
  #
  # source://dnsruby//lib/dnsruby/resource/NAPTR.rb#27
  def preference; end

  # The NAPTR RR preference field
  #
  # source://dnsruby//lib/dnsruby/resource/NAPTR.rb#27
  def preference=(_arg0); end

  # source://dnsruby//lib/dnsruby/resource/NAPTR.rb#66
  def rdata_to_string; end

  # The NAPTR RR regexp field
  #
  # source://dnsruby//lib/dnsruby/resource/NAPTR.rb#33
  def regexp; end

  # source://dnsruby//lib/dnsruby/resource/NAPTR.rb#50
  def regexp=(s); end

  # The NAPTR RR replacement field
  #
  # source://dnsruby//lib/dnsruby/resource/NAPTR.rb#35
  def replacement; end

  # The NAPTR RR replacement field
  #
  # source://dnsruby//lib/dnsruby/resource/NAPTR.rb#35
  def replacement=(_arg0); end

  # The NAPTR RR service field
  #
  # source://dnsruby//lib/dnsruby/resource/NAPTR.rb#31
  def service; end

  # The NAPTR RR service field
  #
  # source://dnsruby//lib/dnsruby/resource/NAPTR.rb#31
  def service=(_arg0); end

  class << self
    # source://dnsruby//lib/dnsruby/resource/NAPTR.rb#89
    def decode_rdata(msg); end
  end
end

# source://dnsruby//lib/dnsruby/resource/NAPTR.rb#21
Dnsruby::RR::NAPTR::ClassValue = T.let(T.unsafe(nil), T.untyped)

# source://dnsruby//lib/dnsruby/resource/NAPTR.rb#22
Dnsruby::RR::NAPTR::TypeValue = T.let(T.unsafe(nil), Integer)

# --
#  Standard (class generic) RRs
# ++
# NS RR
# Nameserver resource record
#
# source://dnsruby//lib/dnsruby/resource/generic.rb#63
class Dnsruby::RR::NS < ::Dnsruby::RR::DomainName
  # source://dnsruby//lib/dnsruby/resource/domain_name.rb#21
  def nsdname; end

  # source://dnsruby//lib/dnsruby/resource/domain_name.rb#23
  def nsdname=(newname); end
end

# source://dnsruby//lib/dnsruby/resource/generic.rb#64
Dnsruby::RR::NS::ClassValue = T.let(T.unsafe(nil), T.untyped)

# source://dnsruby//lib/dnsruby/resource/generic.rb#65
Dnsruby::RR::NS::TypeValue = T.let(T.unsafe(nil), Integer)

# Class for DNS Network Service Access Point (NSAP) resource records.
# RFC 1706.
#
# source://dnsruby//lib/dnsruby/resource/NSAP.rb#20
class Dnsruby::RR::NSAP < ::Dnsruby::RR
  # The RR's administrative authority.
  #
  # source://dnsruby//lib/dnsruby/resource/NSAP.rb#31
  def aa; end

  # The RR's administrative authority.
  #
  # source://dnsruby//lib/dnsruby/resource/NSAP.rb#31
  def aa=(_arg0); end

  # The RR's authority and format identifier.  Dnsruby
  # currently supports only AFI 47 (GOSIP Version 2).
  #
  # source://dnsruby//lib/dnsruby/resource/NSAP.rb#25
  def afi; end

  # The RR's authority and format identifier.  Dnsruby
  # currently supports only AFI 47 (GOSIP Version 2).
  #
  # source://dnsruby//lib/dnsruby/resource/NSAP.rb#25
  def afi=(_arg0); end

  # The RR's area identifier.
  #
  # source://dnsruby//lib/dnsruby/resource/NSAP.rb#35
  def area; end

  # The RR's area identifier.
  #
  # source://dnsruby//lib/dnsruby/resource/NSAP.rb#35
  def area=(_arg0); end

  # The RR's DSP format identifier.
  #
  # source://dnsruby//lib/dnsruby/resource/NSAP.rb#29
  def dfi; end

  # The RR's DSP format identifier.
  #
  # source://dnsruby//lib/dnsruby/resource/NSAP.rb#29
  def dfi=(_arg0); end

  # The RR's domain specific part (the DFI, AA, Rsvd, RD, Area,
  # ID, and SEL fields).
  #
  # source://dnsruby//lib/dnsruby/resource/NSAP.rb#52
  def dsp; end

  # source://dnsruby//lib/dnsruby/resource/NSAP.rb#122
  def encode_rdata(msg, canonical = T.unsafe(nil)); end

  # source://dnsruby//lib/dnsruby/resource/NSAP.rb#90
  def from_data(data); end

  # source://dnsruby//lib/dnsruby/resource/NSAP.rb#94
  def from_string(s); end

  # The RR's system identifier.
  #
  # source://dnsruby//lib/dnsruby/resource/NSAP.rb#37
  def id; end

  # The RR's system identifier.
  #
  # source://dnsruby//lib/dnsruby/resource/NSAP.rb#37
  def id=(_arg0); end

  # The RR's initial domain identifier.
  #
  # source://dnsruby//lib/dnsruby/resource/NSAP.rb#27
  def idi; end

  # The RR's initial domain identifier.
  #
  # source://dnsruby//lib/dnsruby/resource/NSAP.rb#27
  def idi=(_arg0); end

  # The RR's initial domain part (the AFI and IDI fields).
  #
  # source://dnsruby//lib/dnsruby/resource/NSAP.rb#45
  def idp; end

  # The RR's routing domain identifier.
  #
  # source://dnsruby//lib/dnsruby/resource/NSAP.rb#33
  def rd; end

  # The RR's routing domain identifier.
  #
  # source://dnsruby//lib/dnsruby/resource/NSAP.rb#33
  def rd=(_arg0); end

  # source://dnsruby//lib/dnsruby/resource/NSAP.rb#106
  def rdata_to_string; end

  # source://dnsruby//lib/dnsruby/resource/NSAP.rb#57
  def rsvd; end

  # The RR's reserved field.
  #
  # source://dnsruby//lib/dnsruby/resource/NSAP.rb#42
  def rsvd=(_arg0); end

  # The RR's NSAP selector.
  #
  # source://dnsruby//lib/dnsruby/resource/NSAP.rb#39
  def sel; end

  # The RR's NSAP selector.
  #
  # source://dnsruby//lib/dnsruby/resource/NSAP.rb#39
  def sel=(_arg0); end

  # ------------------------------------------------------------------------------
  #  Usage:  str2bcd(STRING, NUM_BYTES)
  #
  #  Takes a string representing a hex number of arbitrary length and
  #  returns an equivalent BCD string of NUM_BYTES length (with
  #  NUM_BYTES * 2 digits), adding leading zeros if necessary.
  # ------------------------------------------------------------------------------
  #
  # source://dnsruby//lib/dnsruby/resource/NSAP.rb#72
  def str2bcd(s, bytes); end

  class << self
    # source://dnsruby//lib/dnsruby/resource/NSAP.rb#142
    def decode_rdata(msg); end
  end
end

# source://dnsruby//lib/dnsruby/resource/NSAP.rb#21
Dnsruby::RR::NSAP::ClassValue = T.let(T.unsafe(nil), T.untyped)

# source://dnsruby//lib/dnsruby/resource/NSAP.rb#22
Dnsruby::RR::NSAP::TypeValue = T.let(T.unsafe(nil), Integer)

# RFC4034, section 4
# The NSEC resource record lists two separate things: the next owner
# name (in the canonical ordering of the zone) that contains
# authoritative data or a delegation point NS RRset, and the set of RR
# types present at the NSEC RR's owner name [RFC3845].  The complete
# set of NSEC RRs in a zone indicates which authoritative RRsets exist
# in a zone and also form a chain of authoritative owner names in the
# zone.  This information is used to provide authenticated denial of
# existence for DNS data, as described in [RFC4035].
#
# source://dnsruby//lib/dnsruby/resource/NSEC.rb#27
class Dnsruby::RR::NSEC < ::Dnsruby::RR
  # source://dnsruby//lib/dnsruby/resource/NSEC.rb#85
  def add_type(t); end

  # source://dnsruby//lib/dnsruby/resource/NSEC.rb#45
  def check_name_in_range(n); end

  # source://dnsruby//lib/dnsruby/resource/NSEC.rb#52
  def check_name_in_wildcard_range(n); end

  # source://dnsruby//lib/dnsruby/resource/NSEC.rb#261
  def encode_rdata(msg, canonical = T.unsafe(nil)); end

  # source://dnsruby//lib/dnsruby/resource/NSEC.rb#150
  def encode_types; end

  # source://dnsruby//lib/dnsruby/resource/NSEC.rb#231
  def from_data(data); end

  # source://dnsruby//lib/dnsruby/resource/NSEC.rb#237
  def from_string(input); end

  # The next name which exists after this NSEC
  # The Next Domain field contains the next owner name (in the canonical
  # ordering of the zone) that has authoritative data or contains a
  # delegation point NS RRset
  #
  # source://dnsruby//lib/dnsruby/resource/NSEC.rb#35
  def next_domain; end

  # source://dnsruby//lib/dnsruby/resource/NSEC.rb#40
  def next_domain=(n); end

  # source://dnsruby//lib/dnsruby/resource/NSEC.rb#250
  def rdata_to_string; end

  # The Type Bit Maps field identifies the RRset types that exist at the
  # NSEC RR's owner name
  #
  # source://dnsruby//lib/dnsruby/resource/NSEC.rb#38
  def types; end

  # source://dnsruby//lib/dnsruby/resource/NSEC.rb#63
  def types=(t); end

  class << self
    # source://dnsruby//lib/dnsruby/resource/NSEC.rb#268
    def decode_rdata(msg); end

    # source://dnsruby//lib/dnsruby/resource/NSEC.rb#89
    def decode_types(bytes); end

    # source://dnsruby//lib/dnsruby/resource/NSEC.rb#154
    def encode_types(nsec); end

    # source://dnsruby//lib/dnsruby/resource/NSEC.rb#67
    def get_types(t); end
  end
end

# The NSEC3 Resource Record (RR) provides authenticated denial of
# existence for DNS Resource Record Sets.
#
# The NSEC3 RR lists RR types present at the original owner name of the
# NSEC3 RR.  It includes the next hashed owner name in the hash order
# of the zone.  The complete set of NSEC3 RRs in a zone indicates which
# RRSets exist for the original owner name of the RR and form a chain
# of hashed owner names in the zone.  This information is used to
# provide authenticated denial of existence for DNS data.  To provide
# protection against zone enumeration, the owner names used in the
# NSEC3 RR are cryptographic hashes of the original owner name
# prepended as a single label to the name of the zone.  The NSEC3 RR
# indicates which hash function is used to construct the hash, which
# salt is used, and how many iterations of the hash function are
# performed over the original owner name.
#
# source://dnsruby//lib/dnsruby/resource/NSEC3.rb#60
class Dnsruby::RR::NSEC3 < ::Dnsruby::RR
  # source://dnsruby//lib/dnsruby/resource/NSEC3.rb#178
  def add_type(t); end

  # source://dnsruby//lib/dnsruby/resource/NSEC3.rb#103
  def calculate_hash; end

  # source://dnsruby//lib/dnsruby/resource/NSEC3.rb#93
  def check_name_in_range(_name); end

  # source://dnsruby//lib/dnsruby/resource/NSEC3.rb#98
  def check_name_in_wildcard_range(_name); end

  # source://dnsruby//lib/dnsruby/resource/NSEC3.rb#243
  def decode_next_hashed(input); end

  # source://dnsruby//lib/dnsruby/resource/NSEC3.rb#251
  def encode_next_hashed(n); end

  # source://dnsruby//lib/dnsruby/resource/NSEC3.rb#300
  def encode_rdata(msg, canonical = T.unsafe(nil)); end

  # The Flags field contains 8 one-bit flags that can be used to indicate
  # different processing.  All undefined flags must be zero.  The only
  # flag defined by the NSEC3 specification is the Opt-Out flag.
  #
  # source://dnsruby//lib/dnsruby/resource/NSEC3.rb#71
  def flags; end

  # source://dnsruby//lib/dnsruby/resource/NSEC3.rb#183
  def flags=(f); end

  # source://dnsruby//lib/dnsruby/resource/NSEC3.rb#211
  def from_data(data); end

  # source://dnsruby//lib/dnsruby/resource/NSEC3.rb#259
  def from_string(input); end

  # source://dnsruby//lib/dnsruby/resource/NSEC3.rb#149
  def h(x); end

  # The Hash Algorithm field identifies the cryptographic hash algorithm
  # used to construct the hash-value.
  #
  # source://dnsruby//lib/dnsruby/resource/NSEC3.rb#66
  def hash_alg; end

  # source://dnsruby//lib/dnsruby/resource/NSEC3.rb#160
  def hash_alg=(a); end

  # The Hash Length field defines the length of the Next Hashed Owner
  # Name field, ranging in value from 1 to 255 octets.
  #
  # source://dnsruby//lib/dnsruby/resource/NSEC3.rb#83
  def hash_length; end

  # def salt_length=(l)
  #         if ((l < 0) || (l > 255))
  #           raise DecodeError.new('NSEC3 salt length must be between 0 and 255')
  #         end
  #         @salt_length = l
  #       end
  #
  # source://dnsruby//lib/dnsruby/resource/NSEC3.rb#204
  def hash_length=(l); end

  # The Iterations field defines the number of additional times the hash
  # function has been performed.
  #
  # source://dnsruby//lib/dnsruby/resource/NSEC3.rb#75
  def iterations; end

  # The Iterations field defines the number of additional times the hash
  # function has been performed.
  #
  # source://dnsruby//lib/dnsruby/resource/NSEC3.rb#75
  def iterations=(_arg0); end

  # The Next Hashed Owner Name field contains the next hashed owner name
  # in hash order.
  #
  # source://dnsruby//lib/dnsruby/resource/NSEC3.rb#87
  def next_hashed; end

  # The Next Hashed Owner Name field contains the next hashed owner name
  # in hash order.
  #
  # source://dnsruby//lib/dnsruby/resource/NSEC3.rb#87
  def next_hashed=(_arg0); end

  # If the Opt-Out flag is set, the NSEC3 record covers zero or more
  # unsigned delegations.
  #
  # @return [Boolean]
  #
  # source://dnsruby//lib/dnsruby/resource/NSEC3.rb#193
  def opt_out?; end

  # source://dnsruby//lib/dnsruby/resource/NSEC3.rb#286
  def rdata_to_string; end

  # The Salt field is appended to the original owner name before hashing
  # in order to defend against pre-calculated dictionary attacks.
  #
  # source://dnsruby//lib/dnsruby/resource/NSEC3.rb#226
  def salt; end

  # source://dnsruby//lib/dnsruby/resource/NSEC3.rb#230
  def salt=(s); end

  # The Salt Length field defines the length of the Salt field in octets,
  # ranging in value from 0 to 255.
  #
  # source://dnsruby//lib/dnsruby/resource/NSEC3.rb#79
  def salt_length; end

  # The Type Bit Maps field identifies the RRset types that exist at the
  # NSEC RR's owner name
  #
  # source://dnsruby//lib/dnsruby/resource/NSEC3.rb#91
  def types; end

  # source://dnsruby//lib/dnsruby/resource/NSEC3.rb#174
  def types=(t); end

  class << self
    # source://dnsruby//lib/dnsruby/resource/NSEC3.rb#107
    def calculate_hash(name, iterations, salt, hash_alg); end

    # source://dnsruby//lib/dnsruby/resource/NSEC3.rb#247
    def decode_next_hashed(input); end

    # source://dnsruby//lib/dnsruby/resource/NSEC3.rb#317
    def decode_rdata(msg); end

    # source://dnsruby//lib/dnsruby/resource/NSEC3.rb#235
    def decode_salt(input); end

    # source://dnsruby//lib/dnsruby/resource/NSEC3.rb#255
    def encode_next_hashed(n); end

    # source://dnsruby//lib/dnsruby/resource/NSEC3.rb#239
    def encode_salt(s); end

    # @raise [ArgumentError]
    #
    # source://dnsruby//lib/dnsruby/resource/NSEC3.rb#153
    def h(x, hash_alg); end
  end
end

# source://dnsruby//lib/dnsruby/resource/NSEC3.rb#61
Dnsruby::RR::NSEC3::ClassValue = T.let(T.unsafe(nil), T.untyped)

# source://dnsruby//lib/dnsruby/resource/NSEC3.rb#182
Dnsruby::RR::NSEC3::OPT_OUT = T.let(T.unsafe(nil), Integer)

# source://dnsruby//lib/dnsruby/resource/NSEC3.rb#62
Dnsruby::RR::NSEC3::TypeValue = T.let(T.unsafe(nil), Integer)

# The NSEC3PARAM RR contains the NSEC3 parameters (hash algorithm,
# flags, iterations and salt) needed by authoritative servers to
# calculate hashed owner names.  The presence of an NSEC3PARAM RR at a
# zone apex indicates that the specified parameters may be used by
# authoritative servers to choose an appropriate set of NSEC3 RRs for
# negative responses.  The NSEC3PARAM RR is not used by validators or
# resolvers.
#
# source://dnsruby//lib/dnsruby/resource/NSEC3PARAM.rb#25
class Dnsruby::RR::NSEC3PARAM < ::Dnsruby::RR
  # source://dnsruby//lib/dnsruby/resource/NSEC3PARAM.rb#113
  def encode_rdata(msg, canonical = T.unsafe(nil)); end

  # The Flags field contains 8 one-bit flags that can be used to indicate
  # different processing.  All undefined flags must be zero.  The only
  # flag defined by the NSEC3 specification is the Opt-Out flag.
  #
  # source://dnsruby//lib/dnsruby/resource/NSEC3PARAM.rb#35
  def flags; end

  # source://dnsruby//lib/dnsruby/resource/NSEC3PARAM.rb#72
  def flags=(f); end

  #         if ((l < 0) || (l > 255))
  #           raise DecodeError.new("NSEC3 salt length must be between 0 and 255")
  #         end
  #         @salt_length = l
  #       end
  #
  # source://dnsruby//lib/dnsruby/resource/NSEC3PARAM.rb#87
  def from_data(data); end

  # source://dnsruby//lib/dnsruby/resource/NSEC3PARAM.rb#97
  def from_string(input); end

  # The Hash Algorithm field identifies the cryptographic hash algorithm
  # used to construct the hash-value.
  #
  # source://dnsruby//lib/dnsruby/resource/NSEC3PARAM.rb#31
  def hash_alg; end

  # source://dnsruby//lib/dnsruby/resource/NSEC3PARAM.rb#54
  def hash_alg=(a); end

  # The Iterations field defines the number of additional times the hash
  # function has been performed.
  #
  # source://dnsruby//lib/dnsruby/resource/NSEC3PARAM.rb#38
  def iterations; end

  # The Iterations field defines the number of additional times the hash
  # function has been performed.
  #
  # source://dnsruby//lib/dnsruby/resource/NSEC3PARAM.rb#38
  def iterations=(_arg0); end

  # source://dnsruby//lib/dnsruby/resource/NSEC3PARAM.rb#108
  def rdata_to_string; end

  # The Salt field is appended to the original owner name before hashing
  # in order to defend against pre-calculated dictionary attacks.
  #
  # source://dnsruby//lib/dnsruby/resource/NSEC3PARAM.rb#45
  def salt; end

  # source://dnsruby//lib/dnsruby/resource/NSEC3PARAM.rb#49
  def salt=(s); end

  # The Salt Length field defines the length of the Salt field in octets,
  # ranging in value from 0 to 255.
  #
  # source://dnsruby//lib/dnsruby/resource/NSEC3PARAM.rb#41
  def salt_length; end

  # source://dnsruby//lib/dnsruby/resource/NSEC3PARAM.rb#68
  def types=(t); end

  class << self
    # source://dnsruby//lib/dnsruby/resource/NSEC3PARAM.rb#127
    def decode_rdata(msg); end
  end
end

# source://dnsruby//lib/dnsruby/resource/NSEC3PARAM.rb#26
Dnsruby::RR::NSEC3PARAM::ClassValue = T.let(T.unsafe(nil), T.untyped)

# source://dnsruby//lib/dnsruby/resource/NSEC3PARAM.rb#27
Dnsruby::RR::NSEC3PARAM::TypeValue = T.let(T.unsafe(nil), Integer)

# source://dnsruby//lib/dnsruby/resource/NSEC.rb#28
Dnsruby::RR::NSEC::ClassValue = T.let(T.unsafe(nil), T.untyped)

# source://dnsruby//lib/dnsruby/resource/NSEC.rb#29
Dnsruby::RR::NSEC::TypeValue = T.let(T.unsafe(nil), Integer)

# Class for NXT resource records.
#
# NXT-specific data types, present in RDATA, are:
#   next_domain: the next domain name, as a Name instance
#   types: array of record types as numbers
#
# RFC 2535 (https://www.ietf.org/rfc/rfc2535.txt)
#
# The RFC mentions that a low bit of zero in the type RDATA
# indicates that the highest type code does not exceed 127,
# and that a low bit of 1 indicates that some mechanism
# other than a bitmap is being used.  This class does not
# support such non-bitmap mechanisms, and assumes there
# will always be a bitmap.
#
# source://dnsruby//lib/dnsruby/resource/NXT.rb#25
class Dnsruby::RR::NXT < ::Dnsruby::RR
  # source://dnsruby//lib/dnsruby/resource/NXT.rb#118
  def build_rdata; end

  # source://dnsruby//lib/dnsruby/resource/NXT.rb#114
  def encode_rdata(message_encoder, _canonical); end

  # source://dnsruby//lib/dnsruby/resource/NXT.rb#41
  def from_data(data); end

  # source://dnsruby//lib/dnsruby/resource/NXT.rb#33
  def from_hash(params_hash); end

  # source://dnsruby//lib/dnsruby/resource/NXT.rb#46
  def from_string(string); end

  # Returns the value of attribute next_domain.
  #
  # source://dnsruby//lib/dnsruby/resource/NXT.rb#29
  def next_domain; end

  # Sets the attribute next_domain
  #
  # @param value the value to set the attribute next_domain to.
  #
  # source://dnsruby//lib/dnsruby/resource/NXT.rb#29
  def next_domain=(_arg0); end

  # 'name' is used in the RR superclass, but 'owner' is the term referred to
  # in the RFC, so we'll make owner an alias for name.
  #
  # source://dnsruby//lib/dnsruby/resource/RR.rb#40
  def owner; end

  # source://dnsruby//lib/dnsruby/resource/RR.rb#58
  def owner=(new_name); end

  # From the RFC:
  # NXT has the following format:
  # foo.nil.    NXT big.foo.nil NS KEY SOA NXT
  # <owner> NXT <next_domain> <record types>
  #
  # We handle the rdata, the RR superclass does the rest.
  #
  # source://dnsruby//lib/dnsruby/resource/NXT.rb#110
  def rdata_to_string; end

  # Returns the value of attribute types.
  #
  # source://dnsruby//lib/dnsruby/resource/NXT.rb#29
  def types; end

  # Sets the attribute types
  #
  # @param value the value to set the attribute types to.
  #
  # source://dnsruby//lib/dnsruby/resource/NXT.rb#29
  def types=(_arg0); end

  class << self
    # Builds rdata from the provided information.
    #
    # @param next_domain either a string or a Name
    # @param types an array of types (where each type is the numeric type code)
    #   or a TypeBitmap
    #
    # source://dnsruby//lib/dnsruby/resource/NXT.rb#94
    def build_rdata(next_domain, types); end

    # source://dnsruby//lib/dnsruby/resource/NXT.rb#122
    def decode_rdata(message_decoder); end

    # Create an instance from an ordered parameter list, e.g.:
    # rdata = RR::NXT.build_rdata('a.dnsruby.com.', [Types::SOA, Types::NXT])
    #
    # rr = RR::NXT.new_from_data('b.dnsruby.com.', Types::NXT,
    #     Classes::IN, 10800, rdata.size, rdata, 0)
    #
    # source://dnsruby//lib/dnsruby/resource/NXT.rb#86
    def new_from_data(*params_data); end

    # Create an instance from a hash of parameters, e.g.:
    #
    # rr = RR::NXT.new_from_hash(
    #     name: 'b.dnsruby.com.',
    #     ttl: 10800,
    #     klass: Classes::IN,
    #     next_domain: 'a.dnsruby.com.',
    #     types: [Types::SOA, Types::NXT])
    #
    # Since the type is assumed to be NXT, it will be assigned
    # automatically, and any other value will be overwritten.
    # Therefore, having it present in the hash is not necessary.
    #
    # source://dnsruby//lib/dnsruby/resource/NXT.rb#70
    def new_from_hash(params_hash); end

    # Create an instance from a string containing parameters, e.g.:
    # b.dnsruby.com.  10800  IN  NXT  A.dnsruby.com.  SOA  NXT
    #
    # source://dnsruby//lib/dnsruby/resource/NXT.rb#77
    def new_from_string(params_string); end
  end
end

# Methods used to manipulate the storage and representation of
# record types as stored in NXT record bitmaps.
#
# source://dnsruby//lib/dnsruby/resource/NXT.rb#161
module Dnsruby::RR::NXT::NxtTypes
  private

  # Assert that the specified number is a legal value with which to
  # instantiate a NXT type bitmap.  Raise on error, do nothing on success.
  #
  # source://dnsruby//lib/dnsruby/resource/NXT.rb#238
  def assert_legal_bitmap_value(number); end

  # From a binary string of type code bits, return an array
  # of type codes.
  #
  # source://dnsruby//lib/dnsruby/resource/NXT.rb#213
  def binary_string_to_codes(binary_string); end

  # From a binary string of type code bits, return an array
  # of type names.
  #
  # source://dnsruby//lib/dnsruby/resource/NXT.rb#221
  def binary_string_to_names(binary_string); end

  # Convert a numeric type code to its corresponding name (e.g. "A" => 1).
  # Unknown types are named "TYPE#{number}".
  #
  # source://dnsruby//lib/dnsruby/resource/NXT.rb#172
  def code_to_name(number); end

  # From an array of type codes, return a binary string.
  #
  # source://dnsruby//lib/dnsruby/resource/NXT.rb#227
  def codes_to_binary_string(codes); end

  # For the given array of type codes, return an array of their
  # corresponding names.
  #
  # source://dnsruby//lib/dnsruby/resource/NXT.rb#201
  def codes_to_names(codes); end

  # Generate a string containing the names corresponding to the
  # numeric type codes.  Sort it by the numeric type code, ascending.
  #
  # source://dnsruby//lib/dnsruby/resource/NXT.rb#207
  def codes_to_string(codes); end

  # source://dnsruby//lib/dnsruby/resource/NXT.rb#248
  def legal_code_value?(code); end

  # Convert a type name to its corresponding numeric type code.
  # Names matching /^TYPE(\d+)$/ are assumed to have a code
  # corresponding to the numeric value of the substring following 'TYPE'.
  #
  # source://dnsruby//lib/dnsruby/resource/NXT.rb#179
  def name_to_code(name); end

  # For the specified string containing names (e.g. 'A NS'),
  # return an array containing the corresponding codes.
  #
  # source://dnsruby//lib/dnsruby/resource/NXT.rb#195
  def names_string_to_codes(name_string); end

  # For a given array of type names, return an array of codes.
  #
  # source://dnsruby//lib/dnsruby/resource/NXT.rb#189
  def names_to_codes(names); end

  class << self
    # Assert that the specified number is a legal value with which to
    # instantiate a NXT type bitmap.  Raise on error, do nothing on success.
    #
    # source://dnsruby//lib/dnsruby/resource/NXT.rb#238
    def assert_legal_bitmap_value(number); end

    # From a binary string of type code bits, return an array
    # of type codes.
    #
    # source://dnsruby//lib/dnsruby/resource/NXT.rb#213
    def binary_string_to_codes(binary_string); end

    # From a binary string of type code bits, return an array
    # of type names.
    #
    # source://dnsruby//lib/dnsruby/resource/NXT.rb#221
    def binary_string_to_names(binary_string); end

    # Convert a numeric type code to its corresponding name (e.g. "A" => 1).
    # Unknown types are named "TYPE#{number}".
    #
    # source://dnsruby//lib/dnsruby/resource/NXT.rb#172
    def code_to_name(number); end

    # From an array of type codes, return a binary string.
    #
    # source://dnsruby//lib/dnsruby/resource/NXT.rb#227
    def codes_to_binary_string(codes); end

    # For the given array of type codes, return an array of their
    # corresponding names.
    #
    # source://dnsruby//lib/dnsruby/resource/NXT.rb#201
    def codes_to_names(codes); end

    # Generate a string containing the names corresponding to the
    # numeric type codes.  Sort it by the numeric type code, ascending.
    #
    # source://dnsruby//lib/dnsruby/resource/NXT.rb#207
    def codes_to_string(codes); end

    # @return [Boolean]
    #
    # source://dnsruby//lib/dnsruby/resource/NXT.rb#248
    def legal_code_value?(code); end

    # Convert a type name to its corresponding numeric type code.
    # Names matching /^TYPE(\d+)$/ are assumed to have a code
    # corresponding to the numeric value of the substring following 'TYPE'.
    #
    # source://dnsruby//lib/dnsruby/resource/NXT.rb#179
    def name_to_code(name); end

    # For the specified string containing names (e.g. 'A NS'),
    # return an array containing the corresponding codes.
    #
    # source://dnsruby//lib/dnsruby/resource/NXT.rb#195
    def names_string_to_codes(name_string); end

    # For a given array of type names, return an array of codes.
    #
    # source://dnsruby//lib/dnsruby/resource/NXT.rb#189
    def names_to_codes(names); end
  end
end

# Maximum bitmap size is 128 bytes; since it's zero offset
# values are 0..(2 ** 128 - 1).  However, the least
# significant bit must not be set, so the maximum is 1 less than that.
#
# source://dnsruby//lib/dnsruby/resource/NXT.rb#168
Dnsruby::RR::NXT::NxtTypes::MAX_BITMAP_NUMBER_VALUE = T.let(T.unsafe(nil), Integer)

# source://dnsruby//lib/dnsruby/resource/NXT.rb#31
Dnsruby::RR::NXT::REQUIRED_KEYS = T.let(T.unsafe(nil), Array)

# source://dnsruby//lib/dnsruby/resource/NXT.rb#254
class Dnsruby::RR::NXT::TypeBitmap
  # @return [TypeBitmap] a new instance of TypeBitmap
  #
  # source://dnsruby//lib/dnsruby/resource/NXT.rb#278
  def initialize(bitmap_number); end

  # Returns the value of attribute bitmap.
  #
  # source://dnsruby//lib/dnsruby/resource/NXT.rb#256
  def bitmap; end

  # Sets the attribute bitmap
  #
  # @param value the value to set the attribute bitmap to.
  #
  # source://dnsruby//lib/dnsruby/resource/NXT.rb#256
  def bitmap=(_arg0); end

  # Returns a binary string representing this data, in as few bytes as possible
  # (i.e. no leading zero bytes).
  #
  # source://dnsruby//lib/dnsruby/resource/NXT.rb#285
  def to_binary_string; end

  # Output types in dig format, e.g. "A AAAA NXT"
  #
  # source://dnsruby//lib/dnsruby/resource/NXT.rb#295
  def to_s; end

  # Returns the instance's data as an array of type codes.
  #
  # source://dnsruby//lib/dnsruby/resource/NXT.rb#290
  def to_type_array; end

  class << self
    # Create an instance from a binary string, e.g. from a NXT record RDATA:
    #
    # source://dnsruby//lib/dnsruby/resource/NXT.rb#271
    def from_binary_string(binary_string); end

    # Create an instance from a string containing type names separated by spaces
    # e.g. "A TXT NXT"
    #
    # source://dnsruby//lib/dnsruby/resource/NXT.rb#260
    def from_names_string(names_string); end

    # Create an instance from type numeric codes (e.g. 30 for NXT).
    #
    # source://dnsruby//lib/dnsruby/resource/NXT.rb#266
    def from_type_codes(type_codes); end

    private

    def new(*_arg0); end
  end
end

# source://dnsruby//lib/dnsruby/resource/NXT.rb#27
Dnsruby::RR::NXT::TypeValue = T.let(T.unsafe(nil), Integer)

# Class for EDNS pseudo resource record OPT.
# This class is effectively internal to Dnsruby
# See RFC 2671, RFC 2435 Section 3
#  @TODO@ Extended labels RFC2671 section 3
#
# source://dnsruby//lib/dnsruby/resource/OPT.rb#22
class Dnsruby::RR::OPT < ::Dnsruby::RR
  # Can be called with up to 3 arguments, none of which must be present
  # * OPT.new()
  # * OPT.new(size)
  # * OPT.new(size,flags)
  # * OPT.new(size,flags,options)
  #
  # @return [OPT] a new instance of OPT
  #
  # source://dnsruby//lib/dnsruby/resource/OPT.rb#39
  def initialize(*args); end

  # source://dnsruby//lib/dnsruby/resource/OPT.rb#128
  def dnssec_ok; end

  # source://dnsruby//lib/dnsruby/resource/OPT.rb#132
  def dnssec_ok=(on); end

  # source://dnsruby//lib/dnsruby/resource/OPT.rb#219
  def edns_client_subnet; end

  # source://dnsruby//lib/dnsruby/resource/OPT.rb#240
  def encode_rdata(msg, canonical = T.unsafe(nil)); end

  # source://dnsruby//lib/dnsruby/resource/OPT.rb#116
  def flags; end

  # source://dnsruby//lib/dnsruby/resource/OPT.rb#120
  def flags=(code); end

  # 4.6. The extended RCODE and flags (which OPT stores in the RR TTL field)
  # are structured as follows:
  #
  #                  +0 (MSB)                            +1 (LSB)
  #       +---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
  #    0: |         EXTENDED-RCODE        |            VERSION            |
  #       +---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
  #    2: |                               Z                               |
  #       +---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
  #
  #    EXTENDED-RCODE  Forms upper 8 bits of extended 12-bit RCODE.  Note
  #                    that EXTENDED-RCODE value "0" indicates that an
  #                    unextended RCODE is in use (values "0" through "15").
  #
  #    VERSION         Indicates the implementation level of whoever sets
  #                    it.  Full conformance with this specification is
  #                    indicated by version "0."
  #
  # source://dnsruby//lib/dnsruby/resource/OPT.rb#91
  def flags_from_ttl; end

  # source://dnsruby//lib/dnsruby/resource/OPT.rb#167
  def from_data(data); end

  # @raise [NotImplementedError]
  #
  # source://dnsruby//lib/dnsruby/resource/OPT.rb#171
  def from_string(input); end

  # source://dnsruby//lib/dnsruby/resource/OPT.rb#184
  def get_client_subnet(opt); end

  # source://dnsruby//lib/dnsruby/resource/OPT.rb#175
  def get_ip_addr(opt, family, source_netmask); end

  # source://dnsruby//lib/dnsruby/resource/OPT.rb#148
  def options(args); end

  # source://dnsruby//lib/dnsruby/resource/OPT.rb#163
  def options=(options); end

  # source://dnsruby//lib/dnsruby/resource/OPT.rb#140
  def payloadsize; end

  # source://dnsruby//lib/dnsruby/resource/OPT.rb#144
  def payloadsize=(size); end

  # source://dnsruby//lib/dnsruby/resource/OPT.rb#200
  def set_client_subnet(subnet); end

  # Should always be zero
  #
  # source://dnsruby//lib/dnsruby/resource/OPT.rb#124
  def set_flags(code); end

  # source://dnsruby//lib/dnsruby/resource/OPT.rb#225
  def to_s; end

  # source://dnsruby//lib/dnsruby/resource/OPT.rb#108
  def version; end

  # source://dnsruby//lib/dnsruby/resource/OPT.rb#112
  def version=(code); end

  # source://dnsruby//lib/dnsruby/resource/OPT.rb#99
  def xrcode; end

  # source://dnsruby//lib/dnsruby/resource/OPT.rb#103
  def xrcode=(c); end

  class << self
    # source://dnsruby//lib/dnsruby/resource/OPT.rb#250
    def decode_rdata(msg); end
  end
end

# source://dnsruby//lib/dnsruby/resource/OPT.rb#27
Dnsruby::RR::OPT::ADDRESS_FAMILIES = T.let(T.unsafe(nil), Array)

# source://dnsruby//lib/dnsruby/resource/OPT.rb#23
Dnsruby::RR::OPT::ClassValue = T.let(T.unsafe(nil), T.untyped)

# source://dnsruby//lib/dnsruby/resource/OPT.rb#25
Dnsruby::RR::OPT::DO_BIT = T.let(T.unsafe(nil), Integer)

# source://dnsruby//lib/dnsruby/resource/OPT.rb#30
Dnsruby::RR::OPT::EDNS_SUBNET_OPTION = T.let(T.unsafe(nil), Integer)

# source://dnsruby//lib/dnsruby/resource/OPT.rb#28
Dnsruby::RR::OPT::IPV4_ADDRESS_FAMILY = T.let(T.unsafe(nil), Integer)

# source://dnsruby//lib/dnsruby/resource/OPT.rb#28
Dnsruby::RR::OPT::IPV6_ADDRESS_FAMILY = T.let(T.unsafe(nil), Integer)

# source://dnsruby//lib/dnsruby/resource/OPT.rb#263
class Dnsruby::RR::OPT::Option
  # @return [Option] a new instance of Option
  #
  # source://dnsruby//lib/dnsruby/resource/OPT.rb#265
  def initialize(code, data); end

  # Returns the value of attribute code.
  #
  # source://dnsruby//lib/dnsruby/resource/OPT.rb#264
  def code; end

  # Sets the attribute code
  #
  # @param value the value to set the attribute code to.
  #
  # source://dnsruby//lib/dnsruby/resource/OPT.rb#264
  def code=(_arg0); end

  # Returns the value of attribute data.
  #
  # source://dnsruby//lib/dnsruby/resource/OPT.rb#264
  def data; end

  # Sets the attribute data
  #
  # @param value the value to set the attribute data to.
  #
  # source://dnsruby//lib/dnsruby/resource/OPT.rb#264
  def data=(_arg0); end
end

# source://dnsruby//lib/dnsruby/resource/OPT.rb#24
Dnsruby::RR::OPT::TypeValue = T.let(T.unsafe(nil), Integer)

# PTR RR
#
# source://dnsruby//lib/dnsruby/resource/generic.rb#115
class Dnsruby::RR::PTR < ::Dnsruby::RR::DomainName; end

# source://dnsruby//lib/dnsruby/resource/generic.rb#116
Dnsruby::RR::PTR::ClassValue = T.let(T.unsafe(nil), T.untyped)

# source://dnsruby//lib/dnsruby/resource/generic.rb#117
Dnsruby::RR::PTR::TypeValue = T.let(T.unsafe(nil), Integer)

# Class for DNS Responsible Person (RP) resource records.
# RFC 1183 Section 2.2
#
# source://dnsruby//lib/dnsruby/resource/RP.rb#20
class Dnsruby::RR::RP < ::Dnsruby::RR
  # source://dnsruby//lib/dnsruby/resource/RP.rb#63
  def encode_rdata(msg, canonical = T.unsafe(nil)); end

  # source://dnsruby//lib/dnsruby/resource/RP.rb#43
  def from_data(data); end

  # source://dnsruby//lib/dnsruby/resource/RP.rb#38
  def from_hash(hash); end

  # source://dnsruby//lib/dnsruby/resource/RP.rb#47
  def from_string(input); end

  # Returns a domain name that specifies the mailbox for the responsible person.
  #
  # source://dnsruby//lib/dnsruby/resource/RP.rb#25
  def mailbox; end

  # source://dnsruby//lib/dnsruby/resource/RP.rb#34
  def mailbox=(s); end

  # source://dnsruby//lib/dnsruby/resource/RP.rb#55
  def rdata_to_string; end

  # A domain name that specifies a TXT record containing further
  # information about the responsible person.
  #
  # source://dnsruby//lib/dnsruby/resource/RP.rb#28
  def txtdomain; end

  # source://dnsruby//lib/dnsruby/resource/RP.rb#30
  def txtdomain=(s); end

  class << self
    # source://dnsruby//lib/dnsruby/resource/RP.rb#68
    def decode_rdata(msg); end
  end
end

# source://dnsruby//lib/dnsruby/resource/RP.rb#21
Dnsruby::RR::RP::ClassValue = T.let(T.unsafe(nil), T.untyped)

# source://dnsruby//lib/dnsruby/resource/RP.rb#22
Dnsruby::RR::RP::TypeValue = T.let(T.unsafe(nil), Integer)

# (RFC4034, section 3)
# DNSSEC uses public key cryptography to sign and authenticate DNS
# resource record sets (RRsets).  Digital signatures are stored in
# RRSIG resource records and are used in the DNSSEC authentication
# process described in [RFC4035].  A validator can use these RRSIG RRs
# to authenticate RRsets from the zone.  The RRSIG RR MUST only be used
# to carry verification material (digital signatures) used to secure
# DNS operations.
#
# An RRSIG record contains the signature for an RRset with a particular
# name, class, and type.  The RRSIG RR specifies a validity interval
# for the signature and uses the Algorithm, the Signer's Name, and the
# Key Tag to identify the DNSKEY RR containing the public key that a
# validator can use to verify the signature.
#
# source://dnsruby//lib/dnsruby/resource/RRSIG.rb#32
class Dnsruby::RR::RRSIG < ::Dnsruby::RR
  # The algorithm used for this RRSIG
  # See Dnsruby::Algorithms for permitted values
  #
  # source://dnsruby//lib/dnsruby/resource/RRSIG.rb#68
  def algorithm; end

  # source://dnsruby//lib/dnsruby/resource/RRSIG.rb#102
  def algorithm=(a); end

  # source://dnsruby//lib/dnsruby/resource/RRSIG.rb#241
  def encode_rdata(msg, canonical = T.unsafe(nil)); end

  # The signature expiration
  #
  # source://dnsruby//lib/dnsruby/resource/RRSIG.rb#75
  def expiration; end

  # The signature expiration
  #
  # source://dnsruby//lib/dnsruby/resource/RRSIG.rb#75
  def expiration=(_arg0); end

  # source://dnsruby//lib/dnsruby/resource/RRSIG.rb#224
  def format_time(time); end

  # source://dnsruby//lib/dnsruby/resource/RRSIG.rb#135
  def from_data(data); end

  # source://dnsruby//lib/dnsruby/resource/RRSIG.rb#145
  def from_string(input); end

  # source://dnsruby//lib/dnsruby/resource/RRSIG.rb#220
  def get_time(input); end

  # The signature inception
  #
  # source://dnsruby//lib/dnsruby/resource/RRSIG.rb#77
  def inception; end

  # The signature inception
  #
  # source://dnsruby//lib/dnsruby/resource/RRSIG.rb#77
  def inception=(_arg0); end

  # source://dnsruby//lib/dnsruby/resource/RRSIG.rb#90
  def init_defaults; end

  # The key tag value of the DNSKEY RR that validates this signature
  #
  # source://dnsruby//lib/dnsruby/resource/RRSIG.rb#79
  def key_tag; end

  # The key tag value of the DNSKEY RR that validates this signature
  #
  # source://dnsruby//lib/dnsruby/resource/RRSIG.rb#79
  def key_tag=(_arg0); end

  # The number of labels in the original RRSIG RR owner name
  # Can be used to determine if name was synthesised from a wildcard.
  #
  # source://dnsruby//lib/dnsruby/resource/RRSIG.rb#71
  def labels; end

  # The number of labels in the original RRSIG RR owner name
  # Can be used to determine if name was synthesised from a wildcard.
  #
  # source://dnsruby//lib/dnsruby/resource/RRSIG.rb#71
  def labels=(_arg0); end

  # The TTL of the covered RRSet as it appears in the authoritative zone
  #
  # source://dnsruby//lib/dnsruby/resource/RRSIG.rb#73
  def original_ttl; end

  # The TTL of the covered RRSet as it appears in the authoritative zone
  #
  # source://dnsruby//lib/dnsruby/resource/RRSIG.rb#73
  def original_ttl=(_arg0); end

  # source://dnsruby//lib/dnsruby/resource/RRSIG.rb#228
  def rdata_to_string; end

  # source://dnsruby//lib/dnsruby/resource/RRSIG.rb#261
  def sig_data; end

  # contains the cryptographic signature that covers
  # the RRSIG RDATA (excluding the Signature field) and the RRset
  # specified by the RRSIG owner name, RRSIG class, and RRSIG Type
  # Covered field
  #
  # source://dnsruby//lib/dnsruby/resource/RRSIG.rb#88
  def signature; end

  # contains the cryptographic signature that covers
  # the RRSIG RDATA (excluding the Signature field) and the RRset
  # specified by the RRSIG owner name, RRSIG class, and RRSIG Type
  # Covered field
  #
  # source://dnsruby//lib/dnsruby/resource/RRSIG.rb#88
  def signature=(_arg0); end

  # identifies the owner name of the DNSKEY RR that a validator is
  # supposed to use to validate this signature
  #
  # source://dnsruby//lib/dnsruby/resource/RRSIG.rb#82
  def signers_name; end

  # source://dnsruby//lib/dnsruby/resource/RRSIG.rb#125
  def signers_name=(s); end

  # The type covered by this RRSIG
  #
  # source://dnsruby//lib/dnsruby/resource/RRSIG.rb#65
  def type_covered; end

  # source://dnsruby//lib/dnsruby/resource/RRSIG.rb#116
  def type_covered=(t); end

  class << self
    # source://dnsruby//lib/dnsruby/resource/RRSIG.rb#250
    def decode_rdata(msg); end

    # source://dnsruby//lib/dnsruby/resource/RRSIG.rb#183
    def get_time(input); end
  end
end

# source://dnsruby//lib/dnsruby/resource/RRSIG.rb#33
Dnsruby::RR::RRSIG::ClassValue = T.let(T.unsafe(nil), T.untyped)

# source://dnsruby//lib/dnsruby/resource/RRSIG.rb#34
Dnsruby::RR::RRSIG::TypeValue = T.let(T.unsafe(nil), Integer)

# Class for DNS Route Through (RT) resource records.
# RFC 1183 Section 3.3
#
# source://dnsruby//lib/dnsruby/resource/RT.rb#20
class Dnsruby::RR::RT < ::Dnsruby::RR
  # source://dnsruby//lib/dnsruby/resource/RT.rb#55
  def encode_rdata(msg, canonical = T.unsafe(nil)); end

  # source://dnsruby//lib/dnsruby/resource/RT.rb#35
  def from_data(data); end

  # source://dnsruby//lib/dnsruby/resource/RT.rb#30
  def from_hash(hash); end

  # source://dnsruby//lib/dnsruby/resource/RT.rb#39
  def from_string(input); end

  # The domain name of the intermediate host.
  #
  # source://dnsruby//lib/dnsruby/resource/RT.rb#28
  def intermediate; end

  # The domain name of the intermediate host.
  #
  # source://dnsruby//lib/dnsruby/resource/RT.rb#28
  def intermediate=(_arg0); end

  # The preference for this route.
  #
  # source://dnsruby//lib/dnsruby/resource/RT.rb#25
  def preference; end

  # The preference for this route.
  #
  # source://dnsruby//lib/dnsruby/resource/RT.rb#25
  def preference=(_arg0); end

  # source://dnsruby//lib/dnsruby/resource/RT.rb#47
  def rdata_to_string; end

  class << self
    # source://dnsruby//lib/dnsruby/resource/RT.rb#60
    def decode_rdata(msg); end
  end
end

# source://dnsruby//lib/dnsruby/resource/RT.rb#21
Dnsruby::RR::RT::ClassValue = T.let(T.unsafe(nil), T.untyped)

# source://dnsruby//lib/dnsruby/resource/RT.rb#22
Dnsruby::RR::RT::TypeValue = T.let(T.unsafe(nil), Integer)

# source://dnsruby//lib/dnsruby/resource/SOA.rb#18
class Dnsruby::RR::SOA < ::Dnsruby::RR
  # source://dnsruby//lib/dnsruby/resource/SOA.rb#80
  def encode_rdata(msg, canonical = T.unsafe(nil)); end

  # The zone's expire interval.
  # How often, in seconds, a secondary nameserver is to use the data
  # before refreshing from the primary nameserver
  #
  # source://dnsruby//lib/dnsruby/resource/SOA.rb#41
  def expire; end

  # The zone's expire interval.
  # How often, in seconds, a secondary nameserver is to use the data
  # before refreshing from the primary nameserver
  #
  # source://dnsruby//lib/dnsruby/resource/SOA.rb#41
  def expire=(_arg0); end

  # source://dnsruby//lib/dnsruby/resource/SOA.rb#45
  def from_data(data); end

  # source://dnsruby//lib/dnsruby/resource/SOA.rb#49
  def from_hash(hash); end

  # source://dnsruby//lib/dnsruby/resource/SOA.rb#59
  def from_string(input); end

  # The minimum (default) TTL for records in this zone.
  #
  # source://dnsruby//lib/dnsruby/resource/SOA.rb#43
  def minimum; end

  # The minimum (default) TTL for records in this zone.
  #
  # source://dnsruby//lib/dnsruby/resource/SOA.rb#43
  def minimum=(_arg0); end

  # The domain name of the original or primary nameserver for
  # this zone.
  #
  # source://dnsruby//lib/dnsruby/resource/SOA.rb#24
  def mname; end

  # The domain name of the original or primary nameserver for
  # this zone.
  #
  # source://dnsruby//lib/dnsruby/resource/SOA.rb#24
  def mname=(_arg0); end

  # source://dnsruby//lib/dnsruby/resource/SOA.rb#72
  def rdata_to_string; end

  # The zone's refresh interval.
  # How often, in seconds, a secondary nameserver is to check for
  # updates from the primary nameserver.
  #
  # source://dnsruby//lib/dnsruby/resource/SOA.rb#33
  def refresh; end

  # The zone's refresh interval.
  # How often, in seconds, a secondary nameserver is to check for
  # updates from the primary nameserver.
  #
  # source://dnsruby//lib/dnsruby/resource/SOA.rb#33
  def refresh=(_arg0); end

  # The zone's retry interval.
  # How often, in seconds, a secondary nameserver is to retry, after a
  # failure to check for a refresh
  #
  # source://dnsruby//lib/dnsruby/resource/SOA.rb#37
  def retry; end

  # The zone's retry interval.
  # How often, in seconds, a secondary nameserver is to retry, after a
  # failure to check for a refresh
  #
  # source://dnsruby//lib/dnsruby/resource/SOA.rb#37
  def retry=(_arg0); end

  # A domain name that specifies the mailbox for the person
  # responsible for this zone.
  #
  # source://dnsruby//lib/dnsruby/resource/SOA.rb#27
  def rname; end

  # A domain name that specifies the mailbox for the person
  # responsible for this zone.
  #
  # source://dnsruby//lib/dnsruby/resource/SOA.rb#27
  def rname=(_arg0); end

  # The zone's serial number.
  #
  # source://dnsruby//lib/dnsruby/resource/SOA.rb#29
  def serial; end

  # The zone's serial number.
  #
  # source://dnsruby//lib/dnsruby/resource/SOA.rb#29
  def serial=(_arg0); end

  class << self
    # source://dnsruby//lib/dnsruby/resource/SOA.rb#86
    def decode_rdata(msg); end
  end
end

# source://dnsruby//lib/dnsruby/resource/SOA.rb#19
Dnsruby::RR::SOA::ClassValue = T.let(T.unsafe(nil), T.untyped)

# source://dnsruby//lib/dnsruby/resource/SOA.rb#20
Dnsruby::RR::SOA::TypeValue = T.let(T.unsafe(nil), Integer)

# This is a clone of the TXT record. This class therfore completely inherits
# all properties of the Dnsruby::Resource::TXT class.
#
# Please see the Dnsruby::Resource::TXT documentation for details
# RFC 1035 Section 3.3.14, draft-schlitt-ospf-classic-02.txt
#
# source://dnsruby//lib/dnsruby/resource/SPF.rb#25
class Dnsruby::RR::SPF < ::Dnsruby::RR::TXT; end

# source://dnsruby//lib/dnsruby/resource/SPF.rb#26
Dnsruby::RR::SPF::TypeValue = T.let(T.unsafe(nil), Integer)

# source://dnsruby//lib/dnsruby/resource/SSHFP.rb#18
class Dnsruby::RR::SSHFP < ::Dnsruby::RR
  # Returns the value of attribute alg.
  #
  # source://dnsruby//lib/dnsruby/resource/SSHFP.rb#22
  def alg; end

  # Sets the attribute alg
  #
  # @param value the value to set the attribute alg to.
  #
  # source://dnsruby//lib/dnsruby/resource/SSHFP.rb#22
  def alg=(_arg0); end

  # source://dnsruby//lib/dnsruby/resource/SSHFP.rb#82
  def encode_rdata(msg, canonical = T.unsafe(nil)); end

  # Returns the value of attribute fp.
  #
  # source://dnsruby//lib/dnsruby/resource/SSHFP.rb#24
  def fp; end

  # Sets the attribute fp
  #
  # @param value the value to set the attribute fp to.
  #
  # source://dnsruby//lib/dnsruby/resource/SSHFP.rb#24
  def fp=(_arg0); end

  # Returns the value of attribute fptype.
  #
  # source://dnsruby//lib/dnsruby/resource/SSHFP.rb#23
  def fptype; end

  # Sets the attribute fptype
  #
  # @param value the value to set the attribute fptype to.
  #
  # source://dnsruby//lib/dnsruby/resource/SSHFP.rb#23
  def fptype=(_arg0); end

  # source://dnsruby//lib/dnsruby/resource/SSHFP.rb#37
  def from_data(data); end

  # source://dnsruby//lib/dnsruby/resource/SSHFP.rb#43
  def from_hash(hash); end

  # source://dnsruby//lib/dnsruby/resource/SSHFP.rb#55
  def from_string(input); end

  # source://dnsruby//lib/dnsruby/resource/SSHFP.rb#76
  def rdata_to_string; end

  class << self
    # source://dnsruby//lib/dnsruby/resource/SSHFP.rb#88
    def decode_rdata(msg); end
  end
end

# source://dnsruby//lib/dnsruby/resource/SSHFP.rb#26
class Dnsruby::RR::SSHFP::Algorithms < ::Dnsruby::CodeMapper; end

# source://dnsruby//lib/dnsruby/resource/SSHFP.rb#28
Dnsruby::RR::SSHFP::Algorithms::DSS = T.let(T.unsafe(nil), Integer)

# source://dnsruby//lib/dnsruby/resource/SSHFP.rb#27
Dnsruby::RR::SSHFP::Algorithms::RSA = T.let(T.unsafe(nil), Integer)

# source://dnsruby//lib/dnsruby/resource/SSHFP.rb#19
Dnsruby::RR::SSHFP::ClassValue = T.let(T.unsafe(nil), T.untyped)

# source://dnsruby//lib/dnsruby/resource/SSHFP.rb#32
class Dnsruby::RR::SSHFP::FpTypes < ::Dnsruby::CodeMapper; end

# source://dnsruby//lib/dnsruby/resource/SSHFP.rb#33
Dnsruby::RR::SSHFP::FpTypes::SHA1 = T.let(T.unsafe(nil), Integer)

# source://dnsruby//lib/dnsruby/resource/SSHFP.rb#20
Dnsruby::RR::SSHFP::TypeValue = T.let(T.unsafe(nil), Integer)

# RFC2930
#
# source://dnsruby//lib/dnsruby/resource/TKEY.rb#38
class Dnsruby::RR::TKEY < ::Dnsruby::RR
  # @return [TKEY] a new instance of TKEY
  #
  # source://dnsruby//lib/dnsruby/resource/TKEY.rb#97
  def initialize; end

  # Gets or sets the domain name that specifies the name of the algorithm.
  # The default algorithm is gss.microsoft.com
  #
  #     rr.algorithm=(algorithm_name)
  #     print "algorithm = ", rr.algorithm, "\n"
  #
  # source://dnsruby//lib/dnsruby/resource/TKEY.rb#51
  def algorithm; end

  # Gets or sets the domain name that specifies the name of the algorithm.
  # The default algorithm is gss.microsoft.com
  #
  #     rr.algorithm=(algorithm_name)
  #     print "algorithm = ", rr.algorithm, "\n"
  #
  # source://dnsruby//lib/dnsruby/resource/TKEY.rb#51
  def algorithm=(_arg0); end

  # source://dnsruby//lib/dnsruby/resource/TKEY.rb#143
  def encode_rdata(msg, canonical = T.unsafe(nil)); end

  # Returns the RCODE covering TKEY processing.  See RFC 2930 for details.
  #
  #     print "error = ", rr.error, "\n"
  #
  # source://dnsruby//lib/dnsruby/resource/TKEY.rb#80
  def error; end

  # Returns the RCODE covering TKEY processing.  See RFC 2930 for details.
  #
  #     print "error = ", rr.error, "\n"
  #
  # source://dnsruby//lib/dnsruby/resource/TKEY.rb#80
  def error=(_arg0); end

  # Gets or sets the expiration time as the number of seconds since 1 Jan 1970
  # 00:00:00 UTC.
  #
  # The default expiration time is the current time plus 1 day.
  #
  #     rr.expiration=(time)
  #     print "expiration = ", rr.expiration, "\n"
  #
  # source://dnsruby//lib/dnsruby/resource/TKEY.rb#69
  def expiration; end

  # Gets or sets the expiration time as the number of seconds since 1 Jan 1970
  # 00:00:00 UTC.
  #
  # The default expiration time is the current time plus 1 day.
  #
  #     rr.expiration=(time)
  #     print "expiration = ", rr.expiration, "\n"
  #
  # source://dnsruby//lib/dnsruby/resource/TKEY.rb#69
  def expiration=(_arg0); end

  # source://dnsruby//lib/dnsruby/resource/TKEY.rb#119
  def from_data(data); end

  # source://dnsruby//lib/dnsruby/resource/TKEY.rb#112
  def from_hash(hash); end

  # Create the RR from a standard string
  #
  # source://dnsruby//lib/dnsruby/resource/TKEY.rb#124
  def from_string(string); end

  # Gets or sets the inception time as the number of seconds since 1 Jan 1970
  # 00:00:00 UTC.
  #
  # The default inception time is the current time.
  #
  #     rr.inception=(time)
  #     print "inception = ", rr.inception, "\n"
  #
  # source://dnsruby//lib/dnsruby/resource/TKEY.rb#60
  def inception; end

  # Gets or sets the inception time as the number of seconds since 1 Jan 1970
  # 00:00:00 UTC.
  #
  # The default inception time is the current time.
  #
  #     rr.inception=(time)
  #     print "inception = ", rr.inception, "\n"
  #
  # source://dnsruby//lib/dnsruby/resource/TKEY.rb#60
  def inception=(_arg0); end

  # Returns the value of attribute key.
  #
  # source://dnsruby//lib/dnsruby/resource/TKEY.rb#44
  def key; end

  # Sets the attribute key
  #
  # @param value the value to set the attribute key to.
  #
  # source://dnsruby//lib/dnsruby/resource/TKEY.rb#44
  def key=(_arg0); end

  # Returns the value of attribute key_size.
  #
  # source://dnsruby//lib/dnsruby/resource/TKEY.rb#43
  def key_size; end

  # Sets the key mode (see rfc2930). The default is 3 which corresponds to GSSAPI
  #
  #     rr.mode=(3)
  #     print "mode = ", rr.mode, "\n"
  #
  # source://dnsruby//lib/dnsruby/resource/TKEY.rb#75
  def mode; end

  # Sets the key mode (see rfc2930). The default is 3 which corresponds to GSSAPI
  #
  #     rr.mode=(3)
  #     print "mode = ", rr.mode, "\n"
  #
  # source://dnsruby//lib/dnsruby/resource/TKEY.rb#75
  def mode=(_arg0); end

  # Returns the Other Data.  This field should be empty.
  #
  #     print "other data = ", rr.other_data, "\n"
  #
  # source://dnsruby//lib/dnsruby/resource/TKEY.rb#90
  def other_data; end

  # source://dnsruby//lib/dnsruby/resource/TKEY.rb#92
  def other_data=(od); end

  # Returns the length of the Other Data.  Should be zero.
  #
  #     print "other size = ", rr.other_size, "\n"
  #
  # source://dnsruby//lib/dnsruby/resource/TKEY.rb#85
  def other_size; end

  # source://dnsruby//lib/dnsruby/resource/TKEY.rb#128
  def rdata_to_string; end

  class << self
    # source://dnsruby//lib/dnsruby/resource/TKEY.rb#152
    def decode_rdata(msg); end
  end
end

# source://dnsruby//lib/dnsruby/resource/TKEY.rb#40
Dnsruby::RR::TKEY::ClassValue = T.let(T.unsafe(nil), T.untyped)

# source://dnsruby//lib/dnsruby/resource/TKEY.rb#39
Dnsruby::RR::TKEY::TypeValue = T.let(T.unsafe(nil), Integer)

# TSIG implements RFC2845.
#
# "This protocol allows for transaction level authentication using
# shared secrets and one way hashing.  It can be used to authenticate
# dynamic updates as coming from an approved client, or to authenticate
# responses as coming from an approved recursive name server."
#
# A Dnsruby::RR::TSIG can represent the data present in a TSIG RR.
# However, it can also represent the data (specified in RFC2845) used
# to sign or verify a DNS message.
#
#
# Example code :
#     res = Dnsruby::Resolver.new("ns0.validation-test-servers.nominet.org.uk")
#
#     # Now configure the resolver with the TSIG key for signing/verifying
#     KEY_NAME="rubytsig"
#     KEY = "8n6gugn4aJ7MazyNlMccGKH1WxD2B3UvN/O/RA6iBupO2/03u9CTa3Ewz3gBWTSBCH3crY4Kk+tigNdeJBAvrw=="
#     res.tsig=KEY_NAME, KEY
#
#     update = Dnsruby::Update.new("validation-test-servers.nominet.org.uk")
#     # Generate update record name, and test it has been made. Then delete it and check it has been deleted
#     update_name = generate_update_name
#     update.absent(update_name)
#     update.add(update_name, 'TXT', 100, "test signed update")
#
#     # Resolver will automatically sign message and verify response
#     response = res.send_message(update)
#     assert(response.verified?) # Check that the response has been verified
#
# source://dnsruby//lib/dnsruby/resource/TSIG.rb#53
class Dnsruby::RR::TSIG < ::Dnsruby::RR
  # Gets or sets the domain name that specifies the name of the algorithm.
  # The only algorithms currently supported are hmac-md5 and hmac-sha1.
  #
  #     rr.algorithm=(algorithm_name)
  #     print "algorithm = ", rr.algorithm, "\n"
  #
  # source://dnsruby//lib/dnsruby/resource/TSIG.rb#399
  def algorithm; end

  # Set the algorithm to use to generate the HMAC
  # Supported values are :
  # * hmac-md5
  # * hmac-sha1
  # * hmac-sha256
  # * hmac-sha512
  #
  # source://dnsruby//lib/dnsruby/resource/TSIG.rb#522
  def algorithm=(alg); end

  # Generates a TSIG record and adds it to the message.
  # Takes an optional original_request argument for the case where this is
  # a response to a query (RFC2845 3.4.1)
  #
  # Message#tsigstate will be set to :Signed.
  #
  # source://dnsruby//lib/dnsruby/resource/TSIG.rb#68
  def apply(message, original_request = T.unsafe(nil)); end

  # source://dnsruby//lib/dnsruby/resource/TSIG.rb#144
  def calculate_mac(algorithm, data); end

  # source://dnsruby//lib/dnsruby/resource/TSIG.rb#569
  def encode_rdata(msg, canonical = T.unsafe(nil)); end

  # Returns the RCODE covering TSIG processing.  Common values are
  # NOERROR, BADSIG, BADKEY, and BADTIME.  See RFC 2845 for details.
  #
  #     print "error = ", rr.error, "\n"
  #
  # source://dnsruby//lib/dnsruby/resource/TSIG.rb#449
  def error; end

  # Returns the RCODE covering TSIG processing.  Common values are
  # NOERROR, BADSIG, BADKEY, and BADTIME.  See RFC 2845 for details.
  #
  #     print "error = ", rr.error, "\n"
  #
  # source://dnsruby//lib/dnsruby/resource/TSIG.rb#449
  def error=(_arg0); end

  # source://dnsruby//lib/dnsruby/resource/TSIG.rb#488
  def from_data(data); end

  # Create the RR from a standard string
  #
  # source://dnsruby//lib/dnsruby/resource/TSIG.rb#504
  def from_string(str); end

  # Gets or sets the "fudge", i.e., the seconds of error permitted in the
  # signing time.
  #
  # The default fudge is 300 seconds.
  #
  #     rr.fudge=(60)
  #     print "fudge = ", rr.fudge, "\n"
  #
  # source://dnsruby//lib/dnsruby/resource/TSIG.rb#419
  def fudge; end

  # source://dnsruby//lib/dnsruby/resource/TSIG.rb#546
  def fudge=(f); end

  # Generates a TSIG record
  #
  # source://dnsruby//lib/dnsruby/resource/TSIG.rb#84
  def generate(msg, original_request = T.unsafe(nil), data = T.unsafe(nil), msg_bytes = T.unsafe(nil), tsig_rr = T.unsafe(nil)); end

  # source://dnsruby//lib/dnsruby/resource/TSIG.rb#469
  def init_defaults; end

  # Stores the secret key used for signing/verifying messages.
  #
  # source://dnsruby//lib/dnsruby/resource/TSIG.rb#467
  def key; end

  # Stores the secret key used for signing/verifying messages.
  #
  # source://dnsruby//lib/dnsruby/resource/TSIG.rb#467
  def key=(_arg0); end

  # Returns the message authentication code (MAC) as a string of hex
  # characters.  The programmer must call a Net::DNS::Packet object's
  # data method before this will return anything meaningful.
  #
  #     print "MAC = ", rr.mac, "\n"
  #
  # source://dnsruby//lib/dnsruby/resource/TSIG.rb#435
  def mac; end

  # Returns the message authentication code (MAC) as a string of hex
  # characters.  The programmer must call a Net::DNS::Packet object's
  # data method before this will return anything meaningful.
  #
  #     print "MAC = ", rr.mac, "\n"
  #
  # source://dnsruby//lib/dnsruby/resource/TSIG.rb#435
  def mac=(_arg0); end

  # Returns the number of octets in the message authentication code (MAC).
  # The programmer must call a Net::DNS::Packet object's data method
  # before this will return anything meaningful.
  #
  #     print "MAC size = ", rr.mac_size, "\n"
  #
  # source://dnsruby//lib/dnsruby/resource/TSIG.rb#427
  def mac_size; end

  # Returns the number of octets in the message authentication code (MAC).
  # The programmer must call a Net::DNS::Packet object's data method
  # before this will return anything meaningful.
  #
  #     print "MAC size = ", rr.mac_size, "\n"
  #
  # source://dnsruby//lib/dnsruby/resource/TSIG.rb#427
  def mac_size=(_arg0); end

  # source://dnsruby//lib/dnsruby/resource/TSIG.rb#492
  def name=(n); end

  # Gets or sets the original message ID.
  #
  #     rr.original_id(12345)
  #     print "original ID = ", rr.original_id, "\n"
  #
  # source://dnsruby//lib/dnsruby/resource/TSIG.rb#442
  def original_id; end

  # Gets or sets the original message ID.
  #
  #     rr.original_id(12345)
  #     print "original ID = ", rr.original_id, "\n"
  #
  # source://dnsruby//lib/dnsruby/resource/TSIG.rb#442
  def original_id=(_arg0); end

  # Returns the Other Data.  This field should be empty unless the
  # error is BADTIME, in which case it will contain the server's
  # time as the number of seconds since 1 Jan 1970 00:00:00 UTC.
  #
  #     print "other data = ", rr.other_data, "\n"
  #
  # source://dnsruby//lib/dnsruby/resource/TSIG.rb#464
  def other_data; end

  # Returns the Other Data.  This field should be empty unless the
  # error is BADTIME, in which case it will contain the server's
  # time as the number of seconds since 1 Jan 1970 00:00:00 UTC.
  #
  #     print "other data = ", rr.other_data, "\n"
  #
  # source://dnsruby//lib/dnsruby/resource/TSIG.rb#464
  def other_data=(_arg0); end

  # Returns the length of the Other Data.  Should be zero unless the
  # error is BADTIME.
  #
  #     print "other len = ", rr.other_size, "\n"
  #
  # source://dnsruby//lib/dnsruby/resource/TSIG.rb#456
  def other_size; end

  # Returns the length of the Other Data.  Should be zero unless the
  # error is BADTIME.
  #
  #     print "other len = ", rr.other_size, "\n"
  #
  # source://dnsruby//lib/dnsruby/resource/TSIG.rb#456
  def other_size=(_arg0); end

  # source://dnsruby//lib/dnsruby/resource/TSIG.rb#78
  def query=(q); end

  # source://dnsruby//lib/dnsruby/resource/TSIG.rb#554
  def rdata_to_string; end

  # Private method to return the TSIG RR data to be signed
  #
  # source://dnsruby//lib/dnsruby/resource/TSIG.rb#171
  def sig_data(tsig_rr, time_signed = T.unsafe(nil)); end

  # Gets or sets the signing time as the number of seconds since 1 Jan 1970
  # 00:00:00 UTC.
  #
  # The default signing time is the current time.
  #
  #     rr.time_signed=(time)
  #     print "time signed = ", rr.time_signed, "\n"
  #
  # source://dnsruby//lib/dnsruby/resource/TSIG.rb#409
  def time_signed; end

  # Gets or sets the signing time as the number of seconds since 1 Jan 1970
  # 00:00:00 UTC.
  #
  # The default signing time is the current time.
  #
  #     rr.time_signed=(time)
  #     print "time signed = ", rr.time_signed, "\n"
  #
  # source://dnsruby//lib/dnsruby/resource/TSIG.rb#409
  def time_signed=(_arg0); end

  # Verify a response. This method will be called by Dnsruby::SingleResolver
  # before passing a response to the client code.
  # The TSIG record will be removed from packet before passing to client, and
  # the Message#tsigstate and Message#tsigerror will be set accordingly.
  # Message#tsigstate will be set to one of :
  # *  :Failed
  # *  :Verified
  #
  # source://dnsruby//lib/dnsruby/resource/TSIG.rb#194
  def verify(query, response, response_bytes, buf = T.unsafe(nil)); end

  # source://dnsruby//lib/dnsruby/resource/TSIG.rb#234
  def verify_common(response); end

  # Checks TSIG signatures across sessions of multiple DNS envelopes.
  # This method is called each time a new envelope comes in. The envelope
  # is checked - if a TSIG is present, them the stream so far is verified,
  # and the response#tsigstate set to :Verified. If a TSIG is not present,
  # and does not need to be present, then the message is added to the digest
  # stream and the response#tsigstate is set to :Intermediate.
  # If there is an error with the TSIG verification, then the response#tsigstate
  # is set to :Failed.
  # Like verify, this method will only be called by the Dnsruby::SingleResolver
  # class. Client code need not call this method directly.
  #
  # source://dnsruby//lib/dnsruby/resource/TSIG.rb#282
  def verify_envelope(response, response_bytes); end

  class << self
    # source://dnsruby//lib/dnsruby/resource/TSIG.rb#584
    def decode_rdata(msg); end
  end
end

# source://dnsruby//lib/dnsruby/resource/TSIG.rb#390
Dnsruby::RR::TSIG::ClassValue = T.let(T.unsafe(nil), T.untyped)

# source://dnsruby//lib/dnsruby/resource/TSIG.rb#61
Dnsruby::RR::TSIG::DEFAULT_ALGORITHM = T.let(T.unsafe(nil), Dnsruby::Name)

# source://dnsruby//lib/dnsruby/resource/TSIG.rb#59
Dnsruby::RR::TSIG::DEFAULT_FUDGE = T.let(T.unsafe(nil), Integer)

# source://dnsruby//lib/dnsruby/resource/TSIG.rb#54
Dnsruby::RR::TSIG::HMAC_MD5 = T.let(T.unsafe(nil), Dnsruby::Name)

# source://dnsruby//lib/dnsruby/resource/TSIG.rb#55
Dnsruby::RR::TSIG::HMAC_SHA1 = T.let(T.unsafe(nil), Dnsruby::Name)

# source://dnsruby//lib/dnsruby/resource/TSIG.rb#56
Dnsruby::RR::TSIG::HMAC_SHA256 = T.let(T.unsafe(nil), Dnsruby::Name)

# source://dnsruby//lib/dnsruby/resource/TSIG.rb#57
Dnsruby::RR::TSIG::HMAC_SHA512 = T.let(T.unsafe(nil), Dnsruby::Name)

# source://dnsruby//lib/dnsruby/resource/TSIG.rb#389
Dnsruby::RR::TSIG::TypeValue = T.let(T.unsafe(nil), Integer)

# Class for DNS Text (TXT) resource records.
# RFC 1035 Section 3.3.14
#
# source://dnsruby//lib/dnsruby/resource/TXT.rb#24
class Dnsruby::RR::TXT < ::Dnsruby::RR
  # source://dnsruby//lib/dnsruby/resource/TXT.rb#31
  def data; end

  # source://dnsruby//lib/dnsruby/resource/TXT.rb#182
  def encode_rdata(msg, canonical = T.unsafe(nil)); end

  # source://dnsruby//lib/dnsruby/resource/TXT.rb#35
  def from_data(data); end

  # source://dnsruby//lib/dnsruby/resource/TXT.rb#39
  def from_hash(hash); end

  # source://dnsruby//lib/dnsruby/resource/TXT.rb#48
  def from_string(input); end

  # source://dnsruby//lib/dnsruby/resource/TXT.rb#170
  def rdata_to_string; end

  # List of the individual elements
  #
  # source://dnsruby//lib/dnsruby/resource/TXT.rb#29
  def strings; end

  # List of the individual elements
  #
  # source://dnsruby//lib/dnsruby/resource/TXT.rb#29
  def strings=(_arg0); end

  class << self
    # source://dnsruby//lib/dnsruby/resource/TXT.rb#186
    def decode_rdata(msg); end

    # source://dnsruby//lib/dnsruby/resource/TXT.rb#140
    def display(str, do_escapes = T.unsafe(nil)); end

    # source://dnsruby//lib/dnsruby/resource/TXT.rb#52
    def parse(input); end
  end
end

# source://dnsruby//lib/dnsruby/resource/TXT.rb#25
Dnsruby::RR::TXT::ClassValue = T.let(T.unsafe(nil), T.untyped)

# source://dnsruby//lib/dnsruby/resource/TXT.rb#45
Dnsruby::RR::TXT::ESCAPE_CHARS = T.let(T.unsafe(nil), Hash)

# source://dnsruby//lib/dnsruby/resource/TXT.rb#46
Dnsruby::RR::TXT::ESCAPE_CODES = T.let(T.unsafe(nil), Hash)

# source://dnsruby//lib/dnsruby/resource/TXT.rb#26
Dnsruby::RR::TXT::TypeValue = T.let(T.unsafe(nil), Integer)

# source://dnsruby//lib/dnsruby/resource/URI.rb#3
class Dnsruby::RR::URI < ::Dnsruby::RR
  # source://dnsruby//lib/dnsruby/resource/URI.rb#39
  def encode_rdata(msg, canonical = T.unsafe(nil)); end

  # source://dnsruby//lib/dnsruby/resource/URI.rb#22
  def from_data(data); end

  # source://dnsruby//lib/dnsruby/resource/URI.rb#16
  def from_hash(hash); end

  # source://dnsruby//lib/dnsruby/resource/URI.rb#26
  def from_string(input); end

  # The NAPTR RR order field
  #
  # source://dnsruby//lib/dnsruby/resource/URI.rb#8
  def priority; end

  # The NAPTR RR order field
  #
  # source://dnsruby//lib/dnsruby/resource/URI.rb#8
  def priority=(_arg0); end

  # source://dnsruby//lib/dnsruby/resource/URI.rb#35
  def rdata_to_string; end

  # The NAPTR RR order field
  #
  # source://dnsruby//lib/dnsruby/resource/URI.rb#14
  def target; end

  # The NAPTR RR order field
  #
  # source://dnsruby//lib/dnsruby/resource/URI.rb#14
  def target=(_arg0); end

  # The NAPTR RR order field
  #
  # source://dnsruby//lib/dnsruby/resource/URI.rb#11
  def weight; end

  # The NAPTR RR order field
  #
  # source://dnsruby//lib/dnsruby/resource/URI.rb#11
  def weight=(_arg0); end

  class << self
    # source://dnsruby//lib/dnsruby/resource/URI.rb#47
    def decode_rdata(msg); end
  end
end

# source://dnsruby//lib/dnsruby/resource/URI.rb#4
Dnsruby::RR::URI::ClassValue = T.let(T.unsafe(nil), T.untyped)

# source://dnsruby//lib/dnsruby/resource/URI.rb#5
Dnsruby::RR::URI::TypeValue = T.let(T.unsafe(nil), Integer)

# Class for DNS X25 resource records.
# RFC 1183 Section 3.1
#
# source://dnsruby//lib/dnsruby/resource/X25.rb#20
class Dnsruby::RR::X25 < ::Dnsruby::RR
  # The PSDN address
  #
  # source://dnsruby//lib/dnsruby/resource/X25.rb#25
  def address; end

  # The PSDN address
  #
  # source://dnsruby//lib/dnsruby/resource/X25.rb#25
  def address=(_arg0); end

  # source://dnsruby//lib/dnsruby/resource/X25.rb#45
  def encode_rdata(msg, canonical = T.unsafe(nil)); end

  # source://dnsruby//lib/dnsruby/resource/X25.rb#27
  def from_data(data); end

  # source://dnsruby//lib/dnsruby/resource/X25.rb#31
  def from_string(input); end

  # source://dnsruby//lib/dnsruby/resource/X25.rb#37
  def rdata_to_string; end

  class << self
    # source://dnsruby//lib/dnsruby/resource/X25.rb#49
    def decode_rdata(msg); end
  end
end

# source://dnsruby//lib/dnsruby/resource/X25.rb#21
Dnsruby::RR::X25::ClassValue = T.let(T.unsafe(nil), T.untyped)

# source://dnsruby//lib/dnsruby/resource/X25.rb#22
Dnsruby::RR::X25::TypeValue = T.let(T.unsafe(nil), Integer)

# RFC2181, section 5
# "It is however possible for most record types to exist
# with the same label, class and type, but with different data.  Such a
# group of records is hereby defined to be a Resource Record Set
# (RRSet)."
# This class also stores the RRSIG records which cover the RRSet
#
# source://dnsruby//lib/dnsruby/resource/RRSet.rb#9
class Dnsruby::RRSet
  include ::Comparable

  # @return [RRSet] a new instance of RRSet
  #
  # source://dnsruby//lib/dnsruby/resource/RRSet.rb#13
  def initialize(rrs = T.unsafe(nil)); end

  # source://dnsruby//lib/dnsruby/resource/RRSet.rb#95
  def <=>(other); end

  # source://dnsruby//lib/dnsruby/resource/RRSet.rb#123
  def ==(other); end

  # source://dnsruby//lib/dnsruby/resource/RRSet.rb#147
  def [](index); end

  # Add the RR to this RRSet
  # Takes a copy of the RR by default. To suppress this, pass false
  # as the second parameter.
  #
  # source://dnsruby//lib/dnsruby/resource/RRSet.rb#56
  def add(rin, do_clone = T.unsafe(nil)); end

  # Delete the RR from this RRSet
  #
  # source://dnsruby//lib/dnsruby/resource/RRSet.rb#139
  def delete(rr); end

  # source://dnsruby//lib/dnsruby/resource/RRSet.rb#142
  def each; end

  # Return the klass of this RRSet
  #
  # source://dnsruby//lib/dnsruby/resource/RRSet.rb#158
  def klass; end

  # source://dnsruby//lib/dnsruby/resource/RRSet.rb#186
  def length; end

  # source://dnsruby//lib/dnsruby/resource/RRSet.rb#172
  def name; end

  # The number of RRSIGs stored in this RRSet
  #
  # source://dnsruby//lib/dnsruby/resource/RRSet.rb#12
  def num_sigs; end

  # source://dnsruby//lib/dnsruby/resource/RRSet.rb#34
  def privateAdd(r); end

  # The RRs (not RRSIGs) stored in this RRSet
  #
  # source://dnsruby//lib/dnsruby/resource/RRSet.rb#31
  def rrs; end

  # The RRSIGs stored with this RRSet
  #
  # source://dnsruby//lib/dnsruby/resource/RRSet.rb#27
  def sigs; end

  # source://dnsruby//lib/dnsruby/resource/RRSet.rb#105
  def sort_canonical; end

  # source://dnsruby//lib/dnsruby/resource/RRSet.rb#179
  def to_s; end

  # Return the ttl of this RRSet
  #
  # source://dnsruby//lib/dnsruby/resource/RRSet.rb#162
  def ttl; end

  # source://dnsruby//lib/dnsruby/resource/RRSet.rb#165
  def ttl=(ttl); end

  # Return the type of this RRSet
  #
  # source://dnsruby//lib/dnsruby/resource/RRSet.rb#151
  def type; end

  class << self
    # source://dnsruby//lib/dnsruby/resource/RRSet.rb#21
    def new_from_string(string); end
  end
end

# source://dnsruby//lib/dnsruby/recursor.rb#113
class Dnsruby::Recursor
  # @return [Recursor] a new instance of Recursor
  #
  # source://dnsruby//lib/dnsruby/recursor.rb#172
  def initialize(res = T.unsafe(nil)); end

  # source://dnsruby//lib/dnsruby/recursor.rb#495
  def _dorecursion(name, type, klass, known_zone, known_authorities, depth, no_validation); end

  # Returns the value of attribute callback.
  #
  # source://dnsruby//lib/dnsruby/recursor.rb#155
  def callback; end

  # Sets the attribute callback
  #
  # @param value the value to set the attribute callback to.
  #
  # source://dnsruby//lib/dnsruby/recursor.rb#155
  def callback=(_arg0); end

  # Returns the value of attribute dnssec.
  #
  # source://dnsruby//lib/dnsruby/recursor.rb#156
  def dnssec; end

  # source://dnsruby//lib/dnsruby/recursor.rb#167
  def dnssec=(dnssec_on); end

  # source://dnsruby//lib/dnsruby/recursor.rb#471
  def get_closest_known_zone_authorities_for(name); end

  # source://dnsruby//lib/dnsruby/recursor.rb#435
  def get_closest_known_zone_for(n); end

  # Returns the value of attribute hints.
  #
  # source://dnsruby//lib/dnsruby/recursor.rb#156
  def hints; end

  # Initialize the hint servers.  Recursive queries need a starting name
  # server to work off of. This method takes a list of IP addresses to use
  # as the starting servers.  These name servers should be authoritative for
  # the root (.) zone.
  #
  #   res.hints=(ips)
  #
  # If no hints are passed, the default nameserver is asked for the hints.
  # Normally these IPs can be obtained from the following location:
  #
  #   ftp://ftp.internic.net/domain/named.root
  #
  # source://dnsruby//lib/dnsruby/recursor.rb#197
  def hints=(hints); end

  # Returns the value of attribute ipv6_ok.
  #
  # source://dnsruby//lib/dnsruby/recursor.rb#155
  def ipv6_ok; end

  # Sets the attribute ipv6_ok
  #
  # @param value the value to set the attribute ipv6_ok to.
  #
  # source://dnsruby//lib/dnsruby/recursor.rb#155
  def ipv6_ok=(_arg0); end

  # Returns the value of attribute nameservers.
  #
  # source://dnsruby//lib/dnsruby/recursor.rb#155
  def nameservers; end

  # Sets the attribute nameservers
  #
  # @param value the value to set the attribute nameservers to.
  #
  # source://dnsruby//lib/dnsruby/recursor.rb#155
  def nameservers=(_arg0); end

  # source://dnsruby//lib/dnsruby/recursor.rb#748
  def prune_rrsets_to_rfc5452(packet, zone); end

  # This method is much like the normal query() method except it disables
  # the recurse flag in the packet and explicitly performs the recursion.
  #
  #   packet = res.query( "www.netscape.com.", "A")
  #   packet = res.query( "www.netscape.com.", "A", "IN", true) # no validation
  #
  # The Recursor maintains a cache of known nameservers.
  # DNSSEC validation is performed unless true is passed as the fourth parameter.
  #
  # source://dnsruby//lib/dnsruby/recursor.rb#402
  def query(name, type = T.unsafe(nil), klass = T.unsafe(nil), no_validation = T.unsafe(nil)); end

  # source://dnsruby//lib/dnsruby/recursor.rb#390
  def query_no_validation_or_recursion(name, type = T.unsafe(nil), klass = T.unsafe(nil)); end

  # Returns the value of attribute recurse.
  #
  # source://dnsruby//lib/dnsruby/recursor.rb#155
  def recurse; end

  # Sets the attribute recurse
  #
  # @param value the value to set the attribute recurse to.
  #
  # source://dnsruby//lib/dnsruby/recursor.rb#155
  def recurse=(_arg0); end

  # source://dnsruby//lib/dnsruby/recursor.rb#377
  def recursion_callback; end

  # This method takes a code reference, which is then invoked each time a
  # packet is received during the recursive lookup.  For example to emulate
  # dig's C<+trace> function:
  #
  #  res.recursion_callback(Proc.new { |packet|
  #      print packet.additional.inspect
  #
  #      print";; Received %d bytes from %s\n\n",
  #          packetanswersize,
  #          packet.answerfrom);
  #  })
  #
  # source://dnsruby//lib/dnsruby/recursor.rb#371
  def recursion_callback=(sub); end

  # The resolver to use for the queries
  #
  # source://dnsruby//lib/dnsruby/recursor.rb#158
  def resolver; end

  # The resolver to use for the queries
  #
  # source://dnsruby//lib/dnsruby/recursor.rb#158
  def resolver=(_arg0); end

  class << self
    # source://dnsruby//lib/dnsruby/recursor.rb#336
    def add_to_hints(hints, rr); end

    # source://dnsruby//lib/dnsruby/recursor.rb#381
    def clear_caches(resolver = T.unsafe(nil)); end

    # source://dnsruby//lib/dnsruby/recursor.rb#200
    def set_hints(hints, resolver); end
  end
end

# source://dnsruby//lib/dnsruby/recursor.rb#114
class Dnsruby::Recursor::AddressCache
  # Like an array, but stores the expiration of each record.
  #
  # @return [AddressCache] a new instance of AddressCache
  #
  # source://dnsruby//lib/dnsruby/recursor.rb#116
  def initialize(*args); end

  # source://dnsruby//lib/dnsruby/recursor.rb#149
  def each; end

  # source://dnsruby//lib/dnsruby/recursor.rb#144
  def length; end

  # source://dnsruby//lib/dnsruby/recursor.rb#120
  def push(item); end

  # source://dnsruby//lib/dnsruby/recursor.rb#127
  def values; end
end

# The requested operation was refused by the remote resolver
#
# source://dnsruby//lib/dnsruby.rb#185
class Dnsruby::Refused < ::Dnsruby::ResolvError; end

# NOTE!  Beware, there is a Ruby library class named Resolv, and you may need to
# explicitly specify Dnsruby::Resolv to use the Dnsruby Resolv class,
# even if you have include'd Dnsruby.
#
# source://dnsruby//lib/dnsruby/resolv.rb#12
class Dnsruby::Resolv
  # Creates a new Resolv using +resolvers+
  #
  # @return [Resolv] a new instance of Resolv
  #
  # source://dnsruby//lib/dnsruby/resolv.rb#61
  def initialize(resolvers = T.unsafe(nil)); end

  # Iterates over all IP addresses for +name+
  #
  # source://dnsruby//lib/dnsruby/resolv.rb#87
  def each_address(name); end

  # Iterates over all hostnames of +address+
  #
  # source://dnsruby//lib/dnsruby/resolv.rb#112
  def each_name(address); end

  # Looks up the first IP address for +name+
  #
  # source://dnsruby//lib/dnsruby/resolv.rb#66
  def getaddress(name); end

  # Looks up all IP addresses for +name+
  #
  # source://dnsruby//lib/dnsruby/resolv.rb#76
  def getaddresses(name); end

  # Looks up the first hostname of +address+
  #
  # source://dnsruby//lib/dnsruby/resolv.rb#92
  def getname(address); end

  # Looks up all hostnames of +address+
  #
  # source://dnsruby//lib/dnsruby/resolv.rb#102
  def getnames(address); end

  class << self
    # Iterates over all IP addresses for +name+
    #
    # source://dnsruby//lib/dnsruby/resolv.rb#38
    def each_address(name, &block); end

    # Iterates over all hostnames of +address+
    #
    # source://dnsruby//lib/dnsruby/resolv.rb#53
    def each_name(address, &proc); end

    # Looks up the first IP address for +name+
    #
    # source://dnsruby//lib/dnsruby/resolv.rb#28
    def getaddress(name); end

    # Looks up all IP addresses for +name+
    #
    # source://dnsruby//lib/dnsruby/resolv.rb#33
    def getaddresses(name); end

    # Looks up the first hostname of +address+
    #
    # source://dnsruby//lib/dnsruby/resolv.rb#43
    def getname(address); end

    # Looks up all hostnames of +address+
    #
    # source://dnsruby//lib/dnsruby/resolv.rb#48
    def getnames(address); end

    # Some class methods require the use of an instance to compute their result.
    # For this purpose we create a single instance that can be reused.
    #
    # source://dnsruby//lib/dnsruby/resolv.rb#20
    def instance; end
  end
end

# Address RegExp to use for matching IP addresses
#
# source://dnsruby//lib/dnsruby/resolv.rb#15
Dnsruby::Resolv::ADDRESS_REGEX = T.let(T.unsafe(nil), Regexp)

# An error raised while querying for a resource
#
# source://dnsruby//lib/dnsruby.rb#160
class Dnsruby::ResolvError < ::StandardError
  # Returns the value of attribute response.
  #
  # source://dnsruby//lib/dnsruby.rb#161
  def response; end

  # Sets the attribute response
  #
  # @param value the value to set the attribute response to.
  #
  # source://dnsruby//lib/dnsruby.rb#161
  def response=(_arg0); end
end

# A timeout error raised while querying for a resource
#
# source://dnsruby//lib/dnsruby.rb#165
class Dnsruby::ResolvTimeout < ::Timeout::Error; end

# == Description
#  Dnsruby::Resolver is a DNS stub resolver.
#  This class performs queries with retries across multiple nameservers.
#  The system configured resolvers are used by default.
#
#  The retry policy is a combination of the Net::DNS and dnsjava approach, and has the option of :
#  * A total timeout for the query (defaults to 0, meaning "no total timeout")
#  * A retransmission system that targets the namervers concurrently once the first query round is
#   complete, but in which the total time per query round is split between the number of nameservers
#   targetted for the first round. and total time for query round is doubled for each query round
#
#  Note that, if a total timeout is specified, then that will apply regardless of the retry policy
#  (i.e. it may cut retries short).
#
#  Note also that these timeouts are distinct from the SingleResolver's packet_timeout
#
#  Timeouts apply to the initial query and response. If DNSSEC validation is to
#  be performed, then additional queries may be required (these are performed automatically
#  by Dnsruby). Each additional query will be performed with its own timeouts.
#  So, even with a query_timeout of 5 seconds, a response which required extensive
#  validation may take several times that long.
#  (Future versions of Dnsruby may expose finer-grained events for client tracking of
#  responses and validation)
#
#  == Methods
#
#  === Synchronous
#  These methods raise an exception or return a response message with rcode==NOERROR
#
#  *  Dnsruby::Resolver#send_message(msg)
#  *  Dnsruby::Resolver#query(name [, type [, klass]])
#
#    There are "!" versions of these two methods that return an array [response, error]
#    instead of raising an error on failure.  They can be called as follows:
#
#    response, error = resolver.send_message!(...)
#    response, error = resolver.query!(...)
#
#    If the request succeeds, response will contain the Dnsruby::Message response
#    and error will be nil.
#
#    If the request fails, response will be nil and error will contain the error raised.
#
#  === Asynchronous
#  These methods use a response queue to return the response and the error
#
#  *  Dnsruby::Resolver#send_async(msg, response_queue, query_id)
#
#  == Event Loop
#  Dnsruby runs a pure Ruby event loop to handle I/O in a single thread.
#  Support for EventMachine has been deprecated.
#
# source://dnsruby//lib/dnsruby/resolver.rb#73
class Dnsruby::Resolver
  # Create a new Resolver object. If no parameters are passed in, then the default
  #  system configuration will be used. Otherwise, a Hash may be passed in with the
  #  following optional elements :
  #
  #
  #  * :port
  #  * :use_tcp
  #  * :tsig
  #  * :ignore_truncation
  #  * :src_address
  #  * :src_address6
  #  * :src_port
  #  * :recurse
  #  * :udp_size
  #  * :config_info - see Config
  #  * :nameserver - can be either a String or an array of Strings
  #  * :packet_timeout
  #  * :query_timeout
  #  * :retry_times
  #  * :retry_delay
  #  * :do_caching
  #  * :tcp_pipelining
  #  * :tcp_pipelining_max_queries - can be a number or :infinite symbol
  #
  # @return [Resolver] a new instance of Resolver
  #
  # source://dnsruby//lib/dnsruby/resolver.rb#439
  def initialize(*args); end

  # source://dnsruby//lib/dnsruby/resolver.rb#480
  def add_config_nameservers; end

  # # Add a new SingleResolver to the list of resolvers this Resolver object will
  #     # query.
  #       # @TODO@ Make a new PacketSender from this SingleResolver!!
  #       @single_resolvers.push(internal)
  #     end
  #
  # source://dnsruby//lib/dnsruby/resolver.rb#568
  def add_server(server); end

  # Can be a single Integer or a Range or an Array
  #  If an invalid port is selected (one reserved by
  #  IANA), then an ArgumentError will be raised.
  #  "0" means "any valid port" - this is only a viable
  #  option if it is the only port in the list.
  #  An ArgumentError will be raised if "0" is added to
  #  an existing set of source ports.
  #
  #         res.add_src_port(60000)
  #         res.add_src_port([60001,60005,60010])
  #         res.add_src_port(60015..60115)
  #
  # source://dnsruby//lib/dnsruby/resolver.rb#642
  def add_src_port(p); end

  # Close the Resolver. Unfinished queries are terminated with OtherResolvError.
  #
  # source://dnsruby//lib/dnsruby/resolver.rb#412
  def close; end

  # The current Config
  #
  # source://dnsruby//lib/dnsruby/resolver.rb#129
  def config; end

  # Use DNSSEC for this Resolver
  #
  # source://dnsruby//lib/dnsruby/resolver.rb#165
  def dnssec; end

  # source://dnsruby//lib/dnsruby/resolver.rb#801
  def dnssec=(d); end

  # Defines whether we will cache responses, or pass every request to the
  #  upstream resolver.  This is only really useful when querying authoritative
  #  servers (as the upstream recursive resolver is likely to cache)
  #
  # source://dnsruby//lib/dnsruby/resolver.rb#177
  def do_caching; end

  # Defines whether we will cache responses, or pass every request to the
  #  upstream resolver.  This is only really useful when querying authoritative
  #  servers (as the upstream recursive resolver is likely to cache)
  #
  # source://dnsruby//lib/dnsruby/resolver.rb#791
  def do_caching=(on); end

  # Defines whether validation is performed by default on this Resolver when the
  #  query method is called.
  #  Note that send_message and send_async expect a
  #  Message object to be passed in, which is already configured to the callers
  #  requirements.
  #
  # source://dnsruby//lib/dnsruby/resolver.rb#172
  def do_validation; end

  # Defines whether validation is performed by default on this Resolver when the
  #  query method is called.
  #  Note that send_message and send_async expect a
  #  Message object to be passed in, which is already configured to the callers
  #  requirements.
  #
  # source://dnsruby//lib/dnsruby/resolver.rb#172
  def do_validation=(_arg0); end

  # source://dnsruby//lib/dnsruby/resolver.rb#821
  def generate_timeouts(base = T.unsafe(nil)); end

  # Should truncation be ignored?
  #  i.e. the TC bit is ignored and thus the resolver will not requery over TCP if TC is set
  #
  # source://dnsruby//lib/dnsruby/resolver.rb#114
  def ignore_truncation; end

  # source://dnsruby//lib/dnsruby/resolver.rb#761
  def ignore_truncation=(on); end

  # source://dnsruby//lib/dnsruby/resolver.rb#589
  def nameserver=(n); end

  # source://dnsruby//lib/dnsruby/resolver.rb#585
  def nameservers=(ns); end

  # If no_tcp==true, then ONLY UDP will be used as a transport.
  #  This should not generally be used, but is provided as a debugging aid.
  #
  # source://dnsruby//lib/dnsruby/resolver.rb#107
  def no_tcp; end

  # source://dnsruby//lib/dnsruby/resolver.rb#706
  def no_tcp=(on); end

  # The timeout for any individual packet. This is the timeout used by SingleResolver
  #
  # source://dnsruby//lib/dnsruby/resolver.rb#150
  def packet_timeout; end

  # --
  #  @TODO@ Should really auto-generate these methods.
  #  Also, any way to tie them up with SingleResolver RDoc?
  #  ++
  #
  # source://dnsruby//lib/dnsruby/resolver.rb#601
  def packet_timeout=(t); end

  # source://dnsruby//lib/dnsruby/resolver.rb#781
  def persistent_tcp=(on); end

  # source://dnsruby//lib/dnsruby/resolver.rb#786
  def persistent_udp=(on); end

  # The port to send queries to on the resolver
  #
  # source://dnsruby//lib/dnsruby/resolver.rb#92
  def port; end

  # source://dnsruby//lib/dnsruby/resolver.rb#776
  def port=(a); end

  # Query for a name. If a valid Message is received, then it is returned
  #  to the caller. Otherwise an exception (a Dnsruby::ResolvError or Dnsruby::ResolvTimeout) is raised.
  #
  #    require 'dnsruby'
  #    res = Dnsruby::Resolver.new
  #    response = res.query('example.com') # defaults to Types.A, Classes.IN
  #    response = res.query('example.com', Types.MX)
  #    response = res.query('208.77.188.166') # IPv4 address so PTR query will be made
  #    response = res.query('208.77.188.166', Types.PTR)
  #
  # source://dnsruby//lib/dnsruby/resolver.rb#194
  def query(name, type = T.unsafe(nil), klass = T.unsafe(nil), set_cd = T.unsafe(nil)); end

  # Like query, but does not raise an error when an error occurs.
  #  Instead, it returns it.
  #  @return a 2 element array: [response, error]
  #
  # source://dnsruby//lib/dnsruby/resolver.rb#209
  def query!(name, type = T.unsafe(nil), klass = T.unsafe(nil), set_cd = T.unsafe(nil)); end

  # source://dnsruby//lib/dnsruby/resolver.rb#219
  def query_no_validation_or_recursion(name, type = T.unsafe(nil), klass = T.unsafe(nil)); end

  # Sends a message with send_plain_message.
  # Effectively a wrapper around send_plain_message, but adds
  # the ability to configure whether an error will be raised
  # or returned if it occurs.
  #
  # @param message the message to send to the DNS server
  # @param error_strategy :return to return [response, error] (default),
  #   :raise to return response only, or raise an error if one occurs
  #
  # source://dnsruby//lib/dnsruby/resolver.rb#284
  def query_raw(message, error_strategy = T.unsafe(nil)); end

  # Note that this timeout represents the total time a query may run for - multiple packets
  #  can be sent to multiple nameservers in this time.
  #  This is distinct from the SingleResolver per-packet timeout
  #  The query_timeout is not required - it will default to 0, which means "do not use query_timeout".
  #  If this is the case then the timeout will be dictated by the retry_times and retry_delay attributes
  #
  # source://dnsruby//lib/dnsruby/resolver.rb#157
  def query_timeout; end

  # Note that this timeout represents the total time a query may run for - multiple packets
  #  can be sent to multiple nameservers in this time.
  #  This is distinct from the SingleResolver per-packet timeout
  #  The query_timeout is not required - it will default to 0, which means "do not use query_timeout".
  #  If this is the case then the timeout will be dictated by the retry_times and retry_delay attributes
  #
  # source://dnsruby//lib/dnsruby/resolver.rb#157
  def query_timeout=(_arg0); end

  # Should the Recursion Desired bit be set?
  #
  # source://dnsruby//lib/dnsruby/resolver.rb#123
  def recurse; end

  # source://dnsruby//lib/dnsruby/resolver.rb#796
  def recurse=(a); end

  # source://dnsruby//lib/dnsruby/resolver.rb#518
  def reset_attributes; end

  # The query will be tried across nameservers retry_times times, with a delay of retry_delay seconds
  #  between each retry. The first time round, retry_delay will be divided by the number of nameservers
  #  being targetted, and a new nameserver will be queried with the resultant delay.
  #
  # source://dnsruby//lib/dnsruby/resolver.rb#162
  def retry_delay; end

  # The query will be tried across nameservers retry_times times, with a delay of retry_delay seconds
  #  between each retry. The first time round, retry_delay will be divided by the number of nameservers
  #  being targetted, and a new nameserver will be queried with the resultant delay.
  #
  # source://dnsruby//lib/dnsruby/resolver.rb#162
  def retry_delay=(_arg0); end

  # The query will be tried across nameservers retry_times times, with a delay of retry_delay seconds
  #  between each retry. The first time round, retry_delay will be divided by the number of nameservers
  #  being targetted, and a new nameserver will be queried with the resultant delay.
  #
  # source://dnsruby//lib/dnsruby/resolver.rb#162
  def retry_times; end

  # The query will be tried across nameservers retry_times times, with a delay of retry_delay seconds
  #  between each retry. The first time round, retry_delay will be divided by the number of nameservers
  #  being targetted, and a new nameserver will be queried with the resultant delay.
  #
  # source://dnsruby//lib/dnsruby/resolver.rb#162
  def retry_times=(_arg0); end

  # Asynchronously send a Message to the server. The send can be done using just
  #  Dnsruby. Support for EventMachine has been deprecated.
  #
  #  == Dnsruby pure Ruby event loop :
  #
  #  A client_queue is supplied by the client,
  #  along with an optional client_query_id to identify the response. The client_query_id
  #  is generated, if not supplied, and returned to the client.
  #  When the response is known,
  #  a tuple of (query_id, response_message, exception) will be added to the client_queue.
  #
  #  The query is sent synchronously in the caller's thread. The select thread is then used to
  #  listen for and process the response (up to pushing it to the client_queue). The client thread
  #  is then used to retrieve the response and deal with it.
  #
  #  Takes :
  #
  #  * msg - the message to send
  #  * client_queue - a Queue to push the response to, when it arrives
  #  * client_query_id - an optional ID to identify the query to the client
  #  * use_tcp - whether to use only TCP (defaults to SingleResolver.use_tcp)
  #
  #  Returns :
  #
  #  * client_query_id - to identify the query response to the client. This ID is
  #  generated if it is not passed in by the client
  #
  #  === Example invocations :
  #
  #     id = res.send_async(msg, queue)
  #     NOT SUPPORTED : id = res.send_async(msg, queue, use_tcp)
  #     id = res.send_async(msg, queue, id)
  #     id = res.send_async(msg, queue, id, use_tcp)
  #
  #  === Example code :
  #
  #    require 'dnsruby'
  #    res = Dnsruby::Resolver.newsend
  #    query_id = 10 # can be any object you like
  #    query_queue = Queue.new
  #    res.send_async(Message.new('example.com', Types.MX),  query_queue, query_id)
  #    query_id_2 = res.send_async(Message.new('example.com', Types.A), query_queue)
  #    # ...do a load of other stuff here...
  #    2.times do
  #      response_id, response, exception = query_queue.pop
  #      # You can check the ID to see which query has been answered
  #      if exception == nil
  #          # deal with good response
  #      else
  #          # deal with problem
  #      end
  #    end
  #
  # source://dnsruby//lib/dnsruby/resolver.rb#392
  def send_async(msg, client_queue, client_query_id = T.unsafe(nil)); end

  # Send a message, and wait for the response. If a valid Message is received, then it is returned
  #  to the caller. Otherwise an exception (a Dnsruby::ResolvError or Dnsruby::ResolvTimeout) is raised.
  #
  #  send_async is called internally.
  #
  #  example :
  #
  #    require 'dnsruby'
  #    include Dnsruby
  #    res = Dnsruby::Resolver.new
  #    begin
  #    response = res.send_message(Message.new('example.com', Types.MX))
  #    rescue ResolvError
  #      # ...
  #    rescue ResolvTimeout
  #      # ...
  #    end
  #
  # source://dnsruby//lib/dnsruby/resolver.rb#248
  def send_message(message); end

  # Like send_message, but does not raise an error when an error occurs.
  #  Instead, it returns it.
  #  @return a 2 element array: [response, error]
  #
  # source://dnsruby//lib/dnsruby/resolver.rb#266
  def send_message!(message); end

  # This method takes a Message (supplied by the client), and sends it to
  #  the configured nameservers. No changes are made to the Message before it
  #  is sent (TSIG signatures will be applied if configured on the Resolver).
  #  Retries are handled as the Resolver is configured to do.
  #  Incoming responses to the query are not cached or validated (although TCP
  #  fallback will be performed if the TC bit is set and the (Single)Resolver has
  #  ignore_truncation set to false).
  #  Note that the Message is left untouched - this means that no OPT records are
  #  added, even if the UDP transport for the server is specified at more than 512
  #  bytes. If it is desired to use EDNS for this packet, then you should call
  #  the Dnsruby::PacketSender#prepare_for_dnssec(msg), or
  #  Dnsruby::PacketSender#add_opt_rr(msg)
  #  The return value from this method is the [response, error] tuple. Either of
  #  these values may be nil - it is up to the client to check.
  #
  #  example :
  #
  #    require 'dnsruby'
  #    include Dnsruby
  #    res = Dnsruby::Resolver.new
  #    response, error = res.send_plain_message(Message.new('example.com', Types.MX))
  #    if error
  #      print "Error returned : #{error}\n"
  #    else
  #      process_response(response)
  #    end
  #
  # source://dnsruby//lib/dnsruby/resolver.rb#326
  def send_plain_message(message); end

  # source://dnsruby//lib/dnsruby/resolver.rb#509
  def set_config_nameserver(n); end

  # source://dnsruby//lib/dnsruby/resolver.rb#817
  def single_res_mutex; end

  # }
  #
  # source://dnsruby//lib/dnsruby/resolver.rb#142
  def single_resolvers; end

  # The array of SingleResolvers used for sending query messages
  #
  # source://dnsruby//lib/dnsruby/resolver.rb#136
  def single_resolvers=(s); end

  # The source address to send queries from for IPv4
  #
  # source://dnsruby//lib/dnsruby/resolver.rb#117
  def src_address; end

  # The source address to send queries from for IPv6
  #
  # source://dnsruby//lib/dnsruby/resolver.rb#120
  def src_address6; end

  # source://dnsruby//lib/dnsruby/resolver.rb#771
  def src_address6=(a); end

  # source://dnsruby//lib/dnsruby/resolver.rb#766
  def src_address=(a); end

  # The source port to send queries from
  #  Returns either a single Integer or an Array
  #  e.g. '0', or '[60001, 60002, 60007]'
  #
  #  Defaults to 0 - random port
  #
  # source://dnsruby//lib/dnsruby/resolver.rb#611
  def src_port; end

  # Can be a single Integer or a Range or an Array
  #  If an invalid port is selected (one reserved by
  #  IANA), then an ArgumentError will be raised.
  #
  #         res.src_port=0
  #         res.src_port=[60001,60005,60010]
  #         res.src_port=60015..60115
  #
  # source://dnsruby//lib/dnsruby/resolver.rb#623
  def src_port=(p); end

  # If tcp_pipelining==true, then we reuse the TCP connection
  #
  # source://dnsruby//lib/dnsruby/resolver.rb#99
  def tcp_pipelining; end

  # source://dnsruby//lib/dnsruby/resolver.rb#691
  def tcp_pipelining=(on); end

  # How many times (number of messages) to reuse the pipelining connection
  # before closing, :infinite for infinite number of requests per connection
  #
  # source://dnsruby//lib/dnsruby/resolver.rb#103
  def tcp_pipelining_max_queries; end

  # source://dnsruby//lib/dnsruby/resolver.rb#696
  def tcp_pipelining_max_queries=(max); end

  # Returns the value of attribute tsig.
  #
  # source://dnsruby//lib/dnsruby/resolver.rb#110
  def tsig; end

  # Sets the TSIG to sign outgoing messages with.
  #  Pass in either a Dnsruby::RR::TSIG, or a key_name and key (or just a key)
  #  Pass in nil to stop tsig signing.
  #  * res.tsig=(tsig_rr)
  #  * res.tsig=(key_name, key) # defaults to hmac-md5
  #  * res.tsig=(key_name, key, alg) # e.g. alg = 'hmac-sha1'
  #  * res.tsig=nil # Stop the resolver from signing
  #
  # source://dnsruby//lib/dnsruby/resolver.rb#718
  def tsig=(t); end

  # The maximum UDP size to be used
  #
  # source://dnsruby//lib/dnsruby/resolver.rb#126
  def udp_size; end

  # source://dnsruby//lib/dnsruby/resolver.rb#812
  def udp_size=(s); end

  # source://dnsruby//lib/dnsruby/resolver.rb#553
  def update; end

  # source://dnsruby//lib/dnsruby/resolver.rb#576
  def update_internal_res(res); end

  # Should TCP be used as a transport rather than UDP?
  #  If use_tcp==true, then ONLY TCP will be used as a transport.
  #
  # source://dnsruby//lib/dnsruby/resolver.rb#96
  def use_tcp; end

  # source://dnsruby//lib/dnsruby/resolver.rb#701
  def use_tcp=(on); end

  class << self
    # source://dnsruby//lib/dnsruby/resolver.rb#656
    def check_port(p, src_port = T.unsafe(nil)); end

    # source://dnsruby//lib/dnsruby/resolver.rb#725
    def create_tsig_options(name, key, algorithm = T.unsafe(nil)); end

    # source://dnsruby//lib/dnsruby/resolver.rb#679
    def get_ports_from(p); end

    # source://dnsruby//lib/dnsruby/resolver.rb#738
    def get_tsig(args); end

    # source://dnsruby//lib/dnsruby/resolver.rb#675
    def port_in_range(p); end
  end
end

# source://dnsruby//lib/dnsruby/resolver.rb#81
Dnsruby::Resolver::AbsoluteMinDnssecUdpSize = T.let(T.unsafe(nil), Integer)

# source://dnsruby//lib/dnsruby/resolver.rb#80
Dnsruby::Resolver::DefaultDnssec = T.let(T.unsafe(nil), FalseClass)

# source://dnsruby//lib/dnsruby/resolver.rb#75
Dnsruby::Resolver::DefaultPacketTimeout = T.let(T.unsafe(nil), Integer)

# source://dnsruby//lib/dnsruby/resolver.rb#78
Dnsruby::Resolver::DefaultPipeLiningMaxQueries = T.let(T.unsafe(nil), Integer)

# source://dnsruby//lib/dnsruby/resolver.rb#79
Dnsruby::Resolver::DefaultPort = T.let(T.unsafe(nil), Integer)

# source://dnsruby//lib/dnsruby/resolver.rb#74
Dnsruby::Resolver::DefaultQueryTimeout = T.let(T.unsafe(nil), Integer)

# source://dnsruby//lib/dnsruby/resolver.rb#77
Dnsruby::Resolver::DefaultRetryDelay = T.let(T.unsafe(nil), Integer)

# source://dnsruby//lib/dnsruby/resolver.rb#76
Dnsruby::Resolver::DefaultRetryTimes = T.let(T.unsafe(nil), Integer)

# source://dnsruby//lib/dnsruby/resolver.rb#83
Dnsruby::Resolver::DefaultUDPSize = T.let(T.unsafe(nil), Integer)

# source://dnsruby//lib/dnsruby/resolver.rb#85
class Dnsruby::Resolver::EventType; end

# source://dnsruby//lib/dnsruby/resolver.rb#88
Dnsruby::Resolver::EventType::ERROR = T.let(T.unsafe(nil), Integer)

# source://dnsruby//lib/dnsruby/resolver.rb#86
Dnsruby::Resolver::EventType::RECEIVED = T.let(T.unsafe(nil), Integer)

# @TODO@ Should be COMPLETE?
#
# source://dnsruby//lib/dnsruby/resolver.rb#87
Dnsruby::Resolver::EventType::VALIDATED = T.let(T.unsafe(nil), Integer)

# source://dnsruby//lib/dnsruby/resolver.rb#82
Dnsruby::Resolver::MinDnssecUdpSize = T.let(T.unsafe(nil), Integer)

# This class implements the I/O using pure Ruby, with no dependencies.
#  Support for EventMachine has been deprecated.
#
# source://dnsruby//lib/dnsruby/resolver.rb#854
class Dnsruby::ResolverRuby
  # @return [ResolverRuby] a new instance of ResolverRuby
  #
  # source://dnsruby//lib/dnsruby/resolver.rb#855
  def initialize(parent); end

  # Close the Resolver. Unfinished queries are terminated with OtherResolvError.
  #
  # source://dnsruby//lib/dnsruby/resolver.rb#941
  def close; end

  # TO BE CALLED IN A SYNCHRONIZED BLOCK
  #
  # source://dnsruby//lib/dnsruby/resolver.rb#1182
  def decrement_resolver_priority(res); end

  # TO BE CALLED IN A SYNCHRONIZED BLOCK
  #
  # source://dnsruby//lib/dnsruby/resolver.rb#1194
  def demote_resolver(res); end

  # source://dnsruby//lib/dnsruby/resolver.rb#931
  def generate_timeouts; end

  # source://dnsruby//lib/dnsruby/resolver.rb#1110
  def handle_error_response(select_queue, query_id, error, response); end

  # This method is called by the SelectThread (in the select thread) when the queue has a new item on it.
  #  The queue interface is used to separate producer/consumer threads, but we're using it here in one thread.
  #  It's probably a good idea to create a new "worker thread" to take items from the select thread queue and
  #  call this method in the worker thread.
  #
  # source://dnsruby//lib/dnsruby/resolver.rb#1033
  def handle_queue_event(queue, id); end

  # source://dnsruby//lib/dnsruby/resolver.rb#1202
  def handle_response(select_queue, query_id, response); end

  # source://dnsruby//lib/dnsruby/resolver.rb#1236
  def handle_validation_error(select_queue, query_id, error, response); end

  # source://dnsruby//lib/dnsruby/resolver.rb#1219
  def handle_validation_response(select_queue, query_id, response); end

  # TO BE CALLED IN A SYNCHRONIZED BLOCK
  #
  # source://dnsruby//lib/dnsruby/resolver.rb#1170
  def increment_resolver_priority(res); end

  # source://dnsruby//lib/dnsruby/resolver.rb#859
  def reset_attributes; end

  # source://dnsruby//lib/dnsruby/resolver.rb#865
  def send_async(msg, client_queue, client_query_id = T.unsafe(nil)); end

  # MUST BE CALLED IN A SYNCHRONIZED BLOCK!
  #
  #  Sends the result to the client's queue, and removes the queue observer from the select thread
  #
  # source://dnsruby//lib/dnsruby/resolver.rb#971
  def send_result(client_queue, client_query_id, select_queue, msg, error); end

  # MUST BE CALLED IN A SYNCHRONIZED BLOCK!
  #
  #  Send the result back to the client, and close the socket for that query by removing
  #  the query from the select thread.
  #
  # source://dnsruby//lib/dnsruby/resolver.rb#956
  def send_result_and_stop_querying(client_queue, client_query_id, select_queue, msg, error); end

  # MUST BE CALLED IN A SYNCHRONIZED BLOCK!
  #
  #  Stops send any more packets for a client-level query
  #
  # source://dnsruby//lib/dnsruby/resolver.rb#964
  def stop_querying(client_query_id); end

  # This method is called twice a second from the select loop, in the select thread.
  #  It should arguably be called from another worker thread... (which also handles the queue)
  #  Each tick, we check if any timeouts have occurred. If so, we take the appropriate action :
  #  Return a timeout to the client, or send a new query
  #
  # source://dnsruby//lib/dnsruby/resolver.rb#988
  def tick; end
end

# source://dnsruby//lib/dnsruby/message/section.rb#2
class Dnsruby::Section < ::Array
  # @return [Section] a new instance of Section
  #
  # source://dnsruby//lib/dnsruby/message/section.rb#4
  def initialize(msg = T.unsafe(nil)); end

  # source://dnsruby//lib/dnsruby/message/section.rb#67
  def ==(other); end

  # source://dnsruby//lib/dnsruby/message/section.rb#79
  def remove_rrset(name, type); end

  # Return the rrset of the specified type in this section
  #
  # source://dnsruby//lib/dnsruby/message/section.rb#10
  def rrset(name, type = T.unsafe(nil), klass = T.unsafe(nil)); end

  # Return an array of all the rrsets in the section
  #
  # source://dnsruby//lib/dnsruby/message/section.rb#29
  def rrsets(type = T.unsafe(nil), include_opt = T.unsafe(nil)); end
end

# source://dnsruby//lib/dnsruby/select_thread.rb#27
class Dnsruby::SelectThread
  include ::Singleton
  extend ::Singleton::SingletonClassMethods

  # This singleton class runs a continuous select loop which
  #  listens for responses on all of the in-use sockets.
  #  When a new query is sent, the thread is woken up, and
  #  the socket is added to the select loop (and the new timeout
  #  calculated).
  #  Note that a combination of the socket and the packet ID is
  #  sufficient to uniquely identify the query to the select thread.
  #
  #  But how do we find the response queue for a particular query?
  #  Hash of client_id->[query, client_queue, socket]
  #  and socket->[client_id]
  #
  #  @todo@ should we implement some of cancel function?
  #
  # @return [SelectThread] a new instance of SelectThread
  #
  # source://dnsruby//lib/dnsruby/select_thread.rb#44
  def initialize; end

  # source://dnsruby//lib/dnsruby/select_thread.rb#761
  def add_observer(client_queue, observer); end

  # source://dnsruby//lib/dnsruby/select_thread.rb#127
  def add_to_select(query_settings); end

  # source://dnsruby//lib/dnsruby/select_thread.rb#148
  def check_select_thread_synchronized; end

  # Removes closed sockets from @@sockets, and returns an array containing 1
  # exception for each closed socket contained in @@socket_hash.
  #
  # source://dnsruby//lib/dnsruby/select_thread.rb#250
  def clean_up_closed_sockets; end

  # source://dnsruby//lib/dnsruby/select_thread.rb#390
  def decrement_remaining_queries(socket); end

  # source://dnsruby//lib/dnsruby/select_thread.rb#165
  def do_select; end

  # source://dnsruby//lib/dnsruby/select_thread.rb#267
  def get_active_ids(queries, id); end

  # source://dnsruby//lib/dnsruby/select_thread.rb#603
  def get_client_id_from_answerfrom(socket, answerip, answerport); end

  # source://dnsruby//lib/dnsruby/select_thread.rb#477
  def get_incoming_data(socket, packet_size); end

  # source://dnsruby//lib/dnsruby/select_thread.rb#76
  def get_socket_pair; end

  # source://dnsruby//lib/dnsruby/select_thread.rb#584
  def handle_recvfrom_failure(socket, exception); end

  # @return [Boolean]
  #
  # source://dnsruby//lib/dnsruby/select_thread.rb#396
  def max_attained?(socket); end

  # source://dnsruby//lib/dnsruby/select_thread.rb#788
  def notify_queue_observers(client_queue, client_query_id); end

  # @return [Boolean]
  #
  # source://dnsruby//lib/dnsruby/select_thread.rb#367
  def persistent?(socket); end

  # source://dnsruby//lib/dnsruby/select_thread.rb#262
  def process_error(errors); end

  # source://dnsruby//lib/dnsruby/select_thread.rb#294
  def process_message(msg, bytes, socket); end

  # @@query_hash[query_settings.client_query_id]=query_settings
  #
  # source://dnsruby//lib/dnsruby/select_thread.rb#272
  def process_ready(ready); end

  # source://dnsruby//lib/dnsruby/select_thread.rb#403
  def process_timeouts; end

  # source://dnsruby//lib/dnsruby/select_thread.rb#634
  def push_exception_to_select(client_id, client_queue, err, msg); end

  # source://dnsruby//lib/dnsruby/select_thread.rb#647
  def push_response_to_select(client_id, client_queue, msg, query, res); end

  # source://dnsruby//lib/dnsruby/select_thread.rb#742
  def push_to_client(client_id, client_queue, msg, err, query, res); end

  # source://dnsruby//lib/dnsruby/select_thread.rb#667
  def push_validation_response_to_select(client_id, client_queue, msg, err, query, res); end

  # source://dnsruby//lib/dnsruby/select_thread.rb#371
  def remove_id(id); end

  # source://dnsruby//lib/dnsruby/select_thread.rb#771
  def remove_observer(client_queue, observer); end

  # @return [Boolean]
  #
  # source://dnsruby//lib/dnsruby/select_thread.rb#157
  def select_thread_alive?; end

  # source://dnsruby//lib/dnsruby/select_thread.rb#622
  def send_exception_to_client(err, socket, client_id, msg = T.unsafe(nil)); end

  # source://dnsruby//lib/dnsruby/select_thread.rb#683
  def send_queued_exceptions; end

  # source://dnsruby//lib/dnsruby/select_thread.rb#698
  def send_queued_responses; end

  # source://dnsruby//lib/dnsruby/select_thread.rb#727
  def send_queued_validation_responses; end

  # source://dnsruby//lib/dnsruby/select_thread.rb#321
  def send_response_to_client(msg, bytes, socket); end

  # source://dnsruby//lib/dnsruby/select_thread.rb#799
  def send_tick_to_observers; end

  # @return [Boolean]
  #
  # source://dnsruby//lib/dnsruby/select_thread.rb#117
  def tcp?(socket); end

  # source://dnsruby//lib/dnsruby/select_thread.rb#414
  def tcp_read(socket); end

  # @return [Boolean]
  #
  # source://dnsruby//lib/dnsruby/select_thread.rb#122
  def udp?(socket); end

  class << self
    private

    def allocate; end
    def new(*_arg0); end
  end
end

# source://dnsruby//lib/dnsruby/select_thread.rb#94
class Dnsruby::SelectThread::QuerySettings
  # new(query_bytes, query, ignore_truncation, client_queue, client_query_id,
  #      socket, dest_server, dest_port, endtime, , udp_packet_size, single_resolver)
  #
  # @return [QuerySettings] a new instance of QuerySettings
  #
  # source://dnsruby//lib/dnsruby/select_thread.rb#100
  def initialize(*args); end

  # Returns the value of attribute client_query_id.
  #
  # source://dnsruby//lib/dnsruby/select_thread.rb#95
  def client_query_id; end

  # Sets the attribute client_query_id
  #
  # @param value the value to set the attribute client_query_id to.
  #
  # source://dnsruby//lib/dnsruby/select_thread.rb#95
  def client_query_id=(_arg0); end

  # Returns the value of attribute client_queue.
  #
  # source://dnsruby//lib/dnsruby/select_thread.rb#95
  def client_queue; end

  # Sets the attribute client_queue
  #
  # @param value the value to set the attribute client_queue to.
  #
  # source://dnsruby//lib/dnsruby/select_thread.rb#95
  def client_queue=(_arg0); end

  # Returns the value of attribute dest_port.
  #
  # source://dnsruby//lib/dnsruby/select_thread.rb#95
  def dest_port; end

  # Sets the attribute dest_port
  #
  # @param value the value to set the attribute dest_port to.
  #
  # source://dnsruby//lib/dnsruby/select_thread.rb#95
  def dest_port=(_arg0); end

  # Returns the value of attribute dest_server.
  #
  # source://dnsruby//lib/dnsruby/select_thread.rb#95
  def dest_server; end

  # Sets the attribute dest_server
  #
  # @param value the value to set the attribute dest_server to.
  #
  # source://dnsruby//lib/dnsruby/select_thread.rb#95
  def dest_server=(_arg0); end

  # Returns the value of attribute endtime.
  #
  # source://dnsruby//lib/dnsruby/select_thread.rb#95
  def endtime; end

  # Sets the attribute endtime
  #
  # @param value the value to set the attribute endtime to.
  #
  # source://dnsruby//lib/dnsruby/select_thread.rb#95
  def endtime=(_arg0); end

  # Returns the value of attribute ignore_truncation.
  #
  # source://dnsruby//lib/dnsruby/select_thread.rb#95
  def ignore_truncation; end

  # Sets the attribute ignore_truncation
  #
  # @param value the value to set the attribute ignore_truncation to.
  #
  # source://dnsruby//lib/dnsruby/select_thread.rb#95
  def ignore_truncation=(_arg0); end

  # Returns the value of attribute is_persistent_socket.
  #
  # source://dnsruby//lib/dnsruby/select_thread.rb#95
  def is_persistent_socket; end

  # Sets the attribute is_persistent_socket
  #
  # @param value the value to set the attribute is_persistent_socket to.
  #
  # source://dnsruby//lib/dnsruby/select_thread.rb#95
  def is_persistent_socket=(_arg0); end

  # Returns the value of attribute query.
  #
  # source://dnsruby//lib/dnsruby/select_thread.rb#95
  def query; end

  # Sets the attribute query
  #
  # @param value the value to set the attribute query to.
  #
  # source://dnsruby//lib/dnsruby/select_thread.rb#95
  def query=(_arg0); end

  # Returns the value of attribute query_bytes.
  #
  # source://dnsruby//lib/dnsruby/select_thread.rb#95
  def query_bytes; end

  # Sets the attribute query_bytes
  #
  # @param value the value to set the attribute query_bytes to.
  #
  # source://dnsruby//lib/dnsruby/select_thread.rb#95
  def query_bytes=(_arg0); end

  # Returns the value of attribute single_resolver.
  #
  # source://dnsruby//lib/dnsruby/select_thread.rb#95
  def single_resolver; end

  # Sets the attribute single_resolver
  #
  # @param value the value to set the attribute single_resolver to.
  #
  # source://dnsruby//lib/dnsruby/select_thread.rb#95
  def single_resolver=(_arg0); end

  # Returns the value of attribute socket.
  #
  # source://dnsruby//lib/dnsruby/select_thread.rb#95
  def socket; end

  # Sets the attribute socket
  #
  # @param value the value to set the attribute socket to.
  #
  # source://dnsruby//lib/dnsruby/select_thread.rb#95
  def socket=(_arg0); end

  # Returns the value of attribute tcp_pipelining_max_queries.
  #
  # source://dnsruby//lib/dnsruby/select_thread.rb#95
  def tcp_pipelining_max_queries; end

  # Sets the attribute tcp_pipelining_max_queries
  #
  # @param value the value to set the attribute tcp_pipelining_max_queries to.
  #
  # source://dnsruby//lib/dnsruby/select_thread.rb#95
  def tcp_pipelining_max_queries=(_arg0); end

  # Returns the value of attribute udp_packet_size.
  #
  # source://dnsruby//lib/dnsruby/select_thread.rb#95
  def udp_packet_size; end

  # Sets the attribute udp_packet_size
  #
  # @param value the value to set the attribute udp_packet_size to.
  #
  # source://dnsruby//lib/dnsruby/select_thread.rb#95
  def udp_packet_size=(_arg0); end
end

# source://dnsruby//lib/dnsruby/select_thread.rb#28
class Dnsruby::SelectThread::SelectWakeup < ::RuntimeError; end

# Indicates a failure in the remote resolver
#
# source://dnsruby//lib/dnsruby.rb#177
class Dnsruby::ServFail < ::Dnsruby::ResolvError; end

# == Dnsruby::SingleResolver
#
#  This class has been deprecated.
#  This implementation exists for legacy clients. New code should use the Dnsruby::Resolver class.
#  The SingleResolver class targets a single resolver, and controls the sending of a single
#  packet with a packet timeout. It performs no retries. Only two threads are used - the client
#  thread and a select thread (which is reused across all queries).
#
# == Methods
#
# === Synchronous
# These methods raise an exception or return a response message with rcode==NOERROR
#
# *  Dnsruby::SingleResolver#send_message(msg [, use_tcp]))
# *  Dnsruby::SingleResolver#query(name [, type [, klass]])
#
# === Asynchronous
# These methods use a response queue to return the response and the error to the client.
# Support for EventMachine has been deprecated
#
# *  Dnsruby::SingleResolver#send_async(...)
#
# source://dnsruby//lib/dnsruby/single_resolver.rb#40
class Dnsruby::SingleResolver < ::Dnsruby::Resolver
  # Can take a hash with the following optional keys :
  #
  #  * :server
  #  * :port
  #  * :use_tcp
  #  * :no_tcp
  #  * :ignore_truncation
  #  * :src_address
  #  * :src_address6
  #  * :src_port
  #  * :udp_size
  #  * :persistent_tcp
  #  * :persistent_udp
  #  * :tsig
  #  * :packet_timeout
  #  * :recurse
  #
  # @return [SingleResolver] a new instance of SingleResolver
  #
  # source://dnsruby//lib/dnsruby/single_resolver.rb#57
  def initialize(*args); end

  # Add the appropriate EDNS OPT RR for the specified packet. This is done
  #  automatically, unless you are using Resolver#send_plain_message
  #
  # source://dnsruby//lib/dnsruby/single_resolver.rb#168
  def add_opt_rr(m); end

  # source://dnsruby//lib/dnsruby/single_resolver.rb#161
  def packet_timeout=(t); end

  # source://dnsruby//lib/dnsruby/resolver.rb#150
  def query_timeout; end

  # source://dnsruby//lib/dnsruby/single_resolver.rb#161
  def query_timeout=(t); end

  # @raise [NoMethodError]
  #
  # source://dnsruby//lib/dnsruby/single_resolver.rb#157
  def retry_delay=(n); end

  # @raise [NoMethodError]
  #
  # source://dnsruby//lib/dnsruby/single_resolver.rb#154
  def retry_times=(n); end

  # source://dnsruby//lib/dnsruby/single_resolver.rb#144
  def server; end

  # source://dnsruby//lib/dnsruby/single_resolver.rb#128
  def server=(s); end
end

# source://dnsruby//lib/dnsruby/single_verifier.rb#23
class Dnsruby::SingleVerifier
  # @return [SingleVerifier] a new instance of SingleVerifier
  #
  # source://dnsruby//lib/dnsruby/single_verifier.rb#29
  def initialize(vtype); end

  # source://dnsruby//lib/dnsruby/single_verifier.rb#86
  def add_dlv_key(key); end

  # source://dnsruby//lib/dnsruby/single_verifier.rb#1216
  def add_nameservers(ns_rrset, ns_additional, nameservers); end

  # source://dnsruby//lib/dnsruby/single_verifier.rb#186
  def add_root_ds(ds); end

  # source://dnsruby//lib/dnsruby/single_verifier.rb#122
  def add_trust_anchor(t); end

  # Add the
  #
  # source://dnsruby//lib/dnsruby/single_verifier.rb#126
  def add_trust_anchor_with_expiration(k, expiration); end

  # Add the specified keys to the trusted key cache.
  #  k can be a KeyCache, or an RRSet of DNSKEYs.
  #
  # source://dnsruby//lib/dnsruby/single_verifier.rb#182
  def add_trusted_key(k); end

  # Check that the key fits a signed DS record key details
  #  If so, then add the key to the trusted keys
  #
  # source://dnsruby//lib/dnsruby/single_verifier.rb#210
  def check_ds(key, ds_rrset); end

  # source://dnsruby//lib/dnsruby/single_verifier.rb#635
  def check_ds_stores(key_rrset); end

  # source://dnsruby//lib/dnsruby/single_verifier.rb#539
  def check_name_in_and_type_not_in_nsecs(msg); end

  # source://dnsruby//lib/dnsruby/single_verifier.rb#499
  def check_name_in_nsecs(msg, qtype = T.unsafe(nil), expected_qtype = T.unsafe(nil)); end

  # @raise [VerifyError]
  #
  # source://dnsruby//lib/dnsruby/single_verifier.rb#543
  def check_name_not_in_wildcard_nsecs(msg); end

  # source://dnsruby//lib/dnsruby/single_verifier.rb#462
  def check_no_wildcard_expansion(msg); end

  # source://dnsruby//lib/dnsruby/single_verifier.rb#449
  def check_num_rrsig_labels(msg); end

  # source://dnsruby//lib/dnsruby/single_verifier.rb#484
  def check_record_proves_no_wildcard(msg, nsec); end

  # Check that the RRSet and RRSIG record are compatible
  #
  # source://dnsruby//lib/dnsruby/single_verifier.rb#150
  def check_rr_data(rrset, sigrec); end

  # Wipes the cache of trusted keys
  #
  # source://dnsruby//lib/dnsruby/single_verifier.rb#141
  def clear_trust_anchors; end

  # Wipes the cache of trusted keys
  #
  # source://dnsruby//lib/dnsruby/single_verifier.rb#191
  def clear_trusted_keys; end

  # source://dnsruby//lib/dnsruby/single_verifier.rb#935
  def find_closest_anchor_for(name); end

  # source://dnsruby//lib/dnsruby/single_verifier.rb#831
  def find_closest_dlv_anchor_for(name); end

  # @TODO@ Handle REVOKED keys! (RFC 5011)
  #  Remember that revoked keys will have a different key_tag than pre-revoked.
  #  So, if we see a revoked key, we should go through our key store for
  #  that authority and remove any keys with the pre-revoked key_tag.
  #
  # source://dnsruby//lib/dnsruby/single_verifier.rb#959
  def follow_chain(anchor, name); end

  # source://dnsruby//lib/dnsruby/single_verifier.rb#1001
  def get_anchor_for(child, parent, current_anchor, parent_res = T.unsafe(nil)); end

  # source://dnsruby//lib/dnsruby/single_verifier.rb#93
  def get_dlv_key(ksk); end

  # source://dnsruby//lib/dnsruby/single_verifier.rb#72
  def get_dlv_resolver; end

  # source://dnsruby//lib/dnsruby/single_verifier.rb#662
  def get_keys_to_check; end

  # Find the first matching DNSKEY and RRSIG record in the two sets.
  #
  # source://dnsruby//lib/dnsruby/single_verifier.rb#668
  def get_matching_key(keys, sigrecs); end

  # source://dnsruby//lib/dnsruby/single_verifier.rb#1161
  def get_nameservers_for(name, res = T.unsafe(nil)); end

  # source://dnsruby//lib/dnsruby/single_verifier.rb#1177
  def get_nameservers_from_message(name, ns_ret); end

  # source://dnsruby//lib/dnsruby/single_verifier.rb#59
  def get_recursor; end

  # source://dnsruby//lib/dnsruby/single_verifier.rb#853
  def get_zone_key_from_dlv_rrset(dlv_rrset, name); end

  # source://dnsruby//lib/dnsruby/single_verifier.rb#895
  def query_dlv_for(name); end

  # source://dnsruby//lib/dnsruby/single_verifier.rb#137
  def remove_trust_anchor(t); end

  # source://dnsruby//lib/dnsruby/single_verifier.rb#55
  def set_hints(hints); end

  # source://dnsruby//lib/dnsruby/single_verifier.rb#145
  def trust_anchors; end

  # source://dnsruby//lib/dnsruby/single_verifier.rb#198
  def trusted_keys; end

  # source://dnsruby//lib/dnsruby/single_verifier.rb#1349
  def try_to_follow_from_anchor(closest_anchor, msg, qname); end

  # source://dnsruby//lib/dnsruby/single_verifier.rb#1286
  def validate(msg, query); end

  # source://dnsruby//lib/dnsruby/single_verifier.rb#1241
  def validate_no_rrsigs(msg); end

  # Verify the specified message (or RRSet) using the set of trusted keys.
  #  If keys is a DNSKEY, or an Array or RRSet of DNSKEYs, then keys
  #  is added to the set of trusted keys before the message (or RRSet) is
  #  verified.
  #
  #  If msg is a Dnsruby::Message, then any signed DNSKEY or DS RRSets are
  #  processed first, and any new keys are added to the trusted key set
  #  before the other RRSets are checked.
  #
  #  msg can be a Dnsruby::Message or Dnsruby::RRSet.
  #  keys may be nil, or a KeyCache or an RRSet of Dnsruby::RR::DNSKEY
  #
  #  Returns true if the message verifies OK, and false otherwise.
  #
  # source://dnsruby//lib/dnsruby/single_verifier.rb#249
  def verify(msg, keys = T.unsafe(nil)); end

  # source://dnsruby//lib/dnsruby/single_verifier.rb#576
  def verify_ds_rrset(ds_rrset, keys = T.unsafe(nil), msg = T.unsafe(nil)); end

  # source://dnsruby//lib/dnsruby/single_verifier.rb#618
  def verify_key_rrset(key_rrset, keys = T.unsafe(nil)); end

  # source://dnsruby//lib/dnsruby/single_verifier.rb#368
  def verify_nsecs(msg); end

  # Verify the signature of an rrset encoded with the specified KeyCache
  #  or RRSet. If no signature is included, false is returned.
  #
  #  Returns true if the RRSet verified, false otherwise.
  #
  # @raise [ArgumentError]
  #
  # source://dnsruby//lib/dnsruby/single_verifier.rb#701
  def verify_rrset(rrset, keys = T.unsafe(nil)); end
end

# source://dnsruby//lib/dnsruby/single_verifier.rb#24
class Dnsruby::SingleVerifier::VerifierType; end

# source://dnsruby//lib/dnsruby/single_verifier.rb#26
Dnsruby::SingleVerifier::VerifierType::ANCHOR = T.let(T.unsafe(nil), Integer)

# source://dnsruby//lib/dnsruby/single_verifier.rb#27
Dnsruby::SingleVerifier::VerifierType::DLV = T.let(T.unsafe(nil), Integer)

# source://dnsruby//lib/dnsruby/single_verifier.rb#25
Dnsruby::SingleVerifier::VerifierType::ROOT = T.let(T.unsafe(nil), Integer)

# Socket was closed by server before request was processed
#
# source://dnsruby//lib/dnsruby.rb#214
class Dnsruby::SocketEofResolvError < ::Dnsruby::ResolvError; end

# This class exists for backwards compatibility.
#
# It's Logger (which defaults to STDOUT, level FATAL) can be configured, or a new Logger can be supplied.
#
#  Dnsruby::TheLog.level=Logger::DEBUG
#  Dnsruby::TheLog.debug("Debug message")
#
# source://dnsruby//lib/dnsruby/the_log.rb#27
class Dnsruby::TheLog
  # source://dnsruby//lib/dnsruby/the_log.rb#36
  def level; end

  # Change the Logger level.
  #
  # source://dnsruby//lib/dnsruby/the_log.rb#33
  def level=(level); end

  # Set a new Logger for use by Dnsruby
  #
  # source://dnsruby//lib/dnsruby/the_log.rb#29
  def set_logger(logger); end

  class << self
    # source://dnsruby//lib/dnsruby/the_log.rb#40
    def method_missing(symbol, *args); end
  end
end

# An error occurred processing the TSIG
#
# source://dnsruby//lib/dnsruby.rb#218
class Dnsruby::TsigError < ::Dnsruby::OtherResolvError; end

# Sent a signed packet, got an unsigned response
#
# source://dnsruby//lib/dnsruby.rb#222
class Dnsruby::TsigNotSignedResponseError < ::Dnsruby::TsigError; end

# The RR types explicitly supported by Dnsruby.
#
#  New RR types should be added to this set
#
# source://dnsruby//lib/dnsruby/code_mappers.rb#112
class Dnsruby::Types < ::Dnsruby::CodeMapper
  # source://dnsruby//lib/dnsruby/code_mappers.rb#193
  def unknown_code(arg); end

  # source://dnsruby//lib/dnsruby/code_mappers.rb#184
  def unknown_string(arg); end

  class << self
    # --
    #  typesbyval and typesbyname functions are wrappers around the similarly named
    #  hashes. They are used for 'unknown' DNS RR types (RFC3597)
    #  typesbyname returns they TYPEcode as a function of the TYPE
    #  mnemonic. If the TYPE mapping is not specified the generic mnemonic
    #  TYPE### is returned.
    #
    # source://dnsruby//lib/dnsruby/code_mappers.rb#204
    def typesbyname(name); end

    # typesbyval returns they TYPE mnemonic as a function of the TYPE
    #  code. If the TYPE mapping is not specified the generic mnemonic
    #  TYPE### is returned.
    #
    # @raise [ArgumentError]
    #
    # source://dnsruby//lib/dnsruby/code_mappers.rb#228
    def typesbyval(val); end
  end
end

# RFC 1035, Section 3.4.1
#
# source://dnsruby//lib/dnsruby/code_mappers.rb#114
Dnsruby::Types::A = T.let(T.unsafe(nil), Integer)

# RFC 1886, Section 2.1
#
# source://dnsruby//lib/dnsruby/code_mappers.rb#141
Dnsruby::Types::AAAA = T.let(T.unsafe(nil), Integer)

# RFC 1183, Section 1
#
# source://dnsruby//lib/dnsruby/code_mappers.rb#131
Dnsruby::Types::AFSDB = T.let(T.unsafe(nil), Integer)

# RFC 1035
#
# source://dnsruby//lib/dnsruby/code_mappers.rb#178
Dnsruby::Types::ANY = T.let(T.unsafe(nil), Integer)

# RFC 3123
#
# source://dnsruby//lib/dnsruby/code_mappers.rb#153
Dnsruby::Types::APL = T.let(T.unsafe(nil), Integer)

# ???
#
# source://dnsruby//lib/dnsruby/code_mappers.rb#147
Dnsruby::Types::ATMA = T.let(T.unsafe(nil), Integer)

# RFC 1035
#
# source://dnsruby//lib/dnsruby/code_mappers.rb#175
Dnsruby::Types::AXFR = T.let(T.unsafe(nil), Integer)

# RFC 6844
#
# source://dnsruby//lib/dnsruby/code_mappers.rb#180
Dnsruby::Types::CAA = T.let(T.unsafe(nil), Integer)

# RFC 7344
#
# source://dnsruby//lib/dnsruby/code_mappers.rb#166
Dnsruby::Types::CDNSKEY = T.let(T.unsafe(nil), Integer)

# RFC 7344
#
# source://dnsruby//lib/dnsruby/code_mappers.rb#165
Dnsruby::Types::CDS = T.let(T.unsafe(nil), Integer)

# RFC 2538
#
# source://dnsruby//lib/dnsruby/code_mappers.rb#150
Dnsruby::Types::CERT = T.let(T.unsafe(nil), Integer)

# RFC 1035, Section 3.3.1
#
# source://dnsruby//lib/dnsruby/code_mappers.rb#118
Dnsruby::Types::CNAME = T.let(T.unsafe(nil), Integer)

# RFC 4701
#
# source://dnsruby//lib/dnsruby/code_mappers.rb#160
Dnsruby::Types::DHCID = T.let(T.unsafe(nil), Integer)

# RFC 4431 (informational)
#
# source://dnsruby//lib/dnsruby/code_mappers.rb#181
Dnsruby::Types::DLV = T.let(T.unsafe(nil), Integer)

# RFC 2672
#
# source://dnsruby//lib/dnsruby/code_mappers.rb#151
Dnsruby::Types::DNAME = T.let(T.unsafe(nil), Integer)

# RFC 4034
#
# source://dnsruby//lib/dnsruby/code_mappers.rb#159
Dnsruby::Types::DNSKEY = T.let(T.unsafe(nil), Integer)

# RFC 4034
#
# source://dnsruby//lib/dnsruby/code_mappers.rb#154
Dnsruby::Types::DS = T.let(T.unsafe(nil), Integer)

# draft-ietf-nimrod-dns-xx.txt
#
# source://dnsruby//lib/dnsruby/code_mappers.rb#144
Dnsruby::Types::EID = T.let(T.unsafe(nil), Integer)

# non-standard
#
# source://dnsruby//lib/dnsruby/code_mappers.rb#170
Dnsruby::Types::GID = T.let(T.unsafe(nil), Integer)

# RFC 1712 (obsolete)
#
# source://dnsruby//lib/dnsruby/code_mappers.rb#140
Dnsruby::Types::GPOS = T.let(T.unsafe(nil), Integer)

# RFC 1035, Section 3.3.2
#
# source://dnsruby//lib/dnsruby/code_mappers.rb#126
Dnsruby::Types::HINFO = T.let(T.unsafe(nil), Integer)

# RFC 5205
#
# source://dnsruby//lib/dnsruby/code_mappers.rb#164
Dnsruby::Types::HIP = T.let(T.unsafe(nil), Integer)

# RFC 4025
#
# source://dnsruby//lib/dnsruby/code_mappers.rb#156
Dnsruby::Types::IPSECKEY = T.let(T.unsafe(nil), Integer)

# RFC 1183, Section 3.2
#
# source://dnsruby//lib/dnsruby/code_mappers.rb#133
Dnsruby::Types::ISDN = T.let(T.unsafe(nil), Integer)

# RFC 1995
#
# source://dnsruby//lib/dnsruby/code_mappers.rb#174
Dnsruby::Types::IXFR = T.let(T.unsafe(nil), Integer)

# RFC 2535, Section 3.1
#
# source://dnsruby//lib/dnsruby/code_mappers.rb#138
Dnsruby::Types::KEY = T.let(T.unsafe(nil), Integer)

# RFC 2230
#
# source://dnsruby//lib/dnsruby/code_mappers.rb#149
Dnsruby::Types::KX = T.let(T.unsafe(nil), Integer)

# RFC 1876
#
# source://dnsruby//lib/dnsruby/code_mappers.rb#142
Dnsruby::Types::LOC = T.let(T.unsafe(nil), Integer)

# RFC 1035 (obsolete - see MX)
#
# source://dnsruby//lib/dnsruby/code_mappers.rb#177
Dnsruby::Types::MAILA = T.let(T.unsafe(nil), Integer)

# RFC 1035 (MB, MG, MR)
#
# source://dnsruby//lib/dnsruby/code_mappers.rb#176
Dnsruby::Types::MAILB = T.let(T.unsafe(nil), Integer)

# RFC 1035, Section 3.3.3
#
# source://dnsruby//lib/dnsruby/code_mappers.rb#120
Dnsruby::Types::MB = T.let(T.unsafe(nil), Integer)

# RFC 1035, Section 3.3.4 (obsolete)
#
# source://dnsruby//lib/dnsruby/code_mappers.rb#116
Dnsruby::Types::MD = T.let(T.unsafe(nil), Integer)

# RFC 1035, Section 3.3.5 (obsolete)
#
# source://dnsruby//lib/dnsruby/code_mappers.rb#117
Dnsruby::Types::MF = T.let(T.unsafe(nil), Integer)

# RFC 1035, Section 3.3.6
#
# source://dnsruby//lib/dnsruby/code_mappers.rb#121
Dnsruby::Types::MG = T.let(T.unsafe(nil), Integer)

# RFC 1035, Section 3.3.7
#
# source://dnsruby//lib/dnsruby/code_mappers.rb#127
Dnsruby::Types::MINFO = T.let(T.unsafe(nil), Integer)

# RFC 1035, Section 3.3.8
#
# source://dnsruby//lib/dnsruby/code_mappers.rb#122
Dnsruby::Types::MR = T.let(T.unsafe(nil), Integer)

# RFC 1035, Section 3.3.9
#
# source://dnsruby//lib/dnsruby/code_mappers.rb#128
Dnsruby::Types::MX = T.let(T.unsafe(nil), Integer)

# RFC 2168
#
# source://dnsruby//lib/dnsruby/code_mappers.rb#148
Dnsruby::Types::NAPTR = T.let(T.unsafe(nil), Integer)

# draft-ietf-nimrod-dns-xx.txt
#
# source://dnsruby//lib/dnsruby/code_mappers.rb#145
Dnsruby::Types::NIMLOC = T.let(T.unsafe(nil), Integer)

# RFC 1035, Section 3.3.11
#
# source://dnsruby//lib/dnsruby/code_mappers.rb#115
Dnsruby::Types::NS = T.let(T.unsafe(nil), Integer)

# RFC 1706, Section 5
#
# source://dnsruby//lib/dnsruby/code_mappers.rb#135
Dnsruby::Types::NSAP = T.let(T.unsafe(nil), Integer)

# RFC 1348 (obsolete)
#
# source://dnsruby//lib/dnsruby/code_mappers.rb#136
Dnsruby::Types::NSAP_PTR = T.let(T.unsafe(nil), Integer)

# RFC 4034
#
# source://dnsruby//lib/dnsruby/code_mappers.rb#158
Dnsruby::Types::NSEC = T.let(T.unsafe(nil), Integer)

# RFC still pending at time of writing
#
# source://dnsruby//lib/dnsruby/code_mappers.rb#161
Dnsruby::Types::NSEC3 = T.let(T.unsafe(nil), Integer)

# RFC still pending at time of writing
#
# source://dnsruby//lib/dnsruby/code_mappers.rb#162
Dnsruby::Types::NSEC3PARAM = T.let(T.unsafe(nil), Integer)

# RFC 1035, Section 3.3.10
#
# source://dnsruby//lib/dnsruby/code_mappers.rb#123
Dnsruby::Types::NULL = T.let(T.unsafe(nil), Integer)

# RFC 2535, Section 5.2 obsoleted by RFC3755
#
# source://dnsruby//lib/dnsruby/code_mappers.rb#143
Dnsruby::Types::NXT = T.let(T.unsafe(nil), Integer)

# RFC 2671
#
# source://dnsruby//lib/dnsruby/code_mappers.rb#152
Dnsruby::Types::OPT = T.let(T.unsafe(nil), Integer)

# RFC 1035, Section 3.3.12
#
# source://dnsruby//lib/dnsruby/code_mappers.rb#125
Dnsruby::Types::PTR = T.let(T.unsafe(nil), Integer)

# RFC 2163,
#
# source://dnsruby//lib/dnsruby/code_mappers.rb#139
Dnsruby::Types::PX = T.let(T.unsafe(nil), Integer)

# RFC 1183, Section 2.2
#
# source://dnsruby//lib/dnsruby/code_mappers.rb#130
Dnsruby::Types::RP = T.let(T.unsafe(nil), Integer)

# RFC 4034
#
# source://dnsruby//lib/dnsruby/code_mappers.rb#157
Dnsruby::Types::RRSIG = T.let(T.unsafe(nil), Integer)

# RFC 1183, Section 3.3
#
# source://dnsruby//lib/dnsruby/code_mappers.rb#134
Dnsruby::Types::RT = T.let(T.unsafe(nil), Integer)

# RFC 2535, Section 4.1
#
# source://dnsruby//lib/dnsruby/code_mappers.rb#137
Dnsruby::Types::SIG = T.let(T.unsafe(nil), Integer)

# RFC2931 consider this a pseudo type
#
# source://dnsruby//lib/dnsruby/code_mappers.rb#113
Dnsruby::Types::SIGZERO = T.let(T.unsafe(nil), Integer)

# RFC 1035, Section 3.3.13
#
# source://dnsruby//lib/dnsruby/code_mappers.rb#119
Dnsruby::Types::SOA = T.let(T.unsafe(nil), Integer)

# RFC 4408
#
# source://dnsruby//lib/dnsruby/code_mappers.rb#167
Dnsruby::Types::SPF = T.let(T.unsafe(nil), Integer)

# RFC 2052
#
# source://dnsruby//lib/dnsruby/code_mappers.rb#146
Dnsruby::Types::SRV = T.let(T.unsafe(nil), Integer)

# RFC 4255
#
# source://dnsruby//lib/dnsruby/code_mappers.rb#155
Dnsruby::Types::SSHFP = T.let(T.unsafe(nil), Integer)

# RFC 2930
#
# source://dnsruby//lib/dnsruby/code_mappers.rb#172
Dnsruby::Types::TKEY = T.let(T.unsafe(nil), Integer)

# RFC 6698
#
# source://dnsruby//lib/dnsruby/code_mappers.rb#163
Dnsruby::Types::TLSA = T.let(T.unsafe(nil), Integer)

# RFC 2931
#
# source://dnsruby//lib/dnsruby/code_mappers.rb#173
Dnsruby::Types::TSIG = T.let(T.unsafe(nil), Integer)

# RFC 1035, Section 3.3.14
#
# source://dnsruby//lib/dnsruby/code_mappers.rb#129
Dnsruby::Types::TXT = T.let(T.unsafe(nil), Integer)

# non-standard
#
# source://dnsruby//lib/dnsruby/code_mappers.rb#169
Dnsruby::Types::UID = T.let(T.unsafe(nil), Integer)

# non-standard
#
# source://dnsruby//lib/dnsruby/code_mappers.rb#168
Dnsruby::Types::UINFO = T.let(T.unsafe(nil), Integer)

# non-standard
#
# source://dnsruby//lib/dnsruby/code_mappers.rb#171
Dnsruby::Types::UNSPEC = T.let(T.unsafe(nil), Integer)

# RFC 7553
#
# source://dnsruby//lib/dnsruby/code_mappers.rb#179
Dnsruby::Types::URI = T.let(T.unsafe(nil), Integer)

# RFC 1035, Section 3.4.2 (deprecated)
#
# source://dnsruby//lib/dnsruby/code_mappers.rb#124
Dnsruby::Types::WKS = T.let(T.unsafe(nil), Integer)

# RFC 1183, Section 3.1
#
# source://dnsruby//lib/dnsruby/code_mappers.rb#132
Dnsruby::Types::X25 = T.let(T.unsafe(nil), Integer)

# The first example below shows a complete program; subsequent examples
# show only the creation of the update packet.
#
# == Add a new host
#
#  require 'Dnsruby'
#
#  # Create the update packet.
#  update = Dnsruby::Update.new('example.com')
#
#  # Prerequisite is that no A records exist for the name.
#  update.absent('foo.example.com.', 'A')
#
#  # Add two A records for the name.
#  update.add('foo.example.com.', 'A', 86400, '192.168.1.2')
#  update.add('foo.example.com.', 'A', 86400, '172.16.3.4')
#
#  # Send the update to the zone's primary master.
#  res = Dnsruby::Resolver.new({:nameserver => 'primary-master.example.com'})
#
#  begin
#      reply = res.send_message(update)
#      print "Update succeeded\n"
#   rescue Exception => e
#      print 'Update failed: #{e}\n'
#   end
#
# == Add an MX record for a name that already exists
#
#     update = Dnsruby::Update.new('example.com')
#     update.present('example.com')
#     update.add('example.com', Dnsruby::Types.MX, 86400, 10, 'mailhost.example.com')
#
# == Add a TXT record for a name that doesn't exist
#
#     update = Dnsruby::Update.new('example.com')
#     update.absent('info.example.com')
#     update.add('info.example.com', Types.TXT, 86400, "yabba dabba doo"')
#
# == Delete all A records for a name
#
#     update = Dnsruby::Update.new('example.com')
#     update.present('foo.example.com', 'A')
#     update.delete('foo.example.com', 'A')
#
# == Delete all RRs for a name
#
#     update = Dnsruby::Update.new('example.com')
#     update.present('byebye.example.com')
#     update.delete('byebye.example.com')
#
# == Perform a signed update
#
#     key_name = 'tsig-key'
#     key      = 'awwLOtRfpGE+rRKF2+DEiw=='
#
#     update = Dnsruby::Update.new('example.com')
#     update.add('foo.example.com', 'A', 86400, '10.1.2.3'))
#     update.add('bar.example.com', 'A', 86400, '10.4.5.6'))
#     res.tsig=(key_name,key)
#
# source://dnsruby//lib/dnsruby/update.rb#82
class Dnsruby::Update < ::Dnsruby::Message
  # Returns a Dnsruby::Update object suitable for performing a DNS
  # dynamic update.  Specifically, it creates a message with the header
  # opcode set to UPDATE and the zone record type to SOA (per RFC 2136,
  # Section 2.3).
  #
  # Programs must use the push method to add RRs to the prerequisite,
  # update, and additional sections before performing the update.
  #
  # Arguments are the zone name and the class.  If the zone is omitted,
  # the default domain will be taken from the resolver configuration.
  # If the class is omitted, it defaults to IN.
  #     packet = Dnsruby::Update.new
  #     packet = Dnsruby::Update.new('example.com')
  #     packet = Dnsruby::Update.new('example.com', 'HS')
  #
  # @return [Update] a new instance of Update
  #
  # source://dnsruby//lib/dnsruby/update.rb#98
  def initialize(zone = T.unsafe(nil), klass = T.unsafe(nil)); end

  # Ways to create the prerequisite records (exists, notexists, inuse, etc. - RFC2136, section 2.4)
  # Can be called with one arg :
  #
  #    update.absent(name)
  #       (5)  Name is not in use.  No RR of any type is owned by a
  #            specified NAME.  Note that this prerequisite IS satisfied by
  #            empty nonterminals.
  #
  # Or with two :
  #
  #    update.absent(name, type)
  #       (3)  RRset does not exist.  No RRs with a specified NAME and TYPE
  #           (in the zone and class denoted by the Zone Section) can exist.
  #
  # source://dnsruby//lib/dnsruby/update.rb#174
  def absent(*args); end

  # Ways to create the update records (add, delete, RFC2136, section 2.5)
  #   " 2.5.1 - Add To An RRset
  #
  #    RRs are added to the Update Section whose NAME, TYPE, TTL, RDLENGTH
  #    and RDATA are those being added, and CLASS is the same as the zone
  #    class.  Any duplicate RRs will be silently ignored by the primary
  #    master."
  #
  #    update.add(rr)
  #    update.add([rr1, rr2])
  #    update.add(name, type, ttl, rdata)
  #
  # source://dnsruby//lib/dnsruby/update.rb#204
  def add(*args); end

  # Ways to create the update records (add, delete, RFC2136, section 2.5)
  #
  # 2.5.2 - Delete An RRset
  #    update.delete(name, type)
  #
  #
  # 2.5.3 - Delete All RRsets From A Name
  #    update.delete(name)
  #
  # 2.5.4 - Delete An RR From An RRset
  #   update.delete(name, type, rdata)
  #
  # source://dnsruby//lib/dnsruby/update.rb#258
  def delete(*args); end

  # Ways to create the prerequisite records (exists, notexists, inuse, etc. - RFC2136, section 2.4)
  #
  #       (1)  RRset exists (value independent).  At least one RR with a
  #            specified NAME and TYPE (in the zone and class specified by
  #            the Zone Section) must exist.
  #
  #            update.present(name, type)
  #
  #       (2)  RRset exists (value dependent).  A set of RRs with a
  #            specified NAME and TYPE exists and has the same members
  #            with the same RDATAs as the RRset specified here in this
  #            Section.
  #
  #            update.present(name, type, rdata)
  #
  #       (4)  Name is in use.  At least one RR with a specified NAME (in
  #            the zone and class specified by the Zone Section) must exist.
  #            Note that this prerequisite is NOT satisfied by empty
  #            nonterminals.
  #
  #            update.present(name)
  #
  # source://dnsruby//lib/dnsruby/update.rb#138
  def present(*args); end
end

# source://dnsruby//lib/dnsruby/version.rb#2
Dnsruby::VERSION = T.let(T.unsafe(nil), String)

# Takes care of the validation for the SelectThread. If queries need to be
#  made in order to validate the response, then a separate thread is fired up
#  to do this.
#
# source://dnsruby//lib/dnsruby/validator_thread.rb#21
class Dnsruby::ValidatorThread
  # include Singleton
  #
  # @return [ValidatorThread] a new instance of ValidatorThread
  #
  # source://dnsruby//lib/dnsruby/validator_thread.rb#23
  def initialize(*args); end

  # source://dnsruby//lib/dnsruby/validator_thread.rb#120
  def cache_if_valid(query, response); end

  # def add_to_queue(item)
  #       print "ADding to validator queue\n"
  # #      @@mutex.synchronize{
  #         @@validation_queue.push(item)
  # #      }
  #     end
  #
  # source://dnsruby//lib/dnsruby/validator_thread.rb#51
  def do_validate; end

  # Create the validation thread, and a queue to receive validation requests
  #  Actually, need to have a thread per validator, as they make recursive calls.
  #       @@mutex = Mutex.new
  #       @@validation_queue = Queue.new
  #       @@validator_thread = Thread.new{
  #         do_validate
  #       }
  #
  # source://dnsruby//lib/dnsruby/validator_thread.rb#33
  def run; end

  # source://dnsruby//lib/dnsruby/validator_thread.rb#80
  def should_validate; end

  # source://dnsruby//lib/dnsruby/validator_thread.rb#97
  def validate(query, response, res); end

  class << self
    # @return [Boolean]
    #
    # source://dnsruby//lib/dnsruby/validator_thread.rb#84
    def requires_validation?(query, response, error, res); end
  end
end

# Indicates an error verifying
#
# source://dnsruby//lib/dnsruby.rb#235
class Dnsruby::VerifyError < ::Dnsruby::ResolvError; end

# Some name that ought to exist, does not exist (in dynamic update)
#
# source://dnsruby//lib/dnsruby.rb#193
class Dnsruby::YXDomain < ::Dnsruby::ResolvError; end

# Some RRSet that ought to exist, does not exist (in dynamic update)
#
# source://dnsruby//lib/dnsruby.rb#197
class Dnsruby::YXRRSet < ::Dnsruby::ResolvError; end

# source://dnsruby//lib/dnsruby/zone_reader.rb#21
class Dnsruby::ZoneReader
  # Create a new ZoneReader. The zone origin is required. If the desired SOA minimum
  #  and TTL are passed in, then they are used as default values.
  #
  # @return [ZoneReader] a new instance of ZoneReader
  #
  # source://dnsruby//lib/dnsruby/zone_reader.rb#27
  def initialize(origin, soa_minimum = T.unsafe(nil), soa_ttl = T.unsafe(nil)); end

  # Get the TTL in seconds from the m, h, d, w format
  #
  # source://dnsruby//lib/dnsruby/zone_reader.rb#397
  def get_ttl(ttl_text_in); end

  # Take a line from the input zone file, and return the normalised form
  #  do_prefix_hack should always be false
  #
  # source://dnsruby//lib/dnsruby/zone_reader.rb#211
  def normalise_line(line, do_prefix_hack = T.unsafe(nil)); end

  # This method is included only for OpenDNSSEC support. It should not be
  #  used otherwise.
  #  Frig the RR type so that NSEC records appear last in the RRSets.
  #  Also make sure that DNSKEYs come first (so we have a key to verify
  #  the RRSet with!).
  #
  # source://dnsruby//lib/dnsruby/zone_reader.rb#448
  def prefix_for_rrset_order(type, type_was); end

  # Takes a filename string, or any type of IO object, and attempts to load a zone.
  #  Returns a list of RRs if successful, nil otherwise.
  #
  # source://dnsruby//lib/dnsruby/zone_reader.rb#47
  def process_file(source); end

  # Iterate over each line in a IO object, and process it.
  #  Returns a list of RRs if successful, nil otherwise.
  #
  # source://dnsruby//lib/dnsruby/zone_reader.rb#59
  def process_io(io); end

  # Process the next line of the file
  #  Returns a string representing the normalised line.
  #
  # source://dnsruby//lib/dnsruby/zone_reader.rb#80
  def process_line(line, do_prefix_hack = T.unsafe(nil)); end

  # source://dnsruby//lib/dnsruby/zone_reader.rb#199
  def process_quotes(section); end

  # source://dnsruby//lib/dnsruby/zone_reader.rb#432
  def replace_soa_ttl_fields(line); end

  # source://dnsruby//lib/dnsruby/zone_reader.rb#131
  def strip_comments(line); end

  # source://dnsruby//lib/dnsruby/zone_reader.rb#158
  def strip_comments_meticulously(line); end
end

# source://dnsruby//lib/dnsruby/zone_reader.rb#22
class Dnsruby::ZoneReader::ParseException < ::Exception; end

# Indicates a zone transfer has failed due to SOA serial mismatch
#
# source://dnsruby//lib/dnsruby.rb#239
class Dnsruby::ZoneSerialError < ::Dnsruby::ResolvError; end

# This class performs zone transfers as per RFC1034 (AXFR) and RFC1995 (IXFR).
#
# source://dnsruby//lib/dnsruby/zone_transfer.rb#19
class Dnsruby::ZoneTransfer
  # @return [ZoneTransfer] a new instance of ZoneTransfer
  #
  # source://dnsruby//lib/dnsruby/zone_transfer.rb#50
  def initialize; end

  # Compare two serials according to RFC 1982. Return 0 if equal,
  # -1 if s1 is bigger, 1 if s1 is smaller.
  #
  # source://dnsruby//lib/dnsruby/zone_transfer.rb#227
  def compare_serial(s1, s2); end

  # Sets the connect timeout in seconds
  #
  # source://dnsruby//lib/dnsruby/zone_transfer.rb#37
  def connect_timeout; end

  # Sets the connect timeout in seconds
  #
  # source://dnsruby//lib/dnsruby/zone_transfer.rb#37
  def connect_timeout=(_arg0); end

  # source://dnsruby//lib/dnsruby/zone_transfer.rb#110
  def do_transfer(zone, server); end

  # The class - defaults to IN
  #
  # source://dnsruby//lib/dnsruby/zone_transfer.rb#25
  def klass; end

  # The class - defaults to IN
  #
  # source://dnsruby//lib/dnsruby/zone_transfer.rb#25
  def klass=(_arg0); end

  # Returns the tsigstate of the last transfer (nil if no TSIG signed transfer has occurred)
  #
  # source://dnsruby//lib/dnsruby/zone_transfer.rb#35
  def last_tsigstate; end

  # source://dnsruby//lib/dnsruby/zone_transfer.rb#246
  def parseRR(rec); end

  # The port to connect to - defaults to 53
  #
  # source://dnsruby//lib/dnsruby/zone_transfer.rb#27
  def port; end

  # The port to connect to - defaults to 53
  #
  # source://dnsruby//lib/dnsruby/zone_transfer.rb#27
  def port=(_arg0); end

  # @raise [ResolvError]
  #
  # source://dnsruby//lib/dnsruby/zone_transfer.rb#368
  def receive_message(socket); end

  # source://dnsruby//lib/dnsruby/zone_transfer.rb#349
  def send_message(socket, msg); end

  # If using IXFR, this is the SOA serial number to start the incrementals from
  #
  # source://dnsruby//lib/dnsruby/zone_transfer.rb#29
  def serial; end

  # If using IXFR, this is the SOA serial number to start the incrementals from
  #
  # source://dnsruby//lib/dnsruby/zone_transfer.rb#29
  def serial=(_arg0); end

  # The nameserver to use for the zone transfer - defaults to system config
  #
  # source://dnsruby//lib/dnsruby/zone_transfer.rb#21
  def server; end

  # The nameserver to use for the zone transfer - defaults to system config
  #
  # source://dnsruby//lib/dnsruby/zone_transfer.rb#21
  def server=(_arg0); end

  # The source address to connect to
  #
  # source://dnsruby//lib/dnsruby/zone_transfer.rb#31
  def src_address; end

  # The source address to connect to
  #
  # source://dnsruby//lib/dnsruby/zone_transfer.rb#31
  def src_address=(_arg0); end

  # source://dnsruby//lib/dnsruby/zone_transfer.rb#360
  def tcp_read(socket, len); end

  # Perform a zone transfer (RFC1995)
  #  If an IXFR query is unsuccessful, then AXFR is tried (and @transfer_type is set
  #  to AXFR)
  #  TCP is used as the only transport
  #
  #  If AXFR is performed, then the zone will be returned as a set of records :
  #
  #        zt = Dnsruby::ZoneTransfer.new
  #        zt.transfer_type = Dnsruby::Types.AXFR
  #        zt.server = "ns0.validation-test-servers.nominet.org.uk"
  #        zone = zt.transfer("validation-test-servers.nominet.org.uk")
  #        soa = zone[0]
  #        rec1 = zone[1]
  #        print zone.to_s
  #
  #
  #  If IXFR is performed, then the incrementals will be returned as a set of Deltas.
  #  Each Delta contains the start and end SOA serial number, as well as an array of
  #  adds and deletes that occurred between the start and end.
  #
  #         zt = Dnsruby::ZoneTransfer.new
  #         zt.transfer_type = Dnsruby::Types.IXFR
  #         zt.server = "ns0.validation-test-servers.nominet.org.uk"
  #         zt.serial = 2007090401
  #         deltas = zt.transfer("validation-test-servers.nominet.org.uk")
  #         assert_equal("Should show up in transfer", deltas[0].adds[1].data)
  #
  # source://dnsruby//lib/dnsruby/zone_transfer.rb#88
  def transfer(zone); end

  # What type of transfer to do (IXFR or AXFR) - defaults to AXFR
  #
  # source://dnsruby//lib/dnsruby/zone_transfer.rb#23
  def transfer_type; end

  # What type of transfer to do (IXFR or AXFR) - defaults to AXFR
  #
  # source://dnsruby//lib/dnsruby/zone_transfer.rb#23
  def transfer_type=(_arg0); end

  # The TSIG record used to sign the transfer
  #
  # source://dnsruby//lib/dnsruby/zone_transfer.rb#33
  def tsig; end

  # Sets the TSIG to sign the zone transfer with.
  # Pass in either a Dnsruby::RR::TSIG, or a key_name and key (or just a key)
  # Pass in nil to stop tsig signing.
  # * res.tsig=(tsig_rr)
  # * res.tsig=(key_name, key)
  # * res.tsig=nil # Don't sign the transfer
  #
  # source://dnsruby//lib/dnsruby/zone_transfer.rb#45
  def tsig=(*args); end
end

# All changes between two versions of a zone in an IXFR response.
#
# source://dnsruby//lib/dnsruby/zone_transfer.rb#200
class Dnsruby::ZoneTransfer::Delta
  # @return [Delta] a new instance of Delta
  #
  # source://dnsruby//lib/dnsruby/zone_transfer.rb#214
  def initialize; end

  # A list of records added between the start and end versions
  #
  # source://dnsruby//lib/dnsruby/zone_transfer.rb#209
  def adds; end

  # A list of records added between the start and end versions
  #
  # source://dnsruby//lib/dnsruby/zone_transfer.rb#209
  def adds=(_arg0); end

  # A list of records deleted between the start and end versions
  #
  # source://dnsruby//lib/dnsruby/zone_transfer.rb#212
  def deletes; end

  # A list of records deleted between the start and end versions
  #
  # source://dnsruby//lib/dnsruby/zone_transfer.rb#212
  def deletes=(_arg0); end

  # The ending serial number of this delta.
  #
  # source://dnsruby//lib/dnsruby/zone_transfer.rb#206
  def end; end

  # The ending serial number of this delta.
  #
  # source://dnsruby//lib/dnsruby/zone_transfer.rb#206
  def end=(_arg0); end

  # The starting serial number of this delta.
  #
  # source://dnsruby//lib/dnsruby/zone_transfer.rb#203
  def start; end

  # The starting serial number of this delta.
  #
  # source://dnsruby//lib/dnsruby/zone_transfer.rb#203
  def start=(_arg0); end

  # source://dnsruby//lib/dnsruby/zone_transfer.rb#219
  def to_s; end
end
