{"version":3,"file":"chunk-ui_packages_updatable-content-element_updatable-content-element_ts-xxxxxxxxxxxx.js","mappings":"uNAEO,kCAAMA,wBASXC,QAAQC,CAAmB,CAAEC,CAAkB,CAAEC,CAAqC,CAAE,CACtF,IAAIC,EAAS,IAAI,CAACC,SAAS,CAACH,EAAW,CAElCE,GACHA,CAAAA,EAAS,IAAI,CAACC,SAAS,CAACH,EAAW,CAAG,CACpCI,SAAU,KACVC,QAAS,IAAIC,GACf,GAGFJ,EAAOG,OAAO,CAACE,GAAG,CAACR,GAGfG,EAAOE,QAAQ,EAKnBF,CAAAA,EAAOE,QAAQ,CAAGI,YAHP,IAAM,IAAI,CAACC,UAAU,CAACT,EAAYC,GAGXD,EAAU,CAC9C,C,mBA3BAG,SAAS,CAKL,CAAC,E,KAyBLM,UAAU,CAAG,CAACT,EAAoBC,KAEhC,IAAMC,EAAS,IAAI,CAACC,SAAS,CAACH,EAAW,CAEzC,GAAI,CAACE,EAAQ,OAEb,IAAMG,EAAUH,EAAOG,OAAO,CAE9B,GAAIA,IAAAA,EAAQK,IAAI,EAMhB,IAAK,IAAMX,KAHXG,EAAOG,OAAO,CAAG,IAAIC,IAGAD,GAEfM,SAASC,IAAI,CAACC,QAAQ,CAACd,IACzBE,EAAgBF,GAKpBM,EAAQS,KAAK,GACf,E,KAGAA,KAAK,CAAG,KACN,IAAK,IAAMC,KAAO,IAAI,CAACZ,SAAS,CAC9B,GAAIa,OAAOC,SAAS,CAACC,cAAc,CAACC,IAAI,CAAC,IAAI,CAAChB,SAAS,CAAEY,GAAM,CAC7D,IAAMb,EAAS,IAAI,CAACC,SAAS,CAACY,EAAI,CAC9Bb,IAEEA,EAAOE,QAAQ,GACjBgB,cAAclB,EAAOE,QAAQ,EAC7BF,EAAOE,QAAQ,CAAG,MAGpBF,EAAOG,OAAO,CAACS,KAAK,GAExB,CAEJ,C,CACF,ECpEA,IAAMO,EAAU,IAAIxB,wBAIb,SAASyB,EAAyBrB,EAAwCsB,EAAAA,EAAa,EAC5F,OAAO,SAA6BC,CAAY,EAC9C,GAAM,CAACC,IAAAA,CAAG,CAAEC,KAAAA,CAAI,CAAEC,cAAAA,CAAa,CAAC,CAAG,EAAuBC,MAAM,CAACC,IAAI,CAC/DC,EAAYN,EAAMzB,MAAM,CACxBA,EAAS0B,EAAMM,SA2BNC,CAAiB,CAAEP,CAAW,EAC/C,GAAIO,EAAKC,YAAY,CAAC,cAAgBR,EAAK,OAAOO,EAClD,IAAK,IAAME,KAAMF,EAAKG,gBAAgB,CAAc,wBAClD,GAAID,EAAGD,YAAY,CAAC,cAAgBR,EAClC,OAAOS,EAGX,OAAO,IACT,EAnCmCJ,EAAWL,GAAOK,EAMjD,GAAI/B,EAAQ,CACV,IAAMqC,EAAUrC,EAAOkC,YAAY,CAAC,gBAE9BI,EAAYtC,EAAOkC,YAAY,CAAC,2BACtC,GAAII,GAEEV,CAAAA,KAAkBW,IAAlBX,GAA+B,CAACA,EAAcT,cAAc,CAACmB,EAAS,EACxE,OAIJ,GAAID,EAAS,CACX,IAAMpC,EAAauC,KAAKC,GAAG,CAACC,SAASL,IAAY,EA5BhC,KA6BjBf,EAAQvB,OAAO,CAACC,EAAQC,EAAYC,EACtC,MACEyC,WAAWzC,EAAiByB,GAAQ,EAAG3B,EAE3C,CACF,CACF,CA/BA4C,EAAAA,EAAaA,EAAEC,iBAAiBC,EAAAA,CAAcA,CAACC,GAAG,CAAEzB,EAAQP,KAAK,C,mCCT1D,IAAM+B,EAAiB7B,OAAO+B,MAAM,CAAC,CAC1CC,QAAS,mBACTC,MAAO,iBACPC,QAAS,mBACTC,MAAO,iBACPC,aAAc,wBACdN,IAAK,eACLO,OAAQ,kBACRC,aAAc,CACZL,MAAO,8BACPH,IAAK,2BACP,CACF,E,qGCTA,IAAMS,EAAsBjC,CAAAA,EAAAA,E,OAAAA,CAAAA,IAGrB,kCAAMkC,gCAAgCC,YAC3CC,mBAAoB,CAClB,IAAI,CAACd,gBAAgB,CAAC,iBAAkBW,EAC1C,CAEAI,sBAAuB,CACrB,IAAI,CAACC,mBAAmB,CAAC,iBAAkBL,EAC7C,CACF,EARaC,wBAAAA,S,2TAAAA,CADZK,EAAAA,EAAUA,C,CACEL,wB","sources":["ui/packages/alive-socket-channel/updatable-content-batcher.ts","ui/packages/alive-socket-channel/alive-socket-channel.ts","ui/packages/soft-nav/states.ts","ui/packages/updatable-content-element/updatable-content-element.ts"],"sourcesContent":["import type {updateContent} from '@github-ui/updatable-content'\n\nexport class BatchedUpdatableContent {\n  intervals: {\n    [key: number]: {\n      interval: NodeJS.Timer | null\n      targets: Set<HTMLElement>\n    }\n  } = {}\n\n  // Append each websocket update to the batch.\n  onEvent(target: HTMLElement, windowSize: number, updaterFunction: typeof updateContent) {\n    let config = this.intervals[windowSize]\n\n    if (!config) {\n      config = this.intervals[windowSize] = {\n        interval: null,\n        targets: new Set(),\n      }\n    }\n\n    config.targets.add(target)\n\n    // Early return if we've already started.\n    if (config.interval) return\n\n    const fn = () => this.onInterval(windowSize, updaterFunction)\n\n    // Start the interval loop if it hasn't been started yet.\n    config.interval = setInterval(fn, windowSize)\n  }\n\n  // Function run on the interval run.\n  onInterval = (windowSize: number, updaterFunction: typeof updateContent) => {\n    // Move the reference.\n    const config = this.intervals[windowSize]\n\n    if (!config) return\n\n    const targets = config.targets\n\n    if (targets.size === 0) return\n\n    // Clear the set so new messages can be batched up for the next iteration.\n    config.targets = new Set()\n\n    // Dispatch all queued updates.\n    for (const target of targets) {\n      // Only execute if we're attached to the DOM.\n      if (document.body.contains(target)) {\n        updaterFunction(target)\n      }\n    }\n\n    // Clear references.\n    targets.clear()\n  }\n\n  // Clear the buffer so that intervals are not run after turbolinks navigations.\n  clear = () => {\n    for (const key in this.intervals) {\n      if (Object.prototype.hasOwnProperty.call(this.intervals, key)) {\n        const config = this.intervals[key]\n        if (config) {\n          // Stop the interval.\n          if (config.interval) {\n            clearInterval(config.interval)\n            config.interval = null\n          }\n\n          config.targets.clear()\n        }\n      }\n    }\n  }\n}\n","import {updateContent} from '@github-ui/updatable-content'\nimport {ssrSafeWindow} from '@github-ui/ssr-utils'\nimport {SOFT_NAV_STATE} from '@github-ui/soft-nav/states'\nimport {BatchedUpdatableContent} from './updatable-content-batcher'\n\nconst MINIMUM_INTERVAL = 1000\n\nconst batcher = new BatchedUpdatableContent()\n\nssrSafeWindow?.addEventListener(SOFT_NAV_STATE.END, batcher.clear)\n\nexport function makeSocketMessageHandler(updaterFunction: typeof updateContent = updateContent) {\n  return function handleSocketMessage(event: Event) {\n    const {gid, wait, event_updates} = (event as CustomEvent).detail.data\n    const container = event.target as HTMLElement\n    const target = gid ? findByGid(container, gid) : container\n\n    /**\n     * TODO: Ideally we'd have a better unique identifier to use to enable better scheduling. We'd have to introduce\n     * a DOM attribute to give a unique identifier.\n     */\n    if (target) {\n      const batched = target.getAttribute('data-batched')\n\n      const eventName = target.getAttribute('data-channel-event-name')\n      if (eventName) {\n        // If the event name is not in the event updates, we don't need to update the content.\n        if (event_updates === undefined || !event_updates.hasOwnProperty(eventName)) {\n          return\n        }\n      }\n\n      if (batched) {\n        const windowSize = Math.max(parseInt(batched) || 0, MINIMUM_INTERVAL)\n        batcher.onEvent(target, windowSize, updaterFunction)\n      } else {\n        setTimeout(updaterFunction, wait || 0, target)\n      }\n    }\n  }\n}\n\nfunction findByGid(root: HTMLElement, gid: string): HTMLElement | null {\n  if (root.getAttribute('data-gid') === gid) return root\n  for (const el of root.querySelectorAll<HTMLElement>(`[data-url][data-gid]`)) {\n    if (el.getAttribute('data-gid') === gid) {\n      return el\n    }\n  }\n  return null\n}\n","export const SOFT_NAV_STATE = Object.freeze({\n  INITIAL: 'soft-nav:initial',\n  START: 'soft-nav:start',\n  SUCCESS: 'soft-nav:success',\n  ERROR: 'soft-nav:error',\n  FRAME_UPDATE: 'soft-nav:frame-update',\n  END: 'soft-nav:end',\n  RENDER: 'soft-nav:render',\n  PROGRESS_BAR: {\n    START: 'soft-nav:progress-bar:start',\n    END: 'soft-nav:progress-bar:end',\n  },\n})\n","import {controller} from '@github/catalyst'\nimport {makeSocketMessageHandler} from '@github-ui/alive-socket-channel'\n\nconst handleSocketMessage = makeSocketMessageHandler()\n\n@controller\nexport class UpdatableContentElement extends HTMLElement {\n  connectedCallback() {\n    this.addEventListener('socket:message', handleSocketMessage)\n  }\n\n  disconnectedCallback() {\n    this.removeEventListener('socket:message', handleSocketMessage)\n  }\n}\n"],"names":["BatchedUpdatableContent","onEvent","target","windowSize","updaterFunction","config","intervals","interval","targets","Set","add","setInterval","onInterval","size","document","body","contains","clear","key","Object","prototype","hasOwnProperty","call","clearInterval","batcher","makeSocketMessageHandler","updateContent","event","gid","wait","event_updates","detail","data","container","findByGid","root","getAttribute","el","querySelectorAll","batched","eventName","undefined","Math","max","parseInt","setTimeout","ssrSafeWindow","addEventListener","SOFT_NAV_STATE","END","freeze","INITIAL","START","SUCCESS","ERROR","FRAME_UPDATE","RENDER","PROGRESS_BAR","handleSocketMessage","UpdatableContentElement","HTMLElement","connectedCallback","disconnectedCallback","removeEventListener","controller"],"sourceRoot":""}