{"version":3,"file":"chunk-app_components_search_parsing_parsing_ts-xxxxxxxxxxxx.js","mappings":"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","sources":["app/components/search/parsing/parsing.ts"],"sourcesContent":["////////////////////////////////////////////////////////////////////////////////\n// IT IS IMPORTANT NOT TO DIRECTLY IMPORT THIS FILE, or @github/blackbird-parser\n// Because the parsing code is kind of large, and search-input-element is on\n// every page, we only want to load the parsing code when the user actually uses\n// the search input.\n// It is ok to use `import type` to get type definitions, because that doesn't\n// cause the module to get loaded at runtime.\n////////////////////////////////////////////////////////////////////////////////\n\n// this is where we load the parser so it's ok to import it here\n\nimport type {\n  BaseNode,\n  FinalNode,\n  Location,\n  NodeWithLocation,\n  TextNode,\n  QualifierNode,\n  ContentNode,\n  NodeWithOperatorLocations,\n} from '@github/blackbird-parser'\n// eslint-disable-next-line @typescript-eslint/no-restricted-imports\nimport {\n  getCompatibleSearchTypes,\n  isContentNode,\n  isQualifierCompatible,\n  SearchType,\n  parse,\n  getPossibleQualifierValues,\n} from '@github/blackbird-parser'\nimport {CaretPositionKind, isQualifier, isSavedQualifier, hasChildren} from './common'\n\n// Re-export SearchType\nexport {SearchType, getPossibleQualifierValues}\n\nconst nonBreakingSpace = String.fromCharCode(160)\n\nexport function parseString(value: string): FinalNode {\n  // we need &nbsp; at the end to make the browser happy but parser doesn't handle nbsp very well\n  // TODO: make parser handle nbsp very well\n  const regex = new RegExp(nonBreakingSpace, 'g')\n  return parse(value.replace(regex, ' '))\n}\n\nexport function parseSearchInput(value: string): [FinalNode, Array<string | HTMLElement>] {\n  const root = parseString(value)\n  const highlights = getHighlights(root)\n  sortHighlights(highlights)\n\n  const nodes = [] as Array<string | HTMLElement>\n  // TODO: would be nice if we could check to see if there have been changes since last run\n  // idx is the index of the last character added to elem\n  let idx = 0\n\n  for (const hl of highlights) {\n    if (idx <= hl.location.start) {\n      // add any text before the highlight\n      nodes.push(value.substring(idx, hl.location.start).replace(' ', String.fromCharCode(160)))\n      idx = hl.location.start\n\n      // now add the highlight\n      const span = document.createElement('span')\n      span.classList.add(hl.className)\n      span.textContent = value.substring(hl.location.start, hl.location.end)\n      nodes.push(span)\n      idx = hl.location.end\n    }\n  }\n  // add any text after the last highlight\n  if (idx < value.length) {\n    nodes.push(value.substring(idx).replace(' ', nonBreakingSpace))\n  }\n\n  return [root, nodes]\n}\n\nexport function getCustomScopeNames(ast: BaseNode): string[] {\n  const nodes: QualifierNode[] = []\n  findCustomScopeNodes(nodes, ast)\n\n  const customScopeNames = nodes.map(node => (node.content as ContentNode).value.toString())\n\n  // Deduplicate custom scope names\n  return [...new Set(customScopeNames)]\n}\n\nfunction findCustomScopeNodes(nodes: QualifierNode[], node: BaseNode): void {\n  if (isSavedQualifier(node) && isContentNode(node.content)) {\n    nodes.push(node)\n  }\n  if (hasChildren(node)) {\n    for (node of node.children) {\n      findCustomScopeNodes(nodes, node)\n    }\n  }\n}\n\n/**\n * This function is designed to convert a search query containing saved searches into a form suitable for the legacy\n * search types. It rewrites saved searches into their expanded form (their query value), and also removes the \"OR\"\n * operator since it is not supported by the legacy search types.\n */\nexport function getExpandedQuery(\n  query: string,\n  customScopes: Array<{name: string; query: string}>,\n  ast: BaseNode,\n): string {\n  let expandedQuery = ''\n\n  const customScopeNodes: QualifierNode[] = []\n\n  findCustomScopeNodes(customScopeNodes, ast)\n\n  let index = 0\n  for (const node of customScopeNodes) {\n    if (isContentNode(node.content)) {\n      expandedQuery += query.substring(index, node.location.start)\n      const scopeValue = customScopes.find(scope => isContentNode(node.content) && scope.name === node.content.value)\n        ?.query\n      if (scopeValue) {\n        expandedQuery += removeUnsupportedOrOperator(scopeValue)\n      }\n      index = node.content.location.end\n    }\n  }\n  expandedQuery += query.substring(index)\n\n  return expandedQuery\n}\n\n// The OR operator is not supported by legacy search types\nfunction removeUnsupportedOrOperator(query: string): string {\n  return query.replaceAll(' OR ', ' ')\n}\n\n// This function moves the cursor to a character offset within the element .\n// If the position is -1, it goes to the end.\nexport function moveCaretToPosition(elem: HTMLInputElement, position: number) {\n  const target = position === -1 ? elem.value.length : position\n  elem.focus()\n  elem.setSelectionRange(target, target)\n  // TODO: try to scroll the cursor into view (perhaps in styledtextinput)\n}\n\ninterface Highlight {\n  className: string\n  location: Location\n}\n\n/**\n * Maps node kind to how it should be highlighted\n */\nconst kindHighlightMap: {[type: string]: {className: string; selector: 'location' | 'operatorLocation'} | undefined} = {\n  And: {className: 'pl-en', selector: 'operatorLocation'},\n  Not: {className: 'pl-en', selector: 'operatorLocation'},\n  Or: {className: 'pl-en', selector: 'operatorLocation'},\n  Regex: {className: 'pl-c1', selector: 'location'},\n}\n\nexport function getHighlights(node: BaseNode): Highlight[] {\n  let highlights: Highlight[] | undefined\n  if (isQualifier(node) && hasLocation(node.content)) {\n    highlights = [{className: 'input-parsed-symbol', location: node.content.location}]\n  } else if (isTextNode(node) && (node.value === 'AND' || node.value === 'OR' || node.value === 'NOT')) {\n    highlights = [{className: 'pl-en', location: node.location}]\n  } else {\n    const info = kindHighlightMap[node.kind]\n    if (info) {\n      if (info.selector === 'location' && hasLocation(node)) {\n        highlights = [{className: info.className, location: node.location}]\n      }\n      if (info.selector === 'operatorLocation' && hasOperatorLocations(node)) {\n        highlights = node.operatorLocations.map(location => ({\n          className: info.className,\n          location,\n        }))\n      }\n    }\n  }\n\n  highlights = highlights ?? []\n  if (hasChildren(node)) {\n    return highlights.concat(node.children.flatMap(getHighlights))\n  } else if (isQualifier(node)) {\n    return highlights.concat(getHighlights(node.content))\n  } else {\n    return highlights\n  }\n}\n\nfunction sortHighlights(highlights: Highlight[]) {\n  highlights.sort((a, b) => a.location.start - b.location.start)\n}\n\nfunction isTextNode(node: BaseNode): node is TextNode {\n  return !!(node as TextNode).value\n}\n\nfunction hasLocation(node: BaseNode): node is NodeWithLocation {\n  return !!(node as NodeWithLocation).location\n}\n\nfunction hasOperatorLocations(node: BaseNode): node is NodeWithOperatorLocations {\n  return !!(node as NodeWithOperatorLocations).operatorLocations\n}\n\nexport function getCaretPositionKindFromIndex(\n  root: FinalNode,\n  idx: number,\n): {node?: BaseNode; kind: CaretPositionKind} {\n  function findMatchingNode(node: BaseNode, index: number): BaseNode | undefined {\n    if (hasChildren(node)) {\n      for (const child of node.children) {\n        const match = findMatchingNode(child, index)\n        if (match) {\n          return match\n        }\n      }\n    }\n\n    if (hasLocation(node)) {\n      const start = node.location.start\n      let end = node.location.end\n\n      if (isQualifier(node) && hasLocation(node.content)) {\n        end = node.content.location.end\n      }\n\n      if (index >= start && index <= end) {\n        return node\n      }\n    }\n  }\n\n  const matchedNode = findMatchingNode(root, idx)\n  if (!matchedNode) {\n    return {kind: CaretPositionKind.Text}\n  }\n\n  if (matchedNode.kind === 'Regex') {\n    return {kind: CaretPositionKind.Regex}\n  }\n\n  if (isQualifier(matchedNode)) {\n    if (matchedNode.qualifier === 'Is') {\n      return {kind: CaretPositionKind.Is, node: matchedNode}\n    } else if (matchedNode.qualifier === 'Language') {\n      return {kind: CaretPositionKind.Language, node: matchedNode}\n    } else if (matchedNode.qualifier === 'Path') {\n      return {kind: CaretPositionKind.Path, node: matchedNode}\n    } else if (matchedNode.qualifier === 'Repo') {\n      return {kind: CaretPositionKind.Repository, node: matchedNode}\n    } else if (matchedNode.qualifier === 'Owner') {\n      return {kind: CaretPositionKind.Owner, node: matchedNode}\n    } else if (matchedNode.qualifier === 'Org') {\n      return {kind: CaretPositionKind.Owner, node: matchedNode}\n    } else if (matchedNode.qualifier === 'Saved') {\n      return {kind: CaretPositionKind.Saved, node: matchedNode}\n    } else {\n      return {kind: CaretPositionKind.OtherQualifier, node: matchedNode}\n    }\n  }\n\n  return {kind: CaretPositionKind.Text, node: matchedNode}\n}\n\nexport function extractUnsupportedQualifiers(root: BaseNode, type: SearchType): string[] {\n  const out: string[] = []\n  function __extractInvalid(node: BaseNode) {\n    if (isQualifier(node) && !isQualifierCompatible(type, node.qualifier)) {\n      const qualifier = node.raw.toLowerCase().substring(0, node.raw.length - 1)\n      if (!out.includes(qualifier)) {\n        out.push(qualifier)\n      }\n    } else if (isQualifier(node) && node.qualifier === 'Is') {\n      // public, private, issue, pr\n      const contentNode = node.content\n      if (isContentNode(contentNode)) {\n        const value = contentNode.value\n        if (type !== SearchType.Issues && value === 'issue') {\n          out.push('is:issue')\n        } else if (type !== SearchType.PRs && value === 'pr') {\n          out.push('is:pr')\n        }\n      }\n    }\n\n    if (hasChildren(node)) {\n      for (const child of node.children) {\n        __extractInvalid(child)\n      }\n    }\n  }\n  __extractInvalid(root)\n\n  return out\n}\n\nconst enum ConstraintKind {\n  Hint,\n  Compatible,\n  Avoid,\n  Match,\n}\n\nexport function chooseSearchType(ast: BaseNode, loggedIn: boolean): SearchType {\n  // Use some heuristics to guess the search type based on the query\n  const searchTypePreferences: Record<SearchType, number> = {\n    [SearchType.Repositories]: 0.5, // Prefer repos if nothing else\n    [SearchType.Code]: 0.2,\n    // Slightly prefer issues to PRs (they share many qualifiers)\n    [SearchType.Issues]: 0.1,\n    [SearchType.PRs]: 0,\n    [SearchType.Discussions]: 0,\n    [SearchType.Commits]: 0,\n    [SearchType.Packages]: 0,\n    [SearchType.Topics]: 0,\n    [SearchType.Users]: 0,\n    [SearchType.Orgs]: 0,\n    [SearchType.Wikis]: 0,\n    // Don't show marketplace results if ambiguous\n    [SearchType.Marketplace]: -0.4,\n    [SearchType.Unknown]: -1,\n    [SearchType.CodeLegacy]: -1,\n  }\n\n  // Deprioritize code search if not logged in.\n  if (!loggedIn) {\n    searchTypePreferences[SearchType.Code] -= 5\n  }\n\n  const constraints: Array<[SearchType[], ConstraintKind]> = []\n  extractSearchTypeConstraints(ast, constraints)\n  for (const constraint of constraints) {\n    const [types, kind] = constraint\n    if (kind === ConstraintKind.Hint) {\n      for (const type of types) {\n        searchTypePreferences[type] += 1\n      }\n    } else if (kind === ConstraintKind.Match) {\n      // if we have an extact type match this should get more than a single point added\n      // otherwise for repo/org searches, Code will always win by weight\n      for (const type of types) {\n        searchTypePreferences[type] += 1.5\n      }\n    } else if (kind === ConstraintKind.Avoid) {\n      for (const type of types) {\n        searchTypePreferences[type] -= 1\n      }\n    } else {\n      const typeMap: Record<string, boolean> = {}\n      for (const type of types) {\n        typeMap[type] = true\n      }\n      for (const allowedType of Object.keys(searchTypePreferences)) {\n        if (!typeMap[allowedType]) {\n          delete searchTypePreferences[allowedType as SearchType]\n        }\n      }\n    }\n  }\n\n  const preferredTypes: Array<[SearchType, number]> = Object.keys(searchTypePreferences).map(key => [\n    key as SearchType,\n    searchTypePreferences[key as SearchType],\n  ])\n\n  let chosenType = SearchType.Unknown\n  if (preferredTypes.length > 0) {\n    preferredTypes.sort((a, b) => b[1] - a[1])\n    chosenType = preferredTypes[0]![0]\n  }\n\n  return chosenType\n}\n\nexport type SearchTypeURLParameter =\n  | ''\n  | 'code'\n  | 'repositories'\n  | 'pullrequests'\n  | 'issues'\n  | 'discussions'\n  | 'commits'\n  | 'registrypackages'\n  | 'marketplace'\n  | 'topics'\n  | 'users'\n  | 'wikis'\n  | 'codelegacy'\n\nexport function mapSearchTypeToURLParam(type: SearchType): SearchTypeURLParameter {\n  // Map the chosen type to a URL param value\n  return ({\n    [SearchType.Unknown]: '',\n    [SearchType.Code]: 'code',\n    [SearchType.Repositories]: 'repositories',\n    [SearchType.PRs]: 'pullrequests',\n    [SearchType.Issues]: 'issues',\n    [SearchType.Discussions]: 'discussions',\n    [SearchType.Commits]: 'commits',\n    [SearchType.Packages]: 'registrypackages',\n    [SearchType.Marketplace]: 'marketplace',\n    [SearchType.Topics]: 'topics',\n    [SearchType.Users]: 'users',\n    [SearchType.Orgs]: 'users',\n    [SearchType.Wikis]: 'wikis',\n    [SearchType.CodeLegacy]: 'codelegacy',\n  }[type] || '') as SearchTypeURLParameter\n}\n\nexport function searchTypeAsPlural(type: SearchType): string {\n  return (\n    {\n      [SearchType.Unknown]: '',\n      [SearchType.Code]: 'code',\n      [SearchType.Repositories]: 'repositories',\n      [SearchType.PRs]: 'pull requests',\n      [SearchType.Issues]: 'issues',\n      [SearchType.Discussions]: 'discussions',\n      [SearchType.Commits]: 'commits',\n      [SearchType.Packages]: 'packages',\n      [SearchType.Marketplace]: 'the marketplace',\n      [SearchType.Topics]: 'topics',\n      [SearchType.Users]: 'users',\n      [SearchType.Orgs]: 'users',\n      [SearchType.Wikis]: 'wikis',\n      [SearchType.CodeLegacy]: 'code',\n    }[type] || ''\n  )\n}\n\nexport function mapURLParamToSearchType(type: SearchTypeURLParameter): SearchType {\n  return (\n    {\n      '': SearchType.Unknown,\n      code: SearchType.Code,\n      repositories: SearchType.Repositories,\n      pullrequests: SearchType.PRs,\n      issues: SearchType.Issues,\n      discussions: SearchType.Discussions,\n      commits: SearchType.Commits,\n      registrypackages: SearchType.Packages,\n      marketplace: SearchType.Marketplace,\n      topics: SearchType.Topics,\n      users: SearchType.Users,\n      orgs: SearchType.Orgs,\n      wikis: SearchType.Wikis,\n      codelegacy: SearchType.CodeLegacy,\n    }[type] || SearchType.Unknown\n  )\n}\n\nfunction extractSearchTypeConstraints(node: BaseNode, out: Array<[SearchType[], ConstraintKind]>) {\n  if (isQualifier(node)) {\n    if (node.qualifier === 'Repo') {\n      out.push([[SearchType.Repositories], ConstraintKind.Avoid])\n    }\n\n    if (node.qualifier === 'Repo' || node.qualifier === 'Org') {\n      out.push([[SearchType.Code], ConstraintKind.Hint])\n    }\n\n    if (node.qualifier === 'Saved') {\n      out.push([[SearchType.Code], ConstraintKind.Compatible])\n    }\n\n    if (isContentNode(node.content)) {\n      // Only code search supports regex queries\n      if (node.content.kind === 'Regex') {\n        out.push([[SearchType.Code], ConstraintKind.Compatible])\n      }\n\n      const value = node.content.value.toString().toLowerCase()\n      if (node.qualifier === 'Is') {\n        if (value === 'pr') {\n          out.push([[SearchType.PRs], ConstraintKind.Compatible])\n        } else if (value === 'issue') {\n          out.push([[SearchType.Issues], ConstraintKind.Compatible])\n        } else if (value === 'sponsorable') {\n          out.push([[SearchType.Users, SearchType.Repositories], ConstraintKind.Compatible])\n        }\n      } else if (node.qualifier === 'Type') {\n        const typeMap = new Map([\n          ['commit', SearchType.Commits],\n          ['discussion', SearchType.Discussions],\n          ['issue', SearchType.Issues],\n          ['marketplace', SearchType.Marketplace],\n          ['org', SearchType.Orgs],\n          ['package', SearchType.Packages],\n          ['pr', SearchType.PRs],\n          ['topic', SearchType.Topics],\n          ['user', SearchType.Users],\n          ['wiki', SearchType.Wikis],\n        ])\n        if (typeMap.has(value)) {\n          out.push([[typeMap.get(value)!], ConstraintKind.Match])\n        }\n      }\n    }\n\n    const compatibleSearchTypes = getCompatibleSearchTypes(node.qualifier)\n    if (compatibleSearchTypes.length > 0) {\n      out.push([compatibleSearchTypes, ConstraintKind.Compatible])\n    }\n  } else if (node.kind === 'Regex') {\n    out.push([[SearchType.Code], ConstraintKind.Compatible])\n  }\n\n  if (hasChildren(node)) {\n    for (const child of node.children) {\n      extractSearchTypeConstraints(child, out)\n    }\n  }\n}\n"],"names":["nonBreakingSpace","String","fromCharCode","parseString","value","regex","parse","replace","parseSearchInput","root","highlights","getHighlights","sortHighlights","sort","a","b","location","start","nodes","idx","hl","push","substring","span","document","createElement","classList","add","className","textContent","end","length","getCustomScopeNames","ast","findCustomScopeNodes","Set","map","node","content","toString","isSavedQualifier","isContentNode","hasChildren","children","getExpandedQuery","query","customScopes","expandedQuery","customScopeNodes","index","scopeValue","find","scope","name","replaceAll","moveCaretToPosition","elem","position","target","focus","setSelectionRange","kindHighlightMap","And","selector","Not","Or","Regex","isQualifier","hasLocation","isTextNode","info","kind","operatorLocations","concat","flatMap","getCaretPositionKindFromIndex","matchedNode","findMatchingNode","child","match","CaretPositionKind","Text","qualifier","Is","Language","Path","Repository","Owner","Saved","OtherQualifier","extractUnsupportedQualifiers","type","out","__extractInvalid","isQualifierCompatible","raw","toLowerCase","includes","contentNode","SearchType","Issues","PRs","chooseSearchType","loggedIn","searchTypePreferences","Repositories","Code","Discussions","Commits","Packages","Topics","Users","Orgs","Wikis","Marketplace","Unknown","CodeLegacy","constraints","constraint","extractSearchTypeConstraints","typeMap","Map","has","get","compatibleSearchTypes","getCompatibleSearchTypes","types","allowedType","Object","keys","preferredTypes","key","chosenType","mapSearchTypeToURLParam","searchTypeAsPlural","mapURLParamToSearchType","code","repositories","pullrequests","issues","discussions","commits","registrypackages","marketplace","topics","users","orgs","wikis","codelegacy"],"sourceRoot":""}