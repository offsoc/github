require "google/protobuf/wrappers_pb"

module Hydro
  module Protobuf
    HYDRO_SCHEMAS_NAMESPACE = "hydro.schemas"

    # Public: Map a hash to a protobuf object instance. The hash may be nested
    # to instantate nested message.
    #
    # Throws UnknownFieldError exceptions when passed an unknown field.
    # Throws InvalidValueError when a field value is an invalid type.
    #
    #   data         - A Hash of fields and values
    #   schema_class - The generated protobuf schema class
    #
    # Example:
    #
    #   message User {
    #     string login = 1;
    #   }
    #
    #   message UserComment {
    #     User author = 1;
    #     string comment = 2;
    #   }
    #
    #   comment = Hydro::Protobuf.to_protobuf({
    #     author: {login: "defunkt"},
    #     comment: "hey",
    #   }, UserComment)
    #
    #   comment = Hydro::Protobuf.to_protobuf({
    #     comment: 5000, # throws InvalidValueError
    #   }, UserComment)
    #
    #   comment = Hydro::Protobuf.to_protobuf({
    #     unknown: "value", # throws UnknownFieldError
    #   }, UserComment)
    #
    # Returns a protobuf instance.
    def self.to_protobuf(data, schema_class, nil_scalar_handler: nil)
      data.each.with_object(schema_class.new) do |(field_name, value), instance|
        unless field = schema_class.descriptor.lookup(field_name.to_s)
          raise UnknownFieldError.new(schema_class, field_name)
        end

        begin
          serializer = Field.new(field, value,
            nil_scalar_handler: nil_scalar_handler
          )
          next unless proto = serializer.to_proto

          if proto.is_a?(Array)
            instance.public_send(field_name).concat(proto)
          else
            instance.public_send(:"#{field_name}=", proto)
          end
        rescue Field::UnsetScalarError
          error = Protobuf::UnsetScalarError.new(schema_class, field)
          nil_scalar_handler&.call(error)
        rescue InvalidValueError => e
          raise InvalidValueError.new(schema_class, field, value, e)
        rescue TypeError, RangeError, ::EncodingError => e
          raise InvalidValueError.new(schema_class, field, value)
        end
      end
    end

    # Public: Lookup the schema class associated with a schema name. As most
    # schemas are assumed to live in the `hydro.schemas` namespace, we permit
    # relative rather than fully-qualified schema names by secondarily
    # searching in the `hydro.schemas` namespace.
    #
    # schema_id - the String name of the schema
    # pool      - the Google::Protobuf::DescriptorPool
    #
    # Returns a schema class.
    def self.get_schema_class(schema_id, pool)
      unless schema = pool.lookup(schema_id) || pool.lookup("#{HYDRO_SCHEMAS_NAMESPACE}.#{schema_id}")
        raise MissingSchemaError.new(schema_id)
      end

      schema.msgclass
    end

    class Field
      UnsetScalarError = Class.new(ArgumentError)

      WRAPPED_SCALARS_TYPES = [
        Google::Protobuf::DoubleValue,
        Google::Protobuf::FloatValue,
        Google::Protobuf::Int64Value,
        Google::Protobuf::UInt64Value,
        Google::Protobuf::Int32Value,
        Google::Protobuf::UInt32Value,
        Google::Protobuf::BoolValue,
        Google::Protobuf::StringValue,
        Google::Protobuf::BytesValue,
      ]

      MAP_ENTRY = /_MapEntry_/

      def initialize(field, value, nil_scalar_handler: nil)
        @field = field
        @value = value
        @nil_scalar_handler = nil_scalar_handler
      end

      def to_proto
        if scalar_type?
          raise UnsetScalarError if value.nil?
          return convert_bytes if bytes_type?
          return convert_string if string_type?
          return value
        end

        return nil if value.nil?
        return convert_enum if enum_type?
        return convert_map if map_type?
        return convert_message if message_type?
      end

      private

      # Internal: Is the field a primitive type e.g. int32, bool?
      #
      # Return a Boolean.
      def scalar_type?
        !message_type? && !enum_type?
      end

      # Internal: Is the field itself a protobuf message?
      #
      # Return a Boolean.
      def message_type?
        field.type == :message
      end

      # Internal: Is the field an enum?
      #
      # Return a Boolean.
      def enum_type?
        field.subtype.is_a?(Google::Protobuf::EnumDescriptor)
      end

      # Internal: Is the field a protobuf map?
      #
      # Return a Boolean.
      def map_type?
        # There isn't a direct method call to determine if a field is a map, but
        # the subtype descriptor has an autogenerated `#name` that includes the
        # string _MapEntry_, and we can check for that or #{FieldName}Entry suffix
        # in newer versions of protoc.
        message_type? && (MAP_ENTRY.match?(field.subtype.name) ||
          field.subtype.name.end_with?("#{field.name.to_s.split("_").map(&:capitalize).join}Entry"))
      end

      # Internal: Is the field bytes?
      #
      # Return a Boolean.
      def bytes_type?
        field.type == :bytes
      end

      # Internal: Is the string bytes?
      #
      # Return a Boolean.
      def string_type?
        field.type == :string
      end

      def repeated?
        field.label == :repeated
      end

      def convert_enum
        repeated { |value| value.upcase.to_sym }
      end

      def convert_map
        key_type, value_type = field.subtype.entries

        case value_type.type
        when :message
          return unless value

          Google::Protobuf::Map.new(
            key_type.type,
            value_type.type,
            value_type.subtype.msgclass,
            value.transform_values do |map_value|
              next value_type.subtype.msgclass.new unless map_value

              Protobuf.to_protobuf(map_value, value_type.subtype.msgclass,
                nil_scalar_handler: @nil_scalar_handler
              )
            end
          )
        when :enum
          Google::Protobuf::Map.new(
            key_type.type,
            value_type.type,
            value_type.subtype.enummodule,
            value
          )
        else
          Google::Protobuf::Map.new(key_type.type, value_type.type, value)
        end
      end

      def convert_message
        repeated { |value| convert_message_with_definition(value) }
      end

      # Internal: Convert a value with its own protobuf definition to a
      # protobuf instance.
      #
      # Timestamps receive special handling so that they can be specified with
      # a Time instance or Integer rather than the more cumbersome
      # '{seconds: n, nanoseconds: n}' form.
      #
      # Returns a protobuf instance.
      def convert_message_with_definition(value)
        if WRAPPED_SCALARS_TYPES.include?(message_schema)
          value = {value: value} unless value.is_a?(Hash)
          return Protobuf.to_protobuf(value, message_schema,
            nil_scalar_handler: @nil_scalar_handler
          )
        end

        if message_schema == Google::Protobuf::Timestamp
          return value if value.is_a?(Google::Protobuf::Timestamp)

          timestamp = Google::Protobuf::Timestamp.new
          timestamp.from_time(Time.at(value))

          return timestamp
        elsif message_schema == Google::Protobuf::Any
          return value if value.is_a?(Google::Protobuf::Any)

          any = Google::Protobuf::Any.new
          if value.is_a?(Hash)
            struct = Google::Protobuf::Struct.from_hash(value)
            any.pack(struct)
          else
            any.pack(value)
          end

          return any
        end

        Protobuf.to_protobuf(value, message_schema,
          nil_scalar_handler: @nil_scalar_handler
        )
      end

      # bytes field types on proto messages are handled as Encoding::BINARY
      # if we don't encode the string here, then non-ascii characters throw errors
      def convert_bytes
        (value.frozen? ? value.dup : value).force_encoding(Encoding::BINARY)
      end

      def convert_string
        return value unless value.is_a?(String)
        return value if value.encoding == Encoding::UTF_8 && value.valid_encoding?

        if value.dup.force_encoding(Encoding::UTF_8).valid_encoding?
          value
        else
          raise ::EncodingError.new("String field '#{field.name}' contains invalid UTF-8")
        end
      end

      def message_schema
        field.subtype.msgclass
      end

      def repeated(&block)
        if repeated?
          values = value
          values = [values] unless values.is_a?(Array)
          values.compact.map(&block)
        else
          block.call(value)
        end
      end

      attr_reader :field, :value
    end

    class UnsetScalarError < ArgumentError
      attr_reader :schema, :field

      def initialize(schema, field)
        @schema, @field = schema, field
      end

      def message
        "#{schema} got `nil` for scalar #{field.type} field '#{field.name}'. "\
        "In proto3, setting a scalar field to `nil` causes the field to take on "\
        "a default value (e.g. \"\" for strings, 0 for integers, etc) and there "\
        "is no way for message readers to know that the field was unset. "\
        "If the field really *should* allow `nil`, consider using a scalar "\
        "wrapper type (see https://git.io/vxjoY for more information)."
      end
    end

    class UnknownFieldError < ArgumentError
      def initialize(schema, field_name)
        @schema, @field_name = schema, field_name
      end

      def message
        "#{@schema} has no field '#{@field_name}'"
      end
    end

    class InvalidValueError < ::TypeError
      def initialize(schema, field, value, error_on_field = nil)
        @schema, @field, @value = schema, field, value
        @error_on_field = error_on_field
      end

      def message
        if @error_on_field
          "Error encoding field #{@schema}.#{@field.name} of type #{expected_type}: " +
            @error_on_field.message
        else
          "Invalid value #{truncated_value} " +
          "for field #{@schema}.#{@field.name}, " +
          "expected #{@field.label} :#{expected_type}"
        end
      end

      def truncated_value
        full = @value.inspect
        full.length > 100 ? full[0..100] + "..." : full
      end

      def expected_type
        @field.submsg_name || @field.type
      end
    end
  end
end
