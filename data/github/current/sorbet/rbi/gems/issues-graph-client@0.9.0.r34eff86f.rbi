# typed: false

# DO NOT EDIT MANUALLY
# This is an autogenerated file for types exported from the `issues-graph-client` gem.
# Please instead update this file by running `bin/tapioca gem issues-graph-client`.

module Google::Protobuf::MessageExts::ClassMethods; end
module IssuesGraph; end

# The Ruby client for the IssuesGraph service.
class IssuesGraph::Client
  # conn     - http_client
  # hmac_key - authentication HMAC key (https://en.wikipedia.org/wiki/HMAC)
  # options  - used to provide non-required statter and logger dependency (default: {}):
  #            :dogstats - Datadog client
  #            :logger   - Logger that responds to `log` method
  #
  # @return [Client] a new instance of Client
  #
  # source://issues-graph-client//ruby/lib/issues-graph/client.rb#38
  def initialize(conn, hmac_key, options = T.unsafe(nil)); end

  # tracking blocks
  #
  # source://issues-graph-client//ruby/lib/issues-graph/client.rb#117
  def add_tracking_block_for_parent(parent, tracking_blocks, log_tags: T.unsafe(nil), stat_tags: T.unsafe(nil)); end

  # source://issues-graph-client//ruby/lib/issues-graph/client.rb#198
  def delete_issue_from_project(from:, to:, log_tags: T.unsafe(nil), stat_tags: T.unsafe(nil)); end

  # source://issues-graph-client//ruby/lib/issues-graph/client.rb#85
  def delete_issue_from_tracking_block(from:, to:, log_tags: T.unsafe(nil), stat_tags: T.unsafe(nil)); end

  # source://issues-graph-client//ruby/lib/issues-graph/client.rb#92
  def delete_tracking_block_from_issue(from:, to:, log_tags: T.unsafe(nil), stat_tags: T.unsafe(nil)); end

  # source://issues-graph-client//ruby/lib/issues-graph/client.rb#99
  def get_issue(key:, use_denormalized_data: T.unsafe(nil), actor_id: T.unsafe(nil), log_tags: T.unsafe(nil), stat_tags: T.unsafe(nil)); end

  # source://issues-graph-client//ruby/lib/issues-graph/client.rb#258
  def get_issue_relationships_and_completions(owner_id:, item_id:, type:); end

  # source://issues-graph-client//ruby/lib/issues-graph/client.rb#185
  def get_project_item_completions(owner_id:, item_id:, actor_id: T.unsafe(nil), log_tags: T.unsafe(nil), stat_tags: T.unsafe(nil), **opts); end

  # source://issues-graph-client//ruby/lib/issues-graph/client.rb#205
  def get_project_tracked_by_items(owner_id:, item_id:, actor_id: T.unsafe(nil), log_tags: T.unsafe(nil), stat_tags: T.unsafe(nil), **opts); end

  # source://issues-graph-client//ruby/lib/issues-graph/client.rb#142
  def get_tracking_blocks_by_parent(owner_id, item_id, log_tags: T.unsafe(nil), stat_tags: T.unsafe(nil)); end

  # source://issues-graph-client//ruby/lib/issues-graph/client.rb#153
  def remove_tracking_block(owner_id, item_id, tracking_block_id, log_tags: T.unsafe(nil), stat_tags: T.unsafe(nil)); end

  # source://issues-graph-client//ruby/lib/issues-graph/client.rb#166
  def replace_tracking_blocks_for_parent(parent, tracking_blocks, actor_id: T.unsafe(nil), log_tags: T.unsafe(nil), stat_tags: T.unsafe(nil)); end

  # main api
  #
  # source://issues-graph-client//ruby/lib/issues-graph/client.rb#52
  def update_issue(issue:, log_tags: T.unsafe(nil), stat_tags: T.unsafe(nil)); end

  # source://issues-graph-client//ruby/lib/issues-graph/client.rb#124
  def update_tracking_block_by_key(block_key, issues_to_add, issues_to_remove, log_tags: T.unsafe(nil), stat_tags: T.unsafe(nil)); end

  # source://issues-graph-client//ruby/lib/issues-graph/client.rb#131
  def update_tracking_block_in_place_by_key(block_key, issues_to_update, log_tags: T.unsafe(nil), stat_tags: T.unsafe(nil)); end

  # deprecated: to be removed
  #
  # source://issues-graph-client//ruby/lib/issues-graph/client.rb#254
  def upsert_issues_and_relationships(from:, to:); end

  # projects
  #
  # source://issues-graph-client//ruby/lib/issues-graph/client.rb#178
  def upsert_project_and_relationships(from:, to:, user: T.unsafe(nil), log_tags: T.unsafe(nil), stat_tags: T.unsafe(nil)); end

  private

  # Private: returns the actor_id from the GitHub context if available
  #
  # source://issues-graph-client//ruby/lib/issues-graph/client.rb#417
  def actor_id_from_context; end

  # source://issues-graph-client//ruby/lib/issues-graph/client.rb#372
  def create_with_dist_handler(method_name, start_time, tags); end

  # source://issues-graph-client//ruby/lib/issues-graph/client.rb#332
  def create_wrap_result_error_handler(method_name, log_tags, stat_tags); end

  # source://issues-graph-client//ruby/lib/issues-graph/client.rb#324
  def create_wrap_result_success_handler(method_name, log_tags, stat_tags); end

  # source://issues-graph-client//ruby/lib/issues-graph/client.rb#283
  def header_timestamp; end

  # Private: separate log method used for timeout error only
  #
  # method_name - The name of the method being called to be added as a "required" tag
  #               of the stat
  # stat_tags   - string array of tags to be added as tags of the timeout stat
  #
  # Returns nothing.
  #
  # source://issues-graph-client//ruby/lib/issues-graph/client.rb#409
  def increment_timeout_stat(method_name, stat_tags: T.unsafe(nil)); end

  # Private: extracts the key information as tags to be used by the logger and statter,
  #          normalizing hash or key object access
  #
  # key - Hash or Key object to extract the information from
  #
  # Returns a string array containing the key fields.
  #
  # source://issues-graph-client//ruby/lib/issues-graph/client.rb#236
  def log_tags_from_key(key); end

  # Private: as long as the http client uses the Promise interface, it's possible to identify
  # if the call was done asynchronously
  # (prioritizing the Faraday Future API because the ruby-twirp implementation already depends on it )
  #
  # @return [Boolean]
  #
  # source://issues-graph-client//ruby/lib/issues-graph/client.rb#397
  def promise_response?(response); end

  # Private: retrieves the query type based on the options provided.
  #
  # opts - hash containing the query options
  #
  # Returns the query type to be used by the server.
  #
  # source://issues-graph-client//ruby/lib/issues-graph/client.rb#223
  def query_type_from(opts = T.unsafe(nil)); end

  # Private: creates the request headers to be used by the http client for every call
  #
  # Returns a hash containing the headers.
  #
  # source://issues-graph-client//ruby/lib/issues-graph/client.rb#267
  def request_headers; end

  # Private: calculates the hmac string based off of the hmac_key provided
  #
  # Returns the calculated string.
  #
  # source://issues-graph-client//ruby/lib/issues-graph/client.rb#276
  def request_hmac; end

  # Private: logs and stats information of the provided error.
  #
  # method_name - The name of the method being called to be added as a tag or field
  # error       - an instance of ::StandardError or descendant, where to extract
  #               the error message to be logged
  # log_tags    - string array of tags in the format "{key}:{value}" that are going
  #               to be converted to log fields. If no log_tags is provided, it'll
  #               be set to the stat_tags
  # stat_tags   - string array of tags in the format "{key}:{value}", to be used
  #               to tag the stat of the error
  #
  # Returns nothing.
  #
  # source://issues-graph-client//ruby/lib/issues-graph/client.rb#433
  def stat_and_log_error(method_name, error, log_tags: T.unsafe(nil), stat_tags: T.unsafe(nil)); end

  # Private: infer timeout error based on the error class name to avoid direct references
  # to Faraday inside the client, keeping it independent of the Faraday implementation
  #
  # @return [Boolean]
  #
  # source://issues-graph-client//ruby/lib/issues-graph/client.rb#388
  def timeout_error?(error); end

  # Private: a wrapper around the client's request method that sends
  # distribution metrics if the statting method is defined. If dogstats is available,
  # each invocation will call the distribution_timing_since method. of the block.
  #
  # method_name - The name of the method being called or what you want the stat to be
  #               named
  # tags        - tags to be added to the time distribution stat.
  #               format convention: "{key}:{value}"
  #
  # Returns the result of the block.
  #
  # source://issues-graph-client//ruby/lib/issues-graph/client.rb#357
  def with_dist(method_name, tags: T.unsafe(nil)); end

  # Private: wrapper around the client's request method that:
  # + normalizes success and errors results
  # + sends distribution metrics if the statting method is defined
  # + sends timeout stats
  # + log and stats raised errors
  #
  # method_name - name of the method to be used in the logs and stats
  # log_tags    - extra tags that can be added to the logs passed in
  #               by the consumers of the client to provide
  #               more context and make the errors easier to track
  # stat_tags   - extra tags to be used when statting calls. Ideally
  #               they should be tags that can be used to group stats.
  #               Avoid request specific tags.
  #
  # Returns an instance of the ::IssuesGraph::Result with all relevant information
  # obtained from the Twirp::Response and/or any error raised by the http client.
  #
  # @raise [::Issues::Errors::ArgumentError]
  #
  # source://issues-graph-client//ruby/lib/issues-graph/client.rb#303
  def wrap_result(method_name, log_tags: T.unsafe(nil), stat_tags: T.unsafe(nil), &block); end
end

# source://issues-graph-client//ruby/lib/issues-graph/client.rb#29
IssuesGraph::Client::ALGORITHM = T.let(T.unsafe(nil), String)

# source://issues-graph-client//ruby/lib/issues-graph/client.rb#30
IssuesGraph::Client::HMAC_HEADER = T.let(T.unsafe(nil), String)

# source://issues-graph-client//ruby/lib/issues-graph/client.rb#31
IssuesGraph::Client::STAT_PREFIX = T.let(T.unsafe(nil), String)

module IssuesGraph::Errors; end
class IssuesGraph::Errors::ArgumentError < ::ArgumentError; end

# Client error wrapper to normalize the Twirp::Error interface for consumers,
# allowing the error to be used with Failbot, since it expects that an error
# will have the @message instance variable instead of @msg that the
# Twirp::Error class implements
class IssuesGraph::Errors::ClientError < ::StandardError
  # msg         - main error message. If not provided, the initializer will
  #               try to use the error message of the inner_error, if available.
  # inner_error - error being wrapped by this class. If the inner_error is a
  #               Twirp::Error, this class will expose its code and use its
  #               msg instance variable to fill the @message of the
  #               StandardError (parent class)
  #
  # @return [ClientError] a new instance of ClientError
  #
  # source://issues-graph-client//ruby/lib/issues-graph/errors.rb#21
  def initialize(msg = T.unsafe(nil), inner_error: T.unsafe(nil)); end

  # source://issues-graph-client//ruby/lib/issues-graph/errors.rb#31
  def code; end

  # Returns the value of attribute inner_error.
  #
  # source://issues-graph-client//ruby/lib/issues-graph/errors.rb#13
  def inner_error; end

  # source://issues-graph-client//ruby/lib/issues-graph/errors.rb#35
  def to_h; end

  private

  # @return [Boolean]
  #
  # source://issues-graph-client//ruby/lib/issues-graph/errors.rb#45
  def wraps_twirp_error?; end
end

# Null object pattern class for missing logger
class IssuesGraph::NullLogger
  # source://issues-graph-client//ruby/lib/issues-graph/client.rb#11
  def log(*_args); end
end

# Null object pattern class for missing statter
class IssuesGraph::NullStatter
  # source://issues-graph-client//ruby/lib/issues-graph/client.rb#18
  def distribution_timing_since(*_args); end

  # source://issues-graph-client//ruby/lib/issues-graph/client.rb#22
  def increment(*_args); end
end

class IssuesGraph::Proto::AddTrackingBlockRequest
  include ::Google::Protobuf::MessageExts
  extend ::Google::Protobuf::MessageExts::ClassMethods

  def initialize(*_arg0); end

  def ==(_arg0); end
  def [](_arg0); end
  def []=(_arg0, _arg1); end
  def clone; end
  def dup; end
  def eql?(_arg0); end
  def hash; end
  def inspect; end
  def method_missing(*_arg0); end
  def to_h; end
  def to_s; end

  private

  def respond_to_missing?(*_arg0); end

  class << self
    def decode(_arg0); end
    def decode_json(*_arg0); end
    def descriptor; end
    def encode(_arg0); end
    def encode_json(*_arg0); end
  end
end

class IssuesGraph::Proto::AddTrackingBlockResponse
  include ::Google::Protobuf::MessageExts
  extend ::Google::Protobuf::MessageExts::ClassMethods

  def initialize(*_arg0); end

  def ==(_arg0); end
  def [](_arg0); end
  def []=(_arg0, _arg1); end
  def clone; end
  def dup; end
  def eql?(_arg0); end
  def hash; end
  def inspect; end
  def method_missing(*_arg0); end
  def to_h; end
  def to_s; end

  private

  def respond_to_missing?(*_arg0); end

  class << self
    def decode(_arg0); end
    def decode_json(*_arg0); end
    def descriptor; end
    def encode(_arg0); end
    def encode_json(*_arg0); end
  end
end

class IssuesGraph::Proto::Completion
  include ::Google::Protobuf::MessageExts
  extend ::Google::Protobuf::MessageExts::ClassMethods

  def initialize(*_arg0); end

  def ==(_arg0); end
  def [](_arg0); end
  def []=(_arg0, _arg1); end
  def clone; end
  def dup; end
  def eql?(_arg0); end
  def hash; end
  def inspect; end
  def method_missing(*_arg0); end
  def to_h; end
  def to_s; end

  private

  def respond_to_missing?(*_arg0); end

  class << self
    def decode(_arg0); end
    def decode_json(*_arg0); end
    def descriptor; end
    def encode(_arg0); end
    def encode_json(*_arg0); end
  end
end

class IssuesGraph::Proto::DeleteRelationshipRequest
  include ::Google::Protobuf::MessageExts
  extend ::Google::Protobuf::MessageExts::ClassMethods

  def initialize(*_arg0); end

  def ==(_arg0); end
  def [](_arg0); end
  def []=(_arg0, _arg1); end
  def clone; end
  def dup; end
  def eql?(_arg0); end
  def hash; end
  def inspect; end
  def method_missing(*_arg0); end
  def to_h; end
  def to_s; end

  private

  def respond_to_missing?(*_arg0); end

  class << self
    def decode(_arg0); end
    def decode_json(*_arg0); end
    def descriptor; end
    def encode(_arg0); end
    def encode_json(*_arg0); end
  end
end

class IssuesGraph::Proto::GetIssueRequest
  include ::Google::Protobuf::MessageExts
  extend ::Google::Protobuf::MessageExts::ClassMethods

  def initialize(*_arg0); end

  def ==(_arg0); end
  def [](_arg0); end
  def []=(_arg0, _arg1); end
  def clone; end
  def dup; end
  def eql?(_arg0); end
  def hash; end
  def inspect; end
  def method_missing(*_arg0); end
  def to_h; end
  def to_s; end

  private

  def respond_to_missing?(*_arg0); end

  class << self
    def decode(_arg0); end
    def decode_json(*_arg0); end
    def descriptor; end
    def encode(_arg0); end
    def encode_json(*_arg0); end
  end
end

class IssuesGraph::Proto::GetIssueResponse
  include ::Google::Protobuf::MessageExts
  extend ::Google::Protobuf::MessageExts::ClassMethods

  def initialize(*_arg0); end

  def ==(_arg0); end
  def [](_arg0); end
  def []=(_arg0, _arg1); end
  def clone; end
  def dup; end
  def eql?(_arg0); end
  def hash; end
  def inspect; end
  def method_missing(*_arg0); end
  def to_h; end
  def to_s; end

  private

  def respond_to_missing?(*_arg0); end

  class << self
    def decode(_arg0); end
    def decode_json(*_arg0); end
    def descriptor; end
    def encode(_arg0); end
    def encode_json(*_arg0); end
  end
end

class IssuesGraph::Proto::GetItemModifiedAtRequest
  include ::Google::Protobuf::MessageExts
  extend ::Google::Protobuf::MessageExts::ClassMethods

  def initialize(*_arg0); end

  def ==(_arg0); end
  def [](_arg0); end
  def []=(_arg0, _arg1); end
  def clone; end
  def dup; end
  def eql?(_arg0); end
  def hash; end
  def inspect; end
  def method_missing(*_arg0); end
  def to_h; end
  def to_s; end

  private

  def respond_to_missing?(*_arg0); end

  class << self
    def decode(_arg0); end
    def decode_json(*_arg0); end
    def descriptor; end
    def encode(_arg0); end
    def encode_json(*_arg0); end
  end
end

class IssuesGraph::Proto::GetItemModifiedAtResponse
  include ::Google::Protobuf::MessageExts
  extend ::Google::Protobuf::MessageExts::ClassMethods

  def initialize(*_arg0); end

  def ==(_arg0); end
  def [](_arg0); end
  def []=(_arg0, _arg1); end
  def clone; end
  def dup; end
  def eql?(_arg0); end
  def hash; end
  def inspect; end
  def method_missing(*_arg0); end
  def to_h; end
  def to_s; end

  private

  def respond_to_missing?(*_arg0); end

  class << self
    def decode(_arg0); end
    def decode_json(*_arg0); end
    def descriptor; end
    def encode(_arg0); end
    def encode_json(*_arg0); end
  end
end

class IssuesGraph::Proto::GetProjectItemCompletionsRequest
  include ::Google::Protobuf::MessageExts
  extend ::Google::Protobuf::MessageExts::ClassMethods

  def initialize(*_arg0); end

  def ==(_arg0); end
  def [](_arg0); end
  def []=(_arg0, _arg1); end
  def clone; end
  def dup; end
  def eql?(_arg0); end
  def hash; end
  def inspect; end
  def method_missing(*_arg0); end
  def to_h; end
  def to_s; end

  private

  def respond_to_missing?(*_arg0); end

  class << self
    def decode(_arg0); end
    def decode_json(*_arg0); end
    def descriptor; end
    def encode(_arg0); end
    def encode_json(*_arg0); end
  end
end

class IssuesGraph::Proto::GetProjectItemCompletionsResponse
  include ::Google::Protobuf::MessageExts
  extend ::Google::Protobuf::MessageExts::ClassMethods

  def initialize(*_arg0); end

  def ==(_arg0); end
  def [](_arg0); end
  def []=(_arg0, _arg1); end
  def clone; end
  def dup; end
  def eql?(_arg0); end
  def hash; end
  def inspect; end
  def method_missing(*_arg0); end
  def to_h; end
  def to_s; end

  private

  def respond_to_missing?(*_arg0); end

  class << self
    def decode(_arg0); end
    def decode_json(*_arg0); end
    def descriptor; end
    def encode(_arg0); end
    def encode_json(*_arg0); end
  end
end

class IssuesGraph::Proto::GetProjectTrackedByItemsRequest
  include ::Google::Protobuf::MessageExts
  extend ::Google::Protobuf::MessageExts::ClassMethods

  def initialize(*_arg0); end

  def ==(_arg0); end
  def [](_arg0); end
  def []=(_arg0, _arg1); end
  def clone; end
  def dup; end
  def eql?(_arg0); end
  def hash; end
  def inspect; end
  def method_missing(*_arg0); end
  def to_h; end
  def to_s; end

  private

  def respond_to_missing?(*_arg0); end

  class << self
    def decode(_arg0); end
    def decode_json(*_arg0); end
    def descriptor; end
    def encode(_arg0); end
    def encode_json(*_arg0); end
  end
end

class IssuesGraph::Proto::GetProjectTrackedByItemsResponse
  include ::Google::Protobuf::MessageExts
  extend ::Google::Protobuf::MessageExts::ClassMethods

  def initialize(*_arg0); end

  def ==(_arg0); end
  def [](_arg0); end
  def []=(_arg0, _arg1); end
  def clone; end
  def dup; end
  def eql?(_arg0); end
  def hash; end
  def inspect; end
  def method_missing(*_arg0); end
  def to_h; end
  def to_s; end

  private

  def respond_to_missing?(*_arg0); end

  class << self
    def decode(_arg0); end
    def decode_json(*_arg0); end
    def descriptor; end
    def encode(_arg0); end
    def encode_json(*_arg0); end
  end
end

class IssuesGraph::Proto::GetTrackingBlockRequest
  include ::Google::Protobuf::MessageExts
  extend ::Google::Protobuf::MessageExts::ClassMethods

  def initialize(*_arg0); end

  def ==(_arg0); end
  def [](_arg0); end
  def []=(_arg0, _arg1); end
  def clone; end
  def dup; end
  def eql?(_arg0); end
  def hash; end
  def inspect; end
  def method_missing(*_arg0); end
  def to_h; end
  def to_s; end

  private

  def respond_to_missing?(*_arg0); end

  class << self
    def decode(_arg0); end
    def decode_json(*_arg0); end
    def descriptor; end
    def encode(_arg0); end
    def encode_json(*_arg0); end
  end
end

class IssuesGraph::Proto::GetTrackingBlockResponse
  include ::Google::Protobuf::MessageExts
  extend ::Google::Protobuf::MessageExts::ClassMethods

  def initialize(*_arg0); end

  def ==(_arg0); end
  def [](_arg0); end
  def []=(_arg0, _arg1); end
  def clone; end
  def dup; end
  def eql?(_arg0); end
  def hash; end
  def inspect; end
  def method_missing(*_arg0); end
  def to_h; end
  def to_s; end

  private

  def respond_to_missing?(*_arg0); end

  class << self
    def decode(_arg0); end
    def decode_json(*_arg0); end
    def descriptor; end
    def encode(_arg0); end
    def encode_json(*_arg0); end
  end
end

class IssuesGraph::Proto::GetTrackingBlocksResponse
  include ::Google::Protobuf::MessageExts
  extend ::Google::Protobuf::MessageExts::ClassMethods

  def initialize(*_arg0); end

  def ==(_arg0); end
  def [](_arg0); end
  def []=(_arg0, _arg1); end
  def clone; end
  def dup; end
  def eql?(_arg0); end
  def hash; end
  def inspect; end
  def method_missing(*_arg0); end
  def to_h; end
  def to_s; end

  private

  def respond_to_missing?(*_arg0); end

  class << self
    def decode(_arg0); end
    def decode_json(*_arg0); end
    def descriptor; end
    def encode(_arg0); end
    def encode_json(*_arg0); end
  end
end

class IssuesGraph::Proto::Issue
  include ::Google::Protobuf::MessageExts
  extend ::Google::Protobuf::MessageExts::ClassMethods

  def initialize(*_arg0); end

  def ==(_arg0); end
  def [](_arg0); end
  def []=(_arg0, _arg1); end
  def clone; end
  def dup; end
  def eql?(_arg0); end
  def hash; end
  def inspect; end
  def method_missing(*_arg0); end
  def to_h; end
  def to_s; end

  private

  def respond_to_missing?(*_arg0); end

  class << self
    def decode(_arg0); end
    def decode_json(*_arg0); end
    def descriptor; end
    def encode(_arg0); end
    def encode_json(*_arg0); end
  end
end

class IssuesGraph::Proto::IssueRelationships
  include ::Google::Protobuf::MessageExts
  extend ::Google::Protobuf::MessageExts::ClassMethods

  def initialize(*_arg0); end

  def ==(_arg0); end
  def [](_arg0); end
  def []=(_arg0, _arg1); end
  def clone; end
  def dup; end
  def eql?(_arg0); end
  def hash; end
  def inspect; end
  def method_missing(*_arg0); end
  def to_h; end
  def to_s; end

  private

  def respond_to_missing?(*_arg0); end

  class << self
    def decode(_arg0); end
    def decode_json(*_arg0); end
    def descriptor; end
    def encode(_arg0); end
    def encode_json(*_arg0); end
  end
end

class IssuesGraph::Proto::IssuesGraphService < ::Twirp::Service; end

module IssuesGraph::Proto::ItemType
  class << self
    def descriptor; end
    def lookup(_arg0); end
    def resolve(_arg0); end
  end
end

# source://issues-graph-client//ruby/lib/issues-graph/proto/v1/service_pb.rb#262
IssuesGraph::Proto::ItemType::DRAFT_ISSUE = T.let(T.unsafe(nil), Integer)

# source://issues-graph-client//ruby/lib/issues-graph/proto/v1/service_pb.rb#262
IssuesGraph::Proto::ItemType::ISSUE = T.let(T.unsafe(nil), Integer)

# source://issues-graph-client//ruby/lib/issues-graph/proto/v1/service_pb.rb#262
IssuesGraph::Proto::ItemType::PULL_REQUEST = T.let(T.unsafe(nil), Integer)

# source://issues-graph-client//ruby/lib/issues-graph/proto/v1/service_pb.rb#262
IssuesGraph::Proto::ItemType::UNDEFINED = T.let(T.unsafe(nil), Integer)

class IssuesGraph::Proto::Key
  include ::Google::Protobuf::MessageExts
  extend ::Google::Protobuf::MessageExts::ClassMethods

  def initialize(*_arg0); end

  def ==(_arg0); end
  def [](_arg0); end
  def []=(_arg0, _arg1); end
  def clone; end
  def dup; end
  def eql?(_arg0); end
  def hash; end
  def inspect; end
  def method_missing(*_arg0); end
  def to_h; end
  def to_s; end

  private

  def respond_to_missing?(*_arg0); end

  class << self
    def decode(_arg0); end
    def decode_json(*_arg0); end
    def descriptor; end
    def encode(_arg0); end
    def encode_json(*_arg0); end
  end
end

class IssuesGraph::Proto::Label
  include ::Google::Protobuf::MessageExts
  extend ::Google::Protobuf::MessageExts::ClassMethods

  def initialize(*_arg0); end

  def ==(_arg0); end
  def [](_arg0); end
  def []=(_arg0, _arg1); end
  def clone; end
  def dup; end
  def eql?(_arg0); end
  def hash; end
  def inspect; end
  def method_missing(*_arg0); end
  def to_h; end
  def to_s; end

  private

  def respond_to_missing?(*_arg0); end

  class << self
    def decode(_arg0); end
    def decode_json(*_arg0); end
    def descriptor; end
    def encode(_arg0); end
    def encode_json(*_arg0); end
  end
end

class IssuesGraph::Proto::NewRelationshipsRequest
  include ::Google::Protobuf::MessageExts
  extend ::Google::Protobuf::MessageExts::ClassMethods

  def initialize(*_arg0); end

  def ==(_arg0); end
  def [](_arg0); end
  def []=(_arg0, _arg1); end
  def clone; end
  def dup; end
  def eql?(_arg0); end
  def hash; end
  def inspect; end
  def method_missing(*_arg0); end
  def to_h; end
  def to_s; end

  private

  def respond_to_missing?(*_arg0); end

  class << self
    def decode(_arg0); end
    def decode_json(*_arg0); end
    def descriptor; end
    def encode(_arg0); end
    def encode_json(*_arg0); end
  end
end

class IssuesGraph::Proto::PrimaryKey
  include ::Google::Protobuf::MessageExts
  extend ::Google::Protobuf::MessageExts::ClassMethods

  def initialize(*_arg0); end

  def ==(_arg0); end
  def [](_arg0); end
  def []=(_arg0, _arg1); end
  def clone; end
  def dup; end
  def eql?(_arg0); end
  def hash; end
  def inspect; end
  def method_missing(*_arg0); end
  def to_h; end
  def to_s; end

  private

  def respond_to_missing?(*_arg0); end

  class << self
    def decode(_arg0); end
    def decode_json(*_arg0); end
    def descriptor; end
    def encode(_arg0); end
    def encode_json(*_arg0); end
  end
end

class IssuesGraph::Proto::Project
  include ::Google::Protobuf::MessageExts
  extend ::Google::Protobuf::MessageExts::ClassMethods

  def initialize(*_arg0); end

  def ==(_arg0); end
  def [](_arg0); end
  def []=(_arg0, _arg1); end
  def clone; end
  def dup; end
  def eql?(_arg0); end
  def hash; end
  def inspect; end
  def method_missing(*_arg0); end
  def to_h; end
  def to_s; end

  private

  def respond_to_missing?(*_arg0); end

  class << self
    def decode(_arg0); end
    def decode_json(*_arg0); end
    def descriptor; end
    def encode(_arg0); end
    def encode_json(*_arg0); end
  end
end

class IssuesGraph::Proto::ProjectsService < ::Twirp::Service; end

module IssuesGraph::Proto::QueryType
  class << self
    def descriptor; end
    def lookup(_arg0); end
    def resolve(_arg0); end
  end
end

# source://issues-graph-client//ruby/lib/issues-graph/proto/v1/service_pb.rb#259
IssuesGraph::Proto::QueryType::DEFAULT = T.let(T.unsafe(nil), Integer)

# source://issues-graph-client//ruby/lib/issues-graph/proto/v1/service_pb.rb#259
IssuesGraph::Proto::QueryType::FORCE_DENORMALIZED = T.let(T.unsafe(nil), Integer)

# source://issues-graph-client//ruby/lib/issues-graph/proto/v1/service_pb.rb#259
IssuesGraph::Proto::QueryType::FORCE_GRAPH = T.let(T.unsafe(nil), Integer)

module IssuesGraph::Proto::RelationshipType
  class << self
    def descriptor; end
    def lookup(_arg0); end
    def resolve(_arg0); end
  end
end

# source://issues-graph-client//ruby/lib/issues-graph/proto/v1/service_pb.rb#261
IssuesGraph::Proto::RelationshipType::AssignedTo = T.let(T.unsafe(nil), Integer)

# source://issues-graph-client//ruby/lib/issues-graph/proto/v1/service_pb.rb#261
IssuesGraph::Proto::RelationshipType::Assignee = T.let(T.unsafe(nil), Integer)

# source://issues-graph-client//ruby/lib/issues-graph/proto/v1/service_pb.rb#261
IssuesGraph::Proto::RelationshipType::BelongsTo = T.let(T.unsafe(nil), Integer)

# source://issues-graph-client//ruby/lib/issues-graph/proto/v1/service_pb.rb#261
IssuesGraph::Proto::RelationshipType::Contains = T.let(T.unsafe(nil), Integer)

# source://issues-graph-client//ruby/lib/issues-graph/proto/v1/service_pb.rb#261
IssuesGraph::Proto::RelationshipType::LabeledBy = T.let(T.unsafe(nil), Integer)

# source://issues-graph-client//ruby/lib/issues-graph/proto/v1/service_pb.rb#261
IssuesGraph::Proto::RelationshipType::Labels = T.let(T.unsafe(nil), Integer)

# source://issues-graph-client//ruby/lib/issues-graph/proto/v1/service_pb.rb#261
IssuesGraph::Proto::RelationshipType::LivesIn = T.let(T.unsafe(nil), Integer)

# source://issues-graph-client//ruby/lib/issues-graph/proto/v1/service_pb.rb#261
IssuesGraph::Proto::RelationshipType::Owns = T.let(T.unsafe(nil), Integer)

# source://issues-graph-client//ruby/lib/issues-graph/proto/v1/service_pb.rb#261
IssuesGraph::Proto::RelationshipType::TrackedBy = T.let(T.unsafe(nil), Integer)

# source://issues-graph-client//ruby/lib/issues-graph/proto/v1/service_pb.rb#261
IssuesGraph::Proto::RelationshipType::Tracks = T.let(T.unsafe(nil), Integer)

# source://issues-graph-client//ruby/lib/issues-graph/proto/v1/service_pb.rb#261
IssuesGraph::Proto::RelationshipType::Undefined = T.let(T.unsafe(nil), Integer)

class IssuesGraph::Proto::RemoveTrackingBlockRequest
  include ::Google::Protobuf::MessageExts
  extend ::Google::Protobuf::MessageExts::ClassMethods

  def initialize(*_arg0); end

  def ==(_arg0); end
  def [](_arg0); end
  def []=(_arg0, _arg1); end
  def clone; end
  def dup; end
  def eql?(_arg0); end
  def hash; end
  def inspect; end
  def method_missing(*_arg0); end
  def to_h; end
  def to_s; end

  private

  def respond_to_missing?(*_arg0); end

  class << self
    def decode(_arg0); end
    def decode_json(*_arg0); end
    def descriptor; end
    def encode(_arg0); end
    def encode_json(*_arg0); end
  end
end

class IssuesGraph::Proto::ReplaceForParentRequest
  include ::Google::Protobuf::MessageExts
  extend ::Google::Protobuf::MessageExts::ClassMethods

  def initialize(*_arg0); end

  def ==(_arg0); end
  def [](_arg0); end
  def []=(_arg0, _arg1); end
  def clone; end
  def dup; end
  def eql?(_arg0); end
  def hash; end
  def inspect; end
  def method_missing(*_arg0); end
  def to_h; end
  def to_s; end

  private

  def respond_to_missing?(*_arg0); end

  class << self
    def decode(_arg0); end
    def decode_json(*_arg0); end
    def descriptor; end
    def encode(_arg0); end
    def encode_json(*_arg0); end
  end
end

class IssuesGraph::Proto::ReplaceForParentResponse
  include ::Google::Protobuf::MessageExts
  extend ::Google::Protobuf::MessageExts::ClassMethods

  def initialize(*_arg0); end

  def ==(_arg0); end
  def [](_arg0); end
  def []=(_arg0, _arg1); end
  def clone; end
  def dup; end
  def eql?(_arg0); end
  def hash; end
  def inspect; end
  def method_missing(*_arg0); end
  def to_h; end
  def to_s; end

  private

  def respond_to_missing?(*_arg0); end

  class << self
    def decode(_arg0); end
    def decode_json(*_arg0); end
    def descriptor; end
    def encode(_arg0); end
    def encode_json(*_arg0); end
  end
end

module IssuesGraph::Proto::ResponseSourceType
  class << self
    def descriptor; end
    def lookup(_arg0); end
    def resolve(_arg0); end
  end
end

# source://issues-graph-client//ruby/lib/issues-graph/proto/v1/service_pb.rb#260
IssuesGraph::Proto::ResponseSourceType::DENORMALIZED = T.let(T.unsafe(nil), Integer)

# source://issues-graph-client//ruby/lib/issues-graph/proto/v1/service_pb.rb#260
IssuesGraph::Proto::ResponseSourceType::GRAPH = T.let(T.unsafe(nil), Integer)

class IssuesGraph::Proto::StatusResponse
  include ::Google::Protobuf::MessageExts
  extend ::Google::Protobuf::MessageExts::ClassMethods

  def initialize(*_arg0); end

  def ==(_arg0); end
  def [](_arg0); end
  def []=(_arg0, _arg1); end
  def clone; end
  def dup; end
  def eql?(_arg0); end
  def hash; end
  def inspect; end
  def method_missing(*_arg0); end
  def to_h; end
  def to_s; end

  private

  def respond_to_missing?(*_arg0); end

  class << self
    def decode(_arg0); end
    def decode_json(*_arg0); end
    def descriptor; end
    def encode(_arg0); end
    def encode_json(*_arg0); end
  end
end

class IssuesGraph::Proto::TrackedByItem
  include ::Google::Protobuf::MessageExts
  extend ::Google::Protobuf::MessageExts::ClassMethods

  def initialize(*_arg0); end

  def ==(_arg0); end
  def [](_arg0); end
  def []=(_arg0, _arg1); end
  def clone; end
  def dup; end
  def eql?(_arg0); end
  def hash; end
  def inspect; end
  def method_missing(*_arg0); end
  def to_h; end
  def to_s; end

  private

  def respond_to_missing?(*_arg0); end

  class << self
    def decode(_arg0); end
    def decode_json(*_arg0); end
    def descriptor; end
    def encode(_arg0); end
    def encode_json(*_arg0); end
  end
end

class IssuesGraph::Proto::TrackingBlock
  include ::Google::Protobuf::MessageExts
  extend ::Google::Protobuf::MessageExts::ClassMethods

  def initialize(*_arg0); end

  def ==(_arg0); end
  def [](_arg0); end
  def []=(_arg0, _arg1); end
  def clone; end
  def dup; end
  def eql?(_arg0); end
  def hash; end
  def inspect; end
  def method_missing(*_arg0); end
  def to_h; end
  def to_s; end

  private

  def respond_to_missing?(*_arg0); end

  class << self
    def decode(_arg0); end
    def decode_json(*_arg0); end
    def descriptor; end
    def encode(_arg0); end
    def encode_json(*_arg0); end
  end
end

class IssuesGraph::Proto::TrackingBlockItem
  include ::Google::Protobuf::MessageExts
  extend ::Google::Protobuf::MessageExts::ClassMethods

  def initialize(*_arg0); end

  def ==(_arg0); end
  def [](_arg0); end
  def []=(_arg0, _arg1); end
  def clone; end
  def dup; end
  def eql?(_arg0); end
  def hash; end
  def inspect; end
  def method_missing(*_arg0); end
  def to_h; end
  def to_s; end

  private

  def respond_to_missing?(*_arg0); end

  class << self
    def decode(_arg0); end
    def decode_json(*_arg0); end
    def descriptor; end
    def encode(_arg0); end
    def encode_json(*_arg0); end
  end
end

class IssuesGraph::Proto::TrackingBlocksService < ::Twirp::Service; end

class IssuesGraph::Proto::UpdateByDiffForParentRequest
  include ::Google::Protobuf::MessageExts
  extend ::Google::Protobuf::MessageExts::ClassMethods

  def initialize(*_arg0); end

  def ==(_arg0); end
  def [](_arg0); end
  def []=(_arg0, _arg1); end
  def clone; end
  def dup; end
  def eql?(_arg0); end
  def hash; end
  def inspect; end
  def method_missing(*_arg0); end
  def to_h; end
  def to_s; end

  private

  def respond_to_missing?(*_arg0); end

  class << self
    def decode(_arg0); end
    def decode_json(*_arg0); end
    def descriptor; end
    def encode(_arg0); end
    def encode_json(*_arg0); end
  end
end

class IssuesGraph::Proto::UpdateByDiffForParentResponse
  include ::Google::Protobuf::MessageExts
  extend ::Google::Protobuf::MessageExts::ClassMethods

  def initialize(*_arg0); end

  def ==(_arg0); end
  def [](_arg0); end
  def []=(_arg0, _arg1); end
  def clone; end
  def dup; end
  def eql?(_arg0); end
  def hash; end
  def inspect; end
  def method_missing(*_arg0); end
  def to_h; end
  def to_s; end

  private

  def respond_to_missing?(*_arg0); end

  class << self
    def decode(_arg0); end
    def decode_json(*_arg0); end
    def descriptor; end
    def encode(_arg0); end
    def encode_json(*_arg0); end
  end
end

class IssuesGraph::Proto::UpdateIssueRequest
  include ::Google::Protobuf::MessageExts
  extend ::Google::Protobuf::MessageExts::ClassMethods

  def initialize(*_arg0); end

  def ==(_arg0); end
  def [](_arg0); end
  def []=(_arg0, _arg1); end
  def clone; end
  def dup; end
  def eql?(_arg0); end
  def hash; end
  def inspect; end
  def method_missing(*_arg0); end
  def to_h; end
  def to_s; end

  private

  def respond_to_missing?(*_arg0); end

  class << self
    def decode(_arg0); end
    def decode_json(*_arg0); end
    def descriptor; end
    def encode(_arg0); end
    def encode_json(*_arg0); end
  end
end

class IssuesGraph::Proto::UpdateTrackingBlockByKeyRequest
  include ::Google::Protobuf::MessageExts
  extend ::Google::Protobuf::MessageExts::ClassMethods

  def initialize(*_arg0); end

  def ==(_arg0); end
  def [](_arg0); end
  def []=(_arg0, _arg1); end
  def clone; end
  def dup; end
  def eql?(_arg0); end
  def hash; end
  def inspect; end
  def method_missing(*_arg0); end
  def to_h; end
  def to_s; end

  private

  def respond_to_missing?(*_arg0); end

  class << self
    def decode(_arg0); end
    def decode_json(*_arg0); end
    def descriptor; end
    def encode(_arg0); end
    def encode_json(*_arg0); end
  end
end

class IssuesGraph::Proto::UpsertProjectAndRelationshipsRequest
  include ::Google::Protobuf::MessageExts
  extend ::Google::Protobuf::MessageExts::ClassMethods

  def initialize(*_arg0); end

  def ==(_arg0); end
  def [](_arg0); end
  def []=(_arg0, _arg1); end
  def clone; end
  def dup; end
  def eql?(_arg0); end
  def hash; end
  def inspect; end
  def method_missing(*_arg0); end
  def to_h; end
  def to_s; end

  private

  def respond_to_missing?(*_arg0); end

  class << self
    def decode(_arg0); end
    def decode_json(*_arg0); end
    def descriptor; end
    def encode(_arg0); end
    def encode_json(*_arg0); end
  end
end

class IssuesGraph::Proto::UpsertProjectAndRelationshipsResponse
  include ::Google::Protobuf::MessageExts
  extend ::Google::Protobuf::MessageExts::ClassMethods

  def initialize(*_arg0); end

  def ==(_arg0); end
  def [](_arg0); end
  def []=(_arg0, _arg1); end
  def clone; end
  def dup; end
  def eql?(_arg0); end
  def hash; end
  def inspect; end
  def method_missing(*_arg0); end
  def to_h; end
  def to_s; end

  private

  def respond_to_missing?(*_arg0); end

  class << self
    def decode(_arg0); end
    def decode_json(*_arg0); end
    def descriptor; end
    def encode(_arg0); end
    def encode_json(*_arg0); end
  end
end

class IssuesGraph::Proto::User
  include ::Google::Protobuf::MessageExts
  extend ::Google::Protobuf::MessageExts::ClassMethods

  def initialize(*_arg0); end

  def ==(_arg0); end
  def [](_arg0); end
  def []=(_arg0, _arg1); end
  def clone; end
  def dup; end
  def eql?(_arg0); end
  def hash; end
  def inspect; end
  def method_missing(*_arg0); end
  def to_h; end
  def to_s; end

  private

  def respond_to_missing?(*_arg0); end

  class << self
    def decode(_arg0); end
    def decode_json(*_arg0); end
    def descriptor; end
    def encode(_arg0); end
    def encode_json(*_arg0); end
  end
end

# PORO envelope for issues-graph client Twirp responses
class IssuesGraph::Result
  # response       - ::Twirp::Response instance. If the response has an error, it'll be used
  #                  to set the @error instance variable of the result object
  # error          - ::Twirp::Error instance
  # original_error - The original error that was rescued and wrapped into the ::Twirp::Error
  # data           - the protobuf data structure to be wrapped by the result object
  #
  # @raise [::IssuesGraph::Errors::ArgumentError]
  # @return [Result] a new instance of Result
  #
  # source://issues-graph-client//ruby/lib/issues-graph/result.rb#38
  def initialize(response: T.unsafe(nil), error: T.unsafe(nil), original_error: T.unsafe(nil), data: T.unsafe(nil)); end

  # Returns the value of attribute data.
  #
  # source://issues-graph-client//ruby/lib/issues-graph/result.rb#31
  def data; end

  # Returns the value of attribute error.
  #
  # source://issues-graph-client//ruby/lib/issues-graph/result.rb#31
  def error; end

  # @return [Boolean]
  #
  # source://issues-graph-client//ruby/lib/issues-graph/result.rb#55
  def error?; end

  # source://issues-graph-client//ruby/lib/issues-graph/result.rb#63
  def error_code; end

  # source://issues-graph-client//ruby/lib/issues-graph/result.rb#59
  def error_message; end

  # Returns the value of attribute original_error.
  #
  # source://issues-graph-client//ruby/lib/issues-graph/result.rb#31
  def original_error; end

  # Returns the value of attribute status.
  #
  # source://issues-graph-client//ruby/lib/issues-graph/result.rb#31
  def status; end

  # @return [Boolean]
  #
  # source://issues-graph-client//ruby/lib/issues-graph/result.rb#51
  def success?; end

  # source://issues-graph-client//ruby/lib/issues-graph/result.rb#67
  def to_h; end

  # ensure that if the @error is present, it will be normalized into a
  # ClientError interface
  #
  # source://issues-graph-client//ruby/lib/issues-graph/result.rb#80
  def wrap_error_for_consumer; end

  class << self
    # creates a result object with an :error status
    #
    # error          - ::Twirp::Error | ClientError | StandardError
    # original_error - optional error intercepted by the client
    #
    # source://issues-graph-client//ruby/lib/issues-graph/result.rb#27
    def error(error, original_error = T.unsafe(nil)); end

    # creates a result object and set its status based on the response provided
    #
    # response - ::Twirp::Response
    #
    # source://issues-graph-client//ruby/lib/issues-graph/result.rb#12
    def response(response); end

    # creates a success result object with the defined data, mainly used for tests
    #
    # data - protobuf response instance
    #
    # source://issues-graph-client//ruby/lib/issues-graph/result.rb#19
    def success(data); end
  end
end
