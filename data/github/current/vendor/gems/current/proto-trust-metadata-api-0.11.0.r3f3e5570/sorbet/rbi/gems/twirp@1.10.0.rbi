# typed: true

# DO NOT EDIT MANUALLY
# This is an autogenerated file for types exported from the `twirp` gem.
# Please instead update this file by running `bin/tapioca gem twirp`.

# source://twirp//lib/twirp/version.rb#14
module Twirp; end

# source://twirp//lib/twirp/client.rb#23
class Twirp::Client
  extend ::Twirp::ServiceDSL

  # Init with a Faraday connection, or a base_url that is used in a default connection.
  # Clients use Content-Type="application/protobuf" by default. For JSON clinets use :content_type => "application/json".
  #
  # @return [Client] a new instance of Client
  #
  # source://twirp//lib/twirp/client.rb#132
  def initialize(conn, opts = T.unsafe(nil)); end

  # Make a remote procedure call to a defined rpc_method. The input can be a Proto message instance,
  # or the attributes (Hash) to instantiate it. Returns a ClientResp instance with an instance of
  # output_class, or a Twirp::Error. The input and output classes are the ones configued with the rpc DSL.
  # If rpc_method was not defined with the rpc DSL then a response with a bad_route error is returned instead.
  #
  # source://twirp//lib/twirp/client.rb#151
  def rpc(rpc_method, input, req_opts = T.unsafe(nil)); end

  private

  # Executes the post-processing on 'resp' in the provided block,
  # either in a call to ".then { ... }" as a promise-like interface,
  # or just execute it directly if the object doesn't support "then".
  # On Ruby 2.6+ all objects have ".then", but they behave the same as
  # a promise-like object, so this behaves identically.
  #
  # This allows extensions of Faraday that return promises to work
  # natively with twirp-ruby. For normal Faraday, this is a noop.
  #
  # source://twirp//lib/twirp/client.rb#179
  def rpc_response_thennable(resp); end

  # source://twirp//lib/twirp/client.rb#187
  def rpc_response_to_clientresp(resp, content_type, rpcdef); end

  class << self
    # DSL (alternative) to define a client from a Service class.
    #
    # source://twirp//lib/twirp/client.rb#31
    def client_for(svclass); end

    # source://twirp//lib/twirp/client.rb#48
    def error_from_response(resp); end

    # @return [Boolean]
    #
    # source://twirp//lib/twirp/client.rb#108
    def is_http_redirect?(status); end

    # source://twirp//lib/twirp/client.rb#112
    def make_http_request(conn, service_full_name, rpc_method, content_type, req_opts, body); end

    # Hook for ServiceDSL#rpc to define a new method client.<ruby_method>(input, req_opts).
    #
    # source://twirp//lib/twirp/client.rb#40
    def rpc_define_method(rpcdef); end

    # Error that was caused by an intermediary proxy like a load balancer.
    # The HTTP errors code from non-twirp sources is mapped to equivalent twirp errors.
    # The mapping is similar to gRPC: https://github.com/grpc/grpc/blob/master/doc/http-grpc-status-mapping.md.
    # Returned twirp Errors have some additional metadata for inspection.
    #
    # source://twirp//lib/twirp/client.rb#78
    def twirp_error_from_intermediary(status, reason, body); end

    # Twirp clients should not follow redirects automatically, Twirp only handles
    # POST requests, redirects should only happen on GET and HEAD requests.
    #
    # source://twirp//lib/twirp/client.rb#98
    def twirp_redirect_error(status, location); end
  end
end

# Convenience class to call any rpc method with dynamic json attributes, without a service definition.
# This is useful to test a service before doing any code-generation.
#
# source://twirp//lib/twirp/client_json.rb#20
class Twirp::ClientJSON < ::Twirp::Client
  # @raise [ArgumentError]
  # @return [ClientJSON] a new instance of ClientJSON
  #
  # source://twirp//lib/twirp/client_json.rb#22
  def initialize(conn, opts = T.unsafe(nil)); end

  # This implementation does not use the defined Protobuf messages to serialize/deserialize data;
  # the request attrs can be anything and the response data is always a plain Hash of attributes.
  #
  # source://twirp//lib/twirp/client_json.rb#34
  def rpc(rpc_method, attrs = T.unsafe(nil), req_opts = T.unsafe(nil)); end

  private

  # source://twirp//lib/twirp/client_json.rb#47
  def rpc_response_to_clientresp(resp); end
end

# source://twirp//lib/twirp/client_resp.rb#15
class Twirp::ClientResp
  # @return [ClientResp] a new instance of ClientResp
  #
  # source://twirp//lib/twirp/client_resp.rb#20
  def initialize(data: T.unsafe(nil), body: T.unsafe(nil), error: T.unsafe(nil)); end

  # Returns the value of attribute body.
  #
  # source://twirp//lib/twirp/client_resp.rb#17
  def body; end

  # Sets the attribute body
  #
  # @param value the value to set the attribute body to.
  #
  # source://twirp//lib/twirp/client_resp.rb#17
  def body=(_arg0); end

  # Returns the value of attribute data.
  #
  # source://twirp//lib/twirp/client_resp.rb#16
  def data; end

  # Sets the attribute data
  #
  # @param value the value to set the attribute data to.
  #
  # source://twirp//lib/twirp/client_resp.rb#16
  def data=(_arg0); end

  # Returns the value of attribute error.
  #
  # source://twirp//lib/twirp/client_resp.rb#18
  def error; end

  # Sets the attribute error
  #
  # @param value the value to set the attribute error to.
  #
  # source://twirp//lib/twirp/client_resp.rb#18
  def error=(_arg0); end
end

# List of all valid error codes in Twirp
#
# source://twirp//lib/twirp/error.rb#41
Twirp::ERROR_CODES = T.let(T.unsafe(nil), Array)

# Valid Twirp error codes and their mapping to related HTTP status.
# This can also be used to check if a code is valid (check if not nil).
#
# source://twirp//lib/twirp/error.rb#18
Twirp::ERROR_CODES_TO_HTTP_STATUS = T.let(T.unsafe(nil), Hash)

# source://twirp//lib/twirp/encoding.rb#18
module Twirp::Encoding
  class << self
    # source://twirp//lib/twirp/encoding.rb#28
    def decode(bytes, msg_class, content_type); end

    # source://twirp//lib/twirp/encoding.rb#49
    def decode_json(bytes); end

    # source://twirp//lib/twirp/encoding.rb#37
    def encode(msg_obj, msg_class, content_type); end

    # source://twirp//lib/twirp/encoding.rb#45
    def encode_json(attrs); end

    # @return [Boolean]
    #
    # source://twirp//lib/twirp/encoding.rb#53
    def valid_content_type?(content_type); end

    # source://twirp//lib/twirp/encoding.rb#57
    def valid_content_types; end
  end
end

# source://twirp//lib/twirp/encoding.rb#19
Twirp::Encoding::JSON = T.let(T.unsafe(nil), String)

# An opt-in content type useful when curling or manually testing a twirp
# service.  This will fail if unknown fields are encountered. The return
# content type will be application/json.
#
# source://twirp//lib/twirp/encoding.rb#23
Twirp::Encoding::JSON_STRICT = T.let(T.unsafe(nil), String)

# source://twirp//lib/twirp/encoding.rb#24
Twirp::Encoding::PROTO = T.let(T.unsafe(nil), String)

# Twirp::Error represents an error response from a Twirp service.
# Twirp::Error is not an Exception to be raised, but a value to be returned
# by service handlers and received by clients.
#
# source://twirp//lib/twirp/error.rb#47
class Twirp::Error
  # Initialize a Twirp::Error
  # The code must be one of the valid ERROR_CODES Symbols (e.g. :internal, :not_found, :permission_denied ...).
  # The msg is a String with the error message.
  # The meta is optional error metadata, if included it must be a Hash with String values.
  #
  # @return [Error] a new instance of Error
  #
  # source://twirp//lib/twirp/error.rb#78
  def initialize(code, msg, meta = T.unsafe(nil)); end

  # used when wrapping another error, but this is not serialized
  #
  # source://twirp//lib/twirp/error.rb#72
  def cause; end

  # used when wrapping another error, but this is not serialized
  #
  # source://twirp//lib/twirp/error.rb#72
  def cause=(_arg0); end

  # Returns the value of attribute code.
  #
  # source://twirp//lib/twirp/error.rb#70
  def code; end

  # source://twirp//lib/twirp/error.rb#98
  def inspect; end

  # Returns the value of attribute meta.
  #
  # source://twirp//lib/twirp/error.rb#70
  def meta; end

  # Returns the value of attribute msg.
  #
  # source://twirp//lib/twirp/error.rb#70
  def msg; end

  # Key-value representation of the error. Can be directly serialized into JSON.
  #
  # source://twirp//lib/twirp/error.rb#85
  def to_h; end

  # source://twirp//lib/twirp/error.rb#94
  def to_s; end

  private

  # source://twirp//lib/twirp/error.rb#105
  def validate_meta(meta); end

  class << self
    # source://twirp//lib/twirp/error.rb#58
    def aborted(msg, meta = T.unsafe(nil)); end

    # source://twirp//lib/twirp/error.rb#58
    def already_exists(msg, meta = T.unsafe(nil)); end

    # source://twirp//lib/twirp/error.rb#58
    def bad_route(msg, meta = T.unsafe(nil)); end

    # source://twirp//lib/twirp/error.rb#58
    def canceled(msg, meta = T.unsafe(nil)); end

    # source://twirp//lib/twirp/error.rb#58
    def data_loss(msg, meta = T.unsafe(nil)); end

    # source://twirp//lib/twirp/error.rb#58
    def deadline_exceeded(msg, meta = T.unsafe(nil)); end

    # source://twirp//lib/twirp/error.rb#58
    def failed_precondition(msg, meta = T.unsafe(nil)); end

    # source://twirp//lib/twirp/error.rb#58
    def internal(msg, meta = T.unsafe(nil)); end

    # Wrap another error as a Twirp::Error :internal.
    #
    # source://twirp//lib/twirp/error.rb#64
    def internal_with(err); end

    # source://twirp//lib/twirp/error.rb#58
    def invalid_argument(msg, meta = T.unsafe(nil)); end

    # source://twirp//lib/twirp/error.rb#58
    def malformed(msg, meta = T.unsafe(nil)); end

    # source://twirp//lib/twirp/error.rb#58
    def not_found(msg, meta = T.unsafe(nil)); end

    # source://twirp//lib/twirp/error.rb#58
    def out_of_range(msg, meta = T.unsafe(nil)); end

    # source://twirp//lib/twirp/error.rb#58
    def permission_denied(msg, meta = T.unsafe(nil)); end

    # source://twirp//lib/twirp/error.rb#58
    def resource_exhausted(msg, meta = T.unsafe(nil)); end

    # source://twirp//lib/twirp/error.rb#58
    def unauthenticated(msg, meta = T.unsafe(nil)); end

    # source://twirp//lib/twirp/error.rb#58
    def unavailable(msg, meta = T.unsafe(nil)); end

    # source://twirp//lib/twirp/error.rb#58
    def unimplemented(msg, meta = T.unsafe(nil)); end

    # source://twirp//lib/twirp/error.rb#58
    def unknown(msg, meta = T.unsafe(nil)); end

    # @return [Boolean]
    #
    # source://twirp//lib/twirp/error.rb#49
    def valid_code?(code); end
  end
end

# source://twirp//lib/twirp/service.rb#21
class Twirp::Service
  extend ::Twirp::ServiceDSL

  # @return [Service] a new instance of Service
  #
  # source://twirp//lib/twirp/service.rb#42
  def initialize(handler); end

  # Setup hook blocks.
  #
  # source://twirp//lib/twirp/service.rb#52
  def before(&block); end

  # Rack app handler.
  #
  # source://twirp//lib/twirp/service.rb#62
  def call(rack_env); end

  # Call the handler method with input attributes or protobuf object.
  # Returns a proto object (response) or a Twirp::Error.
  # Hooks are not called and exceptions are raised instead of being wrapped.
  # This is useful for unit testing the handler. The env should include
  # fake data that is used by the handler, replicating middleware and before hooks.
  #
  # source://twirp//lib/twirp/service.rb#95
  def call_rpc(rpc_method, input = T.unsafe(nil), env = T.unsafe(nil)); end

  # source://twirp//lib/twirp/service.rb#55
  def exception_raised(&block); end

  # Service full_name is needed to route http requests to this service.
  #
  # source://twirp//lib/twirp/service.rb#58
  def full_name; end

  # source://twirp//lib/twirp/service.rb#59
  def name; end

  # source://twirp//lib/twirp/service.rb#54
  def on_error(&block); end

  # source://twirp//lib/twirp/service.rb#53
  def on_success(&block); end

  private

  # Call handler method and return a Protobuf Message or a Twirp::Error.
  #
  # source://twirp//lib/twirp/service.rb#162
  def call_handler(env); end

  # source://twirp//lib/twirp/service.rb#193
  def error_response(twerr, env); end

  # source://twirp//lib/twirp/service.rb#202
  def exception_response(e, env); end

  # source://twirp//lib/twirp/service.rb#156
  def route_err(code, msg, req); end

  # Parse request and fill env with rpc data.
  # Returns a bad_route error if could not be properly routed to a Twirp method.
  # Returns a malformed error if could not decode the body (either bad JSON or bad Protobuf)
  #
  # source://twirp//lib/twirp/service.rb#113
  def route_request(rack_env, env); end

  # source://twirp//lib/twirp/service.rb#179
  def success_response(output, env); end

  class << self
    # Rack response with a Twirp::Error
    #
    # source://twirp//lib/twirp/service.rb#33
    def error_response(twerr); end

    # Whether to raise exceptions instead of handling them with exception_raised hooks.
    # Useful during tests to easily debug and catch unexpected exceptions.
    #
    # source://twirp//lib/twirp/service.rb#30
    def raise_exceptions; end

    # Whether to raise exceptions instead of handling them with exception_raised hooks.
    # Useful during tests to easily debug and catch unexpected exceptions.
    #
    # source://twirp//lib/twirp/service.rb#30
    def raise_exceptions=(_arg0); end
  end
end

# source://twirp//lib/twirp/service_dsl.rb#16
module Twirp::ServiceDSL
  # Configure service package name.
  #
  # source://twirp//lib/twirp/service_dsl.rb#19
  def package(name); end

  # Get configured package name as String.
  # An empty value means that there's no package.
  #
  # source://twirp//lib/twirp/service_dsl.rb#50
  def package_name; end

  # Configure service rpc methods.
  #
  # @raise [ArgumentError]
  #
  # source://twirp//lib/twirp/service_dsl.rb#29
  def rpc(rpc_method, input_class, output_class, opts); end

  # Get raw definitions for rpc methods.
  # This values are used as base env for handler methods.
  #
  # source://twirp//lib/twirp/service_dsl.rb#69
  def rpcs; end

  # Configure service name.
  #
  # source://twirp//lib/twirp/service_dsl.rb#24
  def service(name); end

  # Service name with package prefix, which should uniquelly identifiy the service,
  # for example "example.v3.Haberdasher" for package "example.v3" and service "Haberdasher".
  # This can be used as a path prefix to route requests to the service, because a Twirp URL is:
  # "#{base_url}/#{service_full_name}/#{method]"
  #
  # source://twirp//lib/twirp/service_dsl.rb#63
  def service_full_name; end

  # Service name as String. Defaults to the class name.
  #
  # source://twirp//lib/twirp/service_dsl.rb#55
  def service_name; end
end

# source://twirp//lib/twirp/version.rb#15
Twirp::VERSION = T.let(T.unsafe(nil), String)
