# typed: false

# DO NOT EDIT MANUALLY
# This is an autogenerated file for types exported from the `hydro-client` gem.
# Please instead update this file by running `bin/tapioca gem hydro-client`.

module Google::Protobuf::MessageExts::ClassMethods; end

# A container for raw messages read from a hydro source.
module Hydro
  class << self
    # source://hydro-client//lib/hydro.rb#43
    def consumer_logger; end

    # source://hydro-client//lib/hydro.rb#47
    def consumer_logger=(logger); end

    # source://hydro-client//lib/hydro/instrumenter.rb#38
    def instrumenter; end

    # source://hydro-client//lib/hydro/instrumenter.rb#48
    def instrumenter=(instrumenter); end

    # Loads generated Hydro schemas. Temporarily alters the load path so that
    # `require` statements within generated protobufs work.
    #
    # directory - Required String|Pathname directory where Hydro schemas live.
    #
    # source://hydro-client//lib/hydro.rb#64
    def load_schemas(directory); end

    # source://hydro-client//lib/hydro.rb#35
    def logger; end

    # source://hydro-client//lib/hydro.rb#39
    def logger=(logger); end

    # source://hydro-client//lib/hydro.rb#51
    def publisher_logger; end

    # source://hydro-client//lib/hydro.rb#55
    def publisher_logger=(logger); end

    # gRPC generated service files expect Protobuf generated files to be in the
    # load path without prefixes.
    #
    # source://hydro-client//lib/hydro/generated.rb#4
    def with_generated_files(&block); end
  end
end

class Hydro::AsyncSink
  include ::Hydro::Batching

  # The AsyncSink buffers messages and flushes to another sink in a background
  # thread.
  #
  # sink             - A Hydro::Sink to which messages will be flushed.
  # flush_interval   - The Integer interval in seconds to flush writes.
  # flush_threshold  - The Integer number of buffered messages that triggers an automatic flush.
  # max_buffer_size  - The Integer max number of messages to buffer. The sink will reject writes
  #                    once the max buffer size is reached.
  # max_buffer_bytes - The Integer max number of bytes to buffer. The sink will reject writes
  #                    once the buffer contains the max number of bytes.
  # max_flush_bytes  - The Integer max number of bytes per flush. If the buffer contains more than
  #                    the max bytes, the delivery thread will subdivide the buffer into smaller
  #                    batches.
  #
  # @return [AsyncSink] a new instance of AsyncSink
  #
  # source://hydro-client//lib/hydro/sink/async_sink.rb#36
  def initialize(sink:, flush_interval: T.unsafe(nil), flush_threshold: T.unsafe(nil), max_buffer_size: T.unsafe(nil), max_buffer_bytes: T.unsafe(nil), max_flush_bytes: T.unsafe(nil)); end

  # source://hydro-client//lib/hydro/sink/async_sink.rb#90
  def close; end

  # source://hydro-client//lib/hydro/sink/async_sink.rb#61
  def write(messages, options = T.unsafe(nil)); end

  private

  # @return [Boolean]
  #
  # source://hydro-client//lib/hydro/sink/async_sink.rb#116
  def delivery_thread_started?; end

  # source://hydro-client//lib/hydro/sink/async_sink.rb#145
  def drain_buffer; end

  # source://hydro-client//lib/hydro/sink/async_sink.rb#98
  def flush; end

  # source://hydro-client//lib/hydro/sink/async_sink.rb#172
  def instrument_buffer_usage; end

  # source://hydro-client//lib/hydro/sink/async_sink.rb#181
  def instrument_flush_error(error); end

  # source://hydro-client//lib/hydro/sink/async_sink.rb#120
  def start_delivery_thread; end

  # source://hydro-client//lib/hydro/sink/async_sink.rb#107
  def start_scheduler_thread(interval); end
end

# Represents a change in buffer usage.
#
# source://hydro-client//lib/hydro/sink/async_sink.rb#15
Hydro::AsyncSink::BUFFER_EVENT = T.let(T.unsafe(nil), String)

class Hydro::AsyncSink::Buffer
  # @return [Buffer] a new instance of Buffer
  #
  # source://hydro-client//lib/hydro/sink/async_sink.rb#186
  def initialize; end

  # source://hydro-client//lib/hydro/sink/async_sink.rb#199
  def bytesize; end

  # source://hydro-client//lib/hydro/sink/async_sink.rb#203
  def concat(messages); end

  # source://hydro-client//lib/hydro/sink/async_sink.rb#195
  def count; end

  # source://hydro-client//lib/hydro/sink/async_sink.rb#217
  def drain(max_batch_bytes:); end

  # source://hydro-client//lib/hydro/sink/async_sink.rb#210
  def unshift(messages); end
end

# Limit buffer to 32MB.
#
# source://hydro-client//lib/hydro/sink/async_sink.rb#9
Hydro::AsyncSink::DEFAULT_MAX_BUFFER_BYTES = T.let(T.unsafe(nil), Integer)

# Limit buffer to 10k messages.
#
# source://hydro-client//lib/hydro/sink/async_sink.rb#6
Hydro::AsyncSink::DEFAULT_MAX_BUFFER_SIZE = T.let(T.unsafe(nil), Integer)

# Limit flushed batches to 10MB.
#
# source://hydro-client//lib/hydro/sink/async_sink.rb#12
Hydro::AsyncSink::DEFAULT_MAX_FLUSH_BYTES = T.let(T.unsafe(nil), Integer)

# Represents an error flushing events to the sink.
#
# source://hydro-client//lib/hydro/sink/async_sink.rb#21
Hydro::AsyncSink::FLUSH_ERROR_EVENT = T.let(T.unsafe(nil), String)

# Represents an attempt to flush events to the sink.
#
# source://hydro-client//lib/hydro/sink/async_sink.rb#18
Hydro::AsyncSink::FLUSH_EVENT = T.let(T.unsafe(nil), String)

# Provides a basic batching implementation for a sink.
module Hydro::Batching
  # Internal: add messages to the current batch.
  #
  # Used by sink implementations within `write` to add to a batch instead of
  # writing to the normal message destination when `batching?` is true.
  #
  # source://hydro-client//lib/hydro/sink/batching.rb#46
  def add_to_batch(messages); end

  # Internal: the current batch, an Array of messages.
  #
  # source://hydro-client//lib/hydro/sink/batching.rb#38
  def batch; end

  # Internal: does this sink support batching?
  #
  # @return [Boolean]
  #
  # source://hydro-client//lib/hydro/sink/batching.rb#52
  def batchable?; end

  # Public: is the sink in batching mode?
  #
  # @return [Boolean]
  #
  # source://hydro-client//lib/hydro/sink/batching.rb#28
  def batching?; end

  # Public: flush the current batch.
  #
  # Sets batching to false, and uses the sink `write` method to write the
  # entire batch at once.
  #
  # source://hydro-client//lib/hydro/sink/batching.rb#17
  def flush_batch(options = T.unsafe(nil)); end

  # Public: is there anything in the batch that can be flushed?
  #
  # @return [Boolean]
  #
  # source://hydro-client//lib/hydro/sink/batching.rb#33
  def flushable?; end

  # Public: start batching mode.
  #
  # When enabled, messages will be written to a buffer instead of published
  # directly to the destination system.
  #
  # source://hydro-client//lib/hydro/sink/batching.rb#9
  def start_batch; end
end

class Hydro::Client
  # Build a Hydro::Client.
  #
  # environment - The Symbol :development, :test, :production, or :ghes.
  #
  # @return [Client] a new instance of Client
  #
  # source://hydro-client//lib/hydro/client.rb#9
  def initialize(environment: T.unsafe(nil)); end

  # Public: Build a Hydro::Consumer.
  #
  # decoder - Optional Hydro::Decoder used to decode messages. Defaults to
  #           the protobuf decoder.
  # source  - Optional Hydro::Source from which to read messages. Defaults to
  #           the default source for the environment:
  #           :development - Hydro::KafkaSource when the `seed_brokers` option
  #                          is present, otherwise a Hydro::FileSource.
  #           :test        - A Hydro::MemorySource.
  #           :production  - A Hydro::KafkaSource.
  # deliver_tombstone_messages - Optional boolean to allow the delivery of tombstone messages.
  #           Defaults to false.
  # options - Optional Hash passed along to the default Hydro::Source.
  #           :subscribe_to - String, Regexp, Array<String> or Array<Regexp>.
  #                           Required in production for Hydro::KafkaSource.
  #           :group_id     - Required in production for Hydro::KafkaSource.
  # Example:
  #
  #   client = Hydro::Client.new(environment: :production)
  #
  #   # Use defaults
  #   consumer = client.consumer({
  #     group_id: "my-hydro-consumer",
  #     subscribe_to: ["my-topic"],
  #   })
  #
  #   # Mostly defaults
  #   consumer = client.consumer({
  #     group_id: "my-hydro-consumer",
  #     subscribe_to: /*.my-topic/,
  #     seed_brokers: ["localhost:9092"],
  #     commit_offsets: false,
  #   })
  #
  #   # Override the source
  #   sink = Hydro::MemorySink.new
  #   client.consumer({
  #     source: Hydro::MemorySource.new(sink: sink),
  #   })
  #
  #   client.consumer({
  #     # options passed through to the source
  #   })
  #
  # Returns a Hydro::Consumer.
  #
  # source://hydro-client//lib/hydro/client.rb#143
  def consumer(decoder: T.unsafe(nil), source: T.unsafe(nil), decode_failure_handler: T.unsafe(nil), deliver_tombstone_messages: T.unsafe(nil), **options); end

  # Public: Build a Hydro::Publisher.
  #
  # sink      - Optional Hydro::Sink to which messages will be written.
  #             Defaults to the default sink for the environment:
  #             :development - Hydro::KafkaSink when the `seed_brokers`
  #                            option is present, otherwise a
  #                            Hydro::FileSink.
  #             :test        - A Hydro::MemorySink.
  #             :production  - A Hydro::KafkaSink.
  # encoder   - Optional Hydro::Encoder used to encode messages. Defaults to
  #             the protobuf encoder.
  # site      - Optional String site of origin.
  # topic_format_options - Optional default topic format options to use for publishing.
  # default_headers_proc - Optional proc that returns a hash (string keys and values) that will be set
  #                        as headers on all published messages
  # options              - Optional Hash passed along to the default Hydro::Sink.
  #                        :client_id - Required in production for Hydro::KafkaSink.
  #
  # Example:
  #
  #   client = Hydro::Client.new(environment: :production)
  #
  #   # Use defaults
  #   publisher = client.publisher({
  #     client_id: "my-hydro-publisher",
  #   })
  #
  #   # Mostly use defaults
  #   publisher = client.publisher({
  #     client_id: "my-hydro-publisher",
  #     seed_brokers: ["localhost:9092"]
  #   })
  #
  #   # Override the sink and site
  #   publisher = client.publisher({
  #     client_id: "my-hydro-publisher",
  #     sink: Hydro::MemorySink.new,
  #     site: "sdc42-sea",
  #   })
  #
  #   # Provide Kafka client SSL configuration. See: https://github.com/zendesk/ruby-kafka#setting-up-the-kafka-client
  #   sink = Hydro::KafkaSink.new({
  #     seed_brokers: ["hudson-1:9093", "hudson-2:9093"],
  #     client_id: "my-hydro-publisher",
  #     client_options: {ssl_ca_cert: File.read('/etc/ssl/cert.pem')},
  #     async: false,
  #   })
  #   publisher = client.publisher(sink: sink)
  #
  # Returns a Hydro::Publisher.
  #
  # source://hydro-client//lib/hydro/client.rb#69
  def publisher(sink: T.unsafe(nil), encoder: T.unsafe(nil), site: T.unsafe(nil), topic_format_options: T.unsafe(nil), default_headers_proc: T.unsafe(nil), **options); end

  # Public: Run a Hydro::Processor.
  # processor - Required Hydro::Processor instance.
  # consumer  - Optional Hydro::Consumer. Defaults to the default consumer for
  #             the environment.
  # options   - Optional Hash passed to the Hydro::Executor.
  #
  # Examples:
  #
  #   client = Hydro::Client.new(environment: :production)
  #   processor = MyHydroProcessor.new
  #   client.run(processor)
  #
  # Runs until the process receives a SIGINT.
  #
  # source://hydro-client//lib/hydro/client.rb#92
  def run(processor, consumer: T.unsafe(nil), **options); end

  private

  # Returns the value of attribute defaults.
  #
  # source://hydro-client//lib/hydro/client.rb#154
  def defaults; end
end

module Hydro::Client::Defaults; end

module Hydro::Client::Defaults::Basic
  extend ::Hydro::Client::Defaults::Basic

  # source://hydro-client//lib/hydro/client.rb#170
  def decoder; end

  # source://hydro-client//lib/hydro/client.rb#166
  def encoder(site); end

  # source://hydro-client//lib/hydro/client.rb#158
  def sink(**options); end

  # source://hydro-client//lib/hydro/client.rb#162
  def source(**options); end
end

module Hydro::Client::Defaults::Development
  extend ::Hydro::Client::Defaults::Basic
  extend ::Hydro::Client::Defaults::Development

  # source://hydro-client//lib/hydro/client.rb#186
  def sink(**options); end

  # source://hydro-client//lib/hydro/client.rb#202
  def source(**options); end
end

# source://hydro-client//lib/hydro/client.rb#184
Hydro::Client::Defaults::Development::FILENAME = T.let(T.unsafe(nil), String)

module Hydro::Client::Defaults::GHES
  extend ::Hydro::Client::Defaults::Basic
  extend ::Hydro::Client::Defaults::GHES

  # source://hydro-client//lib/hydro/client.rb#257
  def sink(client_id:, **options); end

  # source://hydro-client//lib/hydro/client.rb#265
  def source(subscribe_to:, **options); end
end

# source://hydro-client//lib/hydro/client.rb#253
Hydro::Client::Defaults::GHES::BROKERS = T.let(T.unsafe(nil), Array)

class Hydro::Client::Defaults::Null
  # @return [Null] a new instance of Null
  #
  # source://hydro-client//lib/hydro/client.rb#277
  def initialize(env); end

  # source://hydro-client//lib/hydro/client.rb#282
  def decoder(*args); end

  # source://hydro-client//lib/hydro/client.rb#282
  def encoder(*args); end

  # source://hydro-client//lib/hydro/client.rb#282
  def sink(*args); end

  # source://hydro-client//lib/hydro/client.rb#282
  def source(*args); end
end

module Hydro::Client::Defaults::Production
  extend ::Hydro::Client::Defaults::Basic
  extend ::Hydro::Client::Defaults::Production

  # source://hydro-client//lib/hydro/client.rb#227
  def sink(client_id:, **options); end

  # source://hydro-client//lib/hydro/client.rb#238
  def source(subscribe_to:, **options); end
end

# source://hydro-client//lib/hydro/client.rb#219
Hydro::Client::Defaults::Production::BROKERS = T.let(T.unsafe(nil), Array)

# source://hydro-client//lib/hydro/client.rb#225
Hydro::Client::Defaults::Production::SSL_CERT = T.let(T.unsafe(nil), String)

module Hydro::Client::Defaults::Test
  extend ::Hydro::Client::Defaults::Basic
end

class Hydro::Consumer
  # Provides an interface for reading decoded messages from a Hydro::Source.
  #
  # source  - a Hydro::Source e.g. Hydro::MemorySource
  # decoder - a Hydro::Decoder e.g. Hydro::ProtobufDecoder
  # deliver_tombstone_messages - a boolean. Enables delivery of tombstone messages which have a `nil` value
  # decode_failure_handler a Proc to call on decode failures
  #
  # @return [Consumer] a new instance of Consumer
  #
  # source://hydro-client//lib/hydro/consumer.rb#11
  def initialize(source:, decoder:, deliver_tombstone_messages: T.unsafe(nil), decode_failure_handler: T.unsafe(nil)); end

  # source://hydro-client//lib/hydro/consumer.rb#85
  def close; end

  # Public: Store the uncommitted offset high water mark.
  #
  # Returns nothing.
  #
  # source://hydro-client//lib/hydro/consumer.rb#114
  def commit_offsets; end

  # Returns the value of attribute deliver_tombstone_messages.
  #
  # source://hydro-client//lib/hydro/consumer.rb#3
  def deliver_tombstone_messages; end

  # Public: Yields successive batches of decoded messages from the source.
  # Decoded messages expose message metadata like timestamp, offset and site
  # of origin.
  #
  # block - a Proc to process each batch
  #
  # source://hydro-client//lib/hydro/consumer.rb#27
  def each_batch; end

  # Public: Yields individual decoded messages from the source.
  # Decoded messages expose message metadata like timestamp, offset and site
  # of origin.
  #
  # block - a Proc to process each batch
  #
  # source://hydro-client//lib/hydro/consumer.rb#60
  def each_message; end

  # Public: Mark a message as processed. Message offsets are not guaranteed
  # to be committed until `commit_offsets` is called. Manually marking
  # messages as processed is only necessary if the
  # `automatically_mark_as_processed` option is `false`.
  #
  # message - a Hydro::Consumer::ConsumerMessage
  #
  # Example:
  #
  #   consumer.each_batch do |batch|
  #     message_1, message_2 = batch[0], batch[1]
  #
  #     # Do some processing
  #     save(message_1)
  #     save(message_2)
  #
  #     consumer.mark_message_as_processed(message_2)
  #   end
  #
  # source://hydro-client//lib/hydro/consumer.rb#107
  def mark_message_as_processed(message); end

  # source://hydro-client//lib/hydro/consumer.rb#18
  def open; end

  # Returns the value of attribute source.
  #
  # source://hydro-client//lib/hydro/consumer.rb#3
  def source; end

  # Public: Send a heartbeat manually to the source
  #
  # Returns nothing
  #
  # source://hydro-client//lib/hydro/consumer.rb#121
  def trigger_heartbeat; end

  private

  # source://hydro-client//lib/hydro/consumer.rb#129
  def decode(message); end

  # Returns the value of attribute decode_failure_handler.
  #
  # source://hydro-client//lib/hydro/consumer.rb#127
  def decode_failure_handler; end

  # Returns the value of attribute decoder.
  #
  # source://hydro-client//lib/hydro/consumer.rb#127
  def decoder; end
end

class Hydro::Consumer::ConsumerMessage
  # @return [ConsumerMessage] a new instance of ConsumerMessage
  #
  # source://hydro-client//lib/hydro/consumer.rb#143
  def initialize(source_message:, schema:, timestamp:, id:, value:); end

  # source://hydro-client//lib/hydro/consumer.rb#167
  def headers; end

  # Returns the value of attribute id.
  #
  # source://hydro-client//lib/hydro/consumer.rb#141
  def id; end

  # source://hydro-client//lib/hydro/consumer.rb#163
  def key; end

  # source://hydro-client//lib/hydro/consumer.rb#159
  def offset; end

  # source://hydro-client//lib/hydro/consumer.rb#155
  def partition; end

  # Returns the value of attribute schema.
  #
  # source://hydro-client//lib/hydro/consumer.rb#141
  def schema; end

  # Returns the value of attribute source_message.
  #
  # source://hydro-client//lib/hydro/consumer.rb#141
  def source_message; end

  # Returns the value of attribute timestamp.
  #
  # source://hydro-client//lib/hydro/consumer.rb#141
  def timestamp; end

  # source://hydro-client//lib/hydro/consumer.rb#151
  def topic; end

  # Returns the value of attribute value.
  #
  # source://hydro-client//lib/hydro/consumer.rb#141
  def value; end
end

class Hydro::DatadogReporter
  # Reports Hydro metrics to Datadog.
  #
  # dogstatsd    - Required Datadog statsd reporter instance
  # default_tags - Optional Array<String> of tags to apply to all metrics
  # client_id    - Optional String unique client identifier for tagging metrics (deprecated, use default_tags)
  #
  # @return [DatadogReporter] a new instance of DatadogReporter
  #
  # source://hydro-client//lib/hydro/datadog_reporter.rb#12
  def initialize(dogstatsd:, default_tags: T.unsafe(nil), client_id: T.unsafe(nil)); end

  # source://hydro-client//lib/hydro/datadog_reporter.rb#18
  def add_default_tags(tags = T.unsafe(nil)); end

  # source://hydro-client//lib/hydro/datadog_reporter.rb#22
  def start; end

  private

  # source://hydro-client//lib/hydro/datadog_reporter.rb#257
  def consumer_tags(payload); end

  # Returns the value of attribute default_tags.
  #
  # source://hydro-client//lib/hydro/datadog_reporter.rb#244
  def default_tags; end

  # source://hydro-client//lib/hydro/datadog_reporter.rb#246
  def statsd; end

  # source://hydro-client//lib/hydro/datadog_reporter.rb#250
  def subscribe(event, &block); end

  # source://hydro-client//lib/hydro/datadog_reporter.rb#262
  def to_tags(hash); end

  class << self
    # source://hydro-client//lib/hydro/datadog_reporter.rb#3
    def start(args); end
  end
end

module Hydro::Decoding; end

class Hydro::Decoding::DecodedMessage
  # A decoded message container.
  #
  # message   - a Hash containing decoded data
  # schema    - a String schema name.
  # timestamp - a Numeric UNIX message timestamp.
  # id        - a UUID identifying the hydro message
  #
  # @return [DecodedMessage] a new instance of DecodedMessage
  #
  # source://hydro-client//lib/hydro/decoding/decoded_message.rb#11
  def initialize(message, schema:, timestamp:, id:); end

  # Returns the value of attribute id.
  #
  # source://hydro-client//lib/hydro/decoding/decoded_message.rb#4
  def id; end

  # Returns the value of attribute message.
  #
  # source://hydro-client//lib/hydro/decoding/decoded_message.rb#4
  def message; end

  # Returns the value of attribute schema.
  #
  # source://hydro-client//lib/hydro/decoding/decoded_message.rb#4
  def schema; end

  # Returns the value of attribute timestamp.
  #
  # source://hydro-client//lib/hydro/decoding/decoded_message.rb#4
  def timestamp; end

  # source://hydro-client//lib/hydro/decoding/decoded_message.rb#18
  def to_h; end
end

class Hydro::Decoding::ProtobufDecoder
  # @return [ProtobufDecoder] a new instance of ProtobufDecoder
  #
  # source://hydro-client//lib/hydro/decoding/protobuf_decoder.rb#8
  def initialize(pool: T.unsafe(nil)); end

  # Public: Decode an encoded protobuf message.
  #
  #   bytes - A String encoded protobuf message
  #
  # Returns a DecodedMessage.
  #
  # source://hydro-client//lib/hydro/decoding/protobuf_decoder.rb#17
  def decode(bytes); end

  private

  # Returns the value of attribute pool.
  #
  # source://hydro-client//lib/hydro/decoding/protobuf_decoder.rb#32
  def pool; end

  class << self
    # source://hydro-client//lib/hydro/decoding/protobuf_decoder.rb#4
    def decode(*args); end
  end
end

class Hydro::DirtyExit < ::RuntimeError; end

# Raised when a message cannot be encoded.
class Hydro::EncodingError < ::Hydro::Error; end

class Hydro::Error < ::StandardError
  # @return [Error] a new instance of Error
  #
  # source://hydro-client//lib/hydro/error.rb#5
  def initialize(message, original_exception: T.unsafe(nil), context: T.unsafe(nil)); end

  # source://hydro-client//lib/hydro/error.rb#11
  def backtrace; end

  # Returns the value of attribute context.
  #
  # source://hydro-client//lib/hydro/error.rb#3
  def context; end

  # source://hydro-client//lib/hydro/error.rb#15
  def failbot_context; end

  # Returns the value of attribute original_exception.
  #
  # source://hydro-client//lib/hydro/error.rb#3
  def original_exception; end
end

class Hydro::Executor
  # Public: Build a new executor to run a processor as a service.
  #
  # process          - A Hydro::Processor instance.
  # consumer         - A Hydro::Consumer to pull messages from.
  # shutdown_signals - An Array<Symbol> of UNIX signals that should shut down the processor.
  #
  # @return [Executor] a new instance of Executor
  #
  # source://hydro-client//lib/hydro/executor.rb#8
  def initialize(processor:, consumer:, shutdown_signals: T.unsafe(nil)); end

  # source://hydro-client//lib/hydro/executor.rb#14
  def run; end

  # source://hydro-client//lib/hydro/executor.rb#27
  def run_processor_loop; end

  private

  # Returns the value of attribute consumer.
  #
  # source://hydro-client//lib/hydro/executor.rb#38
  def consumer; end

  # Returns the value of attribute processor.
  #
  # source://hydro-client//lib/hydro/executor.rb#38
  def processor; end

  # source://hydro-client//lib/hydro/executor.rb#64
  def setup_signal_handlers; end

  # source://hydro-client//lib/hydro/executor.rb#57
  def shutdown; end

  # source://hydro-client//lib/hydro/executor.rb#102
  def shutdown_signal_names; end

  # Returns the value of attribute shutdown_signals.
  #
  # source://hydro-client//lib/hydro/executor.rb#38
  def shutdown_signals; end

  # source://hydro-client//lib/hydro/executor.rb#40
  def start; end

  # source://hydro-client//lib/hydro/executor.rb#82
  def wait_for_threads; end
end

class Hydro::FileSink
  include ::Hydro::Batching

  # Build a Hydro::Sink that writes messages to a file.
  #
  # filename - the String or Pathname name of the target file.
  #
  # @return [FileSink] a new instance of FileSink
  #
  # source://hydro-client//lib/hydro/sink/file_sink.rb#10
  def initialize(filename:); end

  # source://hydro-client//lib/hydro/sink/file_sink.rb#28
  def close; end

  # Returns the value of attribute file.
  #
  # source://hydro-client//lib/hydro/sink/file_sink.rb#5
  def file; end

  # source://hydro-client//lib/hydro/sink/file_sink.rb#14
  def write(messages, options = T.unsafe(nil)); end
end

class Hydro::FileSource
  # Build a Hydro::Source that reads from a file containing serialized
  # Hydro::Messages.
  #
  # filename     - the String or Pathname name of the target file.
  # subscribe_to - the optional String or Regex message topic name.
  # interval     - the Integer polling interval.
  #
  # @return [FileSource] a new instance of FileSource
  #
  # source://hydro-client//lib/hydro/source/file_source.rb#9
  def initialize(filename:, group_id: T.unsafe(nil), subscribe_to: T.unsafe(nil), interval: T.unsafe(nil), **options); end

  # source://hydro-client//lib/hydro/source/file_source.rb#57
  def close; end

  # source://hydro-client//lib/hydro/source/file_source.rb#65
  def commit_offsets; end

  # source://hydro-client//lib/hydro/source/file_source.rb#19
  def each_batch; end

  # source://hydro-client//lib/hydro/source/file_source.rb#51
  def each_message(&block); end

  # source://hydro-client//lib/hydro/source/file_source.rb#61
  def mark_message_as_processed(message); end

  # source://hydro-client//lib/hydro/source/file_source.rb#15
  def open; end

  # source://hydro-client//lib/hydro/source/file_source.rb#69
  def trigger_heartbeat; end

  private

  # Returns the value of attribute file.
  #
  # source://hydro-client//lib/hydro/source/file_source.rb#79
  def file; end

  # Returns the value of attribute interval.
  #
  # source://hydro-client//lib/hydro/source/file_source.rb#79
  def interval; end

  # source://hydro-client//lib/hydro/source/file_source.rb#75
  def subscribe_to; end
end

class Hydro::Gateway::Api::V2::ProduceRequest
  include ::Google::Protobuf::MessageExts
  extend ::Google::Protobuf::MessageExts::ClassMethods

  def initialize(*_arg0); end

  def ==(_arg0); end
  def [](_arg0); end
  def []=(_arg0, _arg1); end
  def clone; end
  def dup; end
  def eql?(_arg0); end
  def hash; end
  def inspect; end
  def method_missing(*_arg0); end
  def to_h; end
  def to_s; end

  private

  def respond_to_missing?(*_arg0); end

  class << self
    def decode(_arg0); end
    def decode_json(*_arg0); end
    def descriptor; end
    def encode(_arg0); end
    def encode_json(*_arg0); end
  end
end

class Hydro::Gateway::Api::V2::ProduceRequest::Message
  include ::Google::Protobuf::MessageExts
  extend ::Google::Protobuf::MessageExts::ClassMethods

  def initialize(*_arg0); end

  def ==(_arg0); end
  def [](_arg0); end
  def []=(_arg0, _arg1); end
  def clone; end
  def dup; end
  def eql?(_arg0); end
  def hash; end
  def inspect; end
  def method_missing(*_arg0); end
  def to_h; end
  def to_s; end

  private

  def respond_to_missing?(*_arg0); end

  class << self
    def decode(_arg0); end
    def decode_json(*_arg0); end
    def descriptor; end
    def encode(_arg0); end
    def encode_json(*_arg0); end
  end
end

class Hydro::Gateway::Api::V2::ProduceRequest::Message::MessageHeader
  include ::Google::Protobuf::MessageExts
  extend ::Google::Protobuf::MessageExts::ClassMethods

  def initialize(*_arg0); end

  def ==(_arg0); end
  def [](_arg0); end
  def []=(_arg0, _arg1); end
  def clone; end
  def dup; end
  def eql?(_arg0); end
  def hash; end
  def inspect; end
  def method_missing(*_arg0); end
  def to_h; end
  def to_s; end

  private

  def respond_to_missing?(*_arg0); end

  class << self
    def decode(_arg0); end
    def decode_json(*_arg0); end
    def descriptor; end
    def encode(_arg0); end
    def encode_json(*_arg0); end
  end
end

class Hydro::Gateway::Api::V2::ProduceResponse
  include ::Google::Protobuf::MessageExts
  extend ::Google::Protobuf::MessageExts::ClassMethods

  def initialize(*_arg0); end

  def ==(_arg0); end
  def [](_arg0); end
  def []=(_arg0, _arg1); end
  def clone; end
  def dup; end
  def eql?(_arg0); end
  def hash; end
  def inspect; end
  def method_missing(*_arg0); end
  def to_h; end
  def to_s; end

  private

  def respond_to_missing?(*_arg0); end

  class << self
    def decode(_arg0); end
    def decode_json(*_arg0); end
    def descriptor; end
    def encode(_arg0); end
    def encode_json(*_arg0); end
  end
end

class Hydro::Gateway::Api::V2::ProduceResponse::DeliveryFailure
  include ::Google::Protobuf::MessageExts
  extend ::Google::Protobuf::MessageExts::ClassMethods

  def initialize(*_arg0); end

  def ==(_arg0); end
  def [](_arg0); end
  def []=(_arg0, _arg1); end
  def clone; end
  def dup; end
  def eql?(_arg0); end
  def hash; end
  def inspect; end
  def method_missing(*_arg0); end
  def to_h; end
  def to_s; end

  private

  def respond_to_missing?(*_arg0); end

  class << self
    def decode(_arg0); end
    def decode_json(*_arg0); end
    def descriptor; end
    def encode(_arg0); end
    def encode_json(*_arg0); end
  end
end

class Hydro::Gateway::Api::V2::ServiceService < ::Twirp::Service; end

class Hydro::GatewaySink
  include ::Hydro::Batching

  # Build a new Hydro::GatewaySink
  #
  # client_id                - A String used to identify clients in requests.
  # cluster                  - A String destination kafka cluster.
  # url                      - A String URL of the gateway twirp service.
  # timeout                  - An optional Integer HTTP timeout in seconds.
  # max_retries              - An optional Integer max retry count. Controls both HTTP retries and
  #                            gateway delivery failure retries. Note than when produce requests
  #                            are retried by GatewaySink or the gateway itself, there is a risk
  #                            of message re-ordering.
  # retriable_twirp_errors   - An optional Array<Symbol> of retriable twirp errors.
  # retriable_faraday_errors - An optional Array<Class> of retriable Faraday errors.
  # block                    - An optional block that receives the Faraday connection builder.
  #                            Can be used to customize the Faraday adapter and middleware.
  #                            Users are highly encouraged to substitute an adapter that supports
  #                            persistent HTTP connections.
  #
  # @return [GatewaySink] a new instance of GatewaySink
  #
  # source://hydro-client//lib/hydro/sink/gateway_sink.rb#63
  def initialize(client_id:, cluster:, url:, timeout: T.unsafe(nil), max_retries: T.unsafe(nil), retry_backoff: T.unsafe(nil), retriable_twirp_errors: T.unsafe(nil), retriable_faraday_errors: T.unsafe(nil), max_message_size: T.unsafe(nil)); end

  # source://hydro-client//lib/hydro/sink/gateway_sink.rb#117
  def close; end

  # source://hydro-client//lib/hydro/sink/gateway_sink.rb#125
  def disable_tracing; end

  # source://hydro-client//lib/hydro/sink/gateway_sink.rb#121
  def enable_tracing; end

  # source://hydro-client//lib/hydro/sink/gateway_sink.rb#129
  def validate_messages(messages); end

  # source://hydro-client//lib/hydro/sink/gateway_sink.rb#89
  def write(messages, options = T.unsafe(nil)); end

  private

  # source://hydro-client//lib/hydro/sink/gateway_sink.rb#200
  def deliver_messages(messages, headers); end

  # source://hydro-client//lib/hydro/sink/gateway_sink.rb#149
  def deliver_with_retries(messages); end

  # @return [Boolean]
  #
  # source://hydro-client//lib/hydro/sink/gateway_sink.rb#267
  def tracing_enabled?; end

  # source://hydro-client//lib/hydro/sink/gateway_sink.rb#259
  def validate_twirp_errors(error_codes); end
end

class Hydro::GatewaySink::ClientError < ::Hydro::Sink::Error; end

# The default maximum number of retries. Retrying covers both HTTP-level errors like timeouts
# as well as gateway retriable delivery failures.
#
# source://hydro-client//lib/hydro/sink/gateway_sink.rb#26
Hydro::GatewaySink::DEFAULT_MAX_RETRIES = T.let(T.unsafe(nil), Integer)

# The set of Faraday error that are considered retriable.
#
# source://hydro-client//lib/hydro/sink/gateway_sink.rb#38
Hydro::GatewaySink::DEFAULT_RETRIABLE_FARADAY_ERRORS = T.let(T.unsafe(nil), Array)

# The set of Twirp::Error codes that are considered retriable.
#
# source://hydro-client//lib/hydro/sink/gateway_sink.rb#32
Hydro::GatewaySink::DEFAULT_RETRIABLE_TWIRP_ERRORS = T.let(T.unsafe(nil), Array)

# The default number of seconds to wait in between retries.
#
# source://hydro-client//lib/hydro/sink/gateway_sink.rb#29
Hydro::GatewaySink::DEFAULT_RETRY_BACKOFF = T.let(T.unsafe(nil), Integer)

# The default HTTP timeout in seconds.
#
# source://hydro-client//lib/hydro/sink/gateway_sink.rb#22
Hydro::GatewaySink::DEFAULT_TIMEOUT = T.let(T.unsafe(nil), Integer)

# Represents an individual message delivery failure. In a single produce request, it's possible
# for some message produce operations to succeed while others fail.
#
# source://hydro-client//lib/hydro/sink/gateway_sink.rb#19
Hydro::GatewaySink::DELIVERY_FAILURE_EVENT = T.let(T.unsafe(nil), String)

class Hydro::GatewaySink::DeliveryFailure < ::Hydro::Sink::Error
  # source://hydro-client//lib/hydro/sink/gateway_sink.rb#276
  def failures; end
end

# source://hydro-client//lib/hydro/sink/gateway_sink.rb#43
Hydro::GatewaySink::GITHUB_REQUEST_ID_HEADER = T.let(T.unsafe(nil), String)

# source://hydro-client//lib/hydro/sink/gateway_sink.rb#44
Hydro::GatewaySink::GLB_VIA_HEADER = T.let(T.unsafe(nil), String)

# Represents a single HTTP request to the gateway.
#
# source://hydro-client//lib/hydro/sink/gateway_sink.rb#12
Hydro::GatewaySink::REQUEST_EVENT = T.let(T.unsafe(nil), String)

# Represents an HTTP request retry.
#
# source://hydro-client//lib/hydro/sink/gateway_sink.rb#15
Hydro::GatewaySink::RETRY_EVENT = T.let(T.unsafe(nil), String)

# Represents a gateway RPC call. May consist of multiple HTTP requests if retries are necessary.
#
# source://hydro-client//lib/hydro/sink/gateway_sink.rb#9
Hydro::GatewaySink::RPC_EVENT = T.let(T.unsafe(nil), String)

class Hydro::GatewaySink::RequestIdGenerator
  class << self
    # source://hydro-client//lib/hydro/sink/gateway_sink.rb#295
    def github_request_id; end

    # source://hydro-client//lib/hydro/sink/gateway_sink.rb#299
    def glb_via; end
  end
end

class Hydro::GatewaySink::ResponseInstrumenter
  # @return [ResponseInstrumenter] a new instance of ResponseInstrumenter
  #
  # source://hydro-client//lib/hydro/sink/gateway_sink.rb#282
  def initialize(app, options = T.unsafe(nil)); end

  # source://hydro-client//lib/hydro/sink/gateway_sink.rb#287
  def call(request_env); end
end

class Hydro::GatewaySink::RetriableClientError < ::Hydro::GatewaySink::ClientError; end

# source://hydro-client//lib/hydro/sink/gateway_sink.rb#45
Hydro::GatewaySink::USER_AGENT_HEADER = T.let(T.unsafe(nil), String)

class Hydro::InvalidSiteError < ::Hydro::Error
  # @return [InvalidSiteError] a new instance of InvalidSiteError
  #
  # source://hydro-client//lib/hydro/site.rb#45
  def initialize(site); end

  # source://hydro-client//lib/hydro/site.rb#49
  def message; end
end

class Hydro::KafkaSink
  include ::Hydro::Batching

  # Build a Hydro::KafkaSink.
  #
  # seed_brokers     - the Array<String> of kafka broker "<host>:<port>"
  # client_id        - a producer application identifier for use in logging,
  #                    debugging and quotas.
  # kafka            - the kafka client Class (only used in tests)
  # close_timeout    - The max amount of time spent attempting to deliver buffered messages on close.
  # client_options   - a Hash of options passed directly to the Kafka::Client
  # producer_options - a Hash of options passed directly to the Kafka::Producer
  #
  # @return [KafkaSink] a new instance of KafkaSink
  #
  # source://hydro-client//lib/hydro/sink/kafka_sink.rb#49
  def initialize(seed_brokers:, client_id:, kafka: T.unsafe(nil), async: T.unsafe(nil), close_timeout: T.unsafe(nil), client_options: T.unsafe(nil), producer_options: T.unsafe(nil)); end

  # source://hydro-client//lib/hydro/sink/kafka_sink.rb#68
  def add_to_batch(messages); end

  # Public: Flushes any messages remaining in the buffer. Blocks until
  # all messages have been delivered or we've exhausted the close timeout.
  #
  # source://hydro-client//lib/hydro/sink/kafka_sink.rb#96
  def close(timeout: T.unsafe(nil)); end

  # source://hydro-client//lib/hydro/sink/kafka_sink.rb#116
  def flush_batch(options = T.unsafe(nil)); end

  # @return [Boolean]
  #
  # source://hydro-client//lib/hydro/sink/kafka_sink.rb#127
  def flushable?; end

  # source://hydro-client//lib/hydro/sink/kafka_sink.rb#59
  def write(messages, options = T.unsafe(nil)); end

  private

  # @return [Boolean]
  #
  # source://hydro-client//lib/hydro/sink/kafka_sink.rb#135
  def async?; end

  # source://hydro-client//lib/hydro/sink/kafka_sink.rb#147
  def client; end

  # Returns the value of attribute client_id.
  #
  # source://hydro-client//lib/hydro/sink/kafka_sink.rb#133
  def client_id; end

  # source://hydro-client//lib/hydro/sink/kafka_sink.rb#163
  def client_options; end

  # source://hydro-client//lib/hydro/sink/kafka_sink.rb#171
  def defaults; end

  # source://hydro-client//lib/hydro/sink/kafka_sink.rb#189
  def handle_kafka_exception(e, messages = T.unsafe(nil)); end

  # source://hydro-client//lib/hydro/sink/kafka_sink.rb#139
  def producer; end

  # source://hydro-client//lib/hydro/sink/kafka_sink.rb#167
  def producer_options; end

  # Returns the value of attribute seed_brokers.
  #
  # source://hydro-client//lib/hydro/sink/kafka_sink.rb#133
  def seed_brokers; end

  # source://hydro-client//lib/hydro/sink/kafka_sink.rb#175
  def validate_messages(messages); end
end

# source://hydro-client//lib/hydro/sink/kafka_sink.rb#10
Hydro::KafkaSink::ASYNC_PRODUCER_DEFAULTS = T.let(T.unsafe(nil), Hash)

# The current 'message.max.bytes' configuration.
#
# source://hydro-client//lib/hydro/sink/kafka_sink.rb#8
Hydro::KafkaSink::MAX_MESSAGE_BATCH_SIZE = T.let(T.unsafe(nil), Integer)

# source://hydro-client//lib/hydro/sink/kafka_sink.rb#8
Hydro::KafkaSink::MAX_MESSAGE_SIZE = T.let(T.unsafe(nil), Integer)

# source://hydro-client//lib/hydro/sink/kafka_sink.rb#35
Hydro::KafkaSink::SYNC_PRODUCER_DEFAULTS = T.let(T.unsafe(nil), Hash)

class Hydro::KafkaSource
  # Expose messages from kafka as a Hydro::Source.
  #
  # seed_brokers - an Array<String> of broker "<host>:<port>". Required.
  # subscribe_to - a String, Regexp, Array<String> or Array<Regexp> that specifies the topic
  #                or topic pattern to consumer from. String args will be converted to regexes.
  #                Required.
  #                args will be converted to regexes. Required.
  # group_id     - a String to uniquely identify the kafka consumer group. Required.
  # simple       - a Boolean to switch to simple consumer mode. A simple consumer does not use
  #                a consumer group and consumes all partitions within single topic.
  # options      - a Hash of additional options passed to the underlying Kafka::Client
  #                and Kafka::Consumer.
  #
  #                Client options:
  #                :client_id                    - the String identifier for this application.
  #                :connect_timeout              - the Integer timeout setting for connecting to
  #                                                brokers.
  #                :socket_timeout               - the Integer timeout setting for socket
  #                                                connections.
  #                :ssl_ca_cert                  - a String PEM encoded CA cert, or an
  #                                                Array<String> of PEM encoded CA certs, to use
  #                                                with an SSL connection.
  #                :ssl_ca_cert_file_path        - a String path on the filesystem to a PEM
  #                                                encoded CA cert to use with an SSL connection.
  #                :ssl_client_cert              - a String PEM encoded client cert to use with
  #                                                an SSL connection. Must be used in combination
  #                                                with ssl_client_cert_key.
  #                :ssl_client_cert_key          - a String PEM encoded client cert key to use
  #                                                with an SSL connection. Must be used in
  #                                                combination with ssl_client_cert.
  #                :ssl_client_cert_key_password - the String password required to read the
  #                                                ssl_client_cert_key. Must be used in
  #                                                combination with ssl_client_cert_key.
  #                :sasl_gssapi_principal        - a String KRB5 principal
  #                :sasl_gssapi_keytab           - a String KRB5 keytab filepath
  #                :sasl_scram_username          - a String SCRAM username
  #                :sasl_scram_password          - a String SCRAM password
  #                :sasl_scram_mechanism         - a String Scram mechanism, either "sha256" or
  #                                                "sha512"
  #                :sasl_over_ssl                - a Boolean whether to enforce SSL with SASL
  #                :sasl_oauth_token_provider    - OAuthBearer Token Provider instance that
  #                                                implements method token.
  #
  #                Consumer group options:
  #                :group_id                - the String id of the group that the consumer should
  #                                           join.
  #                :session_timeout         - the Integer number of seconds after which, if a
  #                                           client hasn't contacted the Kafka cluster, it will
  #                                           be kicked out of the group.
  #                :offset_commit_interval  - the Integer interval between offset commits, in
  #                                           seconds.
  #                :offset_commit_threshold - the Integer number of messages that can be processed
  #                                           before their offsets are committed. If zero, offset
  #                                           commits are not triggered by message processing.
  #                :heartbeat_interval      - the Integer interval between heartbeats; must be
  #                                           less than the session window.
  #                :offset_retention_time   - the Integer time period that committed offsets will
  #                                           be retained, in seconds. Defaults to the broker
  #                                           setting.
  #                :fetcher_max_queue_size  - Integer max number of items in the fetch queue that
  #                                           are stored for further processing. Note, that each
  #                                           item in the queue represents a response from a
  #                                           single broker.
  #
  #                Fetch options:
  #                :start_from_beginning            - Boolean whether to start from the beginning
  #                                                   of the topic or just subscribe to new
  #                                                   messages being produced. This only applies
  #                                                   when first consuming a topic partition â€“ once
  #                                                   the consumer has checkpointed its progress,
  #                                                   it will always resume from the last
  #                                                   checkpoint.
  #                :max_bytes_per_partition         - the Integer maximum amount of data fetched
  #                                                   from a single partition at a time.
  #                :min_bytes                       - the Integer minimum number of bytes to read
  #                                                   before returning messages from each broker;
  #                                                   if `max_wait_time` is reached, this is ignored.
  #                :max_bytes                       - the Integer maximum number of bytes to read
  #                                                   before returning messages from each broker.
  #                :max_wait_time                   - the Numeric maximum duration of time to wait
  #                                                   before returning messages from each broker,
  #                                                   in seconds.
  #                :automatically_mark_as_processed - Boolean whether to automatically mark a
  #                                                   message as successfully processed when the
  #                                                   block returns without an exception. Once
  #                                                   marked successful, the offsets of processed
  #                                                   messages can be committed to Kafka.
  #
  #                Simple consumer options:
  #                :start_from_beginning - A Boolean whether to start from the beginning of the
  #                                        topic or just subscribe to new messages being
  #                                        produced.
  #                :max_wait_time        - The Integer maximum amount of time to wait before the
  #                                        server responds, in seconds.
  #                :min_bytes            - The Integer minimum number of bytes to wait for. If set
  #                                        to zero, the broker will respond immediately, but the
  #                                        response may be empty. The default is 1 byte, which
  #                                        means that the broker will respond as soon as a message
  #                                        is written to the partition.
  #                :max_bytes            - The Integer maximum number of bytes to include in the
  #                                        response message set. Default is 1 MB. You need to set
  #                                        this higher if you expect messages to be larger than
  #                                        this.
  #
  # @return [KafkaSource] a new instance of KafkaSource
  #
  # source://hydro-client//lib/hydro/source/kafka_source.rb#145
  def initialize(seed_brokers:, subscribe_to:, group_id: T.unsafe(nil), simple: T.unsafe(nil), kafka: T.unsafe(nil), **options); end

  # source://hydro-client//lib/hydro/source/kafka_source.rb#212
  def close; end

  # Public: Commit offsets for processed messages.
  #
  # message - a Source::Message
  #
  # source://hydro-client//lib/hydro/source/kafka_source.rb#227
  def commit_offsets; end

  # source://hydro-client//lib/hydro/source/kafka_source.rb#165
  def each_batch(&block); end

  # source://hydro-client//lib/hydro/source/kafka_source.rb#187
  def each_message; end

  # Public: Record but don't commit offsets for processed messages.
  #
  # message - a Source::Message
  #
  # source://hydro-client//lib/hydro/source/kafka_source.rb#220
  def mark_message_as_processed(message); end

  # source://hydro-client//lib/hydro/source/kafka_source.rb#161
  def open; end

  # Public: Send a heartbeat manually to the kafka consumer
  #
  # Returns nothing
  #
  # source://hydro-client//lib/hydro/source/kafka_source.rb#234
  def trigger_heartbeat; end

  private

  # source://hydro-client//lib/hydro/source/kafka_source.rb#302
  def batch_options; end

  # source://hydro-client//lib/hydro/source/kafka_source.rb#258
  def client; end

  # @return [Boolean]
  #
  # source://hydro-client//lib/hydro/source/kafka_source.rb#285
  def client_option?(option); end

  # source://hydro-client//lib/hydro/source/kafka_source.rb#289
  def client_options; end

  # source://hydro-client//lib/hydro/source/kafka_source.rb#242
  def consume_message_batches; end

  # source://hydro-client//lib/hydro/source/kafka_source.rb#268
  def consumer; end

  # source://hydro-client//lib/hydro/source/kafka_source.rb#295
  def consumer_options; end

  # Returns the value of attribute seed_brokers.
  #
  # source://hydro-client//lib/hydro/source/kafka_source.rb#240
  def seed_brokers; end

  # source://hydro-client//lib/hydro/source/kafka_source.rb#314
  def simple_consumer_options; end

  # source://hydro-client//lib/hydro/source/kafka_source.rb#308
  def subscribe_options; end

  # source://hydro-client//lib/hydro/source/kafka_source.rb#327
  def subscribe_to; end

  # source://hydro-client//lib/hydro/source/kafka_source.rb#320
  def topics; end

  # source://hydro-client//lib/hydro/source/kafka_source.rb#331
  def wrap_message(message); end
end

# source://hydro-client//lib/hydro/source/kafka_source.rb#22
Hydro::KafkaSource::BATCH_OPTIONS = T.let(T.unsafe(nil), Array)

# source://hydro-client//lib/hydro/source/kafka_source.rb#13
Hydro::KafkaSource::CLIENT_OPTIONS = T.let(T.unsafe(nil), Array)

# The default socket timeout is 10 seconds, which conflicts with the
# 30-second default session timeout. This means consumer connections can
# time out when joining a group and cause increased consumer group churn.
#
# source://hydro-client//lib/hydro/source/kafka_source.rb#9
Hydro::KafkaSource::DEFAULT_CLIENT_OPTIONS = T.let(T.unsafe(nil), Hash)

class Hydro::KafkaSource::NoMatchingTopicsError < ::ArgumentError
  # @return [NoMatchingTopicsError] a new instance of NoMatchingTopicsError
  #
  # source://hydro-client//lib/hydro/source/kafka_source.rb#343
  def initialize(patterns); end

  # source://hydro-client//lib/hydro/source/kafka_source.rb#347
  def message; end
end

# source://hydro-client//lib/hydro/source/kafka_source.rb#34
Hydro::KafkaSource::SIMPLE_CONSUMER_OPTIONS = T.let(T.unsafe(nil), Array)

# source://hydro-client//lib/hydro/source/kafka_source.rb#29
Hydro::KafkaSource::SUBSCRIBE_OPTIONS = T.let(T.unsafe(nil), Array)

class Hydro::LogSink
  # @return [LogSink] a new instance of LogSink
  #
  # source://hydro-client//lib/hydro/sink/log_sink.rb#21
  def initialize(logger = T.unsafe(nil), formatter: T.unsafe(nil)); end

  # @return [Boolean]
  #
  # source://hydro-client//lib/hydro/sink/log_sink.rb#26
  def batchable?; end

  # source://hydro-client//lib/hydro/sink/log_sink.rb#35
  def close; end

  # source://hydro-client//lib/hydro/sink/log_sink.rb#30
  def write(messages, options = T.unsafe(nil)); end

  private

  # Returns the value of attribute formatter.
  #
  # source://hydro-client//lib/hydro/sink/log_sink.rb#41
  def formatter; end

  # Returns the value of attribute logger.
  #
  # source://hydro-client//lib/hydro/sink/log_sink.rb#41
  def logger; end

  class << self
    # source://hydro-client//lib/hydro/sink/log_sink.rb#17
    def protobuf_as_json(logger = T.unsafe(nil)); end
  end
end

module Hydro::LogSink::Formatters; end

# source://hydro-client//lib/hydro/sink/log_sink.rb#8
Hydro::LogSink::Formatters::ProtobufAsJSON = T.let(T.unsafe(nil), Proc)

# source://hydro-client//lib/hydro/sink/log_sink.rb#6
Hydro::LogSink::Formatters::String = T.let(T.unsafe(nil), Proc)

class Hydro::LogStreamer
  class << self
    # source://hydro-client//lib/hydro/log_streamer.rb#4
    def start; end
  end
end

class Hydro::MemoryInstrumenter < ::Hydro::NoopInstrumenter
  # @return [MemoryInstrumenter] a new instance of MemoryInstrumenter
  #
  # source://hydro-client//lib/hydro/instrumenter.rb#15
  def initialize; end

  # source://hydro-client//lib/hydro/instrumenter.rb#20
  def instrument(name, payload = T.unsafe(nil)); end

  # Returns the value of attribute notifications.
  #
  # source://hydro-client//lib/hydro/instrumenter.rb#13
  def notifications; end

  # Sets the attribute notifications
  #
  # @param value the value to set the attribute notifications to.
  #
  # source://hydro-client//lib/hydro/instrumenter.rb#13
  def notifications=(_arg0); end

  # source://hydro-client//lib/hydro/instrumenter.rb#33
  def subscribe(name, &block); end
end

class Hydro::MemorySink
  include ::Prelude::Enumerator
  include ::Enumerable
  include ::Hydro::Batching

  # @return [MemorySink] a new instance of MemorySink
  #
  # source://hydro-client//lib/hydro/sink/memory_sink.rb#8
  def initialize; end

  # source://hydro-client//lib/hydro/sink/memory_sink.rb#44
  def close; end

  # @return [Boolean]
  #
  # source://hydro-client//lib/hydro/sink/memory_sink.rb#48
  def closed?; end

  # source://hydro-client//lib/hydro/sink/memory_sink.rb#40
  def each(&block); end

  # source://hydro-client//lib/hydro/sink/memory_sink.rb#56
  def force_result(result); end

  # Returns the value of attribute messages.
  #
  # source://hydro-client//lib/hydro/sink/memory_sink.rb#6
  def messages; end

  # source://hydro-client//lib/hydro/sink/memory_sink.rb#60
  def raises(error); end

  # source://hydro-client//lib/hydro/sink/memory_sink.rb#52
  def reset; end

  # source://hydro-client//lib/hydro/sink/memory_sink.rb#64
  def sleeps(n); end

  # source://hydro-client//lib/hydro/sink/memory_sink.rb#14
  def write(messages, options = T.unsafe(nil)); end

  private

  # Returns the value of attribute forward_to.
  #
  # source://hydro-client//lib/hydro/sink/memory_sink.rb#70
  def forward_to; end
end

class Hydro::MemorySource
  # Exposes messages from a Hydro::MemorySink as a Hydro::Source.
  #
  # sink       - a Hydro::MemorySink.
  # batch_size - the Integer number of messages to yield per batch
  #
  # @return [MemorySource] a new instance of MemorySource
  #
  # source://hydro-client//lib/hydro/source/memory_source.rb#11
  def initialize(sink:, group_id: T.unsafe(nil), subscribe_to: T.unsafe(nil), batch_size: T.unsafe(nil), **options); end

  # Public: Perform cleanup (no-op)
  #
  # source://hydro-client//lib/hydro/source/memory_source.rb#76
  def close; end

  # @return [Boolean]
  #
  # source://hydro-client//lib/hydro/source/memory_source.rb#80
  def closed?; end

  # Public: Commit the uncommitted offsets.
  #
  # Returns nothing.
  #
  # source://hydro-client//lib/hydro/source/memory_source.rb#66
  def commit_offsets; end

  # source://hydro-client//lib/hydro/source/memory_source.rb#101
  def committed_offsets; end

  # Public: Yields successive batches of Array<Hydro::Source::Messages>.
  #
  # block - a Proc to process each batch
  #
  # source://hydro-client//lib/hydro/source/memory_source.rb#24
  def each_batch(&block); end

  # Public: Yields individual Hydro::Source::Messages.
  #
  # block - a Proc to process each message
  #
  # source://hydro-client//lib/hydro/source/memory_source.rb#43
  def each_message(&block); end

  # Public: Mark a message as processed. When offsets are committed, the
  # message's offset will be stored so that we can resume where we left off
  # if processing restarts.
  #
  # message - a Source::Message
  #
  # Returns nothing.
  #
  # source://hydro-client//lib/hydro/source/memory_source.rb#59
  def mark_message_as_processed(message); end

  # Public: Initialize the source (no-op)
  #
  # source://hydro-client//lib/hydro/source/memory_source.rb#85
  def open; end

  # @return [Boolean]
  #
  # source://hydro-client//lib/hydro/source/memory_source.rb#89
  def opened?; end

  # source://hydro-client//lib/hydro/source/memory_source.rb#97
  def subscribe_to; end

  # source://hydro-client//lib/hydro/source/memory_source.rb#93
  def trigger_heartbeat; end

  private

  # @return [Boolean]
  #
  # source://hydro-client//lib/hydro/source/memory_source.rb#111
  def already_processed?(message); end

  # @return [Boolean]
  #
  # source://hydro-client//lib/hydro/source/memory_source.rb#107
  def automatically_mark_as_processed?; end

  # Private: Build a <Topic, <Partition, Offset>> map.
  #
  # source://hydro-client//lib/hydro/source/memory_source.rb#134
  def build_offsets_store(default: T.unsafe(nil)); end

  # source://hydro-client//lib/hydro/source/memory_source.rb#127
  def next_offset_for(message); end

  # source://hydro-client//lib/hydro/source/memory_source.rb#116
  def wrap_message(message); end
end

# source://hydro-client//lib/hydro/source/memory_source.rb#3
Hydro::MemorySource::DEFAULTS = T.let(T.unsafe(nil), Hash)

class Hydro::Message
  # @return [Message] a new instance of Message
  #
  # source://hydro-client//lib/hydro/message.rb#16
  def initialize(key: T.unsafe(nil), data: T.unsafe(nil), schema: T.unsafe(nil), topic: T.unsafe(nil), partition: T.unsafe(nil), partition_key: T.unsafe(nil), timestamp: T.unsafe(nil), headers: T.unsafe(nil), compress: T.unsafe(nil)); end

  # source://hydro-client//lib/hydro/message.rb#28
  def ==(other); end

  # Returns the bytesize of the message payload.
  #
  # source://hydro-client//lib/hydro/message.rb#69
  def bytesize; end

  # Returns the value of attribute compress.
  #
  # source://hydro-client//lib/hydro/message.rb#5
  def compress; end

  # Sets the attribute compress
  #
  # @param value the value to set the attribute compress to.
  #
  # source://hydro-client//lib/hydro/message.rb#5
  def compress=(_arg0); end

  # Returns the value of attribute data.
  #
  # source://hydro-client//lib/hydro/message.rb#5
  def data; end

  # Sets the attribute data
  #
  # @param value the value to set the attribute data to.
  #
  # source://hydro-client//lib/hydro/message.rb#5
  def data=(_arg0); end

  # Returns the value of attribute headers.
  #
  # source://hydro-client//lib/hydro/message.rb#5
  def headers; end

  # Sets the attribute headers
  #
  # @param value the value to set the attribute headers to.
  #
  # source://hydro-client//lib/hydro/message.rb#5
  def headers=(_arg0); end

  # Returns the value of attribute key.
  #
  # source://hydro-client//lib/hydro/message.rb#5
  def key; end

  # Sets the attribute key
  #
  # @param value the value to set the attribute key to.
  #
  # source://hydro-client//lib/hydro/message.rb#5
  def key=(_arg0); end

  # Returns the value of attribute partition.
  #
  # source://hydro-client//lib/hydro/message.rb#5
  def partition; end

  # Sets the attribute partition
  #
  # @param value the value to set the attribute partition to.
  #
  # source://hydro-client//lib/hydro/message.rb#5
  def partition=(_arg0); end

  # Returns the value of attribute partition_key.
  #
  # source://hydro-client//lib/hydro/message.rb#5
  def partition_key; end

  # Sets the attribute partition_key
  #
  # @param value the value to set the attribute partition_key to.
  #
  # source://hydro-client//lib/hydro/message.rb#5
  def partition_key=(_arg0); end

  # Returns the value of attribute schema.
  #
  # source://hydro-client//lib/hydro/message.rb#5
  def schema; end

  # Sets the attribute schema
  #
  # @param value the value to set the attribute schema to.
  #
  # source://hydro-client//lib/hydro/message.rb#5
  def schema=(_arg0); end

  # Public: Serialize a message as a String suitable for writing to a
  # whitespace delimited IO e.g. a file or pipe.
  #
  # Returns a String.
  #
  # source://hydro-client//lib/hydro/message.rb#64
  def serialize; end

  # Returns the value of attribute timestamp.
  #
  # source://hydro-client//lib/hydro/message.rb#5
  def timestamp; end

  # Sets the attribute timestamp
  #
  # @param value the value to set the attribute timestamp to.
  #
  # source://hydro-client//lib/hydro/message.rb#5
  def timestamp=(_arg0); end

  # source://hydro-client//lib/hydro/message.rb#42
  def to_h; end

  # source://hydro-client//lib/hydro/message.rb#56
  def to_json; end

  # Returns the value of attribute topic.
  #
  # source://hydro-client//lib/hydro/message.rb#5
  def topic; end

  # Sets the attribute topic
  #
  # @param value the value to set the attribute topic to.
  #
  # source://hydro-client//lib/hydro/message.rb#5
  def topic=(_arg0); end

  class << self
    # Public: Deserialize a serialized message.
    #
    # serialized - a String representing a serialized message.
    #
    # Returns a Hydro::Message.
    #
    # source://hydro-client//lib/hydro/message.rb#12
    def deserialize(serialized); end
  end
end

class Hydro::MissingSchemaError < ::Hydro::Error
  # @return [MissingSchemaError] a new instance of MissingSchemaError
  #
  # source://hydro-client//lib/hydro/error.rb#35
  def initialize(schema); end

  # source://hydro-client//lib/hydro/error.rb#39
  def message; end
end

# Raised when an encoder can't be found for a given message.
class Hydro::NoEncoderError < ::Hydro::Error
  # @return [NoEncoderError] a new instance of NoEncoderError
  #
  # source://hydro-client//lib/hydro/error.rb#25
  def initialize(attributes); end

  # source://hydro-client//lib/hydro/error.rb#29
  def message; end
end

class Hydro::NoopInstrumenter
  # @yield [payload]
  #
  # source://hydro-client//lib/hydro/instrumenter.rb#3
  def instrument(name, payload = T.unsafe(nil)); end

  # source://hydro-client//lib/hydro/instrumenter.rb#7
  def subscribe(*args); end
end

class Hydro::NoopSink
  # @return [Boolean]
  #
  # source://hydro-client//lib/hydro/sink/noop_sink.rb#6
  def batchable?; end

  # source://hydro-client//lib/hydro/sink/noop_sink.rb#15
  def close; end

  # source://hydro-client//lib/hydro/sink/noop_sink.rb#10
  def write(messages, options = T.unsafe(nil)); end
end

# Triggered on sink write
#
# source://hydro-client//lib/hydro/sink/noop_sink.rb#4
Hydro::NoopSink::WRITE_EVENT = T.let(T.unsafe(nil), String)

class Hydro::Processor
  include ::ActiveSupport::Callbacks
  extend ::ActiveSupport::Callbacks::ClassMethods
  extend ::ActiveSupport::DescendantsTracker

  # source://activesupport/8.0.0.alpha.d7f9347368/lib/active_support/callbacks.rb#70
  def __callbacks; end

  # source://activesupport/8.0.0.alpha.d7f9347368/lib/active_support/callbacks.rb#70
  def __callbacks?; end

  # source://activesupport/8.0.0.alpha.d7f9347368/lib/active_support/callbacks.rb#924
  def _close_callbacks; end

  # source://activesupport/8.0.0.alpha.d7f9347368/lib/active_support/callbacks.rb#924
  def _open_callbacks; end

  # source://activesupport/8.0.0.alpha.d7f9347368/lib/active_support/callbacks.rb#912
  def _run_close_callbacks(&block); end

  # source://activesupport/8.0.0.alpha.d7f9347368/lib/active_support/callbacks.rb#912
  def _run_open_callbacks(&block); end

  # Public: Controls whether the processor should receive message batches or individual messages.
  # Defaults to the individual message mode (recommended).
  #
  # Returns a Boolean.
  #
  # @return [Boolean]
  #
  # source://hydro-client//lib/hydro/processor.rb#26
  def batching?; end

  # Returns the value of attribute consumer.
  #
  # source://hydro-client//lib/hydro/processor.rb#7
  def consumer; end

  # Sets the attribute consumer
  #
  # @param value the value to set the attribute consumer to.
  #
  # source://hydro-client//lib/hydro/processor.rb#7
  def consumer=(_arg0); end

  # source://hydro-client//lib/hydro/processor.rb#51
  def group_id; end

  # source://hydro-client//lib/hydro/processor.rb#55
  def options; end

  # Public: Process messages.
  #
  # batch_or_message - In batch mode, an Array of Hydro::Consumer::ConsumerMessage.
  #                    In individual message mode, a single Hydro::Consumer::ConsumerMessage.
  #
  # @raise [NotImplementedError]
  #
  # source://hydro-client//lib/hydro/processor.rb#34
  def process(batch_or_message); end

  # Public: Process a batch of messages and interact with the consumer.
  #
  # batch_or_message - In batch mode, an Array of Hydro::Consumer::ConsumerMessage.
  #                    In individual message mode, a single Hydro::Consumer::ConsumerMessage.
  # consumer - the Hydro::Consumer.
  #
  # source://hydro-client//lib/hydro/processor.rb#43
  def process_with_consumer(batch_or_message, consumer); end

  # source://hydro-client//lib/hydro/processor.rb#47
  def subscribe_to; end

  class << self
    # source://activesupport/8.0.0.alpha.d7f9347368/lib/active_support/callbacks.rb#70
    def __callbacks; end

    # source://activesupport/8.0.0.alpha.d7f9347368/lib/active_support/callbacks.rb#70
    def __callbacks=(value); end

    # source://activesupport/8.0.0.alpha.d7f9347368/lib/active_support/callbacks.rb#70
    def __callbacks?; end

    # source://activesupport/8.0.0.alpha.d7f9347368/lib/active_support/callbacks.rb#916
    def _close_callbacks; end

    # source://activesupport/8.0.0.alpha.d7f9347368/lib/active_support/callbacks.rb#920
    def _close_callbacks=(value); end

    # source://activesupport/8.0.0.alpha.d7f9347368/lib/active_support/callbacks.rb#916
    def _open_callbacks; end

    # source://activesupport/8.0.0.alpha.d7f9347368/lib/active_support/callbacks.rb#920
    def _open_callbacks=(value); end

    # source://hydro-client//lib/hydro/processor.rb#18
    def group_id(group_id); end

    # source://hydro-client//lib/hydro/processor.rb#10
    def options; end

    # source://hydro-client//lib/hydro/processor.rb#14
    def subscribe_to(topic); end
  end
end

module Hydro::Protobuf
  class << self
    # Public: Lookup the schema class associated with a schema name. As most
    # schemas are assumed to live in the `hydro.schemas` namespace, we permit
    # relative rather than fully-qualified schema names by secondarily
    # searching in the `hydro.schemas` namespace.
    #
    # schema_id - the String name of the schema
    # pool      - the Google::Protobuf::DescriptorPool
    #
    # Returns a schema class.
    #
    # source://hydro-client//lib/hydro/encoding/protobuf/protobuf.rb#78
    def get_schema_class(schema_id, pool); end

    # Public: Map a hash to a protobuf object instance. The hash may be nested
    # to instantate nested message.
    #
    # Throws UnknownFieldError exceptions when passed an unknown field.
    # Throws InvalidValueError when a field value is an invalid type.
    #
    #   data         - A Hash of fields and values
    #   schema_class - The generated protobuf schema class
    #
    # Example:
    #
    #   message User {
    #     string login = 1;
    #   }
    #
    #   message UserComment {
    #     User author = 1;
    #     string comment = 2;
    #   }
    #
    #   comment = Hydro::Protobuf.to_protobuf({
    #     author: {login: "defunkt"},
    #     comment: "hey",
    #   }, UserComment)
    #
    #   comment = Hydro::Protobuf.to_protobuf({
    #     comment: 5000, # throws InvalidValueError
    #   }, UserComment)
    #
    #   comment = Hydro::Protobuf.to_protobuf({
    #     unknown: "value", # throws UnknownFieldError
    #   }, UserComment)
    #
    # Returns a protobuf instance.
    #
    # source://hydro-client//lib/hydro/encoding/protobuf/protobuf.rb#41
    def to_protobuf(data, schema_class, nil_scalar_handler: T.unsafe(nil)); end
  end
end

class Hydro::Protobuf::Field
  # @return [Field] a new instance of Field
  #
  # source://hydro-client//lib/hydro/encoding/protobuf/protobuf.rb#103
  def initialize(field, value, nil_scalar_handler: T.unsafe(nil)); end

  # source://hydro-client//lib/hydro/encoding/protobuf/protobuf.rb#109
  def to_proto; end

  private

  # Internal: Is the field bytes?
  #
  # Return a Boolean.
  #
  # @return [Boolean]
  #
  # source://hydro-client//lib/hydro/encoding/protobuf/protobuf.rb#161
  def bytes_type?; end

  # bytes field types on proto messages are handled as Encoding::BINARY
  # if we don't encode the string here, then non-ascii characters throw errors
  #
  # source://hydro-client//lib/hydro/encoding/protobuf/protobuf.rb#259
  def convert_bytes; end

  # source://hydro-client//lib/hydro/encoding/protobuf/protobuf.rb#176
  def convert_enum; end

  # source://hydro-client//lib/hydro/encoding/protobuf/protobuf.rb#180
  def convert_map; end

  # source://hydro-client//lib/hydro/encoding/protobuf/protobuf.rb#211
  def convert_message; end

  # Internal: Convert a value with its own protobuf definition to a
  # protobuf instance.
  #
  # Timestamps receive special handling so that they can be specified with
  # a Time instance or Integer rather than the more cumbersome
  # '{seconds: n, nanoseconds: n}' form.
  #
  # Returns a protobuf instance.
  #
  # source://hydro-client//lib/hydro/encoding/protobuf/protobuf.rb#223
  def convert_message_with_definition(value); end

  # source://hydro-client//lib/hydro/encoding/protobuf/protobuf.rb#263
  def convert_string; end

  # Internal: Is the field an enum?
  #
  # Return a Boolean.
  #
  # @return [Boolean]
  #
  # source://hydro-client//lib/hydro/encoding/protobuf/protobuf.rb#142
  def enum_type?; end

  # Returns the value of attribute field.
  #
  # source://hydro-client//lib/hydro/encoding/protobuf/protobuf.rb#288
  def field; end

  # Internal: Is the field a protobuf map?
  #
  # Return a Boolean.
  #
  # @return [Boolean]
  #
  # source://hydro-client//lib/hydro/encoding/protobuf/protobuf.rb#149
  def map_type?; end

  # source://hydro-client//lib/hydro/encoding/protobuf/protobuf.rb#274
  def message_schema; end

  # Internal: Is the field itself a protobuf message?
  #
  # Return a Boolean.
  #
  # @return [Boolean]
  #
  # source://hydro-client//lib/hydro/encoding/protobuf/protobuf.rb#135
  def message_type?; end

  # source://hydro-client//lib/hydro/encoding/protobuf/protobuf.rb#278
  def repeated(&block); end

  # @return [Boolean]
  #
  # source://hydro-client//lib/hydro/encoding/protobuf/protobuf.rb#172
  def repeated?; end

  # Internal: Is the field a primitive type e.g. int32, bool?
  #
  # Return a Boolean.
  #
  # @return [Boolean]
  #
  # source://hydro-client//lib/hydro/encoding/protobuf/protobuf.rb#128
  def scalar_type?; end

  # Internal: Is the string bytes?
  #
  # Return a Boolean.
  #
  # @return [Boolean]
  #
  # source://hydro-client//lib/hydro/encoding/protobuf/protobuf.rb#168
  def string_type?; end

  # Returns the value of attribute value.
  #
  # source://hydro-client//lib/hydro/encoding/protobuf/protobuf.rb#288
  def value; end
end

# source://hydro-client//lib/hydro/encoding/protobuf/protobuf.rb#101
Hydro::Protobuf::Field::MAP_ENTRY = T.let(T.unsafe(nil), Regexp)

class Hydro::Protobuf::Field::UnsetScalarError < ::ArgumentError; end

# source://hydro-client//lib/hydro/encoding/protobuf/protobuf.rb#89
Hydro::Protobuf::Field::WRAPPED_SCALARS_TYPES = T.let(T.unsafe(nil), Array)

# source://hydro-client//lib/hydro/encoding/protobuf/protobuf.rb#5
Hydro::Protobuf::HYDRO_SCHEMAS_NAMESPACE = T.let(T.unsafe(nil), String)

class Hydro::Protobuf::InvalidValueError < ::TypeError
  # @return [InvalidValueError] a new instance of InvalidValueError
  #
  # source://hydro-client//lib/hydro/encoding/protobuf/protobuf.rb#319
  def initialize(schema, field, value, error_on_field = T.unsafe(nil)); end

  # source://hydro-client//lib/hydro/encoding/protobuf/protobuf.rb#340
  def expected_type; end

  # source://hydro-client//lib/hydro/encoding/protobuf/protobuf.rb#324
  def message; end

  # source://hydro-client//lib/hydro/encoding/protobuf/protobuf.rb#335
  def truncated_value; end
end

class Hydro::Protobuf::UnknownFieldError < ::ArgumentError
  # @return [UnknownFieldError] a new instance of UnknownFieldError
  #
  # source://hydro-client//lib/hydro/encoding/protobuf/protobuf.rb#309
  def initialize(schema, field_name); end

  # source://hydro-client//lib/hydro/encoding/protobuf/protobuf.rb#313
  def message; end
end

class Hydro::Protobuf::UnsetScalarError < ::ArgumentError
  # @return [UnsetScalarError] a new instance of UnsetScalarError
  #
  # source://hydro-client//lib/hydro/encoding/protobuf/protobuf.rb#294
  def initialize(schema, field); end

  # Returns the value of attribute field.
  #
  # source://hydro-client//lib/hydro/encoding/protobuf/protobuf.rb#292
  def field; end

  # source://hydro-client//lib/hydro/encoding/protobuf/protobuf.rb#298
  def message; end

  # Returns the value of attribute schema.
  #
  # source://hydro-client//lib/hydro/encoding/protobuf/protobuf.rb#292
  def schema; end
end

# Encodes messages with Protobuf binary format.
class Hydro::ProtobufEncoder
  # Public: Instantiate a new protobuf encoder. The encoder accepts a
  # handler for the case where a scalar field is set to nil. Because proto3
  # defaults unset scalar fields ("" for strings, 0 for integers, etc),
  # there is no way for message readers to know that a scalar field was unset.
  # To deal with this proto3 constraint, users are encouraged to use wrapper
  # types (see https://git.io/vxjoY) for truly nullable fields.
  #
  # The default encoder behavior is to raise an exception when encountering
  # a `nil` value for a scalar field to prevent users from accidentally
  # publlishing messages with default values. To disable the raise behavior,
  # pass `nil_scalar_handler: :ignore` or pass a custom Proc.
  #
  # pool     - a Google::Protobuf::DescriptorPool
  # callable - :raise, :ignore, or a Proc that accept a single argument, an
  #            instance of UnsetScalarError.
  #
  # Example:
  #
  #     handler = ->(error) { Failbot.report(error) }
  #     ProtobufEncoder.new(nil_scalar_handler: handler)
  #
  # @return [ProtobufEncoder] a new instance of ProtobufEncoder
  #
  # source://hydro-client//lib/hydro/encoding/protobuf_encoder.rb#38
  def initialize(site = T.unsafe(nil), pool: T.unsafe(nil), nil_scalar_handler: T.unsafe(nil)); end

  # Encodes a message as a Protobuf-encoded string using the specified schema.
  #
  # message - the message data as a Hash or nil. Nested message types should also
  #           be encoded as Hashes. These will be recursively encoded as
  #           Protobuf messages.
  #
  # Options
  #
  #   schema    - Determines the schema for encoding.
  #   timestamp - Optional Numeric UNIX timestamp.
  #
  #
  # Returns a String with ASCII-8BIT encoding or nil.
  #
  # source://hydro-client//lib/hydro/encoding/protobuf_encoder.rb#64
  def encode(message, schema:, timestamp: T.unsafe(nil)); end

  private

  # Internal: Wraps messages in an envelope that describes message metadata
  # e.g. schema and timestamp.
  #
  # encoded    - a String encoded message.
  # schema     - a String schema name.
  # timestamp  - a Numeric UNIX message timestamp.
  #
  # Returns an encoded Hydro::Schemas::Hydro::V1::Envelope.
  #
  # source://hydro-client//lib/hydro/encoding/protobuf_encoder.rb#113
  def apply_envelope(message, schema:, timestamp:); end

  # source://hydro-client//lib/hydro/encoding/protobuf_encoder.rb#146
  def default_pool; end

  # Interal: Generates a unique message ID string.
  #
  # Returns a String.
  #
  # source://hydro-client//lib/hydro/encoding/protobuf_encoder.rb#142
  def generate_event_id; end

  # Internal: Retrieve the schema class for encoding. The schema is lazily
  # loaded because the Protobuf classes may not have been loaded when the
  # encoder is instantiated.
  #
  # schema - The name of the schema class to get. Required if schema was not
  #          specified at initialization.
  #
  # Returns a class that can encode a Protobuf message.
  #
  # source://hydro-client//lib/hydro/encoding/protobuf_encoder.rb#91
  def get_schema_class(schema); end

  # Returns the value of attribute nil_scalar_handler.
  #
  # source://hydro-client//lib/hydro/encoding/protobuf_encoder.rb#81
  def nil_scalar_handler; end

  # Internal: Serializes the Protobuf instance as a string. Uses the Protobuf
  # binary format.
  #
  # pb - an instance of a Protobuf class to be serialized or nil.
  #
  # Returns a String with ASCII-8BIT encoding or nil.
  #
  # source://hydro-client//lib/hydro/encoding/protobuf_encoder.rb#101
  def serialize_protobuf(pb); end

  class << self
    # source://hydro-client//lib/hydro/encoding/protobuf_encoder.rb#13
    def encode(site, message, **kwargs); end
  end
end

class Hydro::Publisher
  # Public: Create a new publisher for publishing messages to Hydro.
  #
  # sink                 - Required Sink instance to use.
  # encoder              - Optional default Encoder for the publisher.
  # site                 - Optional site of origin used by encoding.
  # topic_format_options - Optional default topic format options.
  # verification_secrets_mapping - Optional Hash that maps topic names to secrets and secret labels
  #                                Expected format: { "fully qualified topic name" => { secret: "the secret", label: "the label" } }
  # default_headers_proc - Optional proc that returns a hash (string keys and values) that will be set
  #                        as headers on all published messages
  #
  # @return [Publisher] a new instance of Publisher
  #
  # source://hydro-client//lib/hydro/publisher.rb#22
  def initialize(sink:, encoder: T.unsafe(nil), site: T.unsafe(nil), topic_format_options: T.unsafe(nil), verification_secrets_mapping: T.unsafe(nil), default_headers_proc: T.unsafe(nil)); end

  # Public: batch published events for the duration of the block.
  #
  # Yields the publisher to the given block. If the sink supports batching, a
  # batch is started before the block and flushed after it returns.
  #
  # source://hydro-client//lib/hydro/publisher.rb#114
  def batch(&block); end

  # Public: close down the sink and clean up.
  #
  # source://hydro-client//lib/hydro/publisher.rb#136
  def close; end

  # Returns the value of attribute default_topic_format_options.
  #
  # source://hydro-client//lib/hydro/publisher.rb#10
  def default_topic_format_options; end

  # Internal: encode a message.
  #
  # message - Required message contents. The expected type depends on the
  #           capabilities of the encoder implementation.
  #
  # Options
  #   schema    - Required String message schema name.
  #   encoder   - Required Hydro::Encoder to use when encoding.
  #   timestamp - Optional Numeric UNIX message timestamp.
  #
  # Returns a Hydro::Message populated with the encoded message and its topic,
  # partition, key, and timestamp. Raises EncodingError if the message cannot
  # be encoded.
  #
  # source://hydro-client//lib/hydro/publisher.rb#153
  def encode(message, schema:, encoder:, timestamp: T.unsafe(nil)); end

  # Public: flush a batch of messages and return to single-message mode.
  #
  # No-op if the sink doesn't support batching.
  #
  # source://hydro-client//lib/hydro/publisher.rb#131
  def flush_batch; end

  # Public: publish a message. If the publisher is in batch mode, the message
  # is enqueued to the batch. Otherwise the message is written to the sink.
  #
  # message - Required message contents. The expected type depends on the
  #           capabilities of the encoder implementation.
  #
  # Options
  #   schema                    - Required String message schema name.
  #   topic                     - Optional String name of the topic
  #   key                       - Optional message key.
  #   partition_key             - Optional partition key.
  #   partition                 - Optional destination topic partition.
  #   timestamp                 - Optional Numeric UNIX timestamp.
  #   compress                  - Optional Boolean to enable compression (if supported by the sink).
  #   encoder                   - Optional encoder used to encode the message.
  #   headers                   - Optional Hash (string keys and values) headers that will be sent along with the message
  #   verification_secret_label - Optional String used to indentify secret when verifing
  #                               signature - will override producer level setting (must be
  #                               specified if verification_secret is specified)
  #   verification_secret       - Optional String secret used to generate verification signature
  #                               - will override producer level setting (must be specified if
  #                               verification_secret_label is specified)
  #   topic_format_options      - Optional topic format options to override defaults set during initialization.
  #
  # source://hydro-client//lib/hydro/publisher.rb#60
  def publish(message, schema:, encoder: T.unsafe(nil), headers: T.unsafe(nil), topic: T.unsafe(nil), key: T.unsafe(nil), partition: T.unsafe(nil), partition_key: T.unsafe(nil), timestamp: T.unsafe(nil), compress: T.unsafe(nil), verification_secret_label: T.unsafe(nil), verification_secret: T.unsafe(nil), topic_format_options: T.unsafe(nil)); end

  # Returns the value of attribute sink.
  #
  # source://hydro-client//lib/hydro/publisher.rb#10
  def sink; end

  # Public: start batching published messages.
  #
  # No-op if the sink doesn't support batching.
  #
  # source://hydro-client//lib/hydro/publisher.rb#124
  def start_batch; end

  private

  # source://hydro-client//lib/hydro/publisher.rb#167
  def build_verification_headers(secret:, label:, data:); end

  # Returns the value of attribute default_encoder.
  #
  # source://hydro-client//lib/hydro/publisher.rb#165
  def default_encoder; end

  # Returns the value of attribute default_headers_proc.
  #
  # source://hydro-client//lib/hydro/publisher.rb#165
  def default_headers_proc; end

  # Returns the value of attribute verification_secrets_mapping.
  #
  # source://hydro-client//lib/hydro/publisher.rb#165
  def verification_secrets_mapping; end
end

# Triggered whenever a message is encoded.
#
# source://hydro-client//lib/hydro/publisher.rb#8
Hydro::Publisher::ENCODE_EVENT = T.let(T.unsafe(nil), String)

# Triggered whenever a message is published.
#
# source://hydro-client//lib/hydro/publisher.rb#5
Hydro::Publisher::PUBLISH_EVENT = T.let(T.unsafe(nil), String)

module Hydro::Schemas::Hydro; end
module Hydro::Schemas::Hydro::V1; end

class Hydro::Schemas::Hydro::V1::Envelope
  include ::Google::Protobuf::MessageExts
  extend ::Google::Protobuf::MessageExts::ClassMethods

  def initialize(*_arg0); end

  def ==(_arg0); end
  def [](_arg0); end
  def []=(_arg0, _arg1); end
  def clone; end
  def dup; end
  def eql?(_arg0); end
  def hash; end
  def inspect; end
  def method_missing(*_arg0); end
  def to_h; end
  def to_s; end

  private

  def respond_to_missing?(*_arg0); end

  class << self
    def decode(_arg0); end
    def decode_json(*_arg0); end
    def descriptor; end
    def encode(_arg0); end
    def encode_json(*_arg0); end
  end
end

module Hydro::Schemas::Hydro::V1::Envelope::Site
  class << self
    def descriptor; end
    def lookup(_arg0); end
    def resolve(_arg0); end
  end
end

# source://hydro-client//lib/generated/hydro/schemas/hydro/v1/envelope_pb.rb#36
Hydro::Schemas::Hydro::V1::Envelope::Site::AC4_IAD = T.let(T.unsafe(nil), Integer)

# source://hydro-client//lib/generated/hydro/schemas/hydro/v1/envelope_pb.rb#36
Hydro::Schemas::Hydro::V1::Envelope::Site::AM4_AMS = T.let(T.unsafe(nil), Integer)

# source://hydro-client//lib/generated/hydro/schemas/hydro/v1/envelope_pb.rb#36
Hydro::Schemas::Hydro::V1::Envelope::Site::ASH1_IAD = T.let(T.unsafe(nil), Integer)

# source://hydro-client//lib/generated/hydro/schemas/hydro/v1/envelope_pb.rb#36
Hydro::Schemas::Hydro::V1::Envelope::Site::CP1_IAD = T.let(T.unsafe(nil), Integer)

# source://hydro-client//lib/generated/hydro/schemas/hydro/v1/envelope_pb.rb#36
Hydro::Schemas::Hydro::V1::Envelope::Site::DC2_IAD = T.let(T.unsafe(nil), Integer)

# source://hydro-client//lib/generated/hydro/schemas/hydro/v1/envelope_pb.rb#36
Hydro::Schemas::Hydro::V1::Envelope::Site::LOCALHOST = T.let(T.unsafe(nil), Integer)

# source://hydro-client//lib/generated/hydro/schemas/hydro/v1/envelope_pb.rb#36
Hydro::Schemas::Hydro::V1::Envelope::Site::PRIVATE_US_EAST_1 = T.let(T.unsafe(nil), Integer)

# source://hydro-client//lib/generated/hydro/schemas/hydro/v1/envelope_pb.rb#36
Hydro::Schemas::Hydro::V1::Envelope::Site::SDC42_SEA = T.let(T.unsafe(nil), Integer)

# source://hydro-client//lib/generated/hydro/schemas/hydro/v1/envelope_pb.rb#36
Hydro::Schemas::Hydro::V1::Envelope::Site::UNKNOWN = T.let(T.unsafe(nil), Integer)

# source://hydro-client//lib/generated/hydro/schemas/hydro/v1/envelope_pb.rb#36
Hydro::Schemas::Hydro::V1::Envelope::Site::VA3_IAD = T.let(T.unsafe(nil), Integer)

# source://hydro-client//lib/generated/hydro/schemas/hydro/v1/envelope_pb.rb#36
Hydro::Schemas::Hydro::V1::Envelope::Site::VPC_US_EAST_1 = T.let(T.unsafe(nil), Integer)

module Hydro::Sink
  class << self
    # source://hydro-client//lib/hydro/sink.rb#14
    def tee(primary, secondary); end
  end
end

class Hydro::Sink::BufferOverflow < ::Hydro::Sink::Error; end

class Hydro::Sink::Error < ::Hydro::Error
  # @return [Error] a new instance of Error
  #
  # source://hydro-client//lib/hydro/error.rb#48
  def initialize(message, original_exception: T.unsafe(nil), messages: T.unsafe(nil), context: T.unsafe(nil)); end

  # source://hydro-client//lib/hydro/error.rb#53
  def context; end

  # source://hydro-client//lib/hydro/error.rb#61
  def message_counts; end

  # Returns the value of attribute messages.
  #
  # source://hydro-client//lib/hydro/error.rb#46
  def messages; end

  # source://hydro-client//lib/hydro/error.rb#57
  def original_exception; end
end

class Hydro::Sink::MessagesInvalidError < ::Hydro::Sink::Error; end
class Hydro::Sink::MessagesTooLarge < ::Hydro::Sink::MessagesInvalidError; end

# A response from a Sink `write` call.
#
# Wraps any errors so consuming code can respond or ignore the results of a
# write as required.
class Hydro::Sink::Result
  # Public: initialize a Response
  #
  # @return [Result] a new instance of Result
  #
  # source://hydro-client//lib/hydro/sink/result.rb#19
  def initialize(error = T.unsafe(nil)); end

  # The error, if one occurred.
  #
  # source://hydro-client//lib/hydro/sink/result.rb#29
  def error; end

  # Was the publish successful?
  #
  # @return [Boolean]
  #
  # source://hydro-client//lib/hydro/sink/result.rb#24
  def success?; end

  class << self
    # Internal: convenience constructor
    #
    # source://hydro-client//lib/hydro/sink/result.rb#14
    def failure(error); end

    # Internal: convenience constructor
    #
    # source://hydro-client//lib/hydro/sink/result.rb#9
    def success; end
  end
end

class Hydro::Sink::Tee
  # Composes a primary sink and a secondary sink. Sink#write and batching
  # methods are forwarded to both sinks. Any other methods are
  # forwarded to the primary.
  #
  # primary  - a Hydro::Sink instance
  # seconary - a Hydro::Sink instance
  #
  # @return [Tee] a new instance of Tee
  #
  # source://hydro-client//lib/hydro/sink/tee.rb#12
  def initialize(primary, secondary); end

  # @return [Boolean]
  #
  # source://hydro-client//lib/hydro/sink/tee.rb#17
  def batchable?; end

  # source://hydro-client//lib/hydro/sink/tee.rb#30
  def flush_batch; end

  # @return [Boolean]
  #
  # source://hydro-client//lib/hydro/sink/tee.rb#21
  def flushable?; end

  # Returns the value of attribute primary.
  #
  # source://hydro-client//lib/hydro/sink/tee.rb#4
  def primary; end

  # Returns the value of attribute secondary.
  #
  # source://hydro-client//lib/hydro/sink/tee.rb#4
  def secondary; end

  # source://hydro-client//lib/hydro/sink/tee.rb#25
  def start_batch; end

  # source://hydro-client//lib/hydro/sink/tee.rb#35
  def write(*args); end

  private

  # source://hydro-client//lib/hydro/sink/tee.rb#42
  def method_missing(method, *args, &block); end
end

class Hydro::Sink::TimeoutError < ::Hydro::Sink::Error; end

class Hydro::Site
  # site - a string representing the site
  #
  # @return [Site] a new instance of Site
  #
  # source://hydro-client//lib/hydro/site.rb#4
  def initialize(site); end

  # source://hydro-client//lib/hydro/site.rb#29
  def ==(other); end

  # source://hydro-client//lib/hydro/site.rb#33
  def hash; end

  # Returns a protobuf enum value to write to the envelope
  #
  # source://hydro-client//lib/hydro/site.rb#13
  def site_for_envelope; end

  # source://hydro-client//lib/hydro/site.rb#25
  def to_s; end

  # source://hydro-client//lib/hydro/site.rb#21
  def to_sym; end

  private

  # source://hydro-client//lib/hydro/site.rb#39
  def normalized_site; end
end

module Hydro::Source; end
class Hydro::Source::Error < ::Hydro::Error; end

class Hydro::Source::Message
  # @return [Message] a new instance of Message
  #
  # source://hydro-client//lib/hydro/source/message.rb#7
  def initialize(key: T.unsafe(nil), value: T.unsafe(nil), topic: T.unsafe(nil), partition: T.unsafe(nil), offset: T.unsafe(nil), headers: T.unsafe(nil)); end

  # source://hydro-client//lib/hydro/source/message.rb#16
  def ==(other); end

  # source://hydro-client//lib/hydro/source/message.rb#22
  def hash; end

  # Returns the value of attribute headers.
  #
  # source://hydro-client//lib/hydro/source/message.rb#5
  def headers; end

  # Sets the attribute headers
  #
  # @param value the value to set the attribute headers to.
  #
  # source://hydro-client//lib/hydro/source/message.rb#5
  def headers=(_arg0); end

  # Returns the value of attribute key.
  #
  # source://hydro-client//lib/hydro/source/message.rb#5
  def key; end

  # Sets the attribute key
  #
  # @param value the value to set the attribute key to.
  #
  # source://hydro-client//lib/hydro/source/message.rb#5
  def key=(_arg0); end

  # Returns the value of attribute offset.
  #
  # source://hydro-client//lib/hydro/source/message.rb#5
  def offset; end

  # Sets the attribute offset
  #
  # @param value the value to set the attribute offset to.
  #
  # source://hydro-client//lib/hydro/source/message.rb#5
  def offset=(_arg0); end

  # Returns the value of attribute partition.
  #
  # source://hydro-client//lib/hydro/source/message.rb#5
  def partition; end

  # Sets the attribute partition
  #
  # @param value the value to set the attribute partition to.
  #
  # source://hydro-client//lib/hydro/source/message.rb#5
  def partition=(_arg0); end

  # Returns the value of attribute schema.
  #
  # source://hydro-client//lib/hydro/source/message.rb#5
  def schema; end

  # Sets the attribute schema
  #
  # @param value the value to set the attribute schema to.
  #
  # source://hydro-client//lib/hydro/source/message.rb#5
  def schema=(_arg0); end

  # source://hydro-client//lib/hydro/source/message.rb#26
  def to_h; end

  # Returns the value of attribute topic.
  #
  # source://hydro-client//lib/hydro/source/message.rb#5
  def topic; end

  # Sets the attribute topic
  #
  # @param value the value to set the attribute topic to.
  #
  # source://hydro-client//lib/hydro/source/message.rb#5
  def topic=(_arg0); end

  # Returns the value of attribute value.
  #
  # source://hydro-client//lib/hydro/source/message.rb#5
  def value; end

  # Sets the attribute value
  #
  # @param value the value to set the attribute value to.
  #
  # source://hydro-client//lib/hydro/source/message.rb#5
  def value=(_arg0); end

  protected

  # source://hydro-client//lib/hydro/source/message.rb#32
  def fields; end
end

class Hydro::StringEncoder
  # source://hydro-client//lib/hydro/encoding/string_encoder.rb#3
  def encode(message, **args); end
end

# source://hydro-client//lib/hydro/encoding/protobuf_encoder.rb#5
Hydro::TYPE_URL_PREFIX = T.let(T.unsafe(nil), Pathname)

module Hydro::Topic
  class << self
    # Public: Formats a Hydro topic by delegating to the format method
    # associated with format_version passing along the name and any
    # format_version specific options.
    #
    # format_version - Required format version - a class that implements
    #                  `.format(**options), see Hydro::Topic::FormatVersion for
    #                  examples.
    # name           - Required name component specific to format_version.
    #
    # Example:
    #
    #   # returns "cp1-iad.ingest.octochat.v0.Login"
    #   Hydro::Topic.format(
    #     format_version: Hydro::Topic::FormatVersion::V1,
    #     site: "cp1-iad",
    #     namespace: "ingest",
    #     name: "octochat.v0.Login"
    #   )
    #
    #   # returns "octochat.v0.Login"
    #   Hydro::Topic.format(
    #     format_version: Hydro::Topic::FormatVersion::V2,
    #     name: "octochat.v0.Login"
    #   )
    #
    # source://hydro-client//lib/hydro/topic.rb#57
    def format(format_version:, name:, **options); end
  end
end

# source://hydro-client//lib/hydro/topic.rb#27
Hydro::Topic::DEFAULT_FORMAT_OPTIONS = T.let(T.unsafe(nil), Hash)

module Hydro::Topic::FormatVersion; end

class Hydro::Topic::FormatVersion::V1
  class << self
    # source://hydro-client//lib/hydro/topic.rb#8
    def format(name:, site: T.unsafe(nil), namespace: T.unsafe(nil), **_arg3); end
  end
end

# source://hydro-client//lib/hydro/topic.rb#6
Hydro::Topic::FormatVersion::V1::DEFAULT_NAMESPACE = T.let(T.unsafe(nil), String)

# source://hydro-client//lib/hydro/topic.rb#5
Hydro::Topic::FormatVersion::V1::DEFAULT_SITE = T.let(T.unsafe(nil), String)

class Hydro::Topic::FormatVersion::V2
  class << self
    # source://hydro-client//lib/hydro/topic.rb#21
    def format(name:, **_arg1); end
  end
end

# source://hydro-client//lib/hydro/topic.rb#31
Hydro::Topic::HYDRO_SCHEMAS_PREFIX = T.let(T.unsafe(nil), Regexp)

# source://hydro-client//lib/hydro/version.rb#2
Hydro::VERSION = T.let(T.unsafe(nil), String)
