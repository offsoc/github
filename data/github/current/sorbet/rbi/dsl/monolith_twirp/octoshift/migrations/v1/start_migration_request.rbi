# typed: true

# DO NOT EDIT MANUALLY
# This is an autogenerated file for dynamic methods in `MonolithTwirp::Octoshift::Migrations::V1::StartMigrationRequest`.
# Please instead update this file by running `bin/tapioca dsl MonolithTwirp::Octoshift::Migrations::V1::StartMigrationRequest`.

class MonolithTwirp::Octoshift::Migrations::V1::StartMigrationRequest
  sig do
    params(
      access_token: T.nilable(String),
      continue_on_error: T.nilable(T::Boolean),
      git_archive_url: T.nilable(String),
      github_pat: T.nilable(String),
      metadata_archive_url: T.nilable(String),
      repository_name: T.nilable(String),
      should_lock_source: T.nilable(T::Boolean),
      skip_releases: T.nilable(T::Boolean),
      source_connector_id: T.nilable(String),
      source_identifier_url: T.nilable(String),
      target_repo_visibility: T.nilable(T.any(Symbol, Integer)),
      user_id: T.nilable(Integer)
    ).void
  end
  def initialize(access_token: nil, continue_on_error: nil, git_archive_url: nil, github_pat: nil, metadata_archive_url: nil, repository_name: nil, should_lock_source: nil, skip_releases: nil, source_connector_id: nil, source_identifier_url: nil, target_repo_visibility: nil, user_id: nil); end

  sig { returns(String) }
  def access_token; end

  sig { params(value: String).void }
  def access_token=(value); end

  sig { void }
  def clear_access_token; end

  sig { void }
  def clear_continue_on_error; end

  sig { void }
  def clear_git_archive_url; end

  sig { void }
  def clear_github_pat; end

  sig { void }
  def clear_metadata_archive_url; end

  sig { void }
  def clear_repository_name; end

  sig { void }
  def clear_should_lock_source; end

  sig { void }
  def clear_skip_releases; end

  sig { void }
  def clear_source_connector_id; end

  sig { void }
  def clear_source_identifier_url; end

  sig { void }
  def clear_target_repo_visibility; end

  sig { void }
  def clear_user_id; end

  sig { returns(T::Boolean) }
  def continue_on_error; end

  sig { params(value: T::Boolean).void }
  def continue_on_error=(value); end

  sig { returns(String) }
  def git_archive_url; end

  sig { params(value: String).void }
  def git_archive_url=(value); end

  sig { returns(String) }
  def github_pat; end

  sig { params(value: String).void }
  def github_pat=(value); end

  sig { returns(String) }
  def metadata_archive_url; end

  sig { params(value: String).void }
  def metadata_archive_url=(value); end

  sig { returns(String) }
  def repository_name; end

  sig { params(value: String).void }
  def repository_name=(value); end

  sig { returns(T::Boolean) }
  def should_lock_source; end

  sig { params(value: T::Boolean).void }
  def should_lock_source=(value); end

  sig { returns(T::Boolean) }
  def skip_releases; end

  sig { params(value: T::Boolean).void }
  def skip_releases=(value); end

  sig { returns(String) }
  def source_connector_id; end

  sig { params(value: String).void }
  def source_connector_id=(value); end

  sig { returns(String) }
  def source_identifier_url; end

  sig { params(value: String).void }
  def source_identifier_url=(value); end

  sig { returns(T.any(Symbol, Integer)) }
  def target_repo_visibility; end

  sig { params(value: T.any(Symbol, Integer)).void }
  def target_repo_visibility=(value); end

  sig { returns(Integer) }
  def user_id; end

  sig { params(value: Integer).void }
  def user_id=(value); end
end
