#!/usr/bin/env ruby
# frozen_string_literal: true

require "open3"
require "optparse"
require "ostruct"
require "json"

# Variables are wrapped with {{}} to be replaced with the actual values
PR_TITLE = "chore(deps): Update {{library}} to {{release_version}}"
PR_LABELS = %w[primer-release dependencies].freeze
PR_BODY_MARKDOWN = <<~MARKDOWN
  ### Context

  Shipping [{{library}}@{{release_version}}]({{release_pr}})

  ### Changelog

  {{changelog}}

  ### What approach did you choose and why?

  <!-- version: {{release_version}} -->
  <!-- library: {{library}} -->

  > [!NOTE]
  > :octocat: :robot: This pull request was generated by the [primer release workflow](https://github.com/github/primer-engineering/blob/main/how-we-work/primer-release-workflow.md) and auto assigned to @{{pr_assignee}}.

  ### Which environments does this change target?

  - [x] Production: dotcom
  - [x] Production: proxima
  - [x] Production: GHES
  - [ ] Non-production: dev/test
  - [ ] Non-production: docs

  ### Risk Assessment

  <!--
  Choose one of the following and detail why this level was chosen. Delete the others.

  See also: https://thehub.github.com/engineering/products-and-services/dotcom/pr-risk-and-rollout-review/#evaluate-the-pr-for-the-level-of-risk-it-presents
  -->

  - **Low risk** changes are fully under feature flag(s) OR the changes are small, highly observable, and easily rolled back.
  - **Medium risk** changes that are isolated, reduced in scope or could impact few users and not bring the site down.
  - **High risk** changes are those that could impact our customers and SLOs, low or no test coverage, low observability, or slow to rollback.

  ### If something goes wrong, what are the mitigation and rollback strategies?

  <!-- Delete risk mitigation strategies that don't apply. See also: https://thehub.github.com/engineering/products-and-services/dotcom/pr-risk-and-rollout-review/#evaluate-the-pr-for-the-level-of-risk-it-presents -->

  - ### **Unknown** - **I forgot to update this section and don't have a mitigation strategy.**
  - **Other** - Describe your plans if they don't fit into any other buckets.
  - **Experiment** - Change will be tested with an experiment, but will need to be rolled back if the experiment does not work. Please link to the relevant experiment below.
  - **Solo Deploy** - This change will be deployed solo, making it easier to monitor impact and revert if necessary. Solo deploys should be used sparingly since they prevent others from shipping with you.
  - **Feature Flag** - Change can be disabled by feature flag, but will need to be rolled back if the feature flag does not work. Please link to the feature flag in the DevPortal. <!-- Most production changes should be protected by feature flag(s). -->
  - **Review Lab Deploy** - This change will be tested on review-lab before being queued to deploy.
  - **Rollback** - Change can only be disabled by [rolling back](https://ops.githubapp.com/docs/playbooks/github_deployments.md) the merge group, or by deploying a revert commit.

  ---

  _**Reviewers:** Please read carefully. By approving, you support the deployment and mitigation plans as well as the code change. If anything is unclear or missing, please ask for updates._
MARKDOWN

options = OpenStruct.new
options_parse = OptionParser.new do |o|
  o.banner = "Usage: script/primer-release [<release-pr>]\n\nRelease pr must be from a primer library.\n\n"
  o.on("-p", "--create-patch", "Create a patch release") { options.patch = true }
  o.on("-a", "--apply-patch", "Apply patch release") { options.apply_patch = true }
  o.on("-h", "--help", "Print this help message") do
    puts o
    exit
  end
end

def message(msg)
  if ENV["GROUP_OUTPUT"] == "1"
    puts "::group::==> #{msg}"
  else
    puts "==> #{msg}"
  end
end

def run_shell(cmd)
  stdout, stderr, status = Open3.capture3(*cmd)
  if status.success?
    puts stdout
  else
    puts "Error: unexpected error running command: (`#{cmd.join(" ")}` exit #{status.exitstatus}):\n#{stderr}\n"
    exit 1
  end
end

def npm(package, version, workspace)
  message "Updating NPM package \"#{package}\" to #{version}"
  run_shell(["bin/npm", "install", "#{package}@#{version}", "-w", workspace])
  run_shell(["git", "status", "-s"])
  puts "::endgroup::" if ENV["GROUP_OUTPUT"] == "1"
end

# Update the library
def update_primer(options)
  case options.library

  # Primer Behaviors
  when "primer/behaviors"
    npm "@primer/behaviors", options.version, "./npm-workspaces/primer/"

  # Primer CSS
  when "primer/css"
    npm "@primer/css", options.version, "./npm-workspaces/primer/"

  # Primer Primitives
  when "primer/primitives"
    npm "@primer/primitives", options.version, "./npm-workspaces/primer/"

  # Primer React
  when "primer/react"
    npm "@primer/react", options.version, "./npm-workspaces/primer/"

  # Primer Stylelint Config
  when "primer/stylelint-config"
    npm "@primer/stylelint-config", options.version, "./ui/packages/stylelint/"

  # Primer View Components
  when "primer/view_components"
    message "Updating Gemfile \"primer_view_components\" to #{options.version}"
    run_shell(["script/vendor-gem", "https://github.com/primer/view_components.git", "-r", "changeset-release/main"])
    run_shell(["git", "status", "-s"])
    puts "::endgroup::" if ENV["GROUP_OUTPUT"] == "1"

    npm "@primer/view-components", options.version, "./npm-workspaces/primer/"

    # Not implemented
  else
    puts "Error: #{options.library} Not implemented"
    exit 1
  end
end

def lookup_release(options)
  message "Collecting release information from #{options.library}"

  release_pr = JSON.parse(`gh pr view #{options.release_pr} --json statusCheckRollup,body,headRefName`)

  raise OptionParser::InvalidOption, "\n\n#{options.release_pr} must be a Changesets release PR." unless release_pr["headRefName"] == "changeset-release/main"

  options.changelog = release_pr["body"].split("# Releases").last

  status_check = release_pr["statusCheckRollup"].find { |check| check["__typename"] == "StatusContext" }

  raise OptionParser::MissingArgument, "\n\nCannot find release candidate" if status_check.nil?
  options.version = status_check["targetUrl"].split(/@primer\/[^@]+@/).last.sub("/", "")

  options.release_version = options.changelog.match(Regexp.new("## @primer\/[^@]+@([0-9\.]+(?:-[a-zA-Z0-9\.]+)?)"))[1]

  options.branch = "release-#{options.library.sub("/", "-")}-#{options.release_version}"

  puts "Library: #{options.library}"
  puts "Version: #{options.release_version}"
  puts "URL: #{options.release_pr}"
  puts "Changelog: #{options.changelog}"
  puts "::endgroup::" if ENV["GROUP_OUTPUT"] == "1"
end

def replace_variables(template, options)
  body = template.dup
  options.each_pair do |key, value|
    body.gsub!("{{#{key}}}", value.to_s)
  end
  body
end

def create_branch(options)
  message "Creating branch '#{options.branch}'"
  run_shell(["git", "checkout", "-b", options.branch])
  puts "::endgroup::" if ENV["GROUP_OUTPUT"] == "1"
end

def push_branch(options)
  message "Pushing branch '#{options.branch}'"
  run_shell(["git", "push", "origin", options.branch])
  puts "::endgroup::" if ENV["GROUP_OUTPUT"] == "1"
end

def create_commit(options)
  message "Creating commit 'Update #{options.library} to #{options.version}'"
  run_shell(["git", "add", "."])
  run_shell(["git", "commit", "-m", "Update #{options.library} to #{options.version}"])
  puts "::endgroup::" if ENV["GROUP_OUTPUT"] == "1"
end

def create_patch(options)
  message "Creating patch for pull request."
  `git format-patch -1 HEAD --stdout > /tmp/prepare-primer-update-artifacts/primer.patch`
  puts "::endgroup::" if ENV["GROUP_OUTPUT"] == "1"
end

def apply_patch(options)
  message "Applying patch for pull request."
  run_shell(["git", "am", "--keep-non-patch", "/tmp/prepare-primer-update-artifacts/primer.patch"])
  puts "::endgroup::" if ENV["GROUP_OUTPUT"] == "1"
end

def submit_pr(options)

  # Any additional labels to add to the PR
  case options.library
  when "primer/view_components"
    options.labels << "pvc-release"
  when "primer/react"
    options.labels << "prc-release"
  end

  options.pr_assignee = ENV["PR_ASSIGNEE"] || "@me"

  tmp_file_path = "/tmp/primer-pr-body"
  title = replace_variables(PR_TITLE, options)
  message "Submitting Pull Request '#{title}'"
  body = replace_variables(PR_BODY_MARKDOWN, options)

  File.write(tmp_file_path, body)

  run_shell([
    "gh", "pr", "create",
    "--draft",
    "--base", "master",
    "--reviewer", "@github/primer-reviewers",
    "--assignee", options.pr_assignee,
    "--head", options.branch,
    options.labels.map { |l| ["-l", l] },
    "--title", title,
    "--body-file", tmp_file_path
  ].flatten)
  puts "::endgroup::" if ENV["GROUP_OUTPUT"] == "1"
end

begin
  options_parse.parse!(ARGV)
  options.release_pr = ARGV.shift
  # Verify arguments
  raise OptionParser::MissingArgument, "\n\nMissing argument: <release-pr>. Pass in the release pr you would like to use for the update." if options.release_pr.nil?

  options.library = options.release_pr.match(/primer\/[^\/]+/).to_s
  raise OptionParser::InvalidOption, "\n\nRepository url must be from a primer repository. #{options.release_pr}" unless options.library

  options.labels = PR_LABELS.dup

  lookup_release(options)
  if options.patch
    update_primer(options)
    create_commit(options)
    create_patch(options)
  elsif options.apply_patch
    create_branch(options)
    apply_patch(options)
    push_branch(options)
    submit_pr(options)
  end
rescue OptionParser::InvalidOption, OptionParser::MissingArgument, JSON::ParserError
  puts options_parse
  puts ""
  abort
end
