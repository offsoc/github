# typed: true

# DO NOT EDIT MANUALLY
# This is an autogenerated file for types exported from the `prawn` gem.
# Please instead update this file by running `bin/tapioca gem prawn`.

# Implementation of the "ARCFOUR" algorithm ("alleged RC4 (tm)"). Implemented
# as described at:
# http://www.mozilla.org/projects/security/pki/nss/draft-kaukonen-cipher-arcfour-03.txt
#
# "RC4" is a trademark of RSA Data Security, Inc.
#
# @private
#
# source://prawn//lib/prawn/security/arcfour.rb#10
class Arcfour
  # @return [Arcfour] a new instance of Arcfour
  #
  # source://prawn//lib/prawn/security/arcfour.rb#11
  def initialize(key); end

  # Encrypt string.
  #
  # @param string [String]
  # @return [String]
  #
  # source://prawn//lib/prawn/security/arcfour.rb#41
  def encrypt(string); end

  private

  # Produces the next byte of key material in the stream (3.2 Stream Generation)
  #
  # source://prawn//lib/prawn/security/arcfour.rb#48
  def key_byte; end
end

# @private
#
# source://prawn//lib/prawn/security.rb#208
module PDF; end

# source://prawn//lib/prawn/security.rb#209
module PDF::Core
  private

  # Like pdf_object, but returns an encrypted result if required.
  # For direct objects, requires the object identifier and generation number
  # from the indirect object referencing obj.
  #
  # @private
  #
  # source://prawn//lib/prawn/security.rb#217
  def encrypted_pdf_object(obj, key, id, gen, in_content_stream = T.unsafe(nil)); end

  # source://pdf-core/0.10.0/lib/pdf/core/pdf_object.rb#77
  def pdf_object(obj, in_content_stream = T.unsafe(nil)); end

  # source://pdf-core/0.10.0/lib/pdf/core/pdf_object.rb#11
  def real(num); end

  # source://pdf-core/0.10.0/lib/pdf/core/pdf_object.rb#22
  def real_params(array); end

  # source://pdf-core/0.10.0/lib/pdf/core/pdf_object.rb#42
  def string_to_hex(str); end

  # source://pdf-core/0.10.0/lib/pdf/core/pdf_object.rb#31
  def utf8_to_utf16(str); end

  class << self
    # Like pdf_object, but returns an encrypted result if required.
    # For direct objects, requires the object identifier and generation number
    # from the indirect object referencing obj.
    #
    # @private
    #
    # source://prawn//lib/prawn/security.rb#217
    def encrypted_pdf_object(obj, key, id, gen, in_content_stream = T.unsafe(nil)); end

    # source://pdf-core/0.10.0/lib/pdf/core/pdf_object.rb#77
    def pdf_object(obj, in_content_stream = T.unsafe(nil)); end

    # source://pdf-core/0.10.0/lib/pdf/core/pdf_object.rb#11
    def real(num); end

    # source://pdf-core/0.10.0/lib/pdf/core/pdf_object.rb#22
    def real_params(array); end

    # source://pdf-core/0.10.0/lib/pdf/core/pdf_object.rb#42
    def string_to_hex(str); end

    # source://pdf-core/0.10.0/lib/pdf/core/pdf_object.rb#31
    def utf8_to_utf16(str); end
  end
end

# @private
#
# source://prawn//lib/prawn/security.rb#284
class PDF::Core::Reference
  # source://pdf-core/0.10.0/lib/pdf/core/reference.rb#42
  def initialize(id, data); end

  # source://pdf-core/0.10.0/lib/pdf/core/reference.rb#69
  def <<(io); end

  # source://pdf-core/0.10.0/lib/pdf/core/reference.rb#21
  def data; end

  # source://pdf-core/0.10.0/lib/pdf/core/reference.rb#21
  def data=(_arg0); end

  # source://pdf-core/0.10.0/lib/pdf/core/reference.rb#89
  def deep_copy(share = T.unsafe(nil)); end

  # Returns the object definition for the object this references, keyed from
  # `key`.
  #
  # @param key [String]
  # @return [String]
  #
  # source://prawn//lib/prawn/security.rb#290
  def encrypted_object(key); end

  # source://pdf-core/0.10.0/lib/pdf/core/reference.rb#17
  def gen; end

  # source://pdf-core/0.10.0/lib/pdf/core/reference.rb#17
  def gen=(_arg0); end

  # source://pdf-core/0.10.0/lib/pdf/core/reference.rb#13
  def identifier; end

  # source://pdf-core/0.10.0/lib/pdf/core/reference.rb#13
  def identifier=(_arg0); end

  # source://pdf-core/0.10.0/lib/pdf/core/reference.rb#52
  def object; end

  # source://pdf-core/0.10.0/lib/pdf/core/reference.rb#25
  def offset; end

  # source://pdf-core/0.10.0/lib/pdf/core/reference.rb#25
  def offset=(_arg0); end

  # source://pdf-core/0.10.0/lib/pdf/core/reference.rb#112
  def replace(other_ref); end

  # source://pdf-core/0.10.0/lib/pdf/core/reference.rb#29
  def stream; end

  # source://pdf-core/0.10.0/lib/pdf/core/reference.rb#29
  def stream=(_arg0); end

  # source://pdf-core/0.10.0/lib/pdf/core/reference.rb#80
  def to_s; end
end

# @private
#
# source://prawn//lib/prawn/security.rb#263
class PDF::Core::Stream
  # source://pdf-core/0.10.0/lib/pdf/core/stream.rb#18
  def initialize(io = T.unsafe(nil)); end

  # source://pdf-core/0.10.0/lib/pdf/core/stream.rb#28
  def <<(io); end

  # source://pdf-core/0.10.0/lib/pdf/core/stream.rb#37
  def compress!; end

  # source://pdf-core/0.10.0/lib/pdf/core/stream.rb#47
  def compressed?; end

  # source://pdf-core/0.10.0/lib/pdf/core/stream.rb#99
  def data; end

  # source://pdf-core/0.10.0/lib/pdf/core/stream.rb#54
  def empty?; end

  # Encrypt stream.
  #
  # @param key [String]
  # @param id [Integer]
  # @param gen [Integer]
  # @return [String]
  #
  # source://prawn//lib/prawn/security.rb#270
  def encrypted_object(key, id, gen); end

  # source://pdf-core/0.10.0/lib/pdf/core/stream.rb#61
  def filtered_stream; end

  # source://pdf-core/0.10.0/lib/pdf/core/stream.rb#15
  def filters; end

  # source://pdf-core/0.10.0/lib/pdf/core/stream.rb#123
  def inspect; end

  # source://pdf-core/0.10.0/lib/pdf/core/stream.rb#81
  def length; end

  # source://pdf-core/0.10.0/lib/pdf/core/stream.rb#88
  def object; end
end

# Welcome to Prawn, the best PDF Generation library ever.
# This documentation covers user level functionality.
#
# source://prawn//lib/prawn.rb#10
module Prawn
  private

  # When set to `true`, Prawn will verify hash options to ensure only valid keys
  # are used. Off by default.
  #
  # Example:
  #
  # ```shell
  # >> Prawn::Document.new(:tomato => "Juicy")
  # Prawn::Errors::UnknownOption:
  # Detected unknown option(s): [:tomato]
  # Accepted options are: [:page_size, :page_layout, :left_margin, ...]
  # ```
  #
  # @private
  # @return [Boolean]
  #
  # source://prawn//lib/prawn.rb#38
  def debug; end

  # When set to `true`, Prawn will verify hash options to ensure only valid keys
  # are used. Off by default.
  #
  # Example:
  #
  # ```shell
  # >> Prawn::Document.new(:tomato => "Juicy")
  # Prawn::Errors::UnknownOption:
  # Detected unknown option(s): [:tomato]
  # Accepted options are: [:page_size, :page_layout, :left_margin, ...]
  # ```
  #
  # @private
  # @return [Boolean]
  #
  # source://prawn//lib/prawn.rb#38
  def debug=(_arg0); end

  # @param accepted [Array<Symbol>] list of valid options
  # @param actual [Hash<Symbol, any>] opetions hash to validate
  # @private
  # @raise [Prawn::Errors::UnknownOption]
  # @return [void]
  # @yield
  #
  # source://prawn//lib/prawn.rb#50
  def verify_options(accepted, actual); end

  class << self
    # When set to `true`, Prawn will verify hash options to ensure only valid keys
    # are used. Off by default.
    #
    # Example:
    #
    # ```shell
    # >> Prawn::Document.new(:tomato => "Juicy")
    # Prawn::Errors::UnknownOption:
    # Detected unknown option(s): [:tomato]
    # Accepted options are: [:page_size, :page_layout, :left_margin, ...]
    # ```
    #
    # @private
    # @return [Boolean]
    #
    # source://prawn//lib/prawn.rb#38
    def debug; end

    # When set to `true`, Prawn will verify hash options to ensure only valid keys
    # are used. Off by default.
    #
    # Example:
    #
    # ```shell
    # >> Prawn::Document.new(:tomato => "Juicy")
    # Prawn::Errors::UnknownOption:
    # Detected unknown option(s): [:tomato]
    # Accepted options are: [:page_size, :page_layout, :left_margin, ...]
    # ```
    #
    # @private
    # @return [Boolean]
    #
    # source://prawn//lib/prawn.rb#38
    def debug=(_arg0); end

    # Image handler.
    #
    # @return [ImageHandler]
    #
    # source://prawn//lib/prawn/image_handler.rb#9
    def image_handler; end

    # @param accepted [Array<Symbol>] list of valid options
    # @param actual [Hash<Symbol, any>] opetions hash to validate
    # @private
    # @raise [Prawn::Errors::UnknownOption]
    # @return [void]
    # @yield
    #
    # source://prawn//lib/prawn.rb#50
    def verify_options(accepted, actual); end
  end
end

# The base source directory for Prawn as installed on the system.
#
# source://prawn//lib/prawn.rb#16
Prawn::BASEDIR = T.let(T.unsafe(nil), String)

# Directory where Prawn keeps its data files.
#
# source://prawn//lib/prawn.rb#19
Prawn::DATADIR = T.let(T.unsafe(nil), String)

# source://prawn//lib/prawn/security.rb#8
class Prawn::Document
  include ::Prawn::Document::Internals
  include ::PDF::Core::Annotations
  include ::PDF::Core::Destinations
  include ::Prawn::Document::Security
  include ::PDF::Core::Text
  include ::Prawn::Text::Formatted
  include ::Prawn::Text
  include ::Prawn::Graphics::BlendMode
  include ::Prawn::Graphics::Color
  include ::Prawn::Graphics::Dash
  include ::Prawn::Graphics::CapStyle
  include ::Prawn::Graphics::JoinStyle
  include ::Prawn::Graphics::Transparency
  include ::Prawn::Graphics::Transformation
  include ::Prawn::Graphics::Patterns
  include ::Prawn::Graphics
  include ::Prawn::Images
  include ::Prawn::Stamp
  include ::Prawn::SoftMask
  include ::Prawn::TransformationStack

  # Creates a new PDF Document.
  #
  # Setting e.g. the `:margin` to 100 points and the `:left_margin` to 50 will
  # result in margins of 100 points on every side except for the left, where
  # it will be 50.
  #
  # The `:margin` can also be an array much like CSS shorthand:
  #
  # ```ruby
  # # Top and bottom are 20, left and right are 100.
  # margin: [20, 100]
  # # Top is 50, left and right are 100, bottom is 20.
  # margin: [50, 100, 20]
  # # Top is 10, right is 20, bottom is 30, left is 40.
  # margin: [10, 20, 30, 40]
  # ```
  #
  # Additionally, `:page_size` can be specified as a simple two value array
  # giving the width and height of the document you need in PDF Points.
  #
  # @example New document, US Letter paper, portrait orientation
  #   pdf = Prawn::Document.new
  # @example New document, A4 paper, landscaped
  #   pdf = Prawn::Document.new(page_size: "A4", page_layout: :landscape)
  # @example New document, Custom size
  #   pdf = Prawn::Document.new(page_size: [200, 300])
  # @example New document, with background
  #   pdf = Prawn::Document.new(
  #   background: "#{Prawn::DATADIR}/images/pigs.jpg"
  #   )
  # @option options
  # @option options
  # @option options
  # @option options
  # @option options
  # @option options
  # @option options
  # @option options
  # @option options
  # @option options
  # @option options
  # @option options
  # @option options
  # @param options [Hash{Symbol => any}]
  # @return [Document] a new instance of Document
  #
  # source://prawn//lib/prawn/document.rb#227
  def initialize(options = T.unsafe(nil), &block); end

  # A bounding box serves two important purposes:
  # * Provide bounds for flowing text, starting at a given point
  # * Translate the origin (0, 0) for graphics primitives
  #
  # #### Positioning
  #
  # Bounding boxes are positioned relative to their top left corner and
  # the width measurement is towards the right and height measurement is
  # downwards.
  #
  # Usage:
  #
  # * Bounding box 100pt×100pt in the absolute bottom left of the
  #   containing box:
  #
  #   ```ruby
  #   pdf.bounding_box([0, 100], width: 100, height: 100)
  #     stroke_bounds
  #   end
  #   ```
  #
  # * Bounding box 200pt×400pt high in the center of the page:
  #
  #   ```ruby
  #   x_pos = ((bounds.width / 2) - 150)
  #   y_pos = ((bounds.height / 2) + 200)
  #   pdf.bounding_box([x_pos, y_pos], width: 300, height: 400) do
  #     stroke_bounds
  #   end
  #   ```
  #
  # #### Flowing Text
  #
  # When flowing text, the usage of a bounding box is simple. Text will
  # begin at the point specified, flowing the width of the bounding box.
  # After the block exits, the cursor position will be moved to
  # the bottom of the bounding box (y - height). If flowing text exceeds
  # the height of the bounding box, the text will be continued on the next
  # page, starting again at the top-left corner of the bounding box.
  #
  # Usage:
  #
  # ```ruby
  # pdf.bounding_box([100, 500], width: 100, height: 300) do
  #   pdf.text "This text will flow in a very narrow box starting" +
  #    "from [100, 500]. The pointer will then be moved to [100, 200]" +
  #    "and return to the margin_box"
  # end
  # ```
  #
  # Note, this is a low level tool and is designed primarily for building
  # other abstractions. If you just need to flow text on the page, you
  # will want to look at {span} and {text_box} instead.
  #
  # #### Translating Coordinates
  #
  # When translating coordinates, the idea is to allow the user to draw
  # relative to the origin, and then translate their drawing to a specified
  # area of the document, rather than adjust all their drawing coordinates
  # to match this new region.
  #
  # Take for example two triangles which share one point, drawn from the
  # origin:
  #
  # ```ruby
  # pdf.polygon [0, 250], [0, 0], [150, 100]
  # pdf.polygon [100, 0], [150, 100], [200, 0]
  # ```
  #
  # It would be easy enough to translate these triangles to another point,
  # e.g `[200, 200]`
  #
  # ```ruby
  # pdf.polygon [200, 450], [200, 200], [350, 300]
  # pdf.polygon [300, 200], [350, 300], [400, 200]
  # ```
  #
  # However, each time you want to move the drawing, you'd need to alter
  # every point in the drawing calls, which as you might imagine, can become
  # tedious.
  #
  # If instead, we think of the drawing as being bounded by a box, we can
  # see that the image is 200 points wide by 250 points tall.
  #
  # To translate it to a new origin, we simply select a point at
  # (x, y + height).
  #
  # Using the [200, 200] example:
  #
  # ```ruby
  # pdf.bounding_box([200, 450], width: 200, height: 250) do
  #   pdf.stroke do
  #     pdf.polygon [0, 250], [0, 0], [150, 100]
  #     pdf.polygon [100, 0], [150, 100], [200, 0]
  #   end
  # end
  # ```
  #
  # Notice that the drawing is still relative to the origin. If we want to
  # move this drawing around the document, we simply need to recalculate the
  # top-left corner of the rectangular bounding-box, and all of our graphics
  # calls remain unmodified.
  #
  # #### Nesting Bounding Boxes
  #
  # At the top level, bounding boxes are specified relative to the document's
  # margin_box (which is itself a bounding box). You can also nest bounding
  # boxes, allowing you to build components which are relative to each other
  #
  # Usage:
  #
  # ```ruby
  # pdf.bounding_box([200, 450], width: 200, height: 250) do
  #   pdf.stroke_bounds   # Show the containing bounding box
  #   pdf.bounding_box([50, 200], width: 50, height: 50) do
  #     # a 50x50 bounding box that starts 50 pixels left and 50 pixels down
  #     # the parent bounding box.
  #     pdf.stroke_bounds
  #   end
  # end
  # ```
  #
  # #### Stretchiness
  #
  # If you do not specify a height to a bounding box, it will become stretchy
  # and its height will be calculated automatically as you stretch the box
  # downwards.
  #
  #  pdf.bounding_box([100, 400], width: 400) do
  #    pdf.text("The height of this box is #{pdf.bounds.height}")
  #    pdf.text('this is some text')
  #    pdf.text('this is some more text')
  #    pdf.text('and finally a bit more')
  #    pdf.text("Now the height of this box is #{pdf.bounds.height}")
  #  end
  #
  # #### Absolute Positioning
  #
  # If you wish to position the bounding boxes at absolute coordinates rather
  # than relative to the margins or other bounding boxes, you can use canvas()
  #
  # ```ruby
  # pdf.bounding_box([50, 500], width: 200, height: 300) do
  #   pdf.stroke_bounds
  #   pdf.canvas do
  #     Positioned outside the containing box at the 'real' (300, 450)
  #     pdf.bounding_box([300, 450], width: 200, height: 200) do
  #       pdf.stroke_bounds
  #     end
  #   end
  # end
  # ```
  #
  # Of course, if you use canvas, you will be responsible for ensuring that
  # you remain within the printable area of your document.
  #
  # @overload bounding_box
  #
  # source://prawn//lib/prawn/document/bounding_box.rb#174
  def bounding_box(point, *args, &block); end

  # The bounds method returns the current bounding box you are currently in,
  # which is by default the box represented by the margin box on the
  # document itself. When called from within a created `bounding_box`
  # block, the box defined by that call will be returned instead of the
  # document margin box.
  #
  # Another important point about bounding boxes is that all x and
  # y measurements within a bounding box code block are relative to the bottom
  # left corner of the bounding box.
  #
  # @example
  #   Prawn::Document.new do
  #   # In the default "margin box" of a Prawn document of 0.5in along each
  #   # edge
  #
  #   # Draw a border around the page (the manual way)
  #   stroke do
  #   line(bounds.bottom_left, bounds.bottom_right)
  #   line(bounds.bottom_right, bounds.top_right)
  #   line(bounds.top_right, bounds.top_left)
  #   line(bounds.top_left, bounds.bottom_left)
  #   end
  #
  #   # Draw a border around the page (the easy way)
  #   stroke_bounds
  #   end
  # @return [Prawn::Document::BoundingBox]
  #
  # source://prawn//lib/prawn/document.rb#504
  def bounds; end

  # Sets {Document#bounds} to the {BoundingBox} provided. See {#bounds} for
  # a brief description of what a bounding box is. This function is useful if
  # you really need to change the bounding box manually, but usually, just
  # entering and exiting bounding box code blocks is good enough.
  #
  # @param bounding_box [Prawn::Document::BoundingBox]
  # @return [bounding_box]
  #
  # source://prawn//lib/prawn/document.rb#523
  def bounds=(bounding_box); end

  # A shortcut to produce a bounding box which is mapped to the document's
  # absolute coordinates, regardless of how things are nested or margin sizes.
  #
  # @example
  #   pdf.canvas do
  #   pdf.line pdf.bounds.bottom_left, pdf.bounds.top_right
  #   end
  # @return [void]
  # @yieldreturn [void]
  #
  # source://prawn//lib/prawn/document/bounding_box.rb#191
  def canvas(&block); end

  # source://prawn-table/0.2.2/lib/prawn/table/cell.rb#21
  def cell(options = T.unsafe(nil)); end

  # A column box is a bounding box with the additional property that when
  # text flows past the bottom, it will wrap first to another column on the
  # same page, and only flow to the next page when all the columns are
  # filled.
  #
  # `column_box` accepts the same parameters as {bounding_box}, as well as the
  # number of `:columns` and a `:spacer` (in points) between columns. If
  # resetting the top margin is desired on a new page (e.g. to allow for
  # initial page wide column titles) the option `reflow_margins: true` can be
  # set.
  #
  # @overload column_box
  #
  # source://prawn//lib/prawn/document/column_box.rb#34
  def column_box(*args, &block); end

  # The current y drawing position relative to the innermost bounding box,
  # or to the page margins at the top level.
  #
  # @return [Number]
  #
  # source://prawn//lib/prawn/document.rb#415
  def cursor; end

  # Defines the grid system for a particular document. Takes the number of
  # rows and columns and the width to use for the gutter as the
  # keys :rows, :columns, :gutter, :row_gutter, :column_gutter
  #
  # @note A completely new grid object is built each time `define_grid`
  #   is called. This means that all subsequent calls to grid() will use
  #   the newly defined Grid object -- grids are not nestable like
  #   bounding boxes are.
  # @option options
  # @option options
  # @option options
  # @option options
  # @option options
  # @param options [Hash{Symbol => any}]
  # @return [Grid]
  #
  # source://prawn//lib/prawn/grid.rb#24
  def define_grid(options = T.unsafe(nil)); end

  # Remove page of the document by index.
  #
  # @example
  #   pdf = Prawn::Document.new
  #   pdf.page_count #=> 1
  #   3.times { pdf.start_new_page }
  #   pdf.page_count #=> 4
  #   pdf.delete_page(-1)
  #   pdf.page_count #=> 3
  # @param index [Integer]
  # @return [Boolean]
  #
  # source://prawn//lib/prawn/document.rb#366
  def delete_page(index); end

  # Looks up the given font using the given criteria. Once a font has been
  # found by that matches the criteria, it will be cached to subsequent
  # lookups for that font will return the same object.
  #
  # @option options
  # @option options
  # @option options
  # @param name [String]
  # @param options [Hash]
  # @private
  # @return [Font]
  #
  # source://prawn//lib/prawn/font.rb#291
  def find_font(name, options = T.unsafe(nil)); end

  # Executes a block and then restores the original y position. If new pages
  # were created during this block, it will teleport back to the original
  # page when done.
  #
  # @example
  #   pdf.text "A"
  #
  #   pdf.float do
  #   pdf.move_down 100
  #   pdf.text "C"
  #   end
  #
  #   pdf.text "B"
  # @return [void]
  #
  # source://prawn//lib/prawn/document.rb#442
  def float; end

  # Without arguments, this returns the currently selected font. Otherwise, it
  # sets the current font. When a block is used, the font is applied
  # transactionally and is rolled back when the block exits.
  #
  # ```ruby
  # Prawn::Document.generate("font.pdf") do
  #   text "Default font is Helvetica"
  #
  #   font "Times-Roman"
  #   text "Now using Times-Roman"
  #
  #   font("DejaVuSans.ttf") do
  #     text "Using TTF font from file DejaVuSans.ttf"
  #     font "Courier", style: :bold
  #     text "You see this in bold Courier"
  #   end
  #
  #   text "Times-Roman, again"
  # end
  # ```
  #
  # The `name` parameter must be a string. It can be one of the 14 built-in
  # fonts supported by PDF, or the location of a TTF file. The
  # {Fonts::AFM::BUILT_INS} array specifies the valid built in font names.
  #
  # If a TTF/OTF font is specified, the glyphs necessary to render your
  # document will be embedded in the rendered PDF. This should be your
  # preferred option in most cases. It will increase the size of the resulting
  # file, but also make it more portable.
  #
  # The options parameter is an optional hash providing size and style. To use
  # the :style option you need to map those font styles to their respective
  # font files.
  #
  # @option options
  # @param name [String] font name. It can be:
  #   - One of 14 PDF built-in fonts.
  #   - A font file path.
  #   - A font name defined in {font_families}
  # @param options [Hash{Symbol => any}]
  # @return [Font]
  # @see #font_families
  # @see Font::AFM::BUILT_INS
  # @yield
  #
  # source://prawn//lib/prawn/font.rb#56
  def font(name = T.unsafe(nil), options = T.unsafe(nil)); end

  # Hash that maps font family names to their styled individual font
  # definitions.
  #
  # To add support for another font family, append to this hash, e.g:
  #
  # ```ruby
  # pdf.font_families.update(
  #   "MyTrueTypeFamily" => {
  #     bold: "foo-bold.ttf",
  #     italic: "foo-italic.ttf",
  #     bold_italic: "foo-bold-italic.ttf",
  #     normal: "foo.ttf",
  #   }
  # )
  # ```
  #
  # This will then allow you to use the fonts like so:
  #
  # ```ruby
  # pdf.font("MyTrueTypeFamily", style: :bold)
  # pdf.text "Some bold text"
  # pdf.font("MyTrueTypeFamily")
  # pdf.text "Some normal text"
  # ```
  #
  # This assumes that you have appropriate TTF/OTF fonts for each style you
  # wish to support.
  #
  # By default the styles `:bold`, `:italic`, `:bold_italic`, and `:normal`
  # are defined for fonts "Courier", "Times-Roman" and "Helvetica". When
  # defining your own font families, you can map any or all of these styles to
  # whatever font files you'd like.
  #
  # Font definition can be either a hash or just a string.
  #
  # A hash font definition can specify a number of options:
  #
  # - `:file` -- path to the font file (required)
  # - `:subset` -- whether to subset the font (default false). Only
  #   applicable to TrueType and OpenType fonts (includnig DFont and TTC).
  #
  # A string font definition is equivalent to hash definition with only
  # `:file` being specified.
  #
  # @return [Hash{String => Hash{Symbol => String, Hash{Symbol => String}}}]
  #
  # source://prawn//lib/prawn/font.rb#212
  def font_families; end

  # Hash of Font objects keyed by names.
  #
  # @private
  # @return [Hash{String => Font}]
  #
  # source://prawn//lib/prawn/font.rb#314
  def font_registry; end

  # When called with no argument, returns the current font size.
  #
  # When called with a single argument but no block, sets the current font
  # size. When a block is used, the font size is applied transactionally and
  # is rolled back when the block exits. You may still change the font size
  # within a transactional block for individual text segments, or nested calls
  # to `font_size`.
  #
  # @example
  #   Prawn::Document.generate("font_size.pdf") do
  #   font_size 16
  #   text "At size 16"
  #
  #   font_size(10) do
  #   text "At size 10"
  #   text "At size 6", size: 6
  #   text "At size 10"
  #   end
  #
  #   text "At size 16"
  #   end
  # @overload font_size
  # @overload font_size
  #
  # source://prawn//lib/prawn/font.rb#106
  def font_size(points = T.unsafe(nil)); end

  # Sets the font size.
  #
  # @param size [Number]
  # @return [Number]
  #
  # source://prawn//lib/prawn/font.rb#119
  def font_size=(size); end

  # Re-opens the page with the given (1-based) page number so that you can
  # draw on it.
  #
  # @param page_number [Integer]
  # @return [void]
  #
  # source://prawn//lib/prawn/document.rb#395
  def go_to_page(page_number); end

  # A method that can either be used to access a particular grid on the page
  # or work with the grid system directly.
  #
  # @overload grid
  # @overload grid
  # @overload grid
  #
  # source://prawn//lib/prawn/grid.rb#50
  def grid(*args); end

  # @private
  # @raise [NotImplementedError]
  #
  # source://prawn//lib/prawn/document.rb#700
  def group(*_arguments); end

  # Indents the specified number of PDF points for the duration of the block
  #
  # @example
  #   pdf.text "some text"
  #   pdf.indent(20) do
  #   pdf.text "This is indented 20 points"
  #   end
  #   pdf.text "This starts 20 points left of the above line " +
  #   "and is flush with the first line"
  #   pdf.indent 20, 20 do
  #   pdf.text "This line is indented on both sides."
  #   end
  # @param left [Number]
  # @param right [Number]
  # @return [void]
  # @yield
  #
  # source://prawn//lib/prawn/document.rb#615
  def indent(left, right = T.unsafe(nil), &block); end

  # Initializes the first page in a new document.
  # This methods allows customisation of this process in extensions such as
  # Prawn::Template.
  #
  # @param options [Hash]
  # @return [void]
  #
  # source://prawn//lib/prawn/document.rb#767
  def initialize_first_page(options); end

  def inspect; end

  # source://prawn-table/0.2.2/lib/prawn/table/cell.rb#33
  def make_cell(content, options = T.unsafe(nil)); end

  # Current margin box.
  #
  # @return [Prawn::Document::BoundingBox]
  #
  # source://prawn//lib/prawn/document.rb#109
  def margin_box; end

  # Current margin box.
  #
  # @return [Prawn::Document::BoundingBox]
  #
  # source://prawn//lib/prawn/document.rb#109
  def margin_box=(_arg0); end

  # Current page margins.
  #
  # @return [{:left, :top, :right, :bottom => Number}]
  #
  # source://prawn//lib/prawn/document.rb#113
  def margins; end

  # @private
  #
  # source://prawn//lib/prawn/document.rb#749
  def mask(*fields); end

  # Moves to the specified y position in relative terms to the bottom margin.
  #
  # @param new_y [Number]
  # @return [void]
  #
  # source://prawn//lib/prawn/document.rb#423
  def move_cursor_to(new_y); end

  # Moves down the document by n points relative to the current position
  # inside the current bounding box.
  #
  # @param amount [Number]
  # @return [void]
  #
  # source://prawn//lib/prawn/document.rb#541
  def move_down(amount); end

  # Moves up the document by n points relative to the current position inside
  # the current bounding box.
  #
  # @param amount [Number]
  # @return [void]
  #
  # source://prawn//lib/prawn/document.rb#532
  def move_up(amount); end

  # Places a text box on specified pages for page numbering.  This should be
  # called towards the end of document creation, after all your content is
  # already in place. In your template string, `<page>` refers to the current
  # page, and `<total>` refers to the total amount of pages in the document.
  # Page numbering should occur at the end of your {Prawn::Document.generate}
  # block because the method iterates through existing pages after they are
  # created.
  #
  # Please refer to {Prawn::Text#text_box} for additional options concerning
  # text formatting and placement.
  #
  # @example Print page numbers on every page except for the first. Start counting from five.
  #   Prawn::Document.generate("page_with_numbering.pdf") do
  #   number_pages "<page> in a total of <total>", {
  #   start_count_at: 5,
  #   page_filter: lambda { |pg| pg != 1 },
  #   at: [bounds.right - 50, 0],
  #   align: :right,
  #   size: 14
  #   }
  #   end
  # @option options
  # @option options
  # @option options
  # @option options
  # @param string [String] Template string for page number wording.
  #   Should include `<page>` and, optionally, `<total>`.
  # @param options [Hash{Symbol => any}] A hash for page numbering and text box options.
  #
  # source://prawn//lib/prawn/document.rb#652
  def number_pages(string, options = T.unsafe(nil)); end

  # Lazily instantiates a Prawn::Outline object for document. This is used as
  # point of entry to methods to build the outline tree for a document's table
  # of contents.
  #
  # @return [Prawn::Outline]
  #
  # source://prawn//lib/prawn/outline.rb#12
  def outline; end

  # Moves down the document by y, executes a block, then moves down the
  # document by y again.
  #
  # @example
  #   pdf.text "some text"
  #   pdf.pad(100) do
  #   pdf.text "This is 100 points below the previous line of text"
  #   end
  #   pdf.text "This is 100 points below the previous line of text"
  # @param y [Number]
  # @return [void]
  # @yield
  #
  # source://prawn//lib/prawn/document.rb#592
  def pad(y); end

  # Executes a block then moves down the document
  #
  # @example
  #   pdf.text "some text"
  #   pdf.pad_bottom(100) do
  #   pdf.text "This text appears right below the previous line of text"
  #   end
  #   pdf.text "This is 100 points below the previous line of text"
  # @param y [Number]
  # @return [void]
  # @yield
  #
  # source://prawn//lib/prawn/document.rb#574
  def pad_bottom(y); end

  # Moves down the document and then executes a block.
  #
  # @example
  #   pdf.text "some text"
  #   pdf.pad_top(100) do
  #   pdf.text "This is 100 points below the previous line of text"
  #   end
  #   pdf.text "This text appears right below the previous line of text"
  # @param y [Number]
  # @return [void]
  # @yield
  #
  # source://prawn//lib/prawn/document.rb#557
  def pad_top(y); end

  # @private
  #
  # source://prawn//lib/prawn/document.rb#781
  def page; end

  # Number of pages in the document.
  #
  # @example
  #   pdf = Prawn::Document.new
  #   pdf.page_count #=> 1
  #   3.times { pdf.start_new_page }
  #   pdf.page_count #=> 4
  # @return [Integer]
  #
  # source://prawn//lib/prawn/document.rb#386
  def page_count; end

  # Provides a way to execute a block of code repeatedly based on a
  # page_filter.
  #
  # Available page filters are:
  #   :all         repeats on every page
  #   :odd         repeats on odd pages
  #
  # @param page_filter [:all, :odd, :even, Array<Number>, Range, Proc] * `:all`: repeats on every page
  #   * `:odd`: repeats on odd pages
  #   * `:even`: repeats on even pages
  #   * array: repeats on every page listed in the array
  #   * range: repeats on every page included in the range
  #   * lambda: yields page number and repeats for true return values
  # @param page_number [Integer]
  # @return [Boolean]
  #
  # source://prawn//lib/prawn/document.rb#733
  def page_match?(page_filter, page_number); end

  # Current page number.
  #
  # @return [Integer]
  #
  # source://prawn//lib/prawn/document.rb#121
  def page_number; end

  # Current page number.
  #
  # @return [Integer]
  #
  # source://prawn//lib/prawn/document.rb#121
  def page_number=(_arg0); end

  # Returns the innermost non-stretchy bounding box.
  #
  # @private
  # @return [Prawn::Document::BoundingBox]
  #
  # source://prawn//lib/prawn/document.rb#512
  def reference_bounds; end

  # Renders the PDF document to string.
  # Pass an open file descriptor to render to file.
  #
  # @overload render
  #
  # source://prawn//lib/prawn/document.rb#456
  def render(*arguments); end

  # Renders the PDF document to file.
  #
  # @example
  #   pdf.render_file "foo.pdf"
  # @param filename [String]
  # @return [void]
  #
  # source://prawn//lib/prawn/document.rb#472
  def render_file(filename); end

  # Provides a way to execute a block of code repeatedly based on
  # a `page_filter`. Since Stamp is used under the hood, this method is very
  # space efficient.
  #
  # Also accepts an optional second argument for dynamic content which
  # executes the code in the context of the filtered pages without using
  # a Stamp.
  #
  # @example
  #   Prawn::Document.generate("repeat.pdf", skip_page_creation: true) do
  #   repeat :all do
  #   draw_text "ALLLLLL", at: bounds.top_left
  #   end
  #
  #   repeat :odd do
  #   draw_text "ODD", at: [0, 0]
  #   end
  #
  #   repeat :even do
  #   draw_text "EVEN", at: [0, 0]
  #   end
  #
  #   repeat [1, 2] do
  #   draw_text "[1, 2]", at: [100, 0]
  #   end
  #
  #   repeat 2..4 do
  #   draw_text "2..4", at: [200, 0]
  #   end
  #
  #   repeat(lambda { |pg| pg % 3 == 0 }) do
  #   draw_text "Every third", at: [250, 20]
  #   end
  #
  #   10.times do
  #   start_new_page
  #   draw_text "A wonderful page", at: [400, 400]
  #   end
  #
  #   repeat(:all, dynamic: true) do
  #   text page_number, at: [500, 0]
  #   end
  #   end
  # @option options
  # @param page_filter [:all, :odd, :even, Array<Integer>, Range, Proc] Pages to draw the repeater content on.
  #
  #   Available page filters are:
  #
  #   - `:all` -- repeats on every page.
  #   - `:odd` -- repeats on odd pages.
  #   - `:even` -- repeats on even pages.
  #   - Array of Integers -- repeats on every page listed in the array.
  #   - Range -- repeats on every page included in the range.
  #   - Proc -- yields page number and repeats for true return values.
  # @param options [Hash]
  # @return [void]
  #
  # source://prawn//lib/prawn/repeater.rb#77
  def repeat(page_filter, options = T.unsafe(nil), &block); end

  # A list of all repeaters in the document.
  # See {repeat} for details.
  #
  # @private
  # @return [Array]
  #
  # source://prawn//lib/prawn/repeater.rb#10
  def repeaters; end

  # Saves the current font, and then yields. When the block finishes, the
  # original font is restored.
  #
  # @return [void]
  # @yield
  #
  # source://prawn//lib/prawn/font.rb#255
  def save_font; end

  # Sets the font directly, given an actual {Font} object and size.
  #
  # @param font [Font]
  # @param size [Number]
  # @private
  # @return [void]
  #
  # source://prawn//lib/prawn/font.rb#245
  def set_font(font, size = T.unsafe(nil)); end

  # A span is a special purpose bounding box that allows a column of elements
  # to be positioned relative to the margin_box.
  #
  # This method is typically used for flowing a column of text from one page
  # to the next.
  #
  # @example
  #   span(350, position: :center) do
  #   text "Here's some centered text in a 350 point column. " * 100
  #   end
  # @option options
  # @param width [Number] The width of the column in PDF points
  # @param options [Hash{Symbol => any }]
  # @raise [ArgumentError] For unsupported `:position` value.
  # @return [void]
  # @yield
  #
  # source://prawn//lib/prawn/document/span.rb#31
  def span(width, options = T.unsafe(nil)); end

  # Creates and advances to a new page in the document.
  #
  # Page size, margins, and layout can also be set when generating a
  # new page. These values will become the new defaults for page creation.
  #
  # @example
  #   pdf.start_new_page #=> Starts new page keeping current values
  #   pdf.start_new_page(size: "LEGAL", :layout => :landscape)
  #   pdf.start_new_page(left_margin: 50, right_margin: 50)
  #   pdf.start_new_page(margin: 100)
  # @option options
  # @option options
  # @option options
  # @option options
  # @option options
  # @option options
  # @option options
  # @option options
  # @param options [Hash]
  # @return [void]
  #
  # source://prawn//lib/prawn/document.rb#299
  def start_new_page(options = T.unsafe(nil)); end

  # @private
  #
  # source://prawn//lib/prawn/document.rb#778
  def state; end

  # @private
  #
  # source://prawn//lib/prawn/document.rb#778
  def state=(_arg0); end

  # Current text formatter. By default it's {Text::Formatted::Parser}
  #
  # @return [Object]
  #
  # source://prawn//lib/prawn/document.rb#127
  def text_formatter; end

  # Current text formatter. By default it's {Text::Formatted::Parser}
  #
  # @return [Object]
  #
  # source://prawn//lib/prawn/document.rb#127
  def text_formatter=(_arg0); end

  # @private
  # @raise [NotImplementedError]
  #
  # source://prawn//lib/prawn/document.rb#709
  def transaction; end

  # Returns the width of the given string using the given font. If `:size` is
  # not specified as one of the options, the string is measured using the
  # current font size. You can also pass `:kerning` as an option to indicate
  # whether kerning should be used when measuring the width (defaults to
  # `false`).
  #
  # Note that the string _must_ be encoded properly for the font being used.
  # For AFM fonts, this is WinAnsi. For TTF/OTF, make sure the font is encoded
  # as UTF-8. You can use the Font#normalize_encoding method to make sure
  # strings are in an encoding appropriate for the current font.
  #
  # @option options
  # @option options
  # @option options
  # @param string [String]
  # @param options [Hash{Symbol => any}]
  # @return [Number]
  #
  # source://prawn//lib/prawn/font.rb#150
  def width_of(string, options = T.unsafe(nil)); end

  # Absolute cursor position.
  #
  # @return [Number]
  #
  # source://prawn//lib/prawn/document.rb#117
  def y; end

  # Set cursor absolute position.
  #
  # @param new_y [Number]
  # @return [new_y]
  #
  # source://prawn//lib/prawn/document.rb#406
  def y=(new_y); end

  private

  # source://prawn//lib/prawn/document.rb#823
  def apply_margin_options(options); end

  # source://prawn//lib/prawn/document.rb#842
  def font_metric_cache; end

  # source://prawn//lib/prawn/document.rb#798
  def generate_margin_box; end

  # @yield [parent_box]
  #
  # source://prawn//lib/prawn/document/bounding_box.rb#206
  def init_bounding_box(user_block, options = T.unsafe(nil)); end

  # @yield [parent_box]
  #
  # source://prawn//lib/prawn/document/column_box.rb#43
  def init_column_box(user_block, options = T.unsafe(nil)); end

  # source://prawn//lib/prawn/grid.rb#445
  def multi_box(box1, box2); end

  # source://prawn//lib/prawn/grid.rb#441
  def single_box(rows, columns); end

  # setting override_settings to true ensures that a new graphic state does
  # not end up using previous settings.
  #
  # source://prawn//lib/prawn/document.rb#789
  def use_graphic_settings(override_settings = T.unsafe(nil)); end

  # source://prawn//lib/prawn/font.rb#320
  def width_of_inline_formatted_string(string, options = T.unsafe(nil)); end

  # source://prawn//lib/prawn/font.rb#330
  def width_of_string(string, options = T.unsafe(nil)); end

  class << self
    # Any module added to this array will be included into instances of
    # {Prawn::Document} at the per-object level.  These will also be inherited
    # by any subclasses.
    #
    # @example
    #   module MyFancyModule
    #   def party!
    #   text "It's a big party!"
    #   end
    #   end
    #
    #   Prawn::Document.extensions << MyFancyModule
    #
    #   Prawn::Document.generate("foo.pdf") do
    #   party!
    #   end
    # @return [Array<Module>]
    #
    # source://prawn//lib/prawn/document.rb#95
    def extensions; end

    # Creates and renders a PDF document.
    #
    # When using the implicit block form, Prawn will evaluate the block
    # within an instance of {Prawn::Document}, simplifying your syntax.
    # However, please note that you will not be able to reference variables
    # from the enclosing scope within this block.
    #
    # ```ruby
    # # Using implicit block form and rendering to a file
    # Prawn::Document.generate "example.pdf" do
    #   # self here is set to the newly instantiated Prawn::Document
    #   # and so any variables in the outside scope are unavailable
    #   font "Times-Roman"
    #   draw_text "Hello World", at: [200,720], size: 32
    # end
    # ```
    #
    # If you need to access your local and instance variables, use the explicit
    # block form shown below. In this case, Prawn yields an instance of
    # {Prawn::Document} and the block is an ordinary closure:
    #
    # ```ruby
    # # Using explicit block form and rendering to a file
    # content = "Hello World"
    # Prawn::Document.generate "example.pdf" do |pdf|
    #   # self here is left alone
    #   pdf.font "Times-Roman"
    #   pdf.draw_text content, at: [200,720], size: 32
    # end
    # ```
    #
    # source://prawn//lib/prawn/document.rb#161
    def generate(filename, options = T.unsafe(nil), &block); end

    # @private
    # @private
    #
    # source://prawn//lib/prawn/document.rb#100
    def inherited(base); end
  end
end

# Low level layout helper that simplifies coordinate math.
#
# See {Prawn::Document#bounding_box} for a description of what this class
# is used for.
#
# source://prawn//lib/prawn/document/bounding_box.rb#243
class Prawn::Document::BoundingBox
  # @option options
  # @option options
  # @param document [Prawn::Document] ownding document
  # @param parent [BoundingBox?] parent bounding box
  # @param point [Array(Number, Number)] coordinates of the top left corner
  # @param options [Hash{Symbol => any}]
  # @private
  # @return [BoundingBox] a new instance of BoundingBox
  #
  # source://prawn//lib/prawn/document/bounding_box.rb#258
  def initialize(document, parent, point, options = T.unsafe(nil)); end

  # Absolute bottom y-coordinate of the bottom box.
  #
  # @return [Number]
  #
  # source://prawn//lib/prawn/document/bounding_box.rb#487
  def absolute_bottom; end

  # Absolute bottom-left point of the bounding box.
  #
  # @return [Array(Number, Number)]
  #
  # source://prawn//lib/prawn/document/bounding_box.rb#508
  def absolute_bottom_left; end

  # Absolute bottom-left point of the bounding box.
  #
  # @return [Array(Number, Number)]
  #
  # source://prawn//lib/prawn/document/bounding_box.rb#515
  def absolute_bottom_right; end

  # Absolute left x-coordinate of the bounding box.
  #
  # @return [Number]
  #
  # source://prawn//lib/prawn/document/bounding_box.rb#466
  def absolute_left; end

  # Absolute right x-coordinate of the bounding box.
  #
  # @return [Number]
  #
  # source://prawn//lib/prawn/document/bounding_box.rb#473
  def absolute_right; end

  # Absolute top y-coordinate of the bounding box.
  #
  # @return [Number]
  #
  # source://prawn//lib/prawn/document/bounding_box.rb#480
  def absolute_top; end

  # Absolute top-left point of the bounding box.
  #
  # @return [Array(Number, Number)]
  #
  # source://prawn//lib/prawn/document/bounding_box.rb#494
  def absolute_top_left; end

  # Absolute top-right point of the bounding box.
  #
  # @return [Array(Number, Number)]
  #
  # source://prawn//lib/prawn/document/bounding_box.rb#501
  def absolute_top_right; end

  # Increase the left padding of the bounding box.
  #
  # @param left_padding [Number]
  # @private
  # @return [void]
  #
  # source://prawn//lib/prawn/document/bounding_box.rb#348
  def add_left_padding(left_padding); end

  # Increase the right padding of the bounding box.
  #
  # @param right_padding [Number]
  # @private
  # @return [void]
  #
  # source://prawn//lib/prawn/document/bounding_box.rb#370
  def add_right_padding(right_padding); end

  # The translated origin (x, y - height) which describes the location of
  # the bottom left corner of the bounding box.
  #
  # @private
  # @return [Array(Number, Number)]
  #
  # source://prawn//lib/prawn/document/bounding_box.rb#302
  def anchor; end

  # Relative bottom y-coordinate of the bounding box. Always 0.
  #
  # @example Position some text 3 pts from the bottom of the containing box
  #   draw_text('hello', at: [0, (bounds.bottom + 3)])
  # @return [Number]
  #
  # source://prawn//lib/prawn/document/bounding_box.rb#411
  def bottom; end

  # Relative bottom-left point of the bounding box.
  #
  # @example Draw a line along the left hand side of the page
  #   stroke do
  #   line(bounds.bottom_left, bounds.top_left)
  #   end
  # @return [Array(Number, Number)]
  #
  # source://prawn//lib/prawn/document/bounding_box.rb#459
  def bottom_left; end

  # Relative bottom-right point of the bounding box.
  #
  # @example Draw a line along the right hand side of the page
  #   stroke do
  #   line(bounds.bottom_right, bounds.top_right)
  #   end
  # @return [Array(Number, Number)]
  #
  # source://prawn//lib/prawn/document/bounding_box.rb#447
  def bottom_right; end

  # Returns a deep copy of these bounds (including all parent bounds but
  # not copying the reference to the Document).
  #
  # @private
  # @return [BoundingBox]
  #
  # source://prawn//lib/prawn/document/bounding_box.rb#598
  def deep_copy; end

  # Owning document.
  #
  # @private
  # @return [Prawn::Document]
  #
  # source://prawn//lib/prawn/document/bounding_box.rb#277
  def document; end

  # Height of the bounding box. If the box is 'stretchy' (unspecified
  # height attribute), height is calculated as the distance from the top of
  # the box to the current drawing position.
  #
  # @return [Number]
  #
  # source://prawn//lib/prawn/document/bounding_box.rb#529
  def height; end

  # Temporarily adjust the x coordinate to allow for left padding
  #
  # @example
  #   indent 20 do
  #   text "20 points in"
  #   indent 30 do
  #   text "50 points in"
  #   end
  #   end
  #
  #   indent 20, 20 do
  #   text "indented on both sides"
  #   end
  # @param left_padding [Number]
  # @param right_padding [Number]
  # @private
  # @return [void]
  #
  # source://prawn//lib/prawn/document/bounding_box.rb#334
  def indent(left_padding, right_padding = T.unsafe(nil)); end

  # Relative left x-coordinate of the bounding box. Always 0.
  #
  # @example Position some text 3 pts from the left of the containing box
  #   draw_text('hello', at: [(bounds.left + 3), 0])
  # @return [Number]
  #
  # source://prawn//lib/prawn/document/bounding_box.rb#312
  def left; end

  # An alias for {absolute_left}.
  #
  # @private
  # @return [Number]
  #
  # source://prawn//lib/prawn/document/bounding_box.rb#542
  def left_side; end

  # Moves to the top of the next page of the document, starting a new page
  # if necessary.
  #
  # @return [void]
  #
  # source://prawn//lib/prawn/document/bounding_box.rb#560
  def move_past_bottom; end

  # Parent bounding box.
  #
  # @private
  # @return [BoundingBox?]
  #
  # source://prawn//lib/prawn/document/bounding_box.rb#283
  def parent; end

  # Returns the innermost non-stretchy bounding box.
  #
  # @raise [NoReferenceBounds]
  # @return [BoundingBox]
  #
  # source://prawn//lib/prawn/document/bounding_box.rb#581
  def reference_bounds; end

  # Relative right x-coordinate of the bounding box. Equal to the box width.
  #
  # @example Position some text 3 pts from the right of the containing box
  #   draw_text('hello', at: [(bounds.right - 3), 0])
  # @return [Number]
  #
  # source://prawn//lib/prawn/document/bounding_box.rb#391
  def right; end

  # An alias for {absolute_right}.
  #
  # @private
  # @return [Number]
  #
  # source://prawn//lib/prawn/document/bounding_box.rb#550
  def right_side; end

  # Returns `false` when the box has a defined height, `true` when the
  # height is being calculated on the fly based on the current vertical
  # position.
  #
  # @return [Boolean]
  #
  # source://prawn//lib/prawn/document/bounding_box.rb#573
  def stretchy?; end

  # Decrease the left padding of the bounding box.
  #
  # @param left_padding [Number]
  # @private
  # @return [void]
  #
  # source://prawn//lib/prawn/document/bounding_box.rb#359
  def subtract_left_padding(left_padding); end

  # Decrease the right padding of the bounding box.
  #
  # @param right_padding [Number]
  # @private
  # @return [void]
  #
  # source://prawn//lib/prawn/document/bounding_box.rb#380
  def subtract_right_padding(right_padding); end

  # Relative top y-coordinate of the bounding box. Equal to the box height.
  #
  # @example Position some text 3 pts from the top of the containing box
  #   draw_text('hello', at: [0, (bounds.top - 3)])
  # @return [Number]
  #
  # source://prawn//lib/prawn/document/bounding_box.rb#401
  def top; end

  # Relative top-left point of the bounding_box.
  #
  # @example Draw a line from the top left of the box diagonally to the bottom right
  #   stroke do
  #   line(bounds.top_left, bounds.bottom_right)
  #   end
  # @return [Array(Number, Number)]
  #
  # source://prawn//lib/prawn/document/bounding_box.rb#423
  def top_left; end

  # Relative top-right point of the bounding box.
  #
  # @example Draw a line from the top_right of the box diagonally to the bottom left
  #   stroke do
  #   line(bounds.top_right, bounds.bottom_left)
  #   end
  # @return [Array(Number, Number)]
  #
  # source://prawn//lib/prawn/document/bounding_box.rb#435
  def top_right; end

  # The current indentation of the left side of the bounding box.
  #
  # @private
  # @return [Number]
  #
  # source://prawn//lib/prawn/document/bounding_box.rb#289
  def total_left_padding; end

  # The current indentation of the right side of the bounding box.
  #
  # @private
  # @return [Number]
  #
  # source://prawn//lib/prawn/document/bounding_box.rb#295
  def total_right_padding; end

  # Height of the bounding box. If the box is 'stretchy' (unspecified
  # height attribute), height is calculated as the distance from the top of
  # the box to the current drawing position.
  #
  # @return [Number]
  #
  # source://prawn//lib/prawn/document/bounding_box.rb#529
  def update_height; end

  # Width of the bounding box.
  #
  # @return [Number]
  #
  # source://prawn//lib/prawn/document/bounding_box.rb#522
  def width; end

  class << self
    # Restores a copy of the bounds taken by {BoundingBox#deep_copy} in the
    # context of the given `document`. Does *not* set the bounds of the
    # document to the resulting {BoundingBox}, only returns it.
    #
    # @param bounds [BoundingBox]
    # @param document [Prawn::Document]
    # @private
    # @return [BoundingBox]
    #
    # source://prawn//lib/prawn/document/bounding_box.rb#619
    def restore_deep_copy(bounds, document); end
  end
end

# Indicates absence of a reference bounding box of a fixed height.
#
# source://prawn//lib/prawn/document/bounding_box.rb#245
class Prawn::Document::BoundingBox::NoReferenceBounds < ::StandardError
  # @return [NoReferenceBounds] a new instance of NoReferenceBounds
  #
  # source://prawn//lib/prawn/document/bounding_box.rb#246
  def initialize(message = T.unsafe(nil)); end
end

# Implements the necessary functionality to allow {Document#column_box} to
# work.
#
# source://prawn//lib/prawn/document/column_box.rb#58
class Prawn::Document::ColumnBox < ::Prawn::Document::BoundingBox
  # @option options
  # @option options
  # @option options
  # @option options
  # @option options
  # @param point [Array(Number, Number)]
  # @param options [Hash{Symbol => any}]
  # @return [ColumnBox] a new instance of ColumnBox
  #
  # source://prawn//lib/prawn/document/column_box.rb#68
  def initialize(document, parent, point, options = T.unsafe(nil)); end

  # @param left_padding [Number]
  # @private
  # @return [void]
  #
  # source://prawn//lib/prawn/document/column_box.rb#149
  def add_left_padding(left_padding); end

  # @param right_padding [Number]
  # @private
  # @return [void]
  #
  # source://prawn//lib/prawn/document/column_box.rb#165
  def add_right_padding(right_padding); end

  # The column width, not the width of the whole box, before left and/or
  # right padding.
  #
  # @return [Number]
  #
  # source://prawn//lib/prawn/document/column_box.rb#80
  def bare_column_width; end

  # Relative position of the left edge of the current column.
  #
  # @return [Number]
  #
  # source://prawn//lib/prawn/document/column_box.rb#109
  def left; end

  # x coordinate of the left edge of the current column.
  #
  # @return [Number]
  #
  # source://prawn//lib/prawn/document/column_box.rb#102
  def left_side; end

  # Moves to the next column or starts a new page if currently positioned at
  # the rightmost column.
  #
  # @return [void]
  #
  # source://prawn//lib/prawn/document/column_box.rb#132
  def move_past_bottom; end

  # Relative position of the right edge of the current column.
  #
  # @return [Number]
  #
  # source://prawn//lib/prawn/document/column_box.rb#124
  def right; end

  # x coordinate of the right edge of the current column.
  #
  # @return [Number]
  #
  # source://prawn//lib/prawn/document/column_box.rb#116
  def right_side; end

  # @param left_padding [Number]
  # @private
  # @return [void]
  #
  # source://prawn//lib/prawn/document/column_box.rb#157
  def subtract_left_padding(left_padding); end

  # @param right_padding [Number]
  # @private
  # @return [void]
  #
  # source://prawn//lib/prawn/document/column_box.rb#172
  def subtract_right_padding(right_padding); end

  # The column width after padding. Used to calculate how long a line of
  # text can be.
  #
  # @return [Number]
  #
  # source://prawn//lib/prawn/document/column_box.rb#88
  def width; end

  # Column width including the spacer.
  #
  # @return [Number]
  #
  # source://prawn//lib/prawn/document/column_box.rb#95
  def width_of_column; end
end

# Default empty options.
#
# source://prawn//lib/prawn/font.rb#10
Prawn::Document::DEFAULT_OPTS = T.let(T.unsafe(nil), Hash)

# A Grid represents the entire grid system of a Page and calculates
# the column width and row height of the base box.
#
# source://prawn//lib/prawn/grid.rb#71
class Prawn::Document::Grid
  # @option options
  # @option options
  # @option options
  # @option options
  # @option options
  # @param pdf [Prawn::Document]
  # @param options [Hash{Symbol => any}]
  # @return [Grid] a new instance of Grid
  #
  # source://prawn//lib/prawn/grid.rb#104
  def initialize(pdf, options = T.unsafe(nil)); end

  # Column gutter size.
  #
  # @return [Number]
  #
  # source://prawn//lib/prawn/grid.rb#94
  def column_gutter; end

  # Calculates the base width of boxes.
  #
  # @return [Float]
  #
  # source://prawn//lib/prawn/grid.rb#117
  def column_width; end

  # Number of columns in the grid.
  #
  # @return [Integer]
  #
  # source://prawn//lib/prawn/grid.rb#78
  def columns; end

  # Gutter size.
  #
  # @return [Number]
  #
  # source://prawn//lib/prawn/grid.rb#86
  def gutter; end

  # @private
  # @return [Prawn::Document]
  #
  # source://prawn//lib/prawn/grid.rb#74
  def pdf; end

  # Row gutter size.
  #
  # @return [Number]
  #
  # source://prawn//lib/prawn/grid.rb#90
  def row_gutter; end

  # Calculates the base height of boxes.
  #
  # @return [Float]
  #
  # source://prawn//lib/prawn/grid.rb#124
  def row_height; end

  # Number of rows in the grid.
  #
  # @return [Integer]
  #
  # source://prawn//lib/prawn/grid.rb#82
  def rows; end

  # Diagnostic tool to show all of the grid boxes.
  #
  # @param color [Color]
  # @return [void]
  #
  # source://prawn//lib/prawn/grid.rb#132
  def show_all(color = T.unsafe(nil)); end

  private

  # source://prawn//lib/prawn/grid.rb#146
  def apply_gutter(options); end

  # source://prawn//lib/prawn/grid.rb#142
  def subdivide(total, num, gutter); end
end

# A Box is a class that represents a bounded area of a page.
# A Grid object has methods that allow easy access to the coordinates of
# its corners, which can be plugged into most existing Prawn methods.
#
# source://prawn//lib/prawn/grid.rb#164
class Prawn::Document::GridBox
  # @return [GridBox] a new instance of GridBox
  #
  # source://prawn//lib/prawn/grid.rb#168
  def initialize(pdf, rows, columns); end

  # y-coordinate of the bottom.
  #
  # @return [Float]
  #
  # source://prawn//lib/prawn/grid.rb#232
  def bottom; end

  # x,y coordinates of bottom left corner.
  #
  # @return [Array(Float, Float)]
  #
  # source://prawn//lib/prawn/grid.rb#253
  def bottom_left; end

  # x,y coordinates of bottom right corner.
  #
  # @return [Array(Float, Float)]
  #
  # source://prawn//lib/prawn/grid.rb#260
  def bottom_right; end

  # Creates a standard bounding box based on the grid box.
  #
  # @return [void]
  # @yield
  #
  # source://prawn//lib/prawn/grid.rb#268
  def bounding_box(&blk); end

  # Width of the gutter.
  #
  # @return [Float]
  #
  # source://prawn//lib/prawn/grid.rb#204
  def gutter; end

  # Height of a box.
  #
  # @return [Float]
  #
  # source://prawn//lib/prawn/grid.rb#197
  def height; end

  # x-coordinate of left side.
  #
  # @return [Float]
  #
  # source://prawn//lib/prawn/grid.rb#211
  def left; end

  # Mostly diagnostic method that outputs the name of a box as
  # col_num, row_num
  #
  # @return [String]
  #
  # source://prawn//lib/prawn/grid.rb#178
  def name; end

  # @private
  #
  # source://prawn//lib/prawn/grid.rb#166
  def pdf; end

  # x-coordinate of right side.
  #
  # @return [Float]
  #
  # source://prawn//lib/prawn/grid.rb#218
  def right; end

  # Drawn the box. Diagnostic method.
  #
  # @param grid_color [Color]
  # @return [void]
  #
  # source://prawn//lib/prawn/grid.rb#276
  def show(grid_color = T.unsafe(nil)); end

  # y-coordinate of the top.
  #
  # @return [Float]
  #
  # source://prawn//lib/prawn/grid.rb#225
  def top; end

  # x,y coordinates of top left corner.
  #
  # @return [Array(Float, Float)]
  #
  # source://prawn//lib/prawn/grid.rb#239
  def top_left; end

  # x,y coordinates of top right corner.
  #
  # @return [Array(Float, Float)]
  #
  # source://prawn//lib/prawn/grid.rb#246
  def top_right; end

  # @private
  #
  # source://prawn//lib/prawn/grid.rb#183
  def total_height; end

  # Width of a box.
  #
  # @return [Float]
  #
  # source://prawn//lib/prawn/grid.rb#190
  def width; end

  private

  # source://prawn//lib/prawn/grid.rb#290
  def grid; end
end

# This module exposes a few low-level PDF features for those who want
# to extend Prawn's core functionality.  If you are not comfortable with
# low level PDF functionality as defined by Adobe's specification, chances
# are you won't need anything you find here.
#
# @private
#
# source://prawn//lib/prawn/document/internals.rb#13
module Prawn::Document::Internals
  extend ::Forwardable

  # source://forwardable/1.3.3/forwardable.rb#231
  def add_content(*args, **_arg1, &block); end

  # source://forwardable/1.3.3/forwardable.rb#231
  def compression_enabled?(*args, **_arg1, &block); end

  # source://forwardable/1.3.3/forwardable.rb#231
  def deref(*args, **_arg1, &block); end

  # source://forwardable/1.3.3/forwardable.rb#231
  def graphic_state(*args, **_arg1, &block); end

  # source://forwardable/1.3.3/forwardable.rb#231
  def names(*args, **_arg1, &block); end

  # source://forwardable/1.3.3/forwardable.rb#231
  def on_page_create(*args, **_arg1, &block); end

  # source://forwardable/1.3.3/forwardable.rb#231
  def ref(*args, **_arg1, &block); end

  # source://forwardable/1.3.3/forwardable.rb#231
  def ref!(*args, **_arg1, &block); end

  # Document renderer.
  #
  # @return [PDF::Core::Renderer]
  #
  # source://prawn//lib/prawn/document/internals.rb#71
  def renderer; end

  # Restore graphic state.
  #
  # @return [void]
  #
  # source://prawn//lib/prawn/document/internals.rb#38
  def restore_graphics_state; end

  # Save current graphics state.
  #
  # @return [void]
  # @yield Restores graphic state after the block.
  #
  # source://prawn//lib/prawn/document/internals.rb#29
  def save_graphics_state(state = T.unsafe(nil), &block); end
end

# A MultiBox is specified by 2 Boxes and spans the areas between.
#
# source://prawn//lib/prawn/grid.rb#298
class Prawn::Document::MultiBox
  # @return [MultiBox] a new instance of MultiBox
  #
  # source://prawn//lib/prawn/grid.rb#299
  def initialize(pdf, box1, box2); end

  # y-coordinate of the bottom.
  #
  # @return [Float]
  #
  # source://prawn//lib/prawn/grid.rb#364
  def bottom; end

  # x,y coordinates of bottom left corner.
  #
  # @return [Array(Float, Float)]
  #
  # source://prawn//lib/prawn/grid.rb#385
  def bottom_left; end

  # x,y coordinates of bottom right corner.
  #
  # @return [Array(Float, Float)]
  #
  # source://prawn//lib/prawn/grid.rb#392
  def bottom_right; end

  # Creates a standard bounding box based on the grid box.
  #
  # @return [void]
  # @yield
  #
  # source://prawn//lib/prawn/grid.rb#400
  def bounding_box(&blk); end

  # Width of the gutter.
  #
  # @return [Float]
  #
  # source://prawn//lib/prawn/grid.rb#336
  def gutter; end

  # Height of a box.
  #
  # @return [Float]
  #
  # source://prawn//lib/prawn/grid.rb#329
  def height; end

  # x-coordinate of left side.
  #
  # @return [Float]
  #
  # source://prawn//lib/prawn/grid.rb#343
  def left; end

  # Mostly diagnostic method that outputs the name of a box.
  #
  # @return [String]
  #
  # source://prawn//lib/prawn/grid.rb#310
  def name; end

  # @private
  #
  # source://prawn//lib/prawn/grid.rb#305
  def pdf; end

  # x-coordinate of right side.
  #
  # @return [Float]
  #
  # source://prawn//lib/prawn/grid.rb#350
  def right; end

  # Drawn the box. Diagnostic method.
  #
  # @param grid_color [Color]
  # @return [void]
  #
  # source://prawn//lib/prawn/grid.rb#408
  def show(grid_color = T.unsafe(nil)); end

  # y-coordinate of the top.
  #
  # @return [Float]
  #
  # source://prawn//lib/prawn/grid.rb#357
  def top; end

  # x,y coordinates of top left corner.
  #
  # @return [Array(Float, Float)]
  #
  # source://prawn//lib/prawn/grid.rb#371
  def top_left; end

  # x,y coordinates of top right corner.
  #
  # @return [Array(Float, Float)]
  #
  # source://prawn//lib/prawn/grid.rb#378
  def top_right; end

  # @private
  #
  # source://prawn//lib/prawn/grid.rb#315
  def total_height; end

  # Width of a box.
  #
  # @return [Float]
  #
  # source://prawn//lib/prawn/grid.rb#322
  def width; end

  private

  # source://prawn//lib/prawn/grid.rb#434
  def bottom_box; end

  # source://prawn//lib/prawn/grid.rb#422
  def left_box; end

  # source://prawn//lib/prawn/grid.rb#426
  def right_box; end

  # source://prawn//lib/prawn/grid.rb#430
  def top_box; end
end

# Implements PDF encryption (password protection and permissions) as
# specified in the PDF Reference, version 1.3, section 3.5 "Encryption".
#
# source://prawn//lib/prawn/security.rb#11
module Prawn::Document::Security
  # Encrypts the document, to protect confidential data or control
  # modifications to the document. The encryption algorithm used is detailed
  # in the PDF Reference 1.3, section 3.5 "Encryption", and it is
  # implemented by all major PDF readers.
  #
  # #### Examples
  #
  # Deny printing to everyone, but allow anyone to open without a password:
  #
  # ```ruby
  # encrypt_document permissions: { print_document: false },
  #   owner_password: :random
  # ```
  #
  # Set a user and owner password on the document, with full permissions for
  # both the user and the owner:
  #
  # ```ruby
  # encrypt_document user_password: 'foo', owner_password: 'bar'
  # ```
  #
  # Set no passwords, grant all permissions (This is useful because the
  # default in some readers, if no permissions are specified, is "deny"):
  #
  # ```ruby
  # encrypt_document
  # ```
  #
  # #### Caveats
  #
  # * The encryption used is weak; the key is password-derived and is
  #   limited to 40 bits, due to US export controls in effect at the time
  #   the PDF standard was written.
  # * There is nothing technologically requiring PDF readers to respect the
  #   permissions embedded in a document. Many PDF readers do not.
  # * In short, you have **no security at all** against a moderately
  #   motivated person. Don't use this for anything super-serious. This is
  #   not a limitation of Prawn, but is rather a built-in limitation of the
  #   PDF format.
  #
  # @option options
  # @option options
  # @option options
  # @param options [Hash{Symbol => any}]
  # @return [void]
  #
  # source://prawn//lib/prawn/security.rb#78
  def encrypt_document(options = T.unsafe(nil)); end

  private

  # Provides the values for the trailer encryption dictionary.
  #
  # source://prawn//lib/prawn/security.rb#120
  def encryption_dictionary; end

  # The O (owner) value in the encryption dictionary. Algorithm 3.3.
  #
  # source://prawn//lib/prawn/security.rb#191
  def owner_password_hash; end

  # Pads or truncates a password to 32 bytes as per Alg 3.2.
  #
  # source://prawn//lib/prawn/security.rb#174
  def pad_password(password); end

  # source://prawn//lib/prawn/security.rb#143
  def permissions=(perms = T.unsafe(nil)); end

  # source://prawn//lib/prawn/security.rb#165
  def permissions_value; end

  # source://prawn//lib/prawn/security.rb#179
  def user_encryption_key; end

  # The U (user) value in the encryption dictionary. Algorithm 3.4.
  #
  # source://prawn//lib/prawn/security.rb#200
  def user_password_hash; end

  class << self
    # Encrypts the given string under the given key, also requiring the object
    # ID and generation number of the reference.
    #
    # See Algorithm 3.1.
    #
    # @param str [String]
    # @param key [String]
    # @param id [Integer]
    # @param gen [Integer]
    # @return [String]
    #
    # source://prawn//lib/prawn/security.rb#106
    def encrypt_string(str, key, id, gen); end
  end
end

# source://prawn//lib/prawn/security.rb#140
Prawn::Document::Security::FULL_PERMISSIONS = T.let(T.unsafe(nil), Integer)

# source://prawn//lib/prawn/security.rb#169
Prawn::Document::Security::PASSWORD_PADDING = T.let(T.unsafe(nil), String)

# Flags in the permissions word, numbered as LSB = 1
#
# source://prawn//lib/prawn/security.rb#132
Prawn::Document::Security::PERMISSIONS_BITS = T.let(T.unsafe(nil), Hash)

# List of recognised options.
#
# source://prawn//lib/prawn/document.rb#70
Prawn::Document::VALID_OPTIONS = T.let(T.unsafe(nil), Array)

# @private
#
# source://prawn//lib/prawn/encoding.rb#5
module Prawn::Encoding; end

# Map between unicode and WinAnsiEnoding
#
# @private
#
# source://prawn//lib/prawn/encoding.rb#9
class Prawn::Encoding::WinAnsi; end

# source://prawn//lib/prawn/encoding.rb#10
Prawn::Encoding::WinAnsi::CHARACTERS = T.let(T.unsafe(nil), Array)

# Custom error classes for Prawn.
#
# source://prawn//lib/prawn/errors.rb#5
module Prawn::Errors; end

# This error is raised when a block is required, but not provided.
#
# source://prawn//lib/prawn/errors.rb#61
class Prawn::Errors::BlockRequired < ::StandardError; end

# Raised when Prawn is asked to draw something into a too-small box.
#
# source://prawn//lib/prawn/errors.rb#17
class Prawn::Errors::CannotFit < ::StandardError; end

# Raised if {#group} is called with a block that is too big to be rendered
# in the current context.
#
# @private
#
# source://prawn//lib/prawn/errors.rb#23
class Prawn::Errors::CannotGroup < ::StandardError; end

# This error is raised when Prawn is being used on a M17N aware VM, and the
# user attempts to add text that isn't compatible with UTF-8 to their
# document.
#
# source://prawn//lib/prawn/errors.rb#28
class Prawn::Errors::IncompatibleStringEncoding < ::StandardError; end

# This error is raised when a graphics method is called with improper
# arguments.
#
# source://prawn//lib/prawn/errors.rb#65
class Prawn::Errors::InvalidGraphicsPath < ::StandardError; end

# This error is raised when an incompatible join style is specified.
#
# source://prawn//lib/prawn/errors.rb#71
class Prawn::Errors::InvalidJoinStyle < ::StandardError; end

# This error is raised when a name is not a valid format.
#
# source://prawn//lib/prawn/errors.rb#47
class Prawn::Errors::InvalidName < ::StandardError; end

# Raised when a table is spanned in an impossible way.
#
# source://prawn//lib/prawn/errors.rb#7
class Prawn::Errors::InvalidTableSpan < ::StandardError; end

# This error is raised when a named element has already been created. For
# example, in the stamp module, stamps must have unique names within
# a document.
#
# source://prawn//lib/prawn/errors.rb#44
class Prawn::Errors::NameTaken < ::StandardError; end

# This error is raised when a method requiring a current page is called
# without being on a page.
#
# source://prawn//lib/prawn/errors.rb#11
class Prawn::Errors::NotOnPage < ::StandardError; end

# This error is raised when a required option has not been set.
#
# source://prawn//lib/prawn/errors.rb#54
class Prawn::Errors::RequiredOption < ::StandardError; end

# This error is raised when an object is attempted to be referenced by name,
# but no such name is associated with an object.
#
# source://prawn//lib/prawn/errors.rb#51
class Prawn::Errors::UndefinedObjectName < ::StandardError; end

# This error is raised when Prawn cannot find a specified font.
#
# source://prawn//lib/prawn/errors.rb#14
class Prawn::Errors::UnknownFont < ::StandardError; end

# This error is raised when Prawn encounters an unknown key in functions
# that accept an options hash.  This usually means there is a typo in your
# code or that the option you are trying to use has a different name than
# what you have specified.
#
# source://prawn//lib/prawn/errors.rb#34
class Prawn::Errors::UnknownOption < ::StandardError; end

# This error is raised when a requested outline item with a given title does
# not exist.
#
# source://prawn//lib/prawn/errors.rb#58
class Prawn::Errors::UnknownOutlineTitle < ::StandardError; end

# Raised when unrecognized content is provided for a table cell.
#
# source://prawn//lib/prawn/errors.rb#68
class Prawn::Errors::UnrecognizedTableContent < ::StandardError; end

# This error is raised when a user attempts to embed an image of an
# unsupported type. This can either a completely unsupported format, or
# a dialect of a supported format (i.e. some types of PNG).
#
# source://prawn//lib/prawn/errors.rb#39
class Prawn::Errors::UnsupportedImageType < ::StandardError; end

# @deprecated This is not used any more.
#
# source://prawn//lib/prawn.rb#22
Prawn::FLOAT_PRECISION = T.let(T.unsafe(nil), Float)

# Provides font information and helper functions.
#
# @abstract
#
# source://prawn//lib/prawn/font.rb#338
class Prawn::Font
  # @option options
  # @option options
  # @param document [Prawn::Document]
  # @param name [String]
  # @param options [Hash{Symbol => any}]
  # @private
  # @return [Font] a new instance of Font
  #
  # source://prawn//lib/prawn/font.rb#412
  def initialize(document, name, options = T.unsafe(nil)); end

  # Registers the given subset of the current font with the current PDF
  # page. This is safe to call multiple times for a given font and subset,
  # as it will only add the font the first time it is called.
  #
  # @param subset [Integer]
  # @return [void]
  #
  # source://prawn//lib/prawn/font.rb#496
  def add_to_current_page(subset); end

  # The size of the font ascender in PDF points.
  #
  # @return [Number]
  #
  # source://prawn//lib/prawn/font.rb#430
  def ascender; end

  # The size of the font descender in PDF points.
  #
  # @return [Number]
  #
  # source://prawn//lib/prawn/font.rb#437
  def descender; end

  # Compliments the {#hash} implementation.
  #
  # @param other [Object]
  # @return [Boolean]
  #
  # source://prawn//lib/prawn/font.rb#532
  def eql?(other); end

  # The font family.
  #
  # @return [String]
  #
  # source://prawn//lib/prawn/font.rb#359
  def family; end

  # Return a hash (as in `Object#hash`) for the font. This is required since
  # font objects are used as keys in hashes that cache certain values.
  #
  # @return [Integer]
  #
  # source://prawn//lib/prawn/font.rb#524
  def hash; end

  # Gets height of current font in PDF points at current font size.
  #
  # @return [Number]
  #
  # source://prawn//lib/prawn/font.rb#486
  def height; end

  # Gets height of font in PDF points at the given font size.
  #
  # @param size [Number]
  # @return [Number]
  #
  # source://prawn//lib/prawn/font.rb#478
  def height_at(size); end

  # @param subset [Integer]
  # @private
  # @return [Symbol]
  #
  # source://prawn//lib/prawn/font.rb#504
  def identifier_for(subset); end

  # Returns a string containing a human-readable representation of this font.
  #
  # @return [String]
  #
  # source://prawn//lib/prawn/font.rb#516
  def inspect; end

  # The size of the recommended gap between lines of text in PDF points
  #
  # @return [Number]
  #
  # source://prawn//lib/prawn/font.rb#444
  def line_gap; end

  # The font name.
  #
  # @return [String]
  #
  # source://prawn//lib/prawn/font.rb#355
  def name; end

  # Normalizes the encoding of the string to an encoding supported by the
  # font. The string is expected to be UTF-8 going in. It will be re-encoded
  # and the new string will be returned.
  #
  # @abstract
  # @param string [String]
  # @raise [NotImplementedError]
  # @return [String]
  #
  # source://prawn//lib/prawn/font.rb#456
  def normalize_encoding(_string); end

  # Destructive version of {normalize_encoding}; normalizes the encoding of a
  # string in place.
  #
  # @deprecated
  # @note This method doesn't mutate its argument any more.
  # @param str [String]
  # @return [String]
  #
  # source://prawn//lib/prawn/font.rb#469
  def normalize_encoding!(str); end

  # The options hash used to initialize the font.
  #
  # @return [Hash]
  #
  # source://prawn//lib/prawn/font.rb#363
  def options; end

  protected

  # source://prawn//lib/prawn/font.rb#563
  def size; end

  private

  # Returns the value of attribute full_font_embedding.
  #
  # source://prawn//lib/prawn/font.rb#539
  def full_font_embedding; end

  # generate a font identifier that hasn't been used on the current page yet
  #
  # source://prawn//lib/prawn/font.rb#543
  def generate_unique_id; end

  # @return [Boolean]
  #
  # source://prawn//lib/prawn/font.rb#555
  def key_is_unique?(test_key); end

  class << self
    # Guesses font format.
    #
    # @option options
    # @param src [String, IO]
    # @param options [Hash]
    # @private
    # @return [String]
    #
    # source://prawn//lib/prawn/font.rb#394
    def font_format(src, options); end

    # Shortcut interface for constructing a font object. Filenames of the form
    # `*.ttf` will call {Fonts::TTF#initialize TTF.new}, `*.otf` calls
    # {Fonts::OTF#initialize OTF.new}, `*.dfont` calls {Fonts::DFont#initialize
    # DFont.new}, `*.ttc` goes to {Fonts::TTC#initialize TTC.new}, and anything
    # else will be passed through to {Prawn::Fonts::AFM#initialize AFM.new}.
    #
    # @option options
    # @option options
    # @param document [Prawn::Document] owning document
    # @param src [String] font file path
    # @param options [Hash]
    # @return [Prawn::Fonts::Font]
    #
    # source://prawn//lib/prawn/font.rb#377
    def load(document, src, options = T.unsafe(nil)); end
  end
end

# @deprecated
#
# source://prawn//lib/prawn/font.rb#342
Prawn::Font::AFM = Prawn::Fonts::AFM

# @deprecated
#
# source://prawn//lib/prawn/font.rb#348
Prawn::Font::DFont = Prawn::Fonts::DFont

# @deprecated
#
# source://prawn//lib/prawn/font.rb#351
Prawn::Font::TTC = Prawn::Fonts::TTC

# @deprecated
#
# source://prawn//lib/prawn/font.rb#345
Prawn::Font::TTF = Prawn::Fonts::TTF

# Cache used internally by {Prawn::Document} instances to calculate the width
# of various strings for layout purposes.
#
# @private
#
# source://prawn//lib/prawn/font_metric_cache.rb#8
class Prawn::FontMetricCache
  # @return [FontMetricCache] a new instance of FontMetricCache
  #
  # source://prawn//lib/prawn/font_metric_cache.rb#11
  def initialize(document); end

  # Get width of string.
  #
  # @option options
  # @option options
  # @option options
  # @param string [String]
  # @param options [Hash{Symbol => any}]
  # @return [Number]
  #
  # source://prawn//lib/prawn/font_metric_cache.rb#25
  def width_of(string, options); end
end

# source://prawn//lib/prawn/font_metric_cache.rb#9
class Prawn::FontMetricCache::CacheEntry < ::Struct
  # Returns the value of attribute font
  #
  # @return [Object] the current value of font
  def font; end

  # Sets the attribute font
  #
  # @param value [Object] the value to set the attribute font to.
  # @return [Object] the newly set value
  def font=(_); end

  # Returns the value of attribute font_size
  #
  # @return [Object] the current value of font_size
  def font_size; end

  # Sets the attribute font_size
  #
  # @param value [Object] the value to set the attribute font_size to.
  # @return [Object] the newly set value
  def font_size=(_); end

  # Returns the value of attribute options
  #
  # @return [Object] the current value of options
  def options; end

  # Sets the attribute options
  #
  # @param value [Object] the value to set the attribute options to.
  # @return [Object] the newly set value
  def options=(_); end

  # Returns the value of attribute string
  #
  # @return [Object] the current value of string
  def string; end

  # Sets the attribute string
  #
  # @param value [Object] the value to set the attribute string to.
  # @return [Object] the newly set value
  def string=(_); end

  class << self
    def [](*_arg0); end
    def inspect; end
    def keyword_init?; end
    def members; end
    def new(*_arg0); end
  end
end

# Namespace for different fonts.
#
# source://prawn//lib/prawn/fonts.rb#5
module Prawn::Fonts; end

# AFM font. AFM stands for Adobe Font Metrics. It's not a complete font, it
# doesn't provide actual glyph outlines. It only contains glyph metrics to
# make text layout possible. AFM is used for PDF built-in fonts. Those
# fonts are supposed to be present on the target system making it possible
# to save a little bit of space by not embedding the fonts. A file that uses
# these fonts can not be read on a system that doesn't have these fonts
# installed.
#
# @note You shouldn't use this class directly.
#
# source://prawn//lib/prawn/fonts/afm.rb#16
class Prawn::Fonts::AFM < ::Prawn::Font
  # @option options
  # @option options
  # @param document [Prawn::Document]
  # @param name [String]
  # @param options [Hash]
  # @return [AFM] a new instance of AFM
  #
  # source://prawn//lib/prawn/fonts/afm.rb#75
  def initialize(document, name, options = T.unsafe(nil)); end

  # @private
  #
  # source://prawn//lib/prawn/fonts/afm.rb#61
  def attributes; end

  # The font bbox.
  #
  # @return [Array(Number, Number, Number, Number)]
  #
  # source://prawn//lib/prawn/fonts/afm.rb#104
  def bbox; end

  # Returns the number of characters in `str` (a WinAnsi-encoded string).
  #
  # @param str [String]
  # @return [Integer]
  #
  # source://prawn//lib/prawn/fonts/afm.rb#165
  def character_count(str); end

  # Compute width of a string at the specified size, optionally with kerning
  # applied.
  #
  # @option options
  # @option options
  # @param string [String] *must* be encoded as WinAnsi
  # @param options [Hash{Symbol => any}]
  # @return [Number]
  #
  # source://prawn//lib/prawn/fonts/afm.rb#116
  def compute_width_of(string, options = T.unsafe(nil)); end

  # Perform any changes to the string that need to happen
  # before it is rendered to the canvas. Returns an array of
  # subset "chunks", where each chunk is an array of two elements.
  # The first element is the font subset number, and the second
  # is either a string or an array (for kerned text).
  #
  # For Adobe fonts, there is only ever a single subset, so
  # the first element of the array is `0`, and the second is
  # the string itself (or an array, if kerning is performed).
  #
  # The `text` argument must be in WinAnsi encoding (cp1252).
  #
  # @option options
  # @param text [String]
  # @param options [Hash{Symbol => any}]
  # @return [Array<Array(0, (String, Array)>]] Array<Array(0, (String, Array)>]
  #
  # source://prawn//lib/prawn/fonts/afm.rb#185
  def encode_text(text, options = T.unsafe(nil)); end

  # Does this font has a glyph for the character?
  #
  # @param char [String]
  # @return [Boolean]
  #
  # source://prawn//lib/prawn/fonts/afm.rb#193
  def glyph_present?(char); end

  # Does this font contain kerning data.
  #
  # @return [Boolean]
  #
  # source://prawn//lib/prawn/fonts/afm.rb#131
  def has_kerning_data?; end

  # Built-in fonts only work with WinAnsi encoding, so translate the
  # string. Changes the encoding in-place, so the argument itself
  # is replaced with a string in WinAnsi encoding.
  #
  # @param text [String]
  # @return [String]
  #
  # source://prawn//lib/prawn/fonts/afm.rb#141
  def normalize_encoding(text); end

  # Encode text to UTF-8.
  #
  # @param text [String]
  # @return [String]
  #
  # source://prawn//lib/prawn/fonts/afm.rb#157
  def to_utf8(text); end

  # Does this font support Unicode?
  #
  # @return [false]
  #
  # source://prawn//lib/prawn/fonts/afm.rb#39
  def unicode?; end

  private

  # source://prawn//lib/prawn/fonts/afm.rb#218
  def find_font(file); end

  # converts a string into an array with spacing offsets
  # between characters that need to be kerned
  #
  # String *must* be encoded as WinAnsi
  #
  # source://prawn//lib/prawn/fonts/afm.rb#301
  def kern(string); end

  # source://prawn//lib/prawn/fonts/afm.rb#227
  def parse_afm(file_name); end

  # source://prawn//lib/prawn/fonts/afm.rb#283
  def parse_generic_afm_attribute(line, hash); end

  # source://prawn//lib/prawn/fonts/afm.rb#201
  def register(_subset); end

  # @return [Boolean]
  #
  # source://prawn//lib/prawn/fonts/afm.rb#214
  def symbolic?; end

  # source://prawn//lib/prawn/fonts/afm.rb#325
  def unscaled_width_of(string); end

  class << self
    # Parsed AFM data cache.
    #
    # @return [SynchronizedCache]
    #
    # source://prawn//lib/prawn/fonts/afm.rb#66
    def font_data; end

    # Prawn would warn you if you're using non-ASCII glyphs with AFM fonts
    # as not all implementations provide those glyphs. This attribute
    # suppresses that warning.
    #
    # @return [Boolean] (false)
    #
    # source://prawn//lib/prawn/fonts/afm.rb#23
    def hide_m17n_warning; end

    # Prawn would warn you if you're using non-ASCII glyphs with AFM fonts
    # as not all implementations provide those glyphs. This attribute
    # suppresses that warning.
    #
    # @return [Boolean] (false)
    #
    # source://prawn//lib/prawn/fonts/afm.rb#23
    def hide_m17n_warning=(_arg0); end

    # Paths to look for AFM files at.
    #
    # @return [Array<String>]
    #
    # source://prawn//lib/prawn/fonts/afm.rb#46
    def metrics_path; end
  end
end

# List of PDF built-in fonts.
#
# source://prawn//lib/prawn/fonts/afm.rb#29
Prawn::Fonts::AFM::BUILT_INS = T.let(T.unsafe(nil), Array)

# DFONT font. DFONT is a bunch of TrueType fonts in a single file.
#
# @note You shouldn't use this class directly.
#
# source://prawn//lib/prawn/fonts/dfont.rb#10
class Prawn::Fonts::DFont < ::Prawn::Fonts::TTF
  private

  # source://prawn//lib/prawn/fonts/dfont.rb#37
  def read_ttf_file; end

  class << self
    # Returns the number of fonts contained in the dfont file.
    #
    # @param file [String]
    # @return [Integer]
    #
    # source://prawn//lib/prawn/fonts/dfont.rb#29
    def font_count(file); end

    # Returns a list of the names of all named fonts in the given dfont file.
    # Note that fonts are not required to be named in a dfont file, so the
    # list may be empty even if the file does contain fonts. Also, note that
    # the list is returned in no particular order, so the first font in the
    # list is not necessarily the font at index 0 in the file.
    #
    # @param file [String]
    # @return [Array<String>]
    #
    # source://prawn//lib/prawn/fonts/dfont.rb#19
    def named_fonts(file); end
  end
end

# OpenType font. This class is used mostly to distinguish OTF from TTF.
# All functionality is in the {Fonts::TTF} class.
#
# @note You shouldn't use this class directly.
#
# source://prawn//lib/prawn/fonts/otf.rb#11
class Prawn::Fonts::OTF < ::Prawn::Fonts::TTF; end

# TrueType Collection font. It's an SFNT-based format that contains a bunch
# of TrueType fonts in a single file.
#
# @note You shouldn't use this class directly.
#
# source://prawn//lib/prawn/fonts/ttc.rb#11
class Prawn::Fonts::TTC < ::Prawn::Fonts::TTF
  private

  # source://prawn//lib/prawn/fonts/ttc.rb#32
  def font_option_to_index(file, option); end

  # source://prawn//lib/prawn/fonts/ttc.rb#25
  def read_ttf_file; end

  class << self
    # Returns a list of the names of all named fonts in the given ttc file.
    # They are returned in order of their appearance in the file.
    #
    # @param file [String]
    # @return [Array<String>]
    #
    # source://prawn//lib/prawn/fonts/ttc.rb#17
    def font_names(file); end
  end
end

# TrueType font.
#
# @note You shouldn't use this class directly.
#
# source://prawn//lib/prawn/fonts/ttf.rb#19
class Prawn::Fonts::TTF < ::Prawn::Font
  # @option options
  # @option options
  # @param document [Prawn::Document]
  # @param name [String] font file path
  # @param options [Hash]
  # @return [TTF] a new instance of TTF
  #
  # source://prawn//lib/prawn/fonts/ttf.rb#134
  def initialize(document, name, options = T.unsafe(nil)); end

  # Base name of the font.
  #
  # @return [String]
  #
  # source://prawn//lib/prawn/fonts/ttf.rb#240
  def basename; end

  # The font bbox.
  #
  # @return [Array(Number, Number, Number, Number)]
  #
  # source://prawn//lib/prawn/fonts/ttf.rb#184
  def bbox; end

  # @private
  # @return [Number]
  #
  # source://prawn//lib/prawn/fonts/ttf.rb#272
  def cap_height; end

  # Returns the number of characters in `str` (a UTF-8-encoded string).
  #
  # @param str [String]
  # @return [Integer]
  #
  # source://prawn//lib/prawn/fonts/ttf.rb#354
  def character_count(str); end

  # Compute width of a string at the specified size, optionally with kerning
  # applied.
  #
  # @option options
  # @option options
  # @param string [String] *must* be encoded as UTF-8
  # @param options [Hash{Symbol => any}]
  # @return [Number]
  #
  # source://prawn//lib/prawn/fonts/ttf.rb#164
  def compute_width_of(string, options = T.unsafe(nil)); end

  # Perform any changes to the string that need to happen before it is
  # rendered to the canvas. Returns an array of subset "chunks", where the
  # even-numbered indices are the font subset number, and the following
  # entry element is either a string or an array (for kerned text).
  #
  # @option options
  # @param text [String] must be in UTF-8 encoding
  # @param options [Hash{Symbol => any}]
  # @return [Array<Array(0, (String, Array)>]] Array<Array(0, (String, Array)>]
  #
  # source://prawn//lib/prawn/fonts/ttf.rb#204
  def encode_text(text, options = T.unsafe(nil)); end

  # @private
  # @return [Number]
  #
  # source://prawn//lib/prawn/fonts/ttf.rb#290
  def family_class; end

  # Does this font has a glyph for the character?
  #
  # @param char [String]
  # @return [Boolean]
  #
  # source://prawn//lib/prawn/fonts/ttf.rb#345
  def glyph_present?(char); end

  # Does this font contain kerning data.
  #
  # @return [Boolean]
  #
  # source://prawn//lib/prawn/fonts/ttf.rb#191
  def has_kerning_data?; end

  # @private
  # @return [Number]
  #
  # source://prawn//lib/prawn/fonts/ttf.rb#254
  def italic_angle; end

  # Normlize text to a compatible encoding.
  #
  # @param text [String]
  # @return [String]
  #
  # source://prawn//lib/prawn/fonts/ttf.rb#325
  def normalize_encoding(text); end

  # @private
  # @return [Integer]
  #
  # source://prawn//lib/prawn/fonts/ttf.rb#308
  def pdf_flags; end

  # @private
  # @return [Boolean]
  #
  # source://prawn//lib/prawn/fonts/ttf.rb#302
  def script?; end

  # @private
  # @return [Boolean]
  #
  # source://prawn//lib/prawn/fonts/ttf.rb#296
  def serif?; end

  # @private
  # @return [Number]
  #
  # source://prawn//lib/prawn/fonts/ttf.rb#248
  def stem_v; end

  # Returns the value of attribute subsets.
  #
  # source://prawn//lib/prawn/fonts/ttf.rb#58
  def subsets; end

  # Encode text to UTF-8.
  #
  # @param text [String]
  # @return [String]
  #
  # source://prawn//lib/prawn/fonts/ttf.rb#337
  def to_utf8(text); end

  # TTFunk font.
  #
  # @return [TTFunk::File]
  #
  # source://prawn//lib/prawn/fonts/ttf.rb#57
  def ttf; end

  # Does this font support Unicode?
  #
  # @return [true]
  #
  # source://prawn//lib/prawn/fonts/ttf.rb#63
  def unicode?; end

  # @private
  # @return [number]
  #
  # source://prawn//lib/prawn/fonts/ttf.rb#282
  def x_height; end

  private

  # source://prawn//lib/prawn/fonts/ttf.rb#399
  def character_width_by_code(code); end

  # source://prawn//lib/prawn/fonts/ttf.rb#360
  def cmap; end

  # source://prawn//lib/prawn/fonts/ttf.rb#424
  def embed(reference, subset); end

  # source://prawn//lib/prawn/fonts/ttf.rb#523
  def embed_composite_font(reference, font); end

  # source://prawn//lib/prawn/fonts/ttf.rb#519
  def embed_full_font(reference); end

  # @raise [NoPostscriptName]
  #
  # source://prawn//lib/prawn/fonts/ttf.rb#438
  def embed_simple_font(reference, font, unicode_mapping); end

  # source://prawn//lib/prawn/fonts/ttf.rb#432
  def embed_subset(reference, subset); end

  # source://prawn//lib/prawn/fonts/ttf.rb#600
  def font_type(font); end

  # source://prawn//lib/prawn/fonts/ttf.rb#395
  def hmtx; end

  # +string+ must be UTF8-encoded.
  #
  # Returns an array. If an element is a numeric, it represents the
  # kern amount to inject at that position. Otherwise, the element
  # is an array of UTF-16 characters.
  #
  # source://prawn//lib/prawn/fonts/ttf.rb#369
  def kern(string); end

  # source://prawn//lib/prawn/fonts/ttf.rb#386
  def kern_pairs_table; end

  # source://prawn//lib/prawn/fonts/ttf.rb#610
  def read_ttf_file; end

  # source://prawn//lib/prawn/fonts/ttf.rb#413
  def register(subset); end

  # source://prawn//lib/prawn/fonts/ttf.rb#409
  def scale_factor; end
end

# TrueType font error.
#
# source://prawn//lib/prawn/fonts/ttf.rb#21
class Prawn::Fonts::TTF::Error < ::StandardError
  # @return [Error] a new instance of Error
  #
  # source://prawn//lib/prawn/fonts/ttf.rb#28
  def initialize(message = T.unsafe(nil), font: T.unsafe(nil)); end
end

# @private
#
# source://prawn//lib/prawn/fonts/ttf.rb#23
Prawn::Fonts::TTF::Error::DEFAULT_MESSAGE = T.let(T.unsafe(nil), String)

# @private
#
# source://prawn//lib/prawn/fonts/ttf.rb#26
Prawn::Fonts::TTF::Error::MESSAGE_WITH_FONT = T.let(T.unsafe(nil), String)

# An adapter for subset collection to represent a full font.
#
# @private
#
# source://prawn//lib/prawn/fonts/ttf.rb#70
class Prawn::Fonts::TTF::FullFontSubsetsCollection
  # @return [FullFontSubsetsCollection] a new instance of FullFontSubsetsCollection
  #
  # source://prawn//lib/prawn/fonts/ttf.rb#77
  def initialize(original); end

  # Encode characters.
  #
  # @return [Array<Array(FULL_FONT, String)>]
  #
  # source://prawn//lib/prawn/fonts/ttf.rb#104
  def encode(characters); end

  private

  # source://prawn//lib/prawn/fonts/ttf.rb#122
  def check_bounds!(num); end

  # Returns the value of attribute cmap.
  #
  # source://prawn//lib/prawn/fonts/ttf.rb#118
  def cmap; end

  # Returns the value of attribute code_space_max.
  #
  # source://prawn//lib/prawn/fonts/ttf.rb#120
  def code_space_max; end

  # Returns the value of attribute code_space_size.
  #
  # source://prawn//lib/prawn/fonts/ttf.rb#119
  def code_space_size; end
end

# source://prawn//lib/prawn/fonts/ttf.rb#71
Prawn::Fonts::TTF::FullFontSubsetsCollection::FULL_FONT = T.let(T.unsafe(nil), Object)

# Signals absense of a PostScript font name.
#
# source://prawn//lib/prawn/fonts/ttf.rb#47
class Prawn::Fonts::TTF::NoPostscriptName < ::Prawn::Fonts::TTF::Error; end

# @private
#
# source://prawn//lib/prawn/fonts/ttf.rb#49
Prawn::Fonts::TTF::NoPostscriptName::DEFAULT_MESSAGE = T.let(T.unsafe(nil), String)

# @private
#
# source://prawn//lib/prawn/fonts/ttf.rb#52
Prawn::Fonts::TTF::NoPostscriptName::MESSAGE_WITH_FONT = T.let(T.unsafe(nil), String)

# Signals absence of a Unicode character map in the font.
#
# source://prawn//lib/prawn/fonts/ttf.rb#38
class Prawn::Fonts::TTF::NoUnicodeCMap < ::Prawn::Fonts::TTF::Error; end

# @private
#
# source://prawn//lib/prawn/fonts/ttf.rb#40
Prawn::Fonts::TTF::NoUnicodeCMap::DEFAULT_MESSAGE = T.let(T.unsafe(nil), String)

# @private
#
# source://prawn//lib/prawn/fonts/ttf.rb#43
Prawn::Fonts::TTF::NoUnicodeCMap::MESSAGE_WITH_FONT = T.let(T.unsafe(nil), String)

# This class generates ToUnicode CMap for embedde TrueType/OpenType fonts.
# It's a separate format and is somewhat complicated so it has its own
# place.
#
# @private
#
# source://prawn//lib/prawn/fonts/to_unicode_cmap.rb#10
class Prawn::Fonts::ToUnicodeCMap
  # mapping is expected to be a hash with keys being character codes (in
  # broad sense, as used in the showing operation strings) and values being
  # Unicode code points.
  #
  # @return [ToUnicodeCMap] a new instance of ToUnicodeCMap
  #
  # source://prawn//lib/prawn/fonts/to_unicode_cmap.rb#14
  def initialize(mapping, code_space_size = T.unsafe(nil)); end

  # Generate CMap.
  #
  # @return [String]
  #
  # source://prawn//lib/prawn/fonts/to_unicode_cmap.rb#22
  def generate; end

  private

  # Returns the value of attribute cmap.
  #
  # source://prawn//lib/prawn/fonts/to_unicode_cmap.rb#123
  def cmap; end

  # Returns the value of attribute code_space_max.
  #
  # source://prawn//lib/prawn/fonts/to_unicode_cmap.rb#125
  def code_space_max; end

  # Returns the value of attribute code_space_size.
  #
  # source://prawn//lib/prawn/fonts/to_unicode_cmap.rb#124
  def code_space_size; end

  # Returns the value of attribute mapping.
  #
  # source://prawn//lib/prawn/fonts/to_unicode_cmap.rb#121
  def mapping; end

  # source://prawn//lib/prawn/fonts/to_unicode_cmap.rb#127
  def mapping_spans(mapping); end
end

# Implements the drawing facilities for {Prawn::Document}.
# Use this to draw the most beautiful imaginable things.
#
# source://prawn//lib/prawn/graphics/blend_mode.rb#4
module Prawn::Graphics
  include ::Prawn::Graphics::BlendMode
  include ::Prawn::Graphics::Color
  include ::Prawn::Graphics::Dash
  include ::Prawn::Graphics::CapStyle
  include ::Prawn::Graphics::JoinStyle
  include ::Prawn::Graphics::Transparency
  include ::Prawn::Graphics::Transformation
  include ::Prawn::Graphics::Patterns

  # Draws a circle of radius `radius` with the centre-point at
  # `point` as a complete subpath. The drawing point will be moved to
  # the centre-point upon completion of the drawing the circle.
  #
  # @example
  #   pdf.circle [100, 100], 25
  # @param center [Array(Number, Number)]
  # @param radius [Number]
  # @return [void]
  #
  # source://prawn//lib/prawn/graphics.rb#261
  def circle(center, radius); end

  # Closes and strokes the current path. If a block is provided, yields to the
  # block before closing the path. See {Graphics::Color} for color details.
  #
  # @return [void]
  # @yield
  #
  # source://prawn//lib/prawn/graphics.rb#389
  def close_and_stroke; end

  # Closes the current path.
  #
  # source://prawn//lib/prawn/graphics.rb#510
  def close_path; end

  # Draws a Bezier curve between two points, bounded by two additional
  # points
  #
  # @example
  #   pdf.curve [50, 100], [100, 100], bounds: [[90, 90], [75, 75]]
  # @option options
  # @param origin [Array(Number, Number)]
  # @param dest [Array(Number, Number)]
  # @param options [Hash]
  # @return [void]
  #
  # source://prawn//lib/prawn/graphics.rb#242
  def curve(origin, dest, options = T.unsafe(nil)); end

  # Draws a Bezier curve from the current drawing position to the
  # specified point, bounded by two additional points.
  #
  # @example
  #   pdf.curve_to [100, 100], bounds: [[90, 90], [75, 75]]
  # @option options
  # @param dest [Array(Number, Number)]
  # @param options [Hash]
  # @return [void]
  #
  # source://prawn//lib/prawn/graphics.rb#85
  def curve_to(dest, options = T.unsafe(nil)); end

  # Draws an ellipse of `x` radius `radius1` and `y` radius `radius2` with the
  # centre-point at `point` as a complete subpath. The drawing point will be
  # moved to the centre-point upon completion of the drawing the ellipse.
  #
  # @example Draws an ellipse with x-radius 25 and y-radius 50
  #   pdf.ellipse [100, 100], 25, 50
  # @param point [Array(Number, Number)]
  # @param radius1 [Number]
  # @param radius2 [Number]
  # @return [void]
  #
  # source://prawn//lib/prawn/graphics.rb#276
  def ellipse(point, radius1, radius2 = T.unsafe(nil)); end

  # Closes and fills the current path. See {Graphics::Color} for color details.
  #
  # If the option `fill_rule: :even_odd` is specified, Prawn will use the
  # even-odd rule to fill the path. Otherwise, the nonzero winding number rule
  # will be used. See the PDF reference, "Graphics -> Path Construction and
  # Painting -> Clipping Path Operators" for details on the difference.
  #
  # @option options
  # @param options [Hash]
  # @return [void]
  # @yield
  #
  # source://prawn//lib/prawn/graphics.rb#485
  def fill(options = T.unsafe(nil)); end

  # Closes, fills, and strokes the current path. If a block is provided,
  # yields to the block before closing the path. See {Graphics::Color} for
  # color details.
  #
  # If the option `fill_rule: :even_odd` is specified, Prawn will use the
  # even-odd rule to fill the path. Otherwise, the nonzero winding number rule
  # will be used. See the PDF reference, "Graphics -> Path Construction and
  # Painting -> Clipping Path Operators" for details on the difference.
  #
  # @option options
  # @param options [Hash]
  # @return [void]
  # @yield
  #
  # source://prawn//lib/prawn/graphics.rb#503
  def fill_and_stroke(options = T.unsafe(nil)); end

  # Draws, strokes, and fills a circle of radius `radius` with the
  # centre-point at `point`.
  #
  # @param center [Array(Number, Number)]
  # @param radius [Number]
  # @return [void]
  #
  # source://prawn//lib/prawn/graphics.rb#746
  def fill_and_stroke_circle(*args); end

  # source://prawn//lib/prawn/graphics.rb#746
  def fill_and_stroke_circle_at(*args); end

  # source://prawn//lib/prawn/graphics.rb#746
  def fill_and_stroke_curve(*args); end

  # source://prawn//lib/prawn/graphics.rb#746
  def fill_and_stroke_curve_to(*args); end

  # Draws, strokes, and fills an ellipse of x radius `r1` and y radius `r2`
  # with the centre-point at `point`.
  #
  # @param point [Array(Number, Number)]
  # @param radius1 [Number]
  # @param radius2 [Number]
  # @return [void]
  #
  # source://prawn//lib/prawn/graphics.rb#746
  def fill_and_stroke_ellipse(*args); end

  # source://prawn//lib/prawn/graphics.rb#746
  def fill_and_stroke_ellipse_at(*args); end

  # source://prawn//lib/prawn/graphics.rb#746
  def fill_and_stroke_horizontal_line(*args); end

  # source://prawn//lib/prawn/graphics.rb#746
  def fill_and_stroke_horizontal_rule(*args); end

  # source://prawn//lib/prawn/graphics.rb#746
  def fill_and_stroke_line(*args); end

  # source://prawn//lib/prawn/graphics.rb#746
  def fill_and_stroke_line_to(*args); end

  # Draws, strokes, and fills a polygon from the specified points.
  #
  # @param points [Array<Array(Number, Number)>]
  # @return [void]
  #
  # source://prawn//lib/prawn/graphics.rb#746
  def fill_and_stroke_polygon(*args); end

  # Draws, fills, and strokes a rectangle given `point`, `width`, and
  # `height`. The rectangle is bounded by its upper-left corner.
  #
  # @param point [Array(Number, Number)]
  # @param width [Number]
  # @param height [Number]
  # @return [void]
  #
  # source://prawn//lib/prawn/graphics.rb#746
  def fill_and_stroke_rectangle(*args); end

  # source://prawn//lib/prawn/graphics.rb#746
  def fill_and_stroke_rounded_polygon(*args); end

  # Draws, fills, and strokes a rounded rectangle given `point`, `width`,
  # and `height` and `radius` for the rounded corner. The rectangle is
  # bounded by its upper-left corner.
  #
  # @param point [Array(Number, Number)]
  # @param width [Number]
  # @param height [Number]
  # @param radius [Number]
  # @return [void]
  #
  # source://prawn//lib/prawn/graphics.rb#746
  def fill_and_stroke_rounded_rectangle(*args); end

  # source://prawn//lib/prawn/graphics.rb#746
  def fill_and_stroke_rounded_vertex(*args); end

  # source://prawn//lib/prawn/graphics.rb#746
  def fill_and_stroke_vertical_line(*args); end

  # Draws and fills a circle of radius `radius` with the centre-point at
  # `point`.
  #
  # @param center [Array(Number, Number)]
  # @param radius [Number]
  # @return [void]
  #
  # source://prawn//lib/prawn/graphics.rb#746
  def fill_circle(*args); end

  # source://prawn//lib/prawn/graphics.rb#746
  def fill_circle_at(*args); end

  # source://prawn//lib/prawn/graphics.rb#746
  def fill_curve(*args); end

  # source://prawn//lib/prawn/graphics.rb#746
  def fill_curve_to(*args); end

  # Draws and fills an ellipse of x radius `r1` and y radius `r2` with the
  # centre-point at `point`.
  #
  # @param point [Array(Number, Number)]
  # @param radius1 [Number]
  # @param radius2 [Number]
  # @return [void]
  #
  # source://prawn//lib/prawn/graphics.rb#746
  def fill_ellipse(*args); end

  # source://prawn//lib/prawn/graphics.rb#746
  def fill_ellipse_at(*args); end

  # source://prawn//lib/prawn/graphics.rb#746
  def fill_horizontal_line(*args); end

  # source://prawn//lib/prawn/graphics.rb#746
  def fill_horizontal_rule(*args); end

  # source://prawn//lib/prawn/graphics.rb#746
  def fill_line(*args); end

  # source://prawn//lib/prawn/graphics.rb#746
  def fill_line_to(*args); end

  # Draws and fills a polygon from the specified points.
  #
  # @param points [Array<Array(Number, Number)>]
  # @return [void]
  #
  # source://prawn//lib/prawn/graphics.rb#746
  def fill_polygon(*args); end

  # Draws and fills a rectangle given `point`, `width`, and `height`. The
  # rectangle is bounded by its upper-left corner.
  #
  # @param point [Array(Number, Number)]
  # @param width [Number]
  # @param height [Number]
  # @return [void]
  #
  # source://prawn//lib/prawn/graphics.rb#746
  def fill_rectangle(*args); end

  # Draws and fills a rounded polygon from specified points, using `radius`
  # to define Bezier curves.
  #
  # @param radius [Number]
  # @param points [Array<Array(Number, Number)>]
  # @return [void]
  #
  # source://prawn//lib/prawn/graphics.rb#746
  def fill_rounded_polygon(*args); end

  # Draws and fills a rounded rectangle given `point`, `width` and `height`,
  # and `radius` for the rounded corner. The rectangle is bounded by its
  # upper-left corner.
  #
  # @param point [Array(Number, Number)]
  # @param width [Number]
  # @param height [Number]
  # @param radius [Number]
  # @return [void]
  #
  # source://prawn//lib/prawn/graphics.rb#746
  def fill_rounded_rectangle(*args); end

  # source://prawn//lib/prawn/graphics.rb#746
  def fill_rounded_vertex(*args); end

  # source://prawn//lib/prawn/graphics.rb#746
  def fill_vertical_line(*args); end

  # Draws a horizontal line from `x1` to `x2` at the current {Document#y}
  # position, or the position specified by the `:at` option.
  #
  # @example Draw a line from `[25, 75]` to `[100, 75]`
  #   horizontal_line 25, 100, at: 75
  # @option options
  # @param x1 [Number]
  # @param x2 [Number]
  # @param options [Hash]
  # @return [void]
  #
  # source://prawn//lib/prawn/graphics.rb#202
  def horizontal_line(x1, x2, options = T.unsafe(nil)); end

  # Draws a horizontal line from the left border to the right border of the
  # bounding box at the current {Document#y} position.
  #
  # @return [void]
  #
  # source://prawn//lib/prawn/graphics.rb#212
  def horizontal_rule; end

  # Draws a line from one point to another. Points may be specified as
  # tuples or flattened argument list.
  #
  # @example
  #   pdf.line [100, 100], [200, 250]
  #   pdf.line(100, 100, 200, 250)
  # @overload line
  # @overload line
  #
  # source://prawn//lib/prawn/graphics.rb#185
  def line(*points); end

  # Draws a line from the current drawing position to the specified point.
  # The destination may be described as a tuple or a flattened list:
  #
  # @example
  #   pdf.line_to [50, 50]
  #   pdf.line_to(50, 50)
  # @overload line_to
  # @overload line_to
  #
  # source://prawn//lib/prawn/graphics.rb#70
  def line_to(*point); end

  # When called without an argument, returns the current line thickness.
  # When called with an argument, sets the line thickness to the specified
  # value (in PDF points).
  #
  # @example
  #   pdf.line_width #=> 1
  #   pdf.line_width(5)
  #   pdf.line_width #=> 5
  # @overload line_width
  # @overload line_width
  #
  # source://prawn//lib/prawn/graphics.rb#160
  def line_width(width = T.unsafe(nil)); end

  # Sets line thickness to the `width` specified.
  #
  # @param width [Number]
  # @return [void]
  #
  # source://prawn//lib/prawn/graphics.rb#141
  def line_width=(width); end

  # Moves the drawing position to a given point. The point can be specified as
  # a tuple or a flattened argument list.
  #
  # @example
  #   pdf.move_to [100, 50]
  #   pdf.move_to(100, 50)
  # @overload move_to
  # @overload move_to
  #
  # source://prawn//lib/prawn/graphics.rb#51
  def move_to(*point); end

  # Draws a polygon from the specified points.
  #
  # @example Draws a snazzy triangle
  #   pdf.polygon [100,100], [100,200], [200,200]
  # @param points [Array<Array(Number, Number)>]
  # @return [void]
  #
  # source://prawn//lib/prawn/graphics.rb#317
  def polygon(*points); end

  # Draws a rectangle given `point`, `width and `height`. The rectangle is
  # bounded by its upper-left corner.
  #
  # @example
  #   pdf.rectangle [300, 300], 100, 200
  # @param point [Array(Number, Number)]
  # @param width [Number]
  # @param height [Number]
  # @return [void]
  #
  # source://prawn//lib/prawn/graphics.rb#108
  def rectangle(point, width, height); end

  # Draws a rounded polygon from specified points using the radius to define
  # bezier curves.
  #
  # @example Draws a rounded filled in polygon
  #   pdf.fill_and_stroke_rounded_polygon(
  #   10, [100, 250], [200, 300], [300, 250], [300, 150], [200, 100],
  #   [100, 150]
  #   )
  # @param radius [Number]
  # @param points [Array<Array(Number, Number)>]
  # @return [void]
  #
  # source://prawn//lib/prawn/graphics.rb#338
  def rounded_polygon(radius, *points); end

  # Draws a rounded rectangle given `point`, `width`, `height`, and `radius`
  # for the rounded corner. The rectangle is bounded by its upper-left corner.
  #
  # @example
  #   pdf.rounded_rectangle [300, 300], 100, 200, 10
  # @param point [Array(Number, Number)]
  # @param width [Number]
  # @param height [Number]
  # @param radius [Number]
  # @return [void]
  #
  # source://prawn//lib/prawn/graphics.rb#126
  def rounded_rectangle(point, width, height, radius); end

  # Creates a rounded vertex for a line segment used for building a rounded
  # polygon requires a radius to define bezier curve and three points. The
  # first two points define the line segment and the third point helps define
  # the curve for the vertex.
  #
  # @param radius [Number]
  # @param points [Array(Array(Number, Number), Array(Number, Number), Array(Number, Number))]
  # @return [void]
  #
  # source://prawn//lib/prawn/graphics.rb#357
  def rounded_vertex(radius, *points); end

  # Strokes the current path. If a block is provided, yields to the block
  # before closing the path. See {Graphics::Color} for color details.
  #
  # @return [void]
  # @yield
  #
  # source://prawn//lib/prawn/graphics.rb#379
  def stroke; end

  # Draws and strokes X and Y axes rulers beginning at the current bounding
  # box origin (or at a custom location).
  #
  # @option options
  # @option options
  # @option options
  # @option options
  # @option options
  # @option options
  # @param options [Hash]
  # @return [void]
  #
  # source://prawn//lib/prawn/graphics.rb#418
  def stroke_axis(options = T.unsafe(nil)); end

  # Draws and strokes a rectangle represented by the current bounding box.
  #
  # @return [void]
  #
  # source://prawn//lib/prawn/graphics.rb#397
  def stroke_bounds; end

  # source://prawn//lib/prawn/graphics.rb#746
  def stroke_circle(*args); end

  # source://prawn//lib/prawn/graphics.rb#746
  def stroke_circle_at(*args); end

  # Strokes a Bezier curve between two points, bounded by two additional
  # points.
  #
  # @option options
  # @param origin [Array(Number, Number)]
  # @param dest [Array(Number, Number)]
  # @param options [Hash]
  # @return [void]
  #
  # source://prawn//lib/prawn/graphics.rb#746
  def stroke_curve(*args); end

  # source://prawn//lib/prawn/graphics.rb#746
  def stroke_curve_to(*args); end

  # Draws and strokes an ellipse of x radius `r1` and y radius `r2` with the
  # centre-point at `point`.
  #
  # @param point [Array(Number, Number)]
  # @param radius1 [Number]
  # @param radius2 [Number]
  # @return [void]
  #
  # source://prawn//lib/prawn/graphics.rb#746
  def stroke_ellipse(*args); end

  # source://prawn//lib/prawn/graphics.rb#746
  def stroke_ellipse_at(*args); end

  # Strokes a horizontal line from `x1` to `x2` at the current y position,
  # or the position specified by the :at option.
  #
  # @option options
  # @param x1 [Number]
  # @param x2 [Number]
  # @param options [Hash]
  # @return [void]
  #
  # source://prawn//lib/prawn/graphics.rb#746
  def stroke_horizontal_line(*args); end

  # Strokes a horizontal line from the left border to the right border of
  # the bounding box at the current y position.
  #
  # @return [void]
  #
  # source://prawn//lib/prawn/graphics.rb#746
  def stroke_horizontal_rule(*args); end

  # Strokes a line from one point to another. Points may be specified as
  # tuples or flattened argument list.
  #
  # @overload line
  # @overload line
  #
  # source://prawn//lib/prawn/graphics.rb#746
  def stroke_line(*args); end

  # source://prawn//lib/prawn/graphics.rb#746
  def stroke_line_to(*args); end

  # Draws and strokes a polygon from the specified points.
  #
  #   @param points [Array<Array(Number, Number)>]
  #   @return [void]
  #
  # source://prawn//lib/prawn/graphics.rb#746
  def stroke_polygon(*args); end

  # Draws and strokes a rectangle given `point`, `width`, and `height`. The
  # rectangle is bounded by its upper-left corner.
  #
  # @param point [Array(Number, Number)]
  # @param width [Number]
  # @param height [Number]
  # @return [void]
  #
  # source://prawn//lib/prawn/graphics.rb#746
  def stroke_rectangle(*args); end

  # Draws and strokes a rounded polygon from specified points, using
  # `radius` to define Bezier curves.
  #
  # @param radius [Number]
  # @param points [Array<Array(Number, Number)>]
  # @return [void]
  #
  # source://prawn//lib/prawn/graphics.rb#746
  def stroke_rounded_polygon(*args); end

  # Draws and strokes a rounded rectangle given `point`, `width` and
  # `height`, and `radius` for the rounded corner. The rectangle is bounded
  # by its upper-left corner.
  #
  # @param point [Array(Number, Number)]
  # @param width [Number]
  # @param height [Number]
  # @param radius [Number]
  # @return [void]
  #
  # source://prawn//lib/prawn/graphics.rb#746
  def stroke_rounded_rectangle(*args); end

  # source://prawn//lib/prawn/graphics.rb#746
  def stroke_rounded_vertex(*args); end

  # Strokes a vertical line at the x coordinate given by `:at` from `y1` to
  # `y2`.
  #
  # @option params
  # @param y1 [Number]
  # @param y2 [Number]
  # @param params [Hash]
  # @return [void]
  #
  # source://prawn//lib/prawn/graphics.rb#746
  def stroke_vertical_line(*args); end

  # Draws a vertical line at the x coordinate given by `:at` from `y1` to
  # `y2`.
  #
  # @example Draw a line from `[25, 100]` to `[25, 300]`
  #   vertical_line 100, 300, at: 25
  # @option params
  # @param y1 [Number]
  # @param y2 [Number]
  # @param params [Hash]
  # @return [void]
  #
  # source://prawn//lib/prawn/graphics.rb#227
  def vertical_line(y1, y2, params); end

  private

  # source://prawn//lib/prawn/graphics.rb#755
  def current_line_width; end

  # source://prawn//lib/prawn/graphics.rb#759
  def current_line_width=(width); end

  # source://prawn//lib/prawn/graphics.rb#776
  def degree_to_rad(angle); end

  # source://prawn//lib/prawn/graphics.rb#767
  def map_to_absolute(*point); end

  # source://prawn//lib/prawn/graphics.rb#772
  def map_to_absolute!(point); end

  # Returns the coordinates for a point on a line that is a given distance
  # away from the second point defining the line segement
  #
  # source://prawn//lib/prawn/graphics.rb#782
  def point_on_line(distance_from_end, *points); end

  # source://prawn//lib/prawn/graphics.rb#763
  def write_line_width; end
end

# The {Prawn::BlendMode} module is used to change the way two graphic
# objects are blended together.
#
# source://prawn//lib/prawn/graphics/blend_mode.rb#7
module Prawn::Graphics::BlendMode
  # Set blend mode. If a block is passed blend mode is restored afterwards.
  #
  # Passing an array of blend modes is allowed. PDF viewers should blend
  # layers based on the first recognized blend mode.
  #
  # Valid blend modes since PDF 1.4 include `:Normal`, `:Multiply`, `:Screen`,
  # `:Overlay`, `:Darken`, `:Lighten`, `:ColorDodge`, `:ColorBurn`,
  # `:HardLight`, `:SoftLight`, `:Difference`, `:Exclusion`, `:Hue`,
  # `:Saturation`, `:Color`, and `:Luminosity`.
  #
  # @example
  #   pdf.fill_color('0000ff')
  #   pdf.fill_rectangle([x, y + 25], 50, 50)
  #   pdf.blend_mode(:Multiply) do
  #   pdf.fill_color('ff0000')
  #   pdf.fill_circle([x, y], 25)
  #   end
  # @param blend_mode [Symbol, Array<Symbol>]
  # @return [void]
  # @yield
  #
  # source://prawn//lib/prawn/graphics/blend_mode.rb#31
  def blend_mode(blend_mode = T.unsafe(nil)); end

  private

  # source://prawn//lib/prawn/graphics/blend_mode.rb#48
  def blend_mode_dictionary_name(blend_mode); end

  # source://prawn//lib/prawn/graphics/blend_mode.rb#44
  def blend_mode_dictionary_registry; end
end

# Implements stroke cap styling
#
# source://prawn//lib/prawn/graphics/cap_style.rb#6
module Prawn::Graphics::CapStyle
  # Sets the cap style for stroked lines and curves.
  #
  # @overload cap_style
  # @overload cap_style
  #
  # source://prawn//lib/prawn/graphics/cap_style.rb#19
  def cap_style(style = T.unsafe(nil)); end

  # Sets the cap style for stroked lines and curves.
  #
  # @overload cap_style
  # @overload cap_style
  #
  # source://prawn//lib/prawn/graphics/cap_style.rb#19
  def cap_style=(style = T.unsafe(nil)); end

  private

  # source://prawn//lib/prawn/graphics/cap_style.rb#31
  def current_cap_style; end

  # source://prawn//lib/prawn/graphics/cap_style.rb#35
  def current_cap_style=(style); end

  # source://prawn//lib/prawn/graphics/cap_style.rb#39
  def write_stroke_cap_style; end
end

# @private
#
# source://prawn//lib/prawn/graphics/cap_style.rb#10
Prawn::Graphics::CapStyle::CAP_STYLES = T.let(T.unsafe(nil), Hash)

# Implements color handling.
#
# source://prawn//lib/prawn/graphics/color.rb#6
module Prawn::Graphics::Color
  # Sets or returns the fill color.
  #
  # @overload fill_color
  # @overload fill_color
  #
  # source://prawn//lib/prawn/graphics/color.rb#35
  def fill_color(*color); end

  # Sets or returns the fill color.
  #
  # @overload fill_color
  # @overload fill_color
  #
  # source://prawn//lib/prawn/graphics/color.rb#35
  def fill_color=(*color); end

  # Sets or returns the line stroking color.
  #
  # @overload stroke_color
  # @overload stroke_color
  #
  # source://prawn//lib/prawn/graphics/color.rb#67
  def stroke_color(*color); end

  # Sets or returns the line stroking color.
  #
  # @overload stroke_color
  # @overload stroke_color
  #
  # source://prawn//lib/prawn/graphics/color.rb#67
  def stroke_color=(*color); end

  private

  # source://prawn//lib/prawn/graphics/color.rb#156
  def color_space(color); end

  # source://prawn//lib/prawn/graphics/color.rb#152
  def color_to_s(color); end

  # source://prawn//lib/prawn/graphics/color.rb#121
  def color_type(color); end

  # source://prawn//lib/prawn/graphics/color.rb#227
  def current_color_space(type); end

  # source://prawn//lib/prawn/graphics/color.rb#236
  def current_fill_color; end

  # source://prawn//lib/prawn/graphics/color.rb#240
  def current_fill_color=(color); end

  # source://prawn//lib/prawn/graphics/color.rb#244
  def current_stroke_color; end

  # source://prawn//lib/prawn/graphics/color.rb#248
  def current_stroke_color=(color); end

  # Converts hex string into RGB value array.
  #
  # @example
  #   Prawn::Graphics::Color.hex2rgb("ff7808")
  #   #=> [255, 120, 8]
  # @param hex [String] must be 6-digits long.
  # @return [Array(Integer, Integer, Integer)]
  #
  # source://prawn//lib/prawn/graphics/color.rb#101
  def hex2rgb(hex); end

  # source://prawn//lib/prawn/graphics/color.rb#141
  def normalize_color(color); end

  # source://prawn//lib/prawn/graphics/color.rb#110
  def process_color(*color); end

  # Converts RGB value array to hex string suitable for use with
  # {fill_color} and {stroke_color}.
  #
  # @example
  #   Prawn::Graphics::Color.rgb2hex([255, 120, 8])
  #   #=> "ff7808"
  # @param rgb [Array(Number, Number, Number)] Each component has to be in the range from 0 to 255.
  # @return [String]
  #
  # source://prawn//lib/prawn/graphics/color.rb#89
  def rgb2hex(rgb); end

  # source://prawn//lib/prawn/graphics/color.rb#193
  def set_color(type, color, options = T.unsafe(nil)); end

  # source://prawn//lib/prawn/graphics/color.rb#167
  def set_color_space(type, color_space); end

  # source://prawn//lib/prawn/graphics/color.rb#231
  def set_current_color_space(color_space, type); end

  # source://prawn//lib/prawn/graphics/color.rb#214
  def set_fill_color(color = T.unsafe(nil)); end

  # source://prawn//lib/prawn/graphics/color.rb#218
  def set_stroke_color(color = T.unsafe(nil)); end

  # source://prawn//lib/prawn/graphics/color.rb#222
  def update_colors; end

  # source://prawn//lib/prawn/graphics/color.rb#252
  def write_color(color, operator); end

  class << self
    # Converts hex string into RGB value array.
    #
    # @example
    #   Prawn::Graphics::Color.hex2rgb("ff7808")
    #   #=> [255, 120, 8]
    # @param hex [String] must be 6-digits long.
    # @return [Array(Integer, Integer, Integer)]
    #
    # source://prawn//lib/prawn/graphics/color.rb#101
    def hex2rgb(hex); end

    # Converts RGB value array to hex string suitable for use with
    # {fill_color} and {stroke_color}.
    #
    # @example
    #   Prawn::Graphics::Color.rgb2hex([255, 120, 8])
    #   #=> "ff7808"
    # @param rgb [Array(Number, Number, Number)] Each component has to be in the range from 0 to 255.
    # @return [String]
    #
    # source://prawn//lib/prawn/graphics/color.rb#89
    def rgb2hex(rgb); end
  end
end

# source://prawn//lib/prawn/graphics/color.rb#165
Prawn::Graphics::Color::COLOR_SPACES = T.let(T.unsafe(nil), Array)

# Implements stroke dashing.
#
# source://prawn//lib/prawn/graphics/dash.rb#6
module Prawn::Graphics::Dash
  # Get or set stroke dash pattern.
  #
  # @overload dash
  # @overload dash
  #
  # source://prawn//lib/prawn/graphics/dash.rb#59
  def dash(length = T.unsafe(nil), options = T.unsafe(nil)); end

  # Get or set stroke dash pattern.
  #
  # @overload dash
  # @overload dash
  #
  # source://prawn//lib/prawn/graphics/dash.rb#59
  def dash=(length = T.unsafe(nil), options = T.unsafe(nil)); end

  # Returns `true` when stroke is dashed, `false` otherwise.
  #
  # @return [Boolean]
  #
  # source://prawn//lib/prawn/graphics/dash.rb#96
  def dashed?; end

  # Stops dashing, restoring solid stroked lines and curves.
  #
  # @return [void]
  #
  # source://prawn//lib/prawn/graphics/dash.rb#88
  def undash; end

  private

  # source://prawn//lib/prawn/graphics/dash.rb#114
  def current_dash_state; end

  # source://prawn//lib/prawn/graphics/dash.rb#110
  def current_dash_state=(dash_options); end

  # source://prawn//lib/prawn/graphics/dash.rb#118
  def dash_setting; end

  # source://prawn//lib/prawn/graphics/dash.rb#106
  def undashed_setting; end

  # source://prawn//lib/prawn/graphics/dash.rb#102
  def write_stroke_dash; end
end

# Implements stroke join styling.
#
# source://prawn//lib/prawn/graphics/join_style.rb#6
module Prawn::Graphics::JoinStyle
  # Get or set the join style for stroked lines and curves.
  #
  # @overload join_style
  # @overload join_style
  #
  # source://prawn//lib/prawn/graphics/join_style.rb#29
  def join_style(style = T.unsafe(nil)); end

  # Get or set the join style for stroked lines and curves.
  #
  # @overload join_style
  # @overload join_style
  #
  # source://prawn//lib/prawn/graphics/join_style.rb#29
  def join_style=(style = T.unsafe(nil)); end

  private

  # source://prawn//lib/prawn/graphics/join_style.rb#47
  def current_join_style; end

  # source://prawn//lib/prawn/graphics/join_style.rb#51
  def current_join_style=(style); end

  # source://prawn//lib/prawn/graphics/join_style.rb#55
  def write_stroke_join_style; end
end

# @private
#
# source://prawn//lib/prawn/graphics/join_style.rb#8
Prawn::Graphics::JoinStyle::JOIN_STYLES = T.let(T.unsafe(nil), Hash)

# This constant is used to approximate a symmetrical arc using a cubic
# Bezier curve.
#
# source://prawn//lib/prawn/graphics.rb#249
Prawn::Graphics::KAPPA = T.let(T.unsafe(nil), Float)

# Implements axial & radial gradients.
#
# source://prawn//lib/prawn/graphics/patterns.rb#8
module Prawn::Graphics::Patterns
  # Sets the fill gradient.
  #
  # @overload fill_gradient
  # @overload fill_gradient
  # @overload fill_gradient
  #
  # source://prawn//lib/prawn/graphics/patterns.rb#105
  def fill_gradient(*args, **kwargs); end

  # Sets the stroke gradient.
  #
  # @overload fill_gradient
  # @overload fill_gradient
  # @overload fill_gradient
  #
  # source://prawn//lib/prawn/graphics/patterns.rb#194
  def stroke_gradient(*args, **kwargs); end

  private

  # source://prawn//lib/prawn/graphics/patterns.rb#310
  def create_gradient_pattern(gradient); end

  # source://prawn//lib/prawn/graphics/patterns.rb#374
  def gradient_coordinates(gradient); end

  # source://prawn//lib/prawn/graphics/patterns.rb#306
  def gradient_registry; end

  # source://prawn//lib/prawn/graphics/patterns.rb#292
  def gradient_registry_key(gradient); end

  # source://prawn//lib/prawn/graphics/patterns.rb#232
  def parse_gradient_arguments(*arguments, from: T.unsafe(nil), to: T.unsafe(nil), r1: T.unsafe(nil), r2: T.unsafe(nil), stops: T.unsafe(nil), apply_transformations: T.unsafe(nil)); end

  # source://prawn//lib/prawn/graphics/patterns.rb#200
  def set_gradient(type, *grad, **kwargs); end
end

# @private
#
# source://prawn//lib/prawn/graphics/patterns.rb#14
class Prawn::Graphics::Patterns::Gradient < ::Struct
  # Returns the value of attribute apply_transformations
  #
  # @return [Object] the current value of apply_transformations
  def apply_transformations; end

  # Sets the attribute apply_transformations
  #
  # @param value [Object] the value to set the attribute apply_transformations to.
  # @return [Object] the newly set value
  def apply_transformations=(_); end

  # Returns the value of attribute from
  #
  # @return [Object] the current value of from
  def from; end

  # Sets the attribute from
  #
  # @param value [Object] the value to set the attribute from to.
  # @return [Object] the newly set value
  def from=(_); end

  # Returns the value of attribute r1
  #
  # @return [Object] the current value of r1
  def r1; end

  # Sets the attribute r1
  #
  # @param value [Object] the value to set the attribute r1 to.
  # @return [Object] the newly set value
  def r1=(_); end

  # Returns the value of attribute r2
  #
  # @return [Object] the current value of r2
  def r2; end

  # Sets the attribute r2
  #
  # @param value [Object] the value to set the attribute r2 to.
  # @return [Object] the newly set value
  def r2=(_); end

  # Returns the value of attribute stops
  #
  # @return [Object] the current value of stops
  def stops; end

  # Sets the attribute stops
  #
  # @param value [Object] the value to set the attribute stops to.
  # @return [Object] the newly set value
  def stops=(_); end

  # Returns the value of attribute to
  #
  # @return [Object] the current value of to
  def to; end

  # Sets the attribute to
  #
  # @param value [Object] the value to set the attribute to to.
  # @return [Object] the newly set value
  def to=(_); end

  # Returns the value of attribute type
  #
  # @return [Object] the current value of type
  def type; end

  # Sets the attribute type
  #
  # @param value [Object] the value to set the attribute type to.
  # @return [Object] the newly set value
  def type=(_); end

  class << self
    def [](*_arg0); end
    def inspect; end
    def keyword_init?; end
    def members; end
    def new(*_arg0); end
  end
end

# Gradient color stop.
#
# @private
#
# source://prawn//lib/prawn/graphics/patterns.rb#11
class Prawn::Graphics::Patterns::GradientStop < ::Struct
  # Returns the value of attribute color
  #
  # @return [Object] the current value of color
  def color; end

  # Sets the attribute color
  #
  # @param value [Object] the value to set the attribute color to.
  # @return [Object] the newly set value
  def color=(_); end

  # Returns the value of attribute position
  #
  # @return [Object] the current value of position
  def position; end

  # Sets the attribute position
  #
  # @param value [Object] the value to set the attribute position to.
  # @return [Object] the newly set value
  def position=(_); end

  class << self
    def [](*_arg0); end
    def inspect; end
    def keyword_init?; end
    def members; end
    def new(*_arg0); end
  end
end

# Implements user-space coordinate transformation.
#
# source://prawn//lib/prawn/graphics/transformation.rb#6
module Prawn::Graphics::Transformation
  # Rotate the user space. If a block is not provided, then you must save
  # and restore the graphics state yourself.
  #
  # @example
  #   save_graphics_state
  #   rotate 30
  #   text "rotated text"
  #   restore_graphics_state
  # @example Rotating a rectangle around its upper-left corner
  #   x = 300
  #   y = 300
  #   width = 150
  #   height = 200
  #   angle = 30
  #   pdf.rotate(angle, :origin => [x, y]) do
  #   pdf.stroke_rectangle([x, y], width, height)
  #   end
  # @option options
  # @param angle [Number] Angle in degrees.
  # @param options [Hash{Symbol => any}]
  # @raise [Prawn::Errors::BlockRequired] if an `:origin` option is
  #   provided, but no block is given.
  # @return [void]
  # @yield
  #
  # source://prawn//lib/prawn/graphics/transformation.rb#36
  def rotate(angle, options = T.unsafe(nil), &block); end

  # Scale the user space. If a block is not provided, then you must save
  # and restore the graphics state yourself.
  #
  # @example
  #   save_graphics_state
  #   scale 1.5
  #   text "scaled text"
  #   restore_graphics_state
  # @example Scale a rectangle from its upper-left corner
  #   x = 300
  #   y = 300
  #   width = 150
  #   height = 200
  #   factor = 1.5
  #   pdf.scale(angle, :origin => [x, y]) do
  #   pdf.stroke_rectangle([x, y], width, height)
  #   end
  # @option options
  # @param factor [Number] Scale factor.
  # @param options [Hash{Symbol => any}]
  # @raise [Prawn::Errors::BlockRequired] If an `:origin` option is
  #   provided, but no block is given.
  # @return [void]
  # @yield
  #
  # source://prawn//lib/prawn/graphics/transformation.rb#109
  def scale(factor, options = T.unsafe(nil), &block); end

  # Transform the user space (see notes for rotate regarding graphics state)
  # Generally, one would use the {rotate}, {scale}, and {translate}
  # convenience methods instead of calling transformation_matrix directly
  #
  # @param matrix [Array(Number, Number, Number, Number, Number, Number)] Transformation matrix.
  #
  #   The six elements correspond to the following elements of the
  #   transformation matrix:
  #
  #   ```plain
  #   a b 0
  #   c d 0
  #   e f 0
  #   ```
  # @return [void]
  # @yield
  #
  # source://prawn//lib/prawn/graphics/transformation.rb#154
  def transformation_matrix(*matrix); end

  # Translate the user space. If a block is not provided, then you must
  # save and restore the graphics state yourself.
  #
  # @example Move the text up and over 10
  #   save_graphics_state
  #   translate(10, 10)
  #   text "scaled text"
  #   restore_graphics_state
  # @example draw a rectangle with its upper-left corner at x + 10, y + 10
  #   x = 300
  #   y = 300
  #   width = 150
  #   height = 200
  #   pdf.translate(10, 10) do
  #   pdf.stroke_rectangle([x, y], width, height)
  #   end
  # @param x [Number]
  # @param y [Number]
  # @return [void]
  # @yield
  #
  # source://prawn//lib/prawn/graphics/transformation.rb#78
  def translate(x, y, &block); end
end

# This module is used to place transparent content on the page. It has the
# capacity for separate transparency values for stroked content and all
# other content.
#
# source://prawn//lib/prawn/graphics/transparency.rb#8
module Prawn::Graphics::Transparency
  # Set opacity.
  #
  # @example Both the fill and stroke will be at 50% opacity.
  #   pdf.transparent(0.5) do
  #   pdf.text("hello world")
  #   pdf.fill_and_stroke_circle([x, y], 25)
  #   end
  # @example The fill will be at 50% opacity, but the stroke will be at 75% opacity.
  #   pdf.transparent(0.5, 0.75) do
  #   pdf.text("hello world")
  #   pdf.fill_and_stroke_circle([x, y], 25)
  #   end
  # @param opacity [Number] Fill opacity. Clipped to the 0.0 to 1.0 range.
  # @param stroke_opacity [Number] Stroke opacity. Clipped to the
  #   0.0 to 1.0 range.
  # @return [void]
  # @yield
  #
  # source://prawn//lib/prawn/graphics/transparency.rb#30
  def transparent(opacity, stroke_opacity = T.unsafe(nil)); end

  private

  # source://prawn//lib/prawn/graphics/transparency.rb#50
  def next_opacity_dictionary_id; end

  # source://prawn//lib/prawn/graphics/transparency.rb#54
  def opacity_dictionary_name(opacity, stroke_opacity); end

  # source://prawn//lib/prawn/graphics/transparency.rb#46
  def opacity_dictionary_registry; end
end

# ImageHandler provides a way to register image processors with Prawn.
#
# source://prawn//lib/prawn/image_handler.rb#14
class Prawn::ImageHandler
  # @private
  # @return [ImageHandler] a new instance of ImageHandler
  #
  # source://prawn//lib/prawn/image_handler.rb#16
  def initialize; end

  # Find an image handler for an image.
  #
  # @param image_blob [String]
  # @raise [Prawn::Errors::UnsupportedImageType] If no image handler were
  #   found for the image.
  # @return [Object]
  #
  # source://prawn//lib/prawn/image_handler.rb#52
  def find(image_blob); end

  # Register an image handler.
  #
  # @param handler [Object]
  # @return [void]
  #
  # source://prawn//lib/prawn/image_handler.rb#24
  def register(handler); end

  # Register an image handler with the highest priority.
  #
  # @param handler [Object]
  # @return [void]
  #
  # source://prawn//lib/prawn/image_handler.rb#33
  def register!(handler); end

  # Unregister an image handler.
  #
  # @param handler [Object]
  # @return [void]
  #
  # source://prawn//lib/prawn/image_handler.rb#42
  def unregister(handler); end
end

# PDF image embedding.
#
# source://prawn//lib/prawn/images.rb#9
module Prawn::Images
  # Builds an info object (Prawn::Images::*) and a PDF reference representing
  # the given image. Return a pair: [pdf_obj, info].
  #
  # @private
  #
  # source://prawn//lib/prawn/images.rb#72
  def build_image_object(file); end

  # Given a PDF image resource `pdf_obj` that has been added to the page's
  # resources and an `info` object (the pair returned from
  # {build_image_object}), embed the image according to the `options` given.
  #
  # @private
  #
  # source://prawn//lib/prawn/images.rb#102
  def embed_image(pdf_obj, info, options); end

  # Add the image at `file` to the current page. Currently only JPG and
  # PNG files are supported. (Note that processing PNG images with alpha
  # channels can be processor and memory intensive.)
  #
  # If only one of `:width` or `:height` are provided, the image will be
  # scaled proportionally. When both are provided, the image will be stretched
  # to fit the dimensions without maintaining the aspect ratio.
  #
  # @example
  #   Prawn::Document.generate("image2.pdf", page_layout: :landscape) do
  #   pigs = "#{Prawn::DATADIR}/images/pigs.jpg"
  #   image pigs, at: [50,450], width: 450
  #
  #   dice = "#{Prawn::DATADIR}/images/dice.png"
  #   image dice, at: [50, 450], scale: 0.75
  #   end
  # @option options
  # @option options
  # @option options
  # @option options
  # @option options
  # @option options
  # @option options
  # @param file [String, IO] Path to file or an object that responds to `#read` and `#rewind`.
  # @param options [Hash{Symbol => any}]
  # @return [Prawn::Images::Image] An image handler. All image handlers provided by Prawn are subclasses of
  #   {Prawn::Images::Image}. This object can be used to check the image
  #   dimensions and get other format-specific information.
  # @see Prawn::Images::PNG
  # @see Prawn::Images::JPG
  #
  # source://prawn//lib/prawn/images.rb#56
  def image(file, options = T.unsafe(nil)); end

  private

  # source://prawn//lib/prawn/images.rb#175
  def determine_y_with_page_flow(height); end

  # source://prawn//lib/prawn/images.rb#143
  def image_position(width, height, options); end

  # source://prawn//lib/prawn/images.rb#186
  def image_registry; end

  # source://prawn//lib/prawn/images.rb#190
  def next_image_id; end

  # @return [Boolean]
  #
  # source://prawn//lib/prawn/images.rb#182
  def overruns_page?(height); end

  # @raise [ArgumentError]
  #
  # source://prawn//lib/prawn/images.rb#124
  def verify_and_read_image(io_or_path); end
end

# Base class for image info objects
#
# @abstract
#
# source://prawn//lib/prawn/images/image.rb#9
class Prawn::Images::Image
  # Calculate the final image dimensions from provided options.
  #
  # @private
  #
  # source://prawn//lib/prawn/images/image.rb#14
  def calc_image_dimensions(options); end
end

# A convenience class that wraps the logic for extracting the parts of a JPG
# image that we need to embed them in a PDF.
#
# source://prawn//lib/prawn/images/jpg.rb#10
class Prawn::Images::JPG < ::Prawn::Images::Image
  # Process a new JPG image.
  #
  # @param data [String] A binary string of JPEG data.
  # @return [JPG] a new instance of JPG
  #
  # source://prawn//lib/prawn/images/jpg.rb#58
  def initialize(data); end

  # Sample Precision in bits.
  #
  # @return [Integer]
  #
  # source://prawn//lib/prawn/images/jpg.rb#27
  def bits; end

  # Build a PDF object representing this image in `document`, and return
  # a Reference to it.
  #
  # @param document [Prawn::Document]
  # @return [PDF::Core::Reference]
  #
  # source://prawn//lib/prawn/images/jpg.rb#84
  def build_pdf_object(document); end

  # Number of image components (channels).
  #
  # @return [Integer]
  #
  # source://prawn//lib/prawn/images/jpg.rb#31
  def channels; end

  # Image height in pixels.
  #
  # @return [Integer]
  #
  # source://prawn//lib/prawn/images/jpg.rb#23
  def height; end

  # Scaled height of the image in PDF points.
  #
  # @return [Number]
  #
  # source://prawn//lib/prawn/images/jpg.rb#39
  def scaled_height; end

  # Scaled height of the image in PDF points.
  #
  # @return [Number]
  #
  # source://prawn//lib/prawn/images/jpg.rb#39
  def scaled_height=(_arg0); end

  # Scaled width of the image in PDF points.
  #
  # @return [Number]
  #
  # source://prawn//lib/prawn/images/jpg.rb#35
  def scaled_width; end

  # Scaled width of the image in PDF points.
  #
  # @return [Number]
  #
  # source://prawn//lib/prawn/images/jpg.rb#35
  def scaled_width=(_arg0); end

  # Image width in pixels.
  #
  # @return [Integer]
  #
  # source://prawn//lib/prawn/images/jpg.rb#19
  def width; end

  class << self
    # Can this image handler process this image?
    #
    # @param image_blob [String]
    # @return [Boolean]
    #
    # source://prawn//lib/prawn/images/jpg.rb#51
    def can_render?(image_blob); end
  end
end

# Signals an issue with the image format. The image is probably corrupted
# if you're getting this.
#
# source://prawn//lib/prawn/images/jpg.rb#13
class Prawn::Images::JPG::FormatError < ::StandardError; end

# @private
#
# source://prawn//lib/prawn/images/jpg.rb#42
Prawn::Images::JPG::JPEG_SOF_BLOCKS = T.let(T.unsafe(nil), Array)

# A convenience class that wraps the logic for extracting the parts of a PNG
# image that we need to embed them in a PDF.
#
# source://prawn//lib/prawn/images/png.rb#9
class Prawn::Images::PNG < ::Prawn::Images::Image
  # Process a new PNG image
  #
  # @param data [String] A binary string of PNG data.
  # @return [PNG] a new instance of PNG
  #
  # source://prawn//lib/prawn/images/png.rb#75
  def initialize(data); end

  # Extracted alpha-channel.
  #
  # @return [String, nil]
  #
  # source://prawn//lib/prawn/images/png.rb#54
  def alpha_channel; end

  # Is there an alpha-channel in this image?
  #
  # @return [Boolean]
  #
  # source://prawn//lib/prawn/images/png.rb#165
  def alpha_channel?; end

  # Bits per sample or per palette index.
  #
  # @return [Integer]
  #
  # source://prawn//lib/prawn/images/png.rb#34
  def bits; end

  # Build a PDF object representing this image in `document`, and return
  # a Reference to it.
  #
  # @param document [Prawn::Document]
  # @return [PDF::Core::Reference]
  #
  # source://prawn//lib/prawn/images/png.rb#177
  def build_pdf_object(document); end

  # Color type.
  #
  # @return [Integer]
  #
  # source://prawn//lib/prawn/images/png.rb#38
  def color_type; end

  # Number of color components to each pixel.
  #
  # @return [Integer]
  #
  # source://prawn//lib/prawn/images/png.rb#138
  def colors; end

  # Compression method.
  #
  # @return [Integer]
  #
  # source://prawn//lib/prawn/images/png.rb#42
  def compression_method; end

  # Filter method.
  #
  # @return [Integer]
  #
  # source://prawn//lib/prawn/images/png.rb#46
  def filter_method; end

  # Image height in pixels.
  #
  # @return [Integer]
  #
  # source://prawn//lib/prawn/images/png.rb#30
  def height; end

  # Image data.
  #
  # @return [String]
  #
  # source://prawn//lib/prawn/images/png.rb#18
  def img_data; end

  # Interlace method.
  #
  # @return [Integer]
  #
  # source://prawn//lib/prawn/images/png.rb#50
  def interlace_method; end

  # Returns the minimum PDF version required to support this image.
  #
  # @return [Float]
  #
  # source://prawn//lib/prawn/images/png.rb#299
  def min_pdf_version; end

  # Palette data.
  #
  # @return [String]
  #
  # source://prawn//lib/prawn/images/png.rb#14
  def palette; end

  # Scaled height of the image in PDF points.
  #
  # @return [Number]
  #
  # source://prawn//lib/prawn/images/png.rb#62
  def scaled_height; end

  # Scaled height of the image in PDF points.
  #
  # @return [Number]
  #
  # source://prawn//lib/prawn/images/png.rb#62
  def scaled_height=(_arg0); end

  # Scaled width of the image in PDF points.
  #
  # @return [Number]
  #
  # source://prawn//lib/prawn/images/png.rb#58
  def scaled_width; end

  # Scaled width of the image in PDF points.
  #
  # @return [Number]
  #
  # source://prawn//lib/prawn/images/png.rb#58
  def scaled_width=(_arg0); end

  # Split the alpha channel data from the raw image data in images where
  # it's required.
  #
  # @private
  # @return [void]
  #
  # source://prawn//lib/prawn/images/png.rb#152
  def split_alpha_channel!; end

  # Transparency data.
  #
  # @return [Hash{Symbol => String}]
  #
  # source://prawn//lib/prawn/images/png.rb#22
  def transparency; end

  # Image width in pixels.
  #
  # @return [Integer]
  #
  # source://prawn//lib/prawn/images/png.rb#26
  def width; end

  private

  # source://prawn//lib/prawn/images/png.rb#349
  def generate_alpha_channel; end

  # source://prawn//lib/prawn/images/png.rb#313
  def split_image_data; end

  class << self
    # Can this image handler process this image?
    #
    # @param image_blob [String]
    # @return [Boolean]
    #
    # source://prawn//lib/prawn/images/png.rb#68
    def can_render?(image_blob); end
  end
end

# Distance unit conversions between metric, imperial, and PDF.
#
# source://prawn//lib/prawn/measurements.rb#8
module Prawn::Measurements
  # Convert centimeter to millimeters.
  #
  # @param cm [Number]
  # @return [Number]
  #
  # source://prawn//lib/prawn/measurements.rb#15
  def cm2mm(cm); end

  # Convert centimeters to points.
  #
  # @param cm [Number]
  # @return [Number]
  #
  # source://prawn//lib/prawn/measurements.rb#100
  def cm2pt(cm); end

  # Convert decimeters to millimeters.
  #
  # @param dm [Number]
  # @return [Number]
  #
  # source://prawn//lib/prawn/measurements.rb#23
  def dm2mm(dm); end

  # Convert decimeters to points.
  #
  # @param dm [Number]
  # @return [Number]
  #
  # source://prawn//lib/prawn/measurements.rb#108
  def dm2pt(dm); end

  # Convert feet to inches.
  #
  # @param ft [Number]
  # @return [Number]
  #
  # source://prawn//lib/prawn/measurements.rb#42
  def ft2in(ft); end

  # Convert feet to points.
  #
  # @param ft [Number]
  # @return [Number]
  #
  # source://prawn//lib/prawn/measurements.rb#76
  def ft2pt(ft); end

  # Convert inches to points.
  #
  # @param inch [Number]
  # @return [Number]
  #
  # source://prawn//lib/prawn/measurements.rb#68
  def in2pt(inch); end

  # Convert meters to millimeters.
  #
  # @param m [Number]
  # @return [Number]
  #
  # source://prawn//lib/prawn/measurements.rb#31
  def m2mm(m); end

  # Convert meters to points.
  #
  # @param m [Number]
  # @return [Number]
  #
  # source://prawn//lib/prawn/measurements.rb#116
  def m2pt(m); end

  # Convert millimeters to points.
  #
  # @param mm [Number]
  # @return [Number]
  #
  # source://prawn//lib/prawn/measurements.rb#92
  def mm2pt(mm); end

  # Convert points to millimeters.
  #
  # @param pt [Number]
  # @return [Number]
  #
  # source://prawn//lib/prawn/measurements.rb#124
  def pt2mm(pt); end

  # Convert points to points. For completeness.
  #
  # @param pt [Number]
  # @return [Number]
  #
  # source://prawn//lib/prawn/measurements.rb#60
  def pt2pt(pt); end

  # Convert yards to inches.
  #
  # @param yd [Number]
  # @return [Number]
  #
  # source://prawn//lib/prawn/measurements.rb#50
  def yd2in(yd); end

  # Convert yards to points.
  #
  # @param yd [Number]
  # @return [Number]
  #
  # source://prawn//lib/prawn/measurements.rb#84
  def yd2pt(yd); end
end

# The Outline class organizes the outline tree items for the document. Note
# that the {prev} and {parent} are adjusted while navigating through the
# nested blocks. These attributes along with the presence or absence of blocks
# are the primary means by which the relations for the various
# `PDF::Core::OutlineItem`s and the `PDF::Core::OutlineRoot` are set.
#
# Some ideas for the organization of this class were gleaned from `name_tree`.
# In particular the way in which the `PDF::Core::OutlineItem`s are finally
# rendered into document objects through a hash.
#
# source://prawn//lib/prawn/outline.rb#26
class Prawn::Outline
  # @param document [Prawn::Document]
  # @return [Outline] a new instance of Outline
  #
  # source://prawn//lib/prawn/outline.rb#31
  def initialize(document); end

  # Inserts an outline section to the outline tree (see {define}).
  #
  # Although you will probably choose to exclusively use {define} so that your
  # outline tree is contained and easy to manage, this method gives you the
  # option to insert sections to the outline tree at any point during document
  # generation. This method allows you to add a child subsection to any other
  # item at any level in the outline tree. Currently the only way to locate
  # the place of entry is with the title for the item. If your title names are
  # not unique consider using {define}.
  #
  # Consider using this method instead of {update} if you want to have the
  # outline object to be scoped as self (see {insert_section_after} example).
  #
  # ```ruby
  # go_to_page 2
  # start_new_page
  # text "Inserted Page"
  # outline.add_subsection_to title: 'Page 2', :first do
  #   outline.page destination: page_number, title: "Inserted Page"
  # end
  # ```
  #
  # @param title [String] An outline title to add the subsection to.
  # @param position [:first, :last] (:last)
  #   Where the subsection will be placed relative to other child elements. If
  #   you need to position your subsection in between other elements then
  #   consider using {insert_section_after}.
  # @return [void]
  # @yield Uses the same DSL syntax as {define}
  #
  # source://prawn//lib/prawn/outline.rb#115
  def add_subsection_to(title, position = T.unsafe(nil), &block); end

  # Defines/Updates an outline for the document.
  #
  # The outline is an optional nested index that appears on the side of a PDF
  # document usually with direct links to pages. The outline DSL is defined by
  # nested blocks involving two methods: {section} and {page}. Note that one
  # can also use {update} to add more sections to the end of the outline tree
  # using the same syntax and scope.
  #
  # The syntax is best illustrated with an example:
  #
  # ```ruby
  # Prawn::Document.generate('outlined_document.pdf') do
  #   text "Page 1. This is the first Chapter. "
  #   start_new_page
  #   text "Page 2. More in the first Chapter. "
  #   start_new_page
  #   outline.define do
  #     section 'Chapter 1', destination: 1, closed: true do
  #       page destination: 1, title: 'Page 1'
  #       page destination: 2, title: 'Page 2'
  #     end
  #   end
  #   start_new_page do
  #   outline.update do
  #     section 'Chapter 2', destination: 2, do
  #       page destination: 3, title: 'Page 3'
  #     end
  #   end
  # end
  # ```
  #
  # @return [void]
  # @yield
  #
  # source://prawn//lib/prawn/outline.rb#80
  def define(&block); end

  # @private
  #
  # source://prawn//lib/prawn/outline.rb#28
  def document; end

  # @private
  #
  # source://prawn//lib/prawn/outline.rb#28
  def document=(_arg0); end

  # Inserts an outline section to the outline tree (see {define}).
  #
  # Although you will probably choose to exclusively use {define} so that your
  # outline tree is contained and easy to manage, this method gives you the
  # option to insert sections to the outline tree at any point during document
  # generation. Unlike {add_subsection_to}, this method allows you to enter
  # a section after any other item at any level in the outline tree.
  # Currently the only way to locate the place of entry is with the title for
  # the item. If your title names are not unique consider using
  # {define}.
  #
  # @example
  #   go_to_page 2
  #   start_new_page
  #   text "Inserted Page"
  #   update_outline do
  #   insert_section_after :title => 'Page 2' do
  #   page :destination => page_number, :title => "Inserted Page"
  #   end
  #   end
  # @param title [String] The title of other section or page to insert new section after.
  # @return [void]
  # @yield Uses the same DSL syntax as {define}.
  #
  # source://prawn//lib/prawn/outline.rb#151
  def insert_section_after(title, &block); end

  # @private
  #
  # source://prawn//lib/prawn/outline.rb#28
  def items; end

  # @private
  #
  # source://prawn//lib/prawn/outline.rb#28
  def items=(_arg0); end

  # Adds a page to the outline.
  #
  # Although you will probably choose to exclusively use {define} so that your
  # outline tree is contained and easy to manage, this method also gives you
  # the option to add pages to the root of outline tree at any point during
  # document generation. Note that the page will be added at the top level
  # after the other root outline elements. For more flexible placement try
  # using {insert_section_after} and/or {add_subsection_to}.
  #
  # @example
  #   outline.page title: "Very Last Page"
  # @note This method is almost identical to {section} except that it does not
  #   accept a block thereby defining the outline item as a leaf on the
  #   outline tree structure.
  # @option options
  # @option options
  # @option options
  # @param options [Hash{Symbol => any}]
  # @return [void]
  #
  # source://prawn//lib/prawn/outline.rb#219
  def page(options = T.unsafe(nil)); end

  # Returns the current page number of the document.
  #
  # @return [Integer]
  #
  # source://prawn//lib/prawn/outline.rb#43
  def page_number; end

  # @private
  #
  # source://prawn//lib/prawn/outline.rb#28
  def parent; end

  # @private
  #
  # source://prawn//lib/prawn/outline.rb#28
  def parent=(_arg0); end

  # @private
  #
  # source://prawn//lib/prawn/outline.rb#28
  def prev; end

  # @private
  #
  # source://prawn//lib/prawn/outline.rb#28
  def prev=(_arg0); end

  # Adds an outline section to the outline tree.
  #
  # Although you will probably choose to exclusively use {define} so that your
  # outline tree is contained and easy to manage, this method gives you the
  # option to add sections to the outline tree at any point during document
  # generation. When not being called from within another {section} block the
  # section will be added at the top level after the other root elements of
  # the outline. For more flexible placement try using {insert_section_after}
  # and/or {add_subsection_to}.
  #
  # @example
  #   outline.section 'Added Section', destination: 3 do
  #   outline.page destionation: 3, title: 'Page 3'
  #   end
  # @option options
  # @option options
  # @param title [String] The outline text that appears for the section.
  # @param options [Hash{Symbol => any}]
  # @return [void]
  # @yield More nested subsections and/or page blocks.
  #
  # source://prawn//lib/prawn/outline.rb#188
  def section(title, options = T.unsafe(nil), &block); end

  # Defines/Updates an outline for the document.
  #
  # The outline is an optional nested index that appears on the side of a PDF
  # document usually with direct links to pages. The outline DSL is defined by
  # nested blocks involving two methods: {section} and {page}. Note that one
  # can also use {update} to add more sections to the end of the outline tree
  # using the same syntax and scope.
  #
  # The syntax is best illustrated with an example:
  #
  # ```ruby
  # Prawn::Document.generate('outlined_document.pdf') do
  #   text "Page 1. This is the first Chapter. "
  #   start_new_page
  #   text "Page 2. More in the first Chapter. "
  #   start_new_page
  #   outline.define do
  #     section 'Chapter 1', destination: 1, closed: true do
  #       page destination: 1, title: 'Page 1'
  #       page destination: 2, title: 'Page 2'
  #     end
  #   end
  #   start_new_page do
  #   outline.update do
  #     section 'Chapter 2', destination: 2, do
  #       page destination: 3, title: 'Page 3'
  #     end
  #   end
  # end
  # ```
  #
  # @return [void]
  # @yield
  #
  # source://prawn//lib/prawn/outline.rb#80
  def update(&block); end

  private

  # source://prawn//lib/prawn/outline.rb#239
  def add_outline_item(title, options, &block); end

  # source://prawn//lib/prawn/outline.rb#303
  def adjust_relations(nxt, last); end

  # source://prawn//lib/prawn/outline.rb#248
  def create_outline_item(title, options); end

  # source://prawn//lib/prawn/outline.rb#263
  def establish_relations(outline_item); end

  # source://prawn//lib/prawn/outline.rb#269
  def increase_count; end

  # source://prawn//lib/prawn/outline.rb#294
  def insert_section(nxt, &block); end

  # source://prawn//lib/prawn/outline.rb#287
  def reset_parent(outline_item); end

  # source://prawn//lib/prawn/outline.rb#311
  def reset_root_positioning; end

  # The Outline dictionary (12.3.3) for this document.  It is
  # lazily initialized, so that documents that do not have an outline
  # do not incur the additional overhead.
  #
  # source://prawn//lib/prawn/outline.rb#234
  def root; end

  # source://prawn//lib/prawn/outline.rb#282
  def set_variables_for_block(outline_item, block); end
end

# Repeater object.
#
# @private
#
# source://prawn//lib/prawn/repeater.rb#88
class Prawn::Repeater
  # @return [Repeater] a new instance of Repeater
  #
  # source://prawn//lib/prawn/repeater.rb#105
  def initialize(document, page_filter, dynamic = T.unsafe(nil), &block); end

  # Should this repeater run on this page?
  #
  # @param page_number [Integer]
  # @return [Boolean]
  #
  # source://prawn//lib/prawn/repeater.rb#121
  def match?(page_number); end

  # Returns the value of attribute name.
  #
  # source://prawn//lib/prawn/repeater.rb#103
  def name; end

  # Run repeater.
  #
  # @param page_number [Integer]
  # @return [void]
  #
  # source://prawn//lib/prawn/repeater.rb#129
  def run(page_number); end

  class << self
    # Repeater counter.
    #
    # It's not an exact number of repeaters but a counter used to generate
    # unique repeater stamp names.
    #
    # @return [Integer]
    #
    # source://prawn//lib/prawn/repeater.rb#98
    def count; end

    # Sets the attribute count
    #
    # @param value the value to set the attribute count to.
    #
    # source://prawn//lib/prawn/repeater.rb#90
    def count=(_arg0); end
  end
end

# This module is used to create arbitrary transparency in document. Using
# a soft mask allows creating more visually rich documents.
#
# source://prawn//lib/prawn/soft_mask.rb#6
module Prawn::SoftMask
  # Apply soft mask.
  #
  # You must group soft mask and graphics it's applied to under
  # `save_graphics_state` because soft mask is a part of graphic state in PDF.
  #
  # Note that soft mask is applied only to the following content in the
  # graphic state. Anything that comes before `soft_mask` is drawn without
  # mask.
  #
  # Conceptually, soft mask is an alpha channel. Luminosity of the drawing in
  # the soft mask defines the transparency of the drawing the mask is applied
  # to. 0.0 mask luminosity ("black") results in a fully opaque target image and
  # 1.0 mask luminosity ("white") results in a fully transparent target image.
  # Grey values result in some semi-transparent target image.
  #
  # Note: you can use color in mask drawings but it makes harder to reason
  # about the resulting value of alpha channel as it requires an additional
  # luminosity calculation. However, this also allows achieving some advanced
  # artistic effects (e.g. full-color photos in masks to get an effect similar
  # to double exposure).
  #
  # @example
  #   pdf.save_graphics_state do
  #   pdf.soft_mask do
  #   pdf.fill_color "444444"
  #   pdf.fill_polygon [0, 40], [60, 10], [120, 40], [60, 68]
  #   end
  #   pdf.fill_color '000000'
  #   pdf.fill_rectangle [0, 50], 120, 68
  #   end
  # @return [void]
  # @yield Mask content.
  #
  # source://prawn//lib/prawn/soft_mask.rb#42
  def soft_mask(&block); end

  private

  # source://prawn//lib/prawn/soft_mask.rb#101
  def soft_mask_registry; end
end

# This module is used to create content that will be included multiple times
# in a document. Using a stamp has three advantages over creating content anew
# each time it is placed on the page:
# * Faster document creation.
# * Smaller final document.
# * Faster display on subsequent displays of the repeated element because the
#   viewer application can cache the rendered results.
#
# @example
#   pdf.create_stamp("my_stamp") {
#   pdf.fill_circle([10, 15], 5)
#   pdf.draw_text("hello world", at: [20, 10])
#   }
#   pdf.stamp("my_stamp")
#
# source://prawn//lib/prawn/stamp.rb#18
module Prawn::Stamp
  # Creates a re-usable stamp.
  #
  # @example
  #   pdf.create_stamp("my_stamp") {
  #   pdf.fill_circle([10, 15], 5)
  #   pdf.draw_text("hello world", at: [20, 10])
  #   }
  # @param name [String] Stamp name.
  # @raise [Prawn::Errors::NameTaken] if a stamp already exists in this document with this name.
  # @raise [Prawn::Errors::InvalidName] if name is empty.
  # @return [void]
  # @yield Stamp content.
  #
  # source://prawn//lib/prawn/stamp.rb#74
  def create_stamp(name, &block); end

  # Renders the stamp.
  #
  # @example
  #   pdf.create_stamp("my_stamp") {
  #   pdf.fill_circle([10, 15], 5)
  #   pdf.text("hello world", at: [20, 10])
  #   }
  #   pdf.stamp("my_stamp")
  # @param name [String]
  # @raise [Prawn::Errors::InvalidName] if name is empty.
  # @raise [Prawn::Errors::UndefinedObjectName] if no stamp has been created
  #   with this name.
  # @return [void]
  #
  # source://prawn//lib/prawn/stamp.rb#35
  def stamp(name); end

  # Renders the stamp at a position offset from the initial coords at which
  # the elements of the stamp was created.
  #
  # @example
  #   pdf.create_stamp("circle") do
  #   pdf.fill_circle([0, 0], 25)
  #   end
  #   # draws a circle at 100, 100
  #   pdf.stamp_at("circle", [100, 100])
  # @param name [String]
  # @param point [Array(Number, Number)]
  # @return [void]
  # @see [stamp] for exceptions that might be raised.
  #
  # source://prawn//lib/prawn/stamp.rb#56
  def stamp_at(name, point); end

  private

  # @raise [Prawn::Errors::InvalidName]
  #
  # source://prawn//lib/prawn/stamp.rb#103
  def create_stamp_dictionary(name); end

  # source://prawn//lib/prawn/stamp.rb#139
  def freeze_stamp_graphics; end

  # source://prawn//lib/prawn/stamp.rb#86
  def next_stamp_dictionary_id; end

  # @raise [Prawn::Errors::InvalidName]
  #
  # source://prawn//lib/prawn/stamp.rb#90
  def stamp_dictionary(name); end

  # source://prawn//lib/prawn/stamp.rb#82
  def stamp_dictionary_registry; end

  # Referencing annotations from a stamp XObject doesn't result
  # in a working link. Instead, the references must be appended
  # to the /Annot dictionary of the object that contains the
  # call to the stamp object.
  #
  # source://prawn//lib/prawn/stamp.rb#132
  def update_annotation_references(annots); end
end

# Throughout the Prawn codebase, repeated calculations which can benefit from
# caching are made.  n some cases, caching and reusing results can not only
# save CPU cycles but also greatly reduce memory requirements But at the same
# time, we don't want to throw away thread safety.
#
# @private
#
# source://prawn//lib/prawn/utilities.rb#9
class Prawn::SynchronizedCache
  # As an optimization, this could access the hash directly on VMs with
  # a global interpreter lock (like MRI).
  #
  # @return [SynchronizedCache] a new instance of SynchronizedCache
  #
  # source://prawn//lib/prawn/utilities.rb#12
  def initialize; end

  # Get cache entry.
  #
  # @param key [any]
  # @return [any]
  #
  # source://prawn//lib/prawn/utilities.rb#21
  def [](key); end

  # Set cache entry.
  #
  # @param key [any]
  # @param value [any]
  # @return [void]
  #
  # source://prawn//lib/prawn/utilities.rb#30
  def []=(key, value); end
end

# PDF text primitives.
#
# source://prawn//lib/prawn/text/formatted/line_wrap.rb#4
module Prawn::Text
  include ::PDF::Core::Text
  include ::Prawn::Text::Formatted

  # Draws text on the page, beginning at the point specified by the `:at`
  # option the string is assumed to be pre-formatted to properly fit the page.
  #
  # ```ruby
  # pdf.draw_text "Hello World", at: [100, 100]
  # pdf.draw_text "Goodbye World", at: [50,50], size: 16
  # ```
  #
  # If your font contains kerning pair data that Prawn can parse, the
  # text will be kerned by default. You can disable kerning by including
  # a `false` `:kerning` option. If you want to disable kerning on an
  # entire document, set `default_kerning = false` for that document
  #
  # #### Text Positioning Details
  #
  # Prawn will position your text by the left-most edge of its baseline, and
  # flow along a single line. (This means that `:align` will not work)
  #
  # #### Rotation
  #
  # Text can be rotated before it is placed on the canvas by specifying the
  # `:rotate` option with a given angle. Rotation occurs counter-clockwise.
  #
  # #### Encoding
  #
  # Note that strings passed to this function should be encoded as UTF-8. If
  # you get unexpected characters appearing in your rendered document, check
  # this.
  #
  # If the current font is a built-in one, although the string must be encoded
  # as UTF-8, only characters that are available in WinAnsi are allowed.
  #
  # If an empty box is rendered to your PDF instead of the character you
  # wanted it usually means the current font doesn't include that character.
  #
  # @option options
  # @option options
  # @option options
  # @option options
  # @option options
  # @param text [String]
  # @param options [Hash{Symbol => any}]
  # @raise [ArgumentError] If `:at` option is omitted or `:align</tt> option is included.
  # @return [void]
  #
  # source://prawn//lib/prawn/text.rb#345
  def draw_text(text, options); end

  # Low level text placement method.
  #
  # All font and size alterations should already be set.
  #
  # @option options
  # @option options
  # @option options
  # @option options
  # @option options
  # @param text [String]
  # @param options [Hash{Symbol => any}]
  # @return [void]
  #
  # source://prawn//lib/prawn/text.rb#375
  def draw_text!(text, options); end

  # Draws formatted text to the page.
  #
  # Formatted text is an array of hashes, where each hash defines text and
  # format information.
  #
  # @example
  #   text([{ :text => "hello" },
  #   { :text => "world",
  #   :size => 24,
  #   :styles => [:bold, :italic] }])
  # @option options
  # @option options
  # @option options
  # @option options
  # @option options
  # @option options
  # @option options
  # @option options
  # @option options
  # @option option
  # @option options
  # @option options
  # @option options
  # @option options
  # @param array [Array<Hash>] array of text fragments. See
  #   {Text::Formatted#formatted_text_box} for more information on the
  #   structure of this array.
  # @param options [Hash{Symbol => any}]
  # @param option [Hash] a customizable set of options
  # @raise [ArgumentError] if `:at` option included
  # @raise [Prawn::Errrors::CannotFit] if not wide enough to print any text
  # @return [void]
  # @see PDF::Core::Text#text_rendering_mode() for a list of valid text rendering modes.
  #
  # source://prawn//lib/prawn/text.rb#263
  def formatted_text(array, options = T.unsafe(nil)); end

  # Gets height of text in PDF points.
  #
  # @example
  #   text_height = height_of("hello\nworld")
  # @note This method takes the same options as {#text}, _except_
  #   `:indent_paragraphs`.
  # @option options
  # @option options
  # @option options
  # @option options
  # @option options
  # @option options
  # @option options
  # @option options
  # @option option
  # @option options
  # @option options
  # @option options
  # @option options
  # @param string [String]
  # @param options [Hash{Symbol => any}]
  # @param option [Hash] a customizable set of options
  # @raise [ArgumentError] if `:at` option included
  # @raise [Prawn::Errrors::CannotFit] if not wide enough to print any text
  # @raise [NotImplementedError] if `:indent_paragraphs` option included.
  # @return [void]
  # @see PDF::Core::Text#text_rendering_mode() for a list of valid text rendering modes.
  # @see height_of_formatted
  #
  # source://prawn//lib/prawn/text.rb#480
  def height_of(string, options = T.unsafe(nil)); end

  # Gets height of formatted text in PDF points.
  #
  # @example
  #   height_of_formatted([{ :text => "hello" },
  #   { :text => "world",
  #   :size => 24,
  #   :styles => [:bold, :italic] }])
  # @note This method takes the same options as {#text}, _except_
  #   `:indent_paragraphs`.
  # @option options
  # @option options
  # @option options
  # @option options
  # @option options
  # @option options
  # @option options
  # @option options
  # @option option
  # @option options
  # @option options
  # @option options
  # @option options
  # @param array [Array<Hash>] text fragments.
  # @param options [Hash{Symbol => any}]
  # @param option [Hash] a customizable set of options
  # @raise [ArgumentError] if `:at` option included
  # @raise [Prawn::Errrors::CannotFit] if not wide enough to print any text
  # @raise [NotImplementedError] if `:indent_paragraphs` option included.
  # @return [void]
  # @see PDF::Core::Text#text_rendering_mode() for a list of valid text rendering modes.
  # @see height_of
  #
  # source://prawn//lib/prawn/text.rb#575
  def height_of_formatted(array, options = T.unsafe(nil)); end

  # Draws text on the page.
  #
  # If you want text to flow onto a new page or between columns, this is the
  # method to use. If, instead, you want to place bounded text outside of the
  # flow of a document (for captions, labels, charts, etc.), use {Text::Box}
  # or its convenience method {text_box}.
  #
  # Prawn attempts to wrap the text to fit within your current bounding box
  # (or `margin_box` if no bounding box is being used).  Text will flow onto
  # the next page when it reaches the bottom of the bounding box. Text wrap in
  # Prawn does not re-flow line breaks, so if you want fully automated text
  # wrapping, be sure to remove newlines before attempting to draw your
  # string.
  #
  # #### Examples
  #
  # ```ruby
  # pdf.text "Will be wrapped when it hits the edge of your bounding box"
  # pdf.text "This will be centered", align: :center
  # pdf.text "This will be right aligned", align: :right
  # pdf.text "This <i>includes <b>inline</b></i> <font size='24'>formatting</font>", inline_format: true
  # ```
  #
  # If your font contains kerning pair data that Prawn can parse, the text
  # will be kerned by default. You can disable kerning by including a `false`
  # `:kerning` option. If you want to disable kerning on an entire document,
  # set `default_kerning = false` for that document.
  #
  # #### Text Positioning Details
  #
  # The text is positioned at `font.ascender` below the baseline, making it
  # easy to use this method within bounding boxes and spans.
  #
  # #### Encoding
  #
  # Note that strings passed to this function should be encoded as UTF-8. If
  # you get unexpected characters appearing in your rendered document, check
  # this.
  #
  # If the current font is a built-in one, although the string must be encoded
  # as UTF-8, only characters that are available in WinAnsi are allowed.
  #
  # If an empty box is rendered to your PDF instead of the character you
  # wanted it usually means the current font doesn't include that character.
  #
  # @option options
  # @option options
  # @option options
  # @option options
  # @option options
  # @option options
  # @option options
  # @option options
  # @option options
  # @option option
  # @option options
  # @option options
  # @option options
  # @option options
  # @param string [String]
  # @param options [Hash{Symbol => any}]
  # @param option [Hash] a customizable set of options
  # @raise [ArgumentError] if `:at` option included
  # @raise [Prawn::Errrors::CannotFit] if not wide enough to print any text
  # @return [void]
  # @see PDF::Core::Text#text_rendering_mode() for a list of valid text rendering modes.
  #
  # source://prawn//lib/prawn/text.rb#151
  def text(string, options = T.unsafe(nil)); end

  # Draws the requested text into a box.
  #
  # When the text overflows the rectangle, you shrink to fit, or truncate the
  # text. Text boxes are independent of the document y position.
  #
  # #### Encoding
  #
  # Note that strings passed to this function should be encoded as UTF-8. If
  # you get unexpected characters appearing in your rendered document, check
  # this.
  #
  # If the current font is a built-in one, although the string must be encoded
  # as UTF-8, only characters that are available in WinAnsi are allowed.
  #
  # If an empty box is rendered to your PDF instead of the character you
  # wanted it usually means the current font doesn't include that character.
  #
  # @option options
  # @option options
  # @option options
  # @option options
  # @option options
  # @option option
  # @option option
  # @option options
  # @option options
  # @option options
  # @option options
  # @option options
  # @option options
  # @option options
  # @option options
  # @option options
  # @option options
  # @option options
  # @option options
  # @param string [String]
  # @param options [Hash{Symbol => any}]
  # @param option [Hash] a customizable set of options
  # @raise [Prawn::Errors::CannotFit] If not wide enough to print any text.
  # @return [String] Any text that did not print under the current settings.
  #
  # source://prawn//lib/prawn/text/box.rb#83
  def text_box(string, options = T.unsafe(nil)); end

  private

  # source://prawn//lib/prawn/text.rb#603
  def draw_indented_formatted_line(string, options); end

  # source://prawn//lib/prawn/text.rb#594
  def draw_remaining_formatted_text_on_new_pages(remaining_text, options); end

  # source://prawn//lib/prawn/text.rb#616
  def fill_formatted_text_box(text, options); end

  # source://prawn//lib/prawn/text.rb#651
  def inspect_options_for_draw_text(options); end

  # source://prawn//lib/prawn/text.rb#666
  def inspect_options_for_text(options); end

  # source://prawn//lib/prawn/text.rb#635
  def merge_text_box_positioning_options(options); end

  # source://prawn//lib/prawn/text.rb#688
  def move_text_position(amount); end

  # source://prawn//lib/prawn/text.rb#678
  def process_final_gap_option(options); end

  # source://prawn//lib/prawn/text.rb#683
  def process_indent_paragraphs_option(options); end
end

# Text box.
#
# Generally, one would use the {Prawn::Text#text_box} convenience method.
# However, using {Prawn::Text::Box#initialize Box.new} in conjunction with
# `render(dry_run: true)` enables one to do calculations prior to placing
# text on the page, or to determine how much vertical space was consumed by
# the printed text.
#
# source://prawn//lib/prawn/text/box.rb#109
class Prawn::Text::Box < ::Prawn::Text::Formatted::Box
  # @option options
  # @option options
  # @option options
  # @option options
  # @option options
  # @option options
  # @option option
  # @option option
  # @option options
  # @option options
  # @option options
  # @option options
  # @option options
  # @option options
  # @option options
  # @option options
  # @option options
  # @option options
  # @option options
  # @option options
  # @param string [String]
  # @param options [Hash{Symbol => any}]
  # @param option [Hash] a customizable set of options
  # @return [Box] a new instance of Box
  #
  # source://prawn//lib/prawn/text/box.rb#165
  def initialize(string, options = T.unsafe(nil)); end

  # Render text to the document based on the settings defined in
  # constructor.
  #
  # In order to facilitate look-ahead calculations, this method accepts
  # a `dry_run: true` option. If provided, then everything is executed as if
  # rendering, with the exception that nothing is drawn on the page.  Useful
  # for look-ahead computations of height, unprinted text, etc.
  #
  # @option flags
  # @param flags [Hash{Symbol => any}]
  # @raise [Prawn::Text::Formatted::Arranger::BadFontFamily] If no font family is defined for the current font.
  # @raise [Prawn::Errors::CannotFit] If not wide enough to print any text.
  # @return [String] Any text that did not print under the current settings.
  #
  # source://prawn//lib/prawn/text/box.rb#186
  def render(flags = T.unsafe(nil)); end
end

# Fancy pretty text.
#
# source://prawn//lib/prawn/text/formatted/line_wrap.rb#5
module Prawn::Text::Formatted
  # Draws the requested formatted text into a box.
  #
  # When the text overflows the rectangle shrink to fit or truncate the
  # text. Text boxes are independent of the document y position.
  #
  # @example
  #   formatted_text_box([{ :text => "hello" },
  #   { :text => "world",
  #   :size => 24,
  #   :styles => [:bold, :italic] }])
  # @param array [Array<Hash{Symbol => any}>] Formatted text is an array of hashes, where each hash defines text and
  #   format information. The following hash options are supported:
  #
  #   - `:text` --- the text to format according to the other hash options.
  #   - `:styles` --- an array of styles to apply to this text. Available
  #   styles include `:bold`, `:italic`, `:underline`, `:strikethrough`,
  #   `:subscript`, and `:superscript`.
  #   - `:size` ---a number denoting the font size to apply to this text.
  #   - `:character_spacing` --- a number denoting how much to increase or
  #   decrease the default spacing between characters.
  #   - `:font` --- the name of a font. The name must be an AFM font with
  #   the desired faces or must be a font that is already registered using
  #   {Prawn::Document#font_families}.
  #   - `:color` --- anything compatible with
  #   {Prawn::Graphics::Color#fill_color} and
  #   {Prawn::Graphics::Color#stroke_color}.
  #   - :link` --- a URL to which to create a link. A clickable link will be
  #   created to that URL. Note that you must explicitly underline and
  #   color using the appropriate tags if you which to draw attention to
  #   the link.
  #   - `:anchor` --- a destination that has already been or will be
  #   registered using
  #   `PDF::Core::Destinations#add_dest`{:.language-plain}. A clickable
  #   link will be created to that destination. Note that you must
  #   explicitly underline and color using the appropriate tags if you
  #   which to draw attention to the link.
  #   - `:local` --- a file or application to be opened locally. A clickable
  #   link will be created to the provided local file or application. If
  #   the file is another PDF, it will be opened in a new window. Note
  #   that you must explicitly underline and color using the appropriate
  #   options if you which to draw attention to the link.
  #   - `:draw_text_callback` --- if provided, this Proc will be called
  #   instead of {#draw_text!} once per fragment for every low-level
  #   addition of text to the page.
  #   - `:callback` --- an object (or array of such objects) with two
  #   methods: `#render_behind`{:.language-plain} and
  #   `#render_in_front`{:.language-plain}, which are called immediately
  #   prior to and immediately after rendering the text fragment and which
  #   are passed the fragment as an argument.
  # @param options [Hash{Symbol => any}] Accepts the same options as {Text::Box}.
  # @raise [Prawn::Text::Formatted::Arranger::BadFontFamily] If no font family is defined for the current font.
  # @raise [Prawn::Errors::CannotFit] If not wide enough to print any text.
  # @return [Array<Hash>] A formatted text array representing any text that did not print under
  #   the current settings.
  #
  # source://prawn//lib/prawn/text/formatted.rb#73
  def formatted_text_box(array, options = T.unsafe(nil)); end
end

# D data structure for 2-stage processing of lines of formatted text.
#
# @private
#
# source://prawn//lib/prawn/text/formatted/arranger.rb#8
class Prawn::Text::Formatted::Arranger
  # @return [Arranger] a new instance of Arranger
  #
  # source://prawn//lib/prawn/text/formatted/arranger.rb#45
  def initialize(document, options = T.unsafe(nil)); end

  # Apply color and font settings.
  #
  # @param fragment [Prawn::Text::Formatted::Fragment]
  # @return [void]
  # @yield
  #
  # source://prawn//lib/prawn/text/formatted/arranger.rb#191
  def apply_color_and_font_settings(fragment, &block); end

  # Apply font settings.
  #
  # @param fragment [Prawn::Text::Formatted::Fragment]
  # @return [void]
  # @yield
  #
  # source://prawn//lib/prawn/text/formatted/arranger.rb#210
  def apply_font_settings(fragment = T.unsafe(nil), &block); end

  # Returns the value of attribute consumed.
  #
  # source://prawn//lib/prawn/text/formatted/arranger.rb#38
  def consumed; end

  # Sets the attribute consumed
  #
  # @param value the value to set the attribute consumed to.
  #
  # source://prawn//lib/prawn/text/formatted/arranger.rb#38
  def consumed=(_arg0); end

  # Returns the value of attribute current_format_state.
  #
  # source://prawn//lib/prawn/text/formatted/arranger.rb#43
  def current_format_state; end

  # Finish laying out current line.
  #
  # @return [void]
  #
  # source://prawn//lib/prawn/text/formatted/arranger.rb#101
  def finalize_line; end

  # Returns the value of attribute finalized.
  #
  # source://prawn//lib/prawn/text/formatted/arranger.rb#37
  def finalized; end

  # Were all fragments processed?
  #
  # @return [Boolean]
  #
  # source://prawn//lib/prawn/text/formatted/arranger.rb#151
  def finished?; end

  # Get font variant from fragment styles.
  #
  # @param styles [Array<Symbol>]
  # @return [Symbol]
  #
  # source://prawn//lib/prawn/text/formatted/arranger.rb#295
  def font_style(styles); end

  # Set new fragment array.
  #
  # @param array [Array<Hash>]
  # @return [void]
  #
  # source://prawn//lib/prawn/text/formatted/arranger.rb#125
  def format_array=(array); end

  # Returns the value of attribute fragments.
  #
  # source://prawn//lib/prawn/text/formatted/arranger.rb#42
  def fragments; end

  # Prepare for new line layout.
  #
  # @return [void]
  #
  # source://prawn//lib/prawn/text/formatted/arranger.rb#138
  def initialize_line; end

  # Line text.
  #
  # @raise [NotFinalized]
  # @return [String]
  #
  # source://prawn//lib/prawn/text/formatted/arranger.rb#84
  def line; end

  # Line width.
  #
  # @raise [NotFinalized]
  # @return [Number]
  #
  # source://prawn//lib/prawn/text/formatted/arranger.rb#70
  def line_width; end

  # Returns the value of attribute max_ascender.
  #
  # source://prawn//lib/prawn/text/formatted/arranger.rb#36
  def max_ascender; end

  # Returns the value of attribute max_descender.
  #
  # source://prawn//lib/prawn/text/formatted/arranger.rb#35
  def max_descender; end

  # Returns the value of attribute max_line_height.
  #
  # source://prawn//lib/prawn/text/formatted/arranger.rb#34
  def max_line_height; end

  # Get the next unprocessed string.
  #
  # @raise [NotFinalized]
  # @return [String, nil]
  #
  # source://prawn//lib/prawn/text/formatted/arranger.rb#159
  def next_string; end

  # Get the next unprocessed string keeping it in the queue.
  #
  # @return [String, nil]
  #
  # source://prawn//lib/prawn/text/formatted/arranger.rb#178
  def preview_next_string; end

  # Repack remaining fragments.
  #
  # @return [void]
  #
  # source://prawn//lib/prawn/text/formatted/arranger.rb#280
  def repack_unretrieved; end

  # Get the next fragment.
  #
  # @raise [NotFinalized]
  # @return [Prawn::Text::Formatted::Fragment]
  #
  # source://prawn//lib/prawn/text/formatted/arranger.rb#269
  def retrieve_fragment; end

  # Number of spaces in the text.
  #
  # @raise [NotFinalized]
  # @return [Integer]
  #
  # source://prawn//lib/prawn/text/formatted/arranger.rb#56
  def space_count; end

  # The following present only for testing purposes
  #
  # source://prawn//lib/prawn/text/formatted/arranger.rb#41
  def unconsumed; end

  # Update last fragment's text.
  #
  # @param printed [String]
  # @param unprinted [String]
  # @param normalized_soft_hyphen [Boolean]
  # @return [void]
  #
  # source://prawn//lib/prawn/text/formatted/arranger.rb#246
  def update_last_string(printed, unprinted, normalized_soft_hyphen = T.unsafe(nil)); end

  private

  # source://prawn//lib/prawn/text/formatted/arranger.rb#320
  def apply_font_size(size, styles, &block); end

  # source://prawn//lib/prawn/text/formatted/arranger.rb#367
  def fragment_measurements=(fragment); end

  # source://prawn//lib/prawn/text/formatted/arranger.rb#379
  def line_measurement_maximums=(fragment); end

  # source://prawn//lib/prawn/text/formatted/arranger.rb#310
  def load_previous_format_state; end

  # source://prawn//lib/prawn/text/formatted/arranger.rb#351
  def omit_trailing_whitespace_from_line_width; end

  # @return [Boolean]
  #
  # source://prawn//lib/prawn/text/formatted/arranger.rb#337
  def subscript?(styles); end

  # @return [Boolean]
  #
  # source://prawn//lib/prawn/text/formatted/arranger.rb#344
  def superscript?(styles); end
end

# You're getting this because a font doesn't have a family name.
#
# source://prawn//lib/prawn/text/formatted/arranger.rb#28
class Prawn::Text::Formatted::Arranger::BadFontFamily < ::StandardError
  # @return [BadFontFamily] a new instance of BadFontFamily
  #
  # source://prawn//lib/prawn/text/formatted/arranger.rb#29
  def initialize(message = T.unsafe(nil)); end
end

# You're getting this because you're trying to get some information from
# the arranger before it finished processing text.
#
# source://prawn//lib/prawn/text/formatted/arranger.rb#11
class Prawn::Text::Formatted::Arranger::NotFinalized < ::StandardError
  # @return [NotFinalized] a new instance of NotFinalized
  #
  # source://prawn//lib/prawn/text/formatted/arranger.rb#18
  def initialize(message = T.unsafe(nil), method: T.unsafe(nil)); end
end

# @private
#
# source://prawn//lib/prawn/text/formatted/arranger.rb#13
Prawn::Text::Formatted::Arranger::NotFinalized::DEFAULT_MESSAGE = T.let(T.unsafe(nil), String)

# @private
#
# source://prawn//lib/prawn/text/formatted/arranger.rb#16
Prawn::Text::Formatted::Arranger::NotFinalized::MESSAGE_WITH_METHOD = T.let(T.unsafe(nil), String)

# Formatted text box.
#
# Generally, one would use the {Prawn::Text::Formatted#formatted_text_box}
# convenience method. However, using `Text::Formatted::Box.new` in
# conjunction with `#render(dry_run: true)` enables one to do calculations
# prior to placing text on the page, or to determine how much vertical
# space was consumed by the printed text
#
# source://prawn//lib/prawn/text/formatted/box.rb#20
class Prawn::Text::Formatted::Box
  include ::Prawn::Text::Formatted::Wrap

  # See Prawn::Text#text_box for valid options
  #
  # @option options
  # @option options
  # @option options
  # @option options
  # @option options
  # @option options
  # @option option
  # @option option
  # @option options
  # @option options
  # @option options
  # @option options
  # @option options
  # @option options
  # @option options
  # @option options
  # @option options
  # @option options
  # @option options
  # @option options
  # @param formatted_text [Array<Hash{Symbol => any}>] Formatted text is an array of hashes, where each hash defines text
  #   and format information. The following hash options are supported:
  #
  #   - `:text` --- the text to format according to the other hash
  #   options.
  #   - `:styles` --- an array of styles to apply to this text. Available
  #   styles include `:bold`, `:italic`, `:underline`, `:strikethrough`,
  #   `:subscript`, and `:superscript`.
  #   - `:size` ---a number denoting the font size to apply to this text.
  #   - `:character_spacing` --- a number denoting how much to increase or
  #   decrease the default spacing between characters.
  #   - `:font` --- the name of a font. The name must be an AFM font with
  #   the desired faces or must be a font that is already registered
  #   using {Prawn::Document#font_families}.
  #   - `:color` --- anything compatible with
  #   {Prawn::Graphics::Color#fill_color} and
  #   {Prawn::Graphics::Color#stroke_color}.
  #   - :link` --- a URL to which to create a link. A clickable link will
  #   be created to that URL. Note that you must explicitly underline
  #   and color using the appropriate tags if you which to draw
  #   attention to the link.
  #   - `:anchor` --- a destination that has already been or will be
  #   registered using `PDF::Core::Destinations#add_dest`. A clickable
  #   link will be created to that destination. Note that you must
  #   explicitly underline and color using the appropriate tags if you
  #   which to draw attention to the link.
  #   - `:local` --- a file or application to be opened locally.
  #   A clickable link will be created to the provided local file or
  #   application. If the file is another PDF, it will be opened in
  #   a new window. Note that you must explicitly underline and color
  #   using the appropriate options if you which to draw attention to
  #   the link.
  #   - `:draw_text_callback` --- if provided, this Proc will be called
  #   instead of {Prawn::Document#draw_text!} once per fragment for
  #   every low-level addition of text to the page.
  #   - `:callback` --- an object (or array of such objects) with two
  #   methods: `render_behind` and `render_in_front`, which are called
  #   immediately prior to and immediately after rendering the text
  #   fragment and which are passed the fragment as an argument.
  # @param options [Hash{Symbol => any}]
  # @param option [Hash] a customizable set of options
  # @return [Box] a new instance of Box
  #
  # source://prawn//lib/prawn/text/formatted/box.rb#173
  def initialize(formatted_text, options = T.unsafe(nil)); end

  # The height of the ascender of the last line printed.
  #
  # @return [Number]
  #
  # source://prawn//lib/prawn/text/formatted/box.rb#56
  def ascender; end

  # The upper left corner of the text box.
  #
  # @return [Array(Number, Number)]
  #
  # source://prawn//lib/prawn/text/formatted/box.rb#48
  def at; end

  # The width available at this point in the box.
  #
  # @return [Number]
  #
  # source://prawn//lib/prawn/text/formatted/box.rb#285
  def available_width; end

  # The height of the descender of the last line printed.
  #
  # @return [Number]
  #
  # source://prawn//lib/prawn/text/formatted/box.rb#60
  def descender; end

  # @param fragment [Prawn::Text::Formatted::Fragment]
  # @param accumulated_width [Number]
  # @param line_width [Number]
  # @param word_spacing [Number]
  # @private
  # @return [void]
  #
  # source://prawn//lib/prawn/text/formatted/box.rb#304
  def draw_fragment(fragment, accumulated_width = T.unsafe(nil), line_width = T.unsafe(nil), word_spacing = T.unsafe(nil)); end

  # True if everything printed (or, if `:dry_run` was used, everything
  # would have been successfully printed).
  #
  # @return [Boolean]
  #
  # source://prawn//lib/prawn/text/formatted/box.rb#42
  def everything_printed?; end

  # The height actually used during the previous {render}.
  #
  # @return [Number]
  #
  # source://prawn//lib/prawn/text/formatted/box.rb#292
  def height; end

  # The leading used during printing.
  #
  # @return [Number]
  #
  # source://prawn//lib/prawn/text/formatted/box.rb#64
  def leading; end

  # Gap between adjacent lines of text.
  #
  # @return [Number]
  #
  # source://prawn//lib/prawn/text/formatted/box.rb#69
  def line_gap; end

  # The line height of the last line printed.
  #
  # @return [Number]
  #
  # source://prawn//lib/prawn/text/formatted/box.rb#52
  def line_height; end

  # True if nothing printed (or, if `:dry_run` was used, nothing would
  # have been successfully printed).
  #
  # @return [Boolean]
  #
  # source://prawn//lib/prawn/text/formatted/box.rb#34
  def nothing_printed?; end

  # Render text to the document based on the settings defined in
  # constructor.
  #
  # In order to facilitate look-ahead calculations, this method accepts
  # a `dry_run: true` option. If provided, then everything is executed as
  # if rendering, with the exception that nothing is drawn on the page.
  # Useful for look-ahead computations of height, unprinted text, etc.
  #
  # @option flags
  # @param flags [Hash{Symbol => any}]
  # @raise [Prawn::Text::Formatted::Arranger::BadFontFamily] If no font family is defined for the current font.
  # @raise [Prawn::Errors::CannotFit] If not wide enough to print any text.
  # @return [Array<Hash>] A formatted text array representing any text that did not print
  #   under the current settings.
  #
  # source://prawn//lib/prawn/text/formatted/box.rb#251
  def render(flags = T.unsafe(nil)); end

  # The text that was successfully printed (or, if `:dry_run` was
  # used, the text that would have been successfully printed).
  #
  # @return [Array<Hash>]
  #
  # source://prawn//lib/prawn/text/formatted/box.rb#28
  def text; end

  # @private
  #
  # source://prawn//lib/prawn/text/formatted/box.rb#402
  def valid_options; end

  private

  # source://prawn//lib/prawn/text/formatted/box.rb#468
  def analyze_glyphs_for_fallback_font_support(hash); end

  # Returns the default height to be used if none is provided or if the
  # overflow option is set to :expand. If we are in a stretchy bounding
  # box, assume we can stretch to the bottom of the innermost non-stretchy
  # box.
  #
  # source://prawn//lib/prawn/text/formatted/box.rb#561
  def default_height; end

  # source://prawn//lib/prawn/text/formatted/box.rb#686
  def draw_fragment_overlay_anchor(fragment); end

  # source://prawn//lib/prawn/text/formatted/box.rb#671
  def draw_fragment_overlay_link(fragment); end

  # source://prawn//lib/prawn/text/formatted/box.rb#697
  def draw_fragment_overlay_local(fragment); end

  # source://prawn//lib/prawn/text/formatted/box.rb#713
  def draw_fragment_overlay_styles(fragment); end

  # source://prawn//lib/prawn/text/formatted/box.rb#661
  def draw_fragment_overlays(fragment); end

  # source://prawn//lib/prawn/text/formatted/box.rb#655
  def draw_fragment_underlays(fragment); end

  # source://prawn//lib/prawn/text/formatted/box.rb#519
  def find_font_for_this_glyph(char, current_font, fallback_fonts, current_font_options = T.unsafe(nil)); end

  # source://prawn//lib/prawn/text/formatted/box.rb#505
  def font_style(styles); end

  # source://prawn//lib/prawn/text/formatted/box.rb#528
  def form_fragments_from_like_font_glyph_pairs(font_glyph_pairs, hash); end

  # source://prawn//lib/prawn/text/formatted/box.rb#548
  def move_baseline_down; end

  # source://prawn//lib/prawn/text/formatted/box.rb#437
  def normalize_encoding; end

  # source://prawn//lib/prawn/text/formatted/box.rb#421
  def normalized_text(flags); end

  # source://prawn//lib/prawn/text/formatted/box.rb#429
  def original_text; end

  # source://prawn//lib/prawn/text/formatted/box.rb#433
  def original_text=(formatted_text); end

  # source://prawn//lib/prawn/text/formatted/box.rb#457
  def process_fallback_fonts(formatted_text); end

  # source://prawn//lib/prawn/text/formatted/box.rb#620
  def process_options; end

  # source://prawn//lib/prawn/text/formatted/box.rb#569
  def process_vertical_alignment(text); end

  # source://prawn//lib/prawn/text/formatted/box.rb#628
  def render_rotated(text); end

  # Decrease the font size until the text fits or the min font
  # size is reached
  #
  # source://prawn//lib/prawn/text/formatted/box.rb#600
  def shrink_to_fit(text); end

  class << self
    # Text box extensions.
    #
    # Example:
    #
    # ```ruby
    # module MyWrap
    #   def wrap(array)
    #     initialize_wrap([{ text: 'all your base are belong to us' }])
    #     @line_wrap.wrap_line(
    #       document: @document,
    #       kerning: @kerning,
    #       width: 10000,
    #       arranger: @arranger
    #     )
    #     fragment = @arranger.retrieve_fragment
    #     format_and_draw_fragment(fragment, 0, @line_wrap.width, 0)
    #     []
    #   end
    # end
    #
    # Prawn::Text::Formatted::Box.extensions << MyWrap
    #
    # box = Prawn::Text::Formatted::Box.new('hello world')
    # box.render("why can't I print anything other than" +
    #            '"all your base are belong to us"?')
    # ```
    #
    # See {Prawn::Text::Formatted::Wrap} for what is required of the
    # wrap method if you want to override the default wrapping algorithm.
    #
    # @return [Array<Module>]
    #
    # source://prawn//lib/prawn/text/formatted/box.rb#391
    def extensions; end

    # @private
    # @private
    #
    # source://prawn//lib/prawn/text/formatted/box.rb#396
    def inherited(base); end
  end
end

# Prawn::Text::Formatted::Fragment is a state store for a formatted text
# fragment. It does not render anything.
#
# @private
#
# source://prawn//lib/prawn/text/formatted/fragment.rb#10
class Prawn::Text::Formatted::Fragment
  # @param text [String]
  # @param format_state [Hash{Symbol => any}]
  # @param document [Prawn::Documnt]
  # @return [Fragment] a new instance of Fragment
  #
  # source://prawn//lib/prawn/text/formatted/fragment.rb#24
  def initialize(text, format_state, document); end

  # Absolute vertical coordinate of the bottom side of the fragment.
  #
  # @return [Number]
  #
  # source://prawn//lib/prawn/text/formatted/fragment.rb#289
  def absolute_bottom; end

  # Absolute coordinates of the bottom left corner of the fragment.
  #
  # @return [Array(Number, Number)]
  #
  # source://prawn//lib/prawn/text/formatted/fragment.rb#310
  def absolute_bottom_left; end

  # Absolute coordinates of the bottom right corner of the fragment.
  #
  # @return [Array(Number, Number)]
  #
  # source://prawn//lib/prawn/text/formatted/fragment.rb#317
  def absolute_bottom_right; end

  # Fragment bounding box, relative to the containing page.
  #
  # @return [Array(Number, Number, Number, Number)]
  #
  # source://prawn//lib/prawn/text/formatted/fragment.rb#87
  def absolute_bounding_box; end

  # Absolute horizontal coordinate of the left side of the fragment.
  #
  # @return [Number]
  #
  # source://prawn//lib/prawn/text/formatted/fragment.rb#268
  def absolute_left; end

  # Absolute horizontal coordinate of the right side of the fragment.
  #
  # @return [Number]
  #
  # source://prawn//lib/prawn/text/formatted/fragment.rb#275
  def absolute_right; end

  # Absolute vertical coordinate of the top side of the fragment.
  #
  # @return [Number]
  #
  # source://prawn//lib/prawn/text/formatted/fragment.rb#282
  def absolute_top; end

  # Absolute coordinates of the top left corner of the fragment.
  #
  # @return [Array(Number, Number)]
  #
  # source://prawn//lib/prawn/text/formatted/fragment.rb#296
  def absolute_top_left; end

  # Absolute coordinates of the top right corner of the fragment.
  #
  # @return [Array(Number, Number)]
  #
  # source://prawn//lib/prawn/text/formatted/fragment.rb#303
  def absolute_top_right; end

  # Anchor.
  #
  # @return [PDF::Core::Reference, Array, Hash]
  #
  # source://prawn//lib/prawn/text/formatted/fragment.rb#129
  def anchor; end

  # Returns the value of attribute ascender.
  #
  # source://prawn//lib/prawn/text/formatted/fragment.rb#16
  def ascender; end

  # Sets the attribute ascender
  #
  # @param value the value to set the attribute ascender to.
  #
  # source://prawn//lib/prawn/text/formatted/fragment.rb#16
  def ascender=(_arg0); end

  # Returns the value of attribute baseline.
  #
  # source://prawn//lib/prawn/text/formatted/fragment.rb#19
  def baseline; end

  # Sets the attribute baseline
  #
  # @param value the value to set the attribute baseline to.
  #
  # source://prawn//lib/prawn/text/formatted/fragment.rb#19
  def baseline=(_arg0); end

  # Vertical coordinate of the bottom side of the fragment.
  #
  # @return [Number]
  #
  # source://prawn//lib/prawn/text/formatted/fragment.rb#233
  def bottom; end

  # Coordinates of the bottom left corner of the fragment.
  #
  # @return [Array(Number, Number)]
  #
  # source://prawn//lib/prawn/text/formatted/fragment.rb#261
  def bottom_left; end

  # Coordinates of the bottom right corner of the fragment.
  #
  # @return [Array(Number, Number)]
  #
  # source://prawn//lib/prawn/text/formatted/fragment.rb#254
  def bottom_right; end

  # Fragment bounding box, relative to the containing bounding box.
  #
  # @return [Array(Number, Number, Number, Number)]
  #
  # source://prawn//lib/prawn/text/formatted/fragment.rb#80
  def bounding_box; end

  # Callbacks.
  #
  # @return [Array]
  #
  # source://prawn//lib/prawn/text/formatted/fragment.rb#205
  def callback_objects; end

  # Character spacing.
  #
  # @return [Number]
  #
  # source://prawn//lib/prawn/text/formatted/fragment.rb#164
  def character_spacing; end

  # Fragment color.
  #
  # @return [Color]
  #
  # source://prawn//lib/prawn/text/formatted/fragment.rb#143
  def color; end

  # Set default text direction.
  #
  # @param direction [:ltr, :rtl]
  # @return [void]
  #
  # source://prawn//lib/prawn/text/formatted/fragment.rb#180
  def default_direction=(direction); end

  # Returns the value of attribute descender.
  #
  # source://prawn//lib/prawn/text/formatted/fragment.rb#15
  def descender; end

  # Sets the attribute descender
  #
  # @param value the value to set the attribute descender to.
  #
  # source://prawn//lib/prawn/text/formatted/fragment.rb#15
  def descender=(_arg0); end

  # Text direction.
  #
  # @return [:ltr, :rtl]
  #
  # source://prawn//lib/prawn/text/formatted/fragment.rb#172
  def direction; end

  # Fragment font name.
  #
  # @return [String]
  #
  # source://prawn//lib/prawn/text/formatted/fragment.rb#150
  def font; end

  # Returns the value of attribute format_state.
  #
  # source://prawn//lib/prawn/text/formatted/fragment.rb#11
  def format_state; end

  # Height of fragment.
  #
  # @return [Number]
  #
  # source://prawn//lib/prawn/text/formatted/fragment.rb#48
  def height; end

  # Keep trailing spaces.
  #
  # @return [void]
  #
  # source://prawn//lib/prawn/text/formatted/fragment.rb#190
  def include_trailing_white_space!; end

  # Returns the value of attribute left.
  #
  # source://prawn//lib/prawn/text/formatted/fragment.rb#18
  def left; end

  # Sets the attribute left
  #
  # @param value the value to set the attribute left to.
  #
  # source://prawn//lib/prawn/text/formatted/fragment.rb#18
  def left=(_arg0); end

  # Returns the value of attribute line_height.
  #
  # source://prawn//lib/prawn/text/formatted/fragment.rb#14
  def line_height; end

  # Sets the attribute line_height
  #
  # @param value the value to set the attribute line_height to.
  #
  # source://prawn//lib/prawn/text/formatted/fragment.rb#14
  def line_height=(_arg0); end

  # Fragment link.
  #
  # @return [String, nil]
  #
  # source://prawn//lib/prawn/text/formatted/fragment.rb#122
  def link; end

  # Local destination.
  #
  # @return [String]
  #
  # source://prawn//lib/prawn/text/formatted/fragment.rb#136
  def local; end

  # Horizontal coordinate of the right side of the fragment.
  #
  # @return [Number]
  #
  # source://prawn//lib/prawn/text/formatted/fragment.rb#219
  def right; end

  # Font size.
  #
  # @return [Number]
  #
  # source://prawn//lib/prawn/text/formatted/fragment.rb#157
  def size; end

  # Number of spaces in the text.
  #
  # @return [Integer]
  #
  # source://prawn//lib/prawn/text/formatted/fragment.rb#198
  def space_count; end

  # Strikethrough endpoints.
  #
  # @return [Array(Array(Number, Number), Array(Number, Number))]
  #
  # source://prawn//lib/prawn/text/formatted/fragment.rb#107
  def strikethrough_points; end

  # Fragment font styles.
  #
  # @return [Array<Symbol>]
  #
  # source://prawn//lib/prawn/text/formatted/fragment.rb#115
  def styles; end

  # Is this a subscript fragment?
  #
  # @return [Boolean]
  #
  # source://prawn//lib/prawn/text/formatted/fragment.rb#55
  def subscript?; end

  # Is this a superscript fragment?
  #
  # @return [Boolean]
  #
  # source://prawn//lib/prawn/text/formatted/fragment.rb#62
  def superscript?; end

  # Returns the value of attribute text.
  #
  # source://prawn//lib/prawn/text/formatted/fragment.rb#12
  def text; end

  # Vertical coordinate of the top side of the fragment.
  #
  # @return [Number]
  #
  # source://prawn//lib/prawn/text/formatted/fragment.rb#226
  def top; end

  # Coordinates of the top left corner of the fragment.
  #
  # @return [Array(Number, Number)]
  #
  # source://prawn//lib/prawn/text/formatted/fragment.rb#240
  def top_left; end

  # Coordinates of the top right corner of the fragment.
  #
  # @return [Array(Number, Number)]
  #
  # source://prawn//lib/prawn/text/formatted/fragment.rb#247
  def top_right; end

  # Underline endpoints.
  #
  # @return [Array(Array(Number, Number), Array(Number, Number))]
  #
  # source://prawn//lib/prawn/text/formatted/fragment.rb#99
  def underline_points; end

  # Width of fragment.
  #
  # @return [Number]
  #
  # source://prawn//lib/prawn/text/formatted/fragment.rb#38
  def width; end

  # Sets the attribute width
  #
  # @param value the value to set the attribute width to.
  #
  # source://prawn//lib/prawn/text/formatted/fragment.rb#13
  def width=(_arg0); end

  # Returns the value of attribute word_spacing.
  #
  # source://prawn//lib/prawn/text/formatted/fragment.rb#17
  def word_spacing; end

  # Sets the attribute word_spacing
  #
  # @param value the value to set the attribute word_spacing to.
  #
  # source://prawn//lib/prawn/text/formatted/fragment.rb#17
  def word_spacing=(_arg0); end

  # Vertical offset of the fragment.
  #
  # @return [Number]
  #
  # source://prawn//lib/prawn/text/formatted/fragment.rb#69
  def y_offset; end

  private

  # @return [Boolean]
  #
  # source://prawn//lib/prawn/text/formatted/fragment.rb#343
  def exclude_trailing_white_space?; end

  # source://prawn//lib/prawn/text/formatted/fragment.rb#351
  def normalized_soft_hyphen; end

  # source://prawn//lib/prawn/text/formatted/fragment.rb#355
  def process_soft_hyphens(string); end

  # source://prawn//lib/prawn/text/formatted/fragment.rb#323
  def process_text(text); end

  # @return [Boolean]
  #
  # source://prawn//lib/prawn/text/formatted/fragment.rb#347
  def soft_hyphens_need_processing?(string); end

  # source://prawn//lib/prawn/text/formatted/fragment.rb#363
  def strip_zero_width_spaces(string); end
end

# Implements individual line wrapping of formatted text.
#
# @private
#
# source://prawn//lib/prawn/text/formatted/line_wrap.rb#9
class Prawn::Text::Formatted::LineWrap
  # Whether this line is the last line in the paragraph.
  #
  # @return [Boolean]
  #
  # source://prawn//lib/prawn/text/formatted/line_wrap.rb#24
  def paragraph_finished?; end

  # The number of spaces in the last wrapped line.
  #
  # @return [Integer]
  #
  # source://prawn//lib/prawn/text/formatted/line_wrap.rb#19
  def space_count; end

  # Break the fragment into tokens.
  #
  # @param fragment [String]
  # @return [Array<String>]
  #
  # source://prawn//lib/prawn/text/formatted/line_wrap.rb#32
  def tokenize(fragment); end

  # The width of the last wrapped line.
  #
  # @return [Number]
  #
  # source://prawn//lib/prawn/text/formatted/line_wrap.rb#13
  def width; end

  # Work in conjunction with the {Prawn::Text::Formatted::Arranger}
  # defined in the `:arranger` option to determine what formatted text
  # will fit within the width defined by the `:width` option.
  #
  # @option options
  # @option options
  # @option options
  # @option options
  # @option options
  # @param options [Hash{Symbol => any}]
  # @return [String]
  #
  # source://prawn//lib/prawn/text/formatted/line_wrap.rb#47
  def wrap_line(options); end

  private

  # returns true if all text was printed without running into the end of
  # the line
  #
  # source://prawn//lib/prawn/text/formatted/line_wrap.rb#97
  def add_fragment_to_line(fragment); end

  # source://prawn//lib/prawn/text/formatted/line_wrap.rb#320
  def append_char(char); end

  # source://prawn//lib/prawn/text/formatted/line_wrap.rb#86
  def apply_font_settings_and_add_fragment_to_line(fragment); end

  # source://prawn//lib/prawn/text/formatted/line_wrap.rb#187
  def break_chars(encoding = T.unsafe(nil)); end

  # @return [Boolean]
  #
  # source://prawn//lib/prawn/text/formatted/line_wrap.rb#74
  def empty_line?(fragment); end

  # source://prawn//lib/prawn/text/formatted/line_wrap.rb#306
  def end_of_the_line_reached(segment); end

  # @return [Boolean]
  #
  # source://prawn//lib/prawn/text/formatted/line_wrap.rb#70
  def first_fragment_on_this_line?(fragment); end

  # @return [Boolean]
  #
  # source://prawn//lib/prawn/text/formatted/line_wrap.rb#292
  def fragment_begins_with_breakable?(fragment); end

  # source://prawn//lib/prawn/text/formatted/line_wrap.rb#235
  def fragment_finished(fragment); end

  # source://prawn//lib/prawn/text/formatted/line_wrap.rb#206
  def hyphen(_encoding = T.unsafe(nil)); end

  # source://prawn//lib/prawn/text/formatted/line_wrap.rb#217
  def initialize_line(options); end

  # @return [Boolean]
  #
  # source://prawn//lib/prawn/text/formatted/line_wrap.rb#213
  def line_empty?; end

  # @return [Boolean]
  #
  # source://prawn//lib/prawn/text/formatted/line_wrap.rb#296
  def line_finished?; end

  # @return [Boolean]
  #
  # source://prawn//lib/prawn/text/formatted/line_wrap.rb#82
  def next_string_newline?; end

  # @return [Boolean]
  #
  # source://prawn//lib/prawn/text/formatted/line_wrap.rb#288
  def previous_fragment_ended_with_breakable?; end

  # @return [Boolean]
  #
  # source://prawn//lib/prawn/text/formatted/line_wrap.rb#267
  def pull_preceding_fragment_to_join_this_one?(current_fragment); end

  # source://prawn//lib/prawn/text/formatted/line_wrap.rb#277
  def remember_this_fragment_for_backward_looking_ops; end

  # The pattern used to determine chunks of text to place on a given line
  #
  # source://prawn//lib/prawn/text/formatted/line_wrap.rb#138
  def scan_pattern(encoding = T.unsafe(nil)); end

  # source://prawn//lib/prawn/text/formatted/line_wrap.rb#180
  def soft_hyphen(encoding = T.unsafe(nil)); end

  # source://prawn//lib/prawn/text/formatted/line_wrap.rb#300
  def update_line_status_based_on_last_output; end

  # source://prawn//lib/prawn/text/formatted/line_wrap.rb#250
  def update_output_based_on_last_fragment(fragment, normalized_soft_hyphen = T.unsafe(nil)); end

  # source://prawn//lib/prawn/text/formatted/line_wrap.rb#202
  def whitespace(encoding = T.unsafe(nil)); end

  # The pattern used to determine whether any word breaks exist on a
  # current line, which in turn determines whether character level
  # word breaking is needed
  #
  # source://prawn//lib/prawn/text/formatted/line_wrap.rb#164
  def word_division_scan_pattern(encoding = T.unsafe(nil)); end

  # source://prawn//lib/prawn/text/formatted/line_wrap.rb#314
  def wrap_by_char(segment); end

  # source://prawn//lib/prawn/text/formatted/line_wrap.rb#195
  def zero_width_space(encoding = T.unsafe(nil)); end
end

# Implements a bi-directional parser between a subset of html and
# formatted text arrays.
#
# source://prawn//lib/prawn/text/formatted/parser.rb#8
class Prawn::Text::Formatted::Parser
  class << self
    # @param tokens [Array<String>]
    # @private
    # @return [Array<Hash>]
    #
    # source://prawn//lib/prawn/text/formatted/parser.rb#151
    def array_from_tokens(tokens); end

    # Break text into paragraphs.
    #
    # @param array [Array<Hash>] Text fragments.
    # @private
    # @return [Array<Array<Hash>>] Pragraphs of text fragments.
    #
    # source://prawn//lib/prawn/text/formatted/parser.rb#125
    def array_paragraphs(array); end

    # Escape characters that can interfere with inline format parsing.
    #
    # @param text [String]
    # @return [String]
    #
    # source://prawn//lib/prawn/text/formatted/parser.rb#270
    def escape(text); end

    # Parse formatted string.
    #
    # @param string [String]
    # @return [Array<Hash>] Text fragments.
    #
    # source://prawn//lib/prawn/text/formatted/parser.rb#48
    def format(string, *_args); end

    # Serialize text fragments to an inline format string.
    #
    # @param array [Array<Hash>]
    # @return [String]
    #
    # source://prawn//lib/prawn/text/formatted/parser.rb#57
    def to_string(array); end

    # Unescape characters that can interfere with inline format parsing.
    #
    # @param text [String]
    # @return [String]
    #
    # source://prawn//lib/prawn/text/formatted/parser.rb#278
    def unescape(text); end
  end
end

# Escaped characters.
#
# @private
#
# source://prawn//lib/prawn/text/formatted/parser.rb#35
Prawn::Text::Formatted::Parser::ESCAPE_CHARS = T.let(T.unsafe(nil), Hash)

# Parser regular expression.
#
# @private
#
# source://prawn//lib/prawn/text/formatted/parser.rb#13
Prawn::Text::Formatted::Parser::PARSER_REGEX = T.let(T.unsafe(nil), Regexp)

# @private
#
# source://prawn//lib/prawn/text/formatted/parser.rb#42
Prawn::Text::Formatted::Parser::UNESCAPE_CHARS = T.let(T.unsafe(nil), Hash)

# Handles text wrapping for for formatted text.
#
# @private
#
# source://prawn//lib/prawn/text/formatted/wrap.rb#12
module Prawn::Text::Formatted::Wrap
  # source://prawn//lib/prawn/text/formatted/wrap.rb#13
  def initialize(_array, options); end

  # See the developer documentation for PDF::Core::Text#wrap
  #
  # Formatted#wrap should set the following variables:
  #   <tt>@line_height</tt>::
  #        the height of the tallest fragment in the last printed line
  #   <tt>@descender</tt>::
  #        the descender height of the tallest fragment in the last
  #        printed line
  #   <tt>@ascender</tt>::
  #        the ascender heigth of the tallest fragment in the last
  #        printed line
  #   <tt>@baseline_y</tt>::
  #       the baseline of the current line
  #   <tt>@nothing_printed</tt>::
  #       set to true until something is printed, then false
  #   <tt>@everything_printed</tt>::
  #       set to false until everything printed, then true
  #
  # Returns any formatted text that was not printed
  #
  # source://prawn//lib/prawn/text/formatted/wrap.rb#42
  def wrap(array); end

  private

  # @return [Boolean]
  #
  # source://prawn//lib/prawn/text/formatted/wrap.rb#118
  def enough_height_for_this_line?; end

  # source://prawn//lib/prawn/text/formatted/wrap.rb#153
  def format_and_draw_fragment(fragment, accumulated_width, line_width, word_spacing); end

  # source://prawn//lib/prawn/text/formatted/wrap.rb#138
  def initialize_wrap(array); end

  # source://prawn//lib/prawn/text/formatted/wrap.rb#74
  def print_line; end

  # source://prawn//lib/prawn/text/formatted/wrap.rb#109
  def word_spacing_for_this_line; end
end

# No-Break Space
#
# source://prawn//lib/prawn/text.rb#15
Prawn::Text::NBSP = T.let(T.unsafe(nil), String)

# Soft Hyphen (invisible, except when causing a line break)
#
# source://prawn//lib/prawn/text.rb#21
Prawn::Text::SHY = T.let(T.unsafe(nil), String)

# Zero Width Space (indicate word boundaries without a space)
#
# source://prawn//lib/prawn/text.rb#18
Prawn::Text::ZWSP = T.let(T.unsafe(nil), String)

# Stores the transformations that have been applied to the document.
#
# @private
#
# source://prawn//lib/prawn/transformation_stack.rb#8
module Prawn::TransformationStack
  # Add transformation to the stack.
  #
  # @param a [Number]
  # @param b [Number]
  # @param c [Number]
  # @param d [Number]
  # @param e [Number]
  # @param f [Number]
  # @return [void]
  #
  # source://prawn//lib/prawn/transformation_stack.rb#20
  def add_to_transformation_stack(a, b, c, d, e, f); end

  # Get current transformation matrix. It's a result of multiplication of the
  # whole transformation stack with additional translation.
  #
  # @param x [Number]
  # @param y [Number]
  # @return [Array(Number, Number, Number, Number, Number, Number)]
  #
  # source://prawn//lib/prawn/transformation_stack.rb#48
  def current_transformation_matrix_with_translation(x = T.unsafe(nil), y = T.unsafe(nil)); end

  # Restore previous transformation.
  #
  # Effectively pops the last transformation off of the transformation stack.
  #
  # @return [void]
  #
  # source://prawn//lib/prawn/transformation_stack.rb#38
  def restore_transformation_stack; end

  # Save transformation stack.
  #
  # @return [void]
  #
  # source://prawn//lib/prawn/transformation_stack.rb#28
  def save_transformation_stack; end
end

# Prawn versions
#
# source://prawn//lib/prawn/version.rb#5
Prawn::VERSION = T.let(T.unsafe(nil), String)

# This mixin allows you to create modular Prawn code without the
# need to create subclasses of {Prawn::Document}.
#
# ```ruby
# class Greeter
#   include Prawn::View
#
#   # Optional override: allows you to set document options or even use
#   # a custom document class
#   def document
#     @document ||= Prawn::Document.new(page_size: 'A4')
#   end
#
#   def initialize(name)
#     @name = name
#   end
#
#   def say_hello
#     text "Hello, #{@name}!"
#   end
#
#   def say_goodbye
#     font("Courier") do
#       text "Goodbye, #{@name}!"
#     end
#   end
# end
#
# greeter = Greeter.new("Gregory")
#
# greeter.say_hello
# greeter.say_goodbye
#
# greeter.save_as("greetings.pdf")
# ```
#
# The short story about why you should use this mixin rather than creating
# subclasses of `Prawn::Document` is that it helps prevent accidental
# conflicts between your code and Prawn's code.
#
# Here's the slightly longer story...
#
# By using composition rather than inheritance under the hood, this mixin
# allows you to keep your state separate from `Prawn::Document`'s state, and
# also will prevent unexpected method name collisions due to late binding
# effects.
#
# This mixin is mostly meant for extending Prawn's functionality with your own
# additions, but you can also use it to replace or wrap existing Prawn
# methods. Calling `super` will still work as expected, and alternatively you
# can explicitly call `document.some_method` to delegate to Prawn where
# needed.
#
# source://prawn//lib/prawn/view.rb#56
module Prawn::View
  # Lazily instantiates a `Prawn::Document` object.
  #
  # You can also redefine this method in your own classes to use
  # a custom document class.
  #
  # @return [Prawn::Dcoument]
  #
  # source://prawn//lib/prawn/view.rb#65
  def document; end

  # Delegates all unhandled calls to object returned by {document} method.
  #
  # @param method_name [Symbol]
  # @param args [Array] Positional arguments.
  # @param kwargs [Hash] Keyword arguments.
  # @param block [Proc]
  #
  # source://prawn//lib/prawn/view.rb#75
  def method_missing(method_name, *args, **kwargs, &block); end

  # Syntatic sugar that calls `document.render_file` under the hood.
  #
  # @example
  #   greeter.save_as("greetings.pdf")
  # @param filename [String]
  # @return [void]
  #
  # source://prawn//lib/prawn/view.rb#112
  def save_as(filename); end

  # Syntactic sugar that uses `instance_eval` under the hood to provide
  # a block-based DSL.
  #
  # @example
  #   greeter.update do
  #   say_hello
  #   say_goodbye
  #   end
  # @return [void]
  # @yield
  #
  # source://prawn//lib/prawn/view.rb#101
  def update(&block); end

  private

  # Does this object respond to the specified message?
  #
  # @param method_name [Symbol]
  # @param _include_all [Boolean]
  # @return [Boolean]
  #
  # source://prawn//lib/prawn/view.rb#86
  def respond_to_missing?(method_name, _include_all = T.unsafe(nil)); end
end
