# typed: true

# DO NOT EDIT MANUALLY
# This is an autogenerated file for types exported from the `licensee` gem.
# Please instead update this file by running `bin/tapioca gem licensee`.

# source://licensee//lib/licensee/version.rb#3
module Licensee
  class << self
    # source://licensee//lib/licensee.rb#47
    def confidence_threshold; end

    # source://licensee//lib/licensee.rb#51
    def confidence_threshold=(value); end

    # Inverse of the confidence threshold, represented as a float
    # By default this will be 0.02
    #
    # source://licensee//lib/licensee.rb#58
    def inverse_confidence_threshold; end

    # source://licensee//lib/licensee.rb#33
    def license(path); end

    # source://licensee//lib/licensee.rb#28
    def licenses(options = T.unsafe(nil)); end

    # source://licensee//lib/licensee.rb#37
    def project(path, **args); end
  end
end

# Over which percent is a match considered a match by default
#
# source://licensee//lib/licensee.rb#21
Licensee::CONFIDENCE_THRESHOLD = T.let(T.unsafe(nil), Integer)

# source://licensee//lib/licensee/content_helper.rb#7
module Licensee::ContentHelper
  # SHA1 of the normalized content
  #
  # source://licensee//lib/licensee/content_helper.rb#136
  def content_hash; end

  # source://licensee//lib/licensee/content_helper.rb#153
  def content_normalized(wrap: T.unsafe(nil)); end

  # source://licensee//lib/licensee/content_helper.rb#144
  def content_without_title_and_version; end

  # Number of characters in the normalized content
  #
  # source://licensee//lib/licensee/content_helper.rb#113
  def length; end

  # source://licensee//lib/licensee/content_helper.rb#120
  def length_delta(other); end

  # source://licensee//lib/licensee/content_helper.rb#128
  def similarity(other); end

  # source://licensee//lib/licensee/content_helper.rb#108
  def wordset; end

  private

  # source://licensee//lib/licensee/content_helper.rb#219
  def _content; end

  # Returns an array of strings of substitutable fields in normalized content
  #
  # source://licensee//lib/licensee/content_helper.rb#328
  def fields_normalized; end

  # source://licensee//lib/licensee/content_helper.rb#333
  def fields_normalized_set; end

  # source://licensee//lib/licensee/content_helper.rb#301
  def normalize(from_or_key, to = T.unsafe(nil)); end

  # source://licensee//lib/licensee/content_helper.rb#318
  def normalize_bullets; end

  # source://licensee//lib/licensee/content_helper.rb#285
  def normalize_span_markup; end

  # source://licensee//lib/licensee/content_helper.rb#314
  def normalize_spelling; end

  # source://licensee//lib/licensee/content_helper.rb#223
  def strip(regex_or_sym); end

  # source://licensee//lib/licensee/content_helper.rb#242
  def strip_borders; end

  # source://licensee//lib/licensee/content_helper.rb#259
  def strip_cc0_optional; end

  # source://licensee//lib/licensee/content_helper.rb#267
  def strip_cc_optional; end

  # source://licensee//lib/licensee/content_helper.rb#246
  def strip_comments; end

  # source://licensee//lib/licensee/content_helper.rb#254
  def strip_copyright; end

  # source://licensee//lib/licensee/content_helper.rb#280
  def strip_end_of_terms; end

  # source://licensee//lib/licensee/content_helper.rb#293
  def strip_html; end

  # source://licensee//lib/licensee/content_helper.rb#289
  def strip_link_markup; end

  # source://licensee//lib/licensee/content_helper.rb#238
  def strip_title; end

  # source://licensee//lib/licensee/content_helper.rb#274
  def strip_unlicense_optional; end

  # source://licensee//lib/licensee/content_helper.rb#337
  def variation_adjusted_length_delta(other); end

  # source://licensee//lib/licensee/content_helper.rb#323
  def wordset_fieldless; end

  class << self
    # Backwards compatibalize constants to avoid a breaking change
    #
    # source://licensee//lib/licensee/content_helper.rb#171
    def const_missing(const); end

    # source://licensee//lib/licensee/content_helper.rb#195
    def format_percent(float); end

    # source://licensee//lib/licensee/content_helper.rb#199
    def title_regex; end

    # Wrap text to the given line length
    #
    # source://licensee//lib/licensee/content_helper.rb#177
    def wrap(text, line_width = T.unsafe(nil)); end
  end
end

# source://licensee//lib/licensee/content_helper.rb#8
Licensee::ContentHelper::DIGEST = OpenSSL::Digest::SHA1

# source://licensee//lib/licensee/content_helper.rb#10
Licensee::ContentHelper::END_OF_TERMS_REGEX = T.let(T.unsafe(nil), Regexp)

# source://licensee//lib/licensee/content_helper.rb#34
Licensee::ContentHelper::NORMALIZATIONS = T.let(T.unsafe(nil), Hash)

# source://licensee//lib/licensee/content_helper.rb#11
Licensee::ContentHelper::REGEXES = T.let(T.unsafe(nil), Hash)

# source://licensee//lib/licensee/content_helper.rb#9
Licensee::ContentHelper::START_REGEX = T.let(T.unsafe(nil), Regexp)

# source://licensee//lib/licensee/content_helper.rb#89
Licensee::ContentHelper::STRIP_METHODS = T.let(T.unsafe(nil), Array)

# source://licensee//lib/licensee/content_helper.rb#45
Licensee::ContentHelper::VARIETAL_WORDS = T.let(T.unsafe(nil), Hash)

# source://licensee//lib/licensee.rb#24
Licensee::DOMAIN = T.let(T.unsafe(nil), String)

# source://licensee//lib/licensee/hash_helper.rb#4
module Licensee::HashHelper
  # source://licensee//lib/licensee/hash_helper.rb#5
  def to_h; end
end

# source://licensee//lib/licensee/license.rb#6
class Licensee::InvalidLicense < ::ArgumentError; end

# source://licensee//lib/licensee/license.rb#8
class Licensee::License
  include ::Licensee::ContentHelper
  include ::Licensee::HashHelper
  extend ::Forwardable

  # @return [License] a new instance of License
  #
  # source://licensee//lib/licensee/license.rb#113
  def initialize(key); end

  # source://licensee//lib/licensee/license.rb#226
  def ==(other); end

  # source://licensee//lib/licensee/license.rb#215
  def body; end

  # source://licensee//lib/licensee/license.rb#209
  def cc?; end

  # source://forwardable/1.3.3/forwardable.rb#231
  def conditions(*args, **_arg1, &block); end

  # source://licensee//lib/licensee/license.rb#215
  def content; end

  # Returns a string with `[fields]` replaced by `{{{fields}}}`
  # Does not mangle non-supported fields in the form of `[field]`
  #
  # source://licensee//lib/licensee/license.rb#249
  def content_for_mustache; end

  # source://licensee//lib/licensee/license.rb#209
  def creative_commons?; end

  # source://forwardable/1.3.3/forwardable.rb#231
  def description(*args, **_arg1, &block); end

  # source://forwardable/1.3.3/forwardable.rb#231
  def featured?(*args, **_arg1, &block); end

  # source://licensee//lib/licensee/license.rb#243
  def fields; end

  # @return [Boolean]
  #
  # source://licensee//lib/licensee/license.rb#200
  def gpl?; end

  # source://forwardable/1.3.3/forwardable.rb#231
  def hidden?(*args, **_arg1, &block); end

  # source://forwardable/1.3.3/forwardable.rb#231
  def how(*args, **_arg1, &block); end

  # source://licensee//lib/licensee/license.rb#238
  def inspect; end

  # Returns the value of attribute key.
  #
  # source://licensee//lib/licensee/license.rb#81
  def key; end

  # @return [Boolean]
  #
  # source://licensee//lib/licensee/license.rb#204
  def lgpl?; end

  # source://forwardable/1.3.3/forwardable.rb#231
  def limitations(*args, **_arg1, &block); end

  # source://licensee//lib/licensee/license.rb#123
  def meta; end

  # source://licensee//lib/licensee/license.rb#134
  def name; end

  # source://licensee//lib/licensee/license.rb#140
  def name_without_version; end

  # source://forwardable/1.3.3/forwardable.rb#231
  def nickname(*args, **_arg1, &block); end

  # source://forwardable/1.3.3/forwardable.rb#231
  def note(*args, **_arg1, &block); end

  # @return [Boolean]
  #
  # source://licensee//lib/licensee/license.rb#196
  def other?; end

  # source://licensee//lib/licensee/license.rb#118
  def path; end

  # source://forwardable/1.3.3/forwardable.rb#231
  def permissions(*args, **_arg1, &block); end

  # @return [Boolean]
  #
  # source://licensee//lib/licensee/license.rb#230
  def pseudo_license?; end

  # source://licensee//lib/licensee/license.rb#234
  def rules; end

  # source://forwardable/1.3.3/forwardable.rb#231
  def source(*args, **_arg1, &block); end

  # source://licensee//lib/licensee/license.rb#185
  def source_regex; end

  # source://licensee//lib/licensee/license.rb#127
  def spdx_id; end

  # source://licensee//lib/licensee/license.rb#215
  def text; end

  # source://forwardable/1.3.3/forwardable.rb#231
  def title(*args, **_arg1, &block); end

  # source://licensee//lib/licensee/license.rb#144
  def title_regex; end

  # source://licensee//lib/licensee/license.rb#215
  def to_s; end

  # source://licensee//lib/licensee/license.rb#222
  def url; end

  # source://forwardable/1.3.3/forwardable.rb#231
  def using(*args, **_arg1, &block); end

  private

  # source://licensee//lib/licensee/license.rb#263
  def parts; end

  # source://licensee//lib/licensee/license.rb#256
  def raw_content; end

  # source://licensee//lib/licensee/license.rb#273
  def spdx_alt_segments; end

  # source://licensee//lib/licensee/license.rb#269
  def yaml; end

  class << self
    # source://licensee//lib/licensee/license.rb#44
    def [](key, options = T.unsafe(nil)); end

    # source://licensee//lib/licensee/license.rb#20
    def all(options = T.unsafe(nil)); end

    # source://licensee//lib/licensee/license.rb#44
    def find(key, options = T.unsafe(nil)); end

    # source://licensee//lib/licensee/license.rb#44
    def find_by_key(key, options = T.unsafe(nil)); end

    # source://licensee//lib/licensee/license.rb#52
    def find_by_title(title); end

    # source://licensee//lib/licensee/license.rb#38
    def keys; end

    # source://licensee//lib/licensee/license.rb#58
    def license_dir; end

    # source://licensee//lib/licensee/license.rb#62
    def license_files; end

    # source://licensee//lib/licensee/license.rb#66
    def spdx_dir; end

    private

    # source://licensee//lib/licensee/license.rb#76
    def keys_licenses(options = T.unsafe(nil)); end

    # source://licensee//lib/licensee/license.rb#72
    def licenses; end
  end
end

# source://licensee//lib/licensee/license.rb#95
Licensee::License::DEFAULT_OPTIONS = T.let(T.unsafe(nil), Hash)

# source://licensee//lib/licensee/license.rb#104
Licensee::License::HASH_METHODS = T.let(T.unsafe(nil), Array)

# source://licensee//lib/licensee/license.rb#92
Licensee::License::PSEUDO_LICENSES = T.let(T.unsafe(nil), Array)

# source://licensee//lib/licensee/license.rb#101
Licensee::License::SOURCE_PREFIX = T.let(T.unsafe(nil), Regexp)

# source://licensee//lib/licensee/license.rb#102
Licensee::License::SOURCE_SUFFIX = T.let(T.unsafe(nil), Regexp)

# Preserved for backwards compatibility
#
# source://licensee//lib/licensee/license.rb#84
Licensee::License::YAML_DEFAULTS = T.let(T.unsafe(nil), Array)

# source://licensee//lib/licensee/license_field.rb#4
class Licensee::LicenseField < ::Struct
  # Returns the value of attribute name
  #
  # @return [Object] the current value of name
  def key; end

  # The human-readable field name
  #
  # source://licensee//lib/licensee/license_field.rb#53
  def label; end

  # source://licensee//lib/licensee/license_field.rb#58
  def raw_text; end

  # The human-readable field name
  #
  # source://licensee//lib/licensee/license_field.rb#53
  def to_s; end

  class << self
    # source://licensee//lib/licensee/license_field.rb#21
    def all; end

    # source://licensee//lib/licensee/license_field.rb#11
    def find(key); end

    # source://licensee//lib/licensee/license_field.rb#37
    def from_array(array); end

    # source://licensee//lib/licensee/license_field.rb#42
    def from_content(content); end

    # source://licensee//lib/licensee/license_field.rb#31
    def from_hash(hash); end

    # Returns an array of strings representing all field keys
    #
    # source://licensee//lib/licensee/license_field.rb#16
    def keys; end
  end
end

# source://licensee//lib/licensee/license_field.rb#50
Licensee::LicenseField::FIELD_REGEX = T.let(T.unsafe(nil), Regexp)

# source://licensee//lib/licensee/license_meta.rb#7
class Licensee::LicenseMeta < ::Struct
  include ::Licensee::HashHelper

  # Backward compatibalize `#["spdx-id"]` calls to avoid a breaking change
  #
  # source://licensee//lib/licensee/license_meta.rb#55
  def [](key); end

  def featured?; end
  def hidden?; end

  # Returns the value of attribute source
  #
  # @return [Object] the current value of source
  #
  # source://licensee//lib/licensee/license_meta.rb#60
  def source; end

  class << self
    # source://licensee//lib/licensee/license_meta.rb#37
    def from_hash(hash); end

    # source://licensee//lib/licensee/license_meta.rb#26
    def from_yaml(yaml); end

    # source://licensee//lib/licensee/license_meta.rb#45
    def helper_methods; end
  end
end

# source://licensee//lib/licensee/license_meta.rb#10
Licensee::LicenseMeta::DEFAULTS = T.let(T.unsafe(nil), Hash)

# source://licensee//lib/licensee/license_meta.rb#18
Licensee::LicenseMeta::HASH_METHODS = T.let(T.unsafe(nil), Array)

# source://licensee//lib/licensee/license_meta.rb#15
Licensee::LicenseMeta::PREDICATE_FIELDS = T.let(T.unsafe(nil), Array)

# source://licensee//lib/licensee/license_rules.rb#5
class Licensee::LicenseRules < ::Struct
  include ::Licensee::HashHelper

  # source://licensee//lib/licensee/license_rules.rb#30
  def flatten; end

  # @return [Boolean]
  #
  # source://licensee//lib/licensee/license_rules.rb#34
  def has_key?(key); end

  # @return [Boolean]
  #
  # source://licensee//lib/licensee/license_rules.rb#34
  def key?(key); end

  class << self
    # source://licensee//lib/licensee/license_rules.rb#24
    def from_hash(hash); end

    # source://licensee//lib/licensee/license_rules.rb#10
    def from_license(license); end

    # source://licensee//lib/licensee/license_rules.rb#14
    def from_meta(meta); end
  end
end

# source://licensee//lib/licensee/license_rules.rb#7
Licensee::LicenseRules::HASH_METHODS = T.let(T.unsafe(nil), Array)

# source://licensee//lib/licensee/matchers.rb#4
module Licensee::Matchers; end

# source://licensee//lib/licensee/matchers/cabal.rb#5
class Licensee::Matchers::Cabal < ::Licensee::Matchers::Package
  private

  # source://licensee//lib/licensee/matchers/cabal.rb#20
  def license_property; end

  # source://licensee//lib/licensee/matchers/cabal.rb#25
  def spdx_name(cabal_name); end
end

# source://licensee//lib/licensee/matchers/cabal.rb#9
Licensee::Matchers::Cabal::LICENSE_CONVERSIONS = T.let(T.unsafe(nil), Hash)

# While we could parse the cabal file, prefer
# a lenient regex for speed and security. Moar parsing moar problems.
#
# source://licensee//lib/licensee/matchers/cabal.rb#8
Licensee::Matchers::Cabal::LICENSE_REGEX = T.let(T.unsafe(nil), Regexp)

# source://licensee//lib/licensee/matchers/cargo.rb#5
class Licensee::Matchers::Cargo < ::Licensee::Matchers::Package
  private

  # source://licensee//lib/licensee/matchers/cargo.rb#12
  def license_property; end
end

# source://licensee//lib/licensee/matchers/cargo.rb#6
Licensee::Matchers::Cargo::LICENSE_REGEX = T.let(T.unsafe(nil), Regexp)

# source://licensee//lib/licensee/matchers/copyright.rb#5
class Licensee::Matchers::Copyright < ::Licensee::Matchers::Matcher
  # source://licensee//lib/licensee/matchers/copyright.rb#19
  def confidence; end

  # Returns the value of attribute file.
  #
  # source://licensee//lib/licensee/matchers/copyright.rb#6
  def file; end

  # source://licensee//lib/licensee/matchers/copyright.rb#12
  def match; end
end

# source://licensee//lib/licensee/matchers/copyright.rb#8
Licensee::Matchers::Copyright::COPYRIGHT_SYMBOLS = T.let(T.unsafe(nil), Regexp)

# source://licensee//lib/licensee/matchers/copyright.rb#9
Licensee::Matchers::Copyright::MAIN_LINE_REGEX = T.let(T.unsafe(nil), Regexp)

# source://licensee//lib/licensee/matchers/copyright.rb#10
Licensee::Matchers::Copyright::OPTIONAL_LINE_REGEX = T.let(T.unsafe(nil), Regexp)

# source://licensee//lib/licensee/matchers/copyright.rb#11
Licensee::Matchers::Copyright::REGEX = T.let(T.unsafe(nil), Regexp)

# source://licensee//lib/licensee/matchers/cran.rb#5
class Licensee::Matchers::Cran < ::Licensee::Matchers::Package
  # Returns the value of attribute file.
  #
  # source://licensee//lib/licensee/matchers/cran.rb#6
  def file; end

  private

  # source://licensee//lib/licensee/matchers/cran.rb#27
  def gpl_version(license_key); end

  # source://licensee//lib/licensee/matchers/cran.rb#18
  def license_field; end

  # source://licensee//lib/licensee/matchers/cran.rb#34
  def license_property; end
end

# source://licensee//lib/licensee/matchers/cran.rb#12
Licensee::Matchers::Cran::GPL_VERSION_REGEX = T.let(T.unsafe(nil), Regexp)

# While we could parse the DESCRIPTION file, prefer
# a lenient regex for speed and security. Moar parsing moar problems.
#
# source://licensee//lib/licensee/matchers/cran.rb#10
Licensee::Matchers::Cran::LICENSE_FIELD_REGEX = T.let(T.unsafe(nil), Regexp)

# source://licensee//lib/licensee/matchers/cran.rb#11
Licensee::Matchers::Cran::PLUS_FILE_LICENSE_REGEX = T.let(T.unsafe(nil), Regexp)

# source://licensee//lib/licensee/matchers/dice.rb#5
class Licensee::Matchers::Dice < ::Licensee::Matchers::Matcher
  # source://licensee//lib/licensee/matchers/dice.rb#51
  def confidence; end

  # source://licensee//lib/licensee/matchers/dice.rb#34
  def licenses_by_similarity; end

  # source://licensee//lib/licensee/matchers/dice.rb#8
  def match; end

  # source://licensee//lib/licensee/matchers/dice.rb#44
  def matches; end

  # source://licensee//lib/licensee/matchers/dice.rb#34
  def matches_by_similarity; end

  # source://licensee//lib/licensee/matchers/dice.rb#23
  def potential_licenses; end

  # source://licensee//lib/licensee/matchers/dice.rb#23
  def potential_matches; end

  private

  # source://licensee//lib/licensee/matchers/dice.rb#57
  def minimum_confidence; end
end

# source://licensee//lib/licensee/matchers/dist_zilla.rb#5
class Licensee::Matchers::DistZilla < ::Licensee::Matchers::Package
  # Returns the value of attribute file.
  #
  # source://licensee//lib/licensee/matchers/dist_zilla.rb#6
  def file; end

  private

  # source://licensee//lib/licensee/matchers/dist_zilla.rb#12
  def license_property; end

  # source://licensee//lib/licensee/matchers/dist_zilla.rb#17
  def spdx_name(perl_name); end
end

# source://licensee//lib/licensee/matchers/dist_zilla.rb#8
Licensee::Matchers::DistZilla::LICENSE_REGEX = T.let(T.unsafe(nil), Regexp)

# source://licensee//lib/licensee/matchers/exact.rb#5
class Licensee::Matchers::Exact < ::Licensee::Matchers::Matcher
  # source://licensee//lib/licensee/matchers/exact.rb#14
  def confidence; end

  # source://licensee//lib/licensee/matchers/exact.rb#6
  def match; end
end

# source://licensee//lib/licensee/matchers/gemspec.rb#5
class Licensee::Matchers::Gemspec < ::Licensee::Matchers::Package
  private

  # source://licensee//lib/licensee/matchers/gemspec.rb#48
  def declarations; end

  # source://licensee//lib/licensee/matchers/gemspec.rb#43
  def license_array_property; end

  # source://licensee//lib/licensee/matchers/gemspec.rb#29
  def license_property; end
end

# an array contains one or more values. all values, or array itself,
# can be surrounded by any amount of whitespace.  do not capture
# non-value groups
#
# source://licensee//lib/licensee/matchers/gemspec.rb#13
Licensee::Matchers::Gemspec::ARRAY_REGEX = T.let(T.unsafe(nil), Regexp)

# source://licensee//lib/licensee/matchers/gemspec.rb#15
Licensee::Matchers::Gemspec::DECLARATION_REGEX = T.let(T.unsafe(nil), Regexp)

# source://licensee//lib/licensee/matchers/gemspec.rb#23
Licensee::Matchers::Gemspec::LICENSE_ARRAY_REGEX = T.let(T.unsafe(nil), Regexp)

# source://licensee//lib/licensee/matchers/gemspec.rb#19
Licensee::Matchers::Gemspec::LICENSE_REGEX = T.let(T.unsafe(nil), Regexp)

# a value is a string surrounded by any amount of whitespace
# optionally ended with (non-captured) ".freeze"
#
# source://licensee//lib/licensee/matchers/gemspec.rb#8
Licensee::Matchers::Gemspec::VALUE_REGEX = T.let(T.unsafe(nil), Regexp)

# source://licensee//lib/licensee/matchers/matcher.rb#5
class Licensee::Matchers::Matcher
  include ::Licensee::HashHelper

  # @return [Matcher] a new instance of Matcher
  #
  # source://licensee//lib/licensee/matchers/matcher.rb#11
  def initialize(file); end

  # source://licensee//lib/licensee/matchers/matcher.rb#23
  def confidence; end

  # Returns the value of attribute file.
  #
  # source://licensee//lib/licensee/matchers/matcher.rb#6
  def file; end

  # source://licensee//lib/licensee/matchers/matcher.rb#19
  def match; end

  # source://licensee//lib/licensee/matchers/matcher.rb#15
  def name; end

  private

  # source://licensee//lib/licensee/matchers/matcher.rb#29
  def potential_matches; end
end

# source://licensee//lib/licensee/matchers/matcher.rb#9
Licensee::Matchers::Matcher::HASH_METHODS = T.let(T.unsafe(nil), Array)

# source://licensee//lib/licensee/matchers/npm_bower.rb#5
class Licensee::Matchers::NpmBower < ::Licensee::Matchers::Package
  private

  # source://licensee//lib/licensee/matchers/npm_bower.rb#14
  def license_property; end
end

# While we could parse the package.json or bower.json file, prefer
# a lenient regex for speed and security. Moar parsing moar problems.
#
# source://licensee//lib/licensee/matchers/npm_bower.rb#8
Licensee::Matchers::NpmBower::LICENSE_REGEX = T.let(T.unsafe(nil), Regexp)

# source://licensee//lib/licensee/matchers/nuget.rb#5
class Licensee::Matchers::NuGet < ::Licensee::Matchers::Package
  private

  # source://licensee//lib/licensee/matchers/nuget.rb#21
  def license_from_first_capture(url, pattern); end

  # source://licensee//lib/licensee/matchers/nuget.rb#26
  def license_from_url(url); end

  # source://licensee//lib/licensee/matchers/nuget.rb#33
  def license_property; end
end

# source://licensee//lib/licensee/matchers/nuget.rb#17
Licensee::Matchers::NuGet::APACHE_REGEX = T.let(T.unsafe(nil), Regexp)

# While we could parse the nuspec file, prefer a lenient regex for speed and security.
# Moar parsing moar problems.
#
# source://licensee//lib/licensee/matchers/nuget.rb#8
Licensee::Matchers::NuGet::LICENSE_REGEX = T.let(T.unsafe(nil), Regexp)

# source://licensee//lib/licensee/matchers/nuget.rb#12
Licensee::Matchers::NuGet::LICENSE_URL_REGEX = T.let(T.unsafe(nil), Regexp)

# source://licensee//lib/licensee/matchers/nuget.rb#14
Licensee::Matchers::NuGet::NUGET_REGEX = T.let(T.unsafe(nil), Regexp)

# source://licensee//lib/licensee/matchers/nuget.rb#15
Licensee::Matchers::NuGet::OPENSOURCE_REGEX = T.let(T.unsafe(nil), Regexp)

# source://licensee//lib/licensee/matchers/nuget.rb#16
Licensee::Matchers::NuGet::SPDX_REGEX = T.let(T.unsafe(nil), Regexp)

# source://licensee//lib/licensee/matchers/package.rb#5
class Licensee::Matchers::Package < ::Licensee::Matchers::Matcher
  # source://licensee//lib/licensee/matchers/package.rb#16
  def confidence; end

  # source://licensee//lib/licensee/matchers/package.rb#20
  def license_property; end

  # source://licensee//lib/licensee/matchers/package.rb#6
  def match; end
end

# source://licensee//lib/licensee/matchers/reference.rb#6
class Licensee::Matchers::Reference < ::Licensee::Matchers::Matcher
  # source://licensee//lib/licensee/matchers/reference.rb#14
  def confidence; end

  # source://licensee//lib/licensee/matchers/reference.rb#7
  def match; end
end

# source://licensee//lib/licensee/matchers/spdx.rb#5
class Licensee::Matchers::Spdx < ::Licensee::Matchers::Package
  private

  # source://licensee//lib/licensee/matchers/spdx.rb#12
  def license_property; end
end

# source://licensee//lib/licensee/matchers/spdx.rb#8
Licensee::Matchers::Spdx::LICENSE_REGEX = T.let(T.unsafe(nil), Regexp)

# source://licensee//lib/licensee/project_files.rb#4
module Licensee::ProjectFiles; end

# source://licensee//lib/licensee/project_files/license_file.rb#5
class Licensee::ProjectFiles::LicenseFile < ::Licensee::ProjectFiles::ProjectFile
  include ::Licensee::ContentHelper

  # source://licensee//lib/licensee/project_files/license_file.rb#64
  def attribution; end

  # @return [Boolean]
  #
  # source://licensee//lib/licensee/project_files/license_file.rb#81
  def gpl?; end

  # @return [Boolean]
  #
  # source://licensee//lib/licensee/project_files/license_file.rb#77
  def lgpl?; end

  # source://licensee//lib/licensee/project_files/license_file.rb#85
  def license; end

  # source://licensee//lib/licensee/project_files/license_file.rb#60
  def possible_matchers; end

  # Is this file likely to result in a creative commons false positive?
  #
  # @return [Boolean]
  #
  # source://licensee//lib/licensee/project_files/license_file.rb#73
  def potential_false_positive?; end

  class << self
    # source://licensee//lib/licensee/project_files/license_file.rb#98
    def lesser_gpl_score(filename); end

    # source://licensee//lib/licensee/project_files/license_file.rb#93
    def name_score(filename); end
  end
end

# Regex to match any extension
#
# source://licensee//lib/licensee/project_files/license_file.rb#20
Licensee::ProjectFiles::LicenseFile::ANY_EXT_REGEX = T.let(T.unsafe(nil), Regexp)

# source://licensee//lib/licensee/project_files/license_file.rb#56
Licensee::ProjectFiles::LicenseFile::CC_FALSE_POSITIVE_REGEX = T.let(T.unsafe(nil), Regexp)

# source://licensee//lib/licensee/project_files/license_file.rb#26
Licensee::ProjectFiles::LicenseFile::COPYING_REGEX = T.let(T.unsafe(nil), Regexp)

# source://licensee//lib/licensee/project_files/license_file.rb#35
Licensee::ProjectFiles::LicenseFile::FILENAME_REGEXES = T.let(T.unsafe(nil), Hash)

# Regex to match any extension except .spdx or .header
#
# source://licensee//lib/licensee/project_files/license_file.rb#13
Licensee::ProjectFiles::LicenseFile::LICENSE_EXT_REGEX = T.let(T.unsafe(nil), Regexp)

# source://licensee//lib/licensee/project_files/license_file.rb#23
Licensee::ProjectFiles::LicenseFile::LICENSE_REGEX = T.let(T.unsafe(nil), Regexp)

# Regex to match OFL.
#
# source://licensee//lib/licensee/project_files/license_file.rb#29
Licensee::ProjectFiles::LicenseFile::OFL_REGEX = T.let(T.unsafe(nil), Regexp)

# source://licensee//lib/licensee/project_files/license_file.rb#17
Licensee::ProjectFiles::LicenseFile::OTHER_EXT_REGEX = T.let(T.unsafe(nil), Regexp)

# BSD + PATENTS patent file
#
# source://licensee//lib/licensee/project_files/license_file.rb#32
Licensee::ProjectFiles::LicenseFile::PATENTS_REGEX = T.let(T.unsafe(nil), Regexp)

# List of extensions to give preference to
#
# source://licensee//lib/licensee/project_files/license_file.rb#9
Licensee::ProjectFiles::LicenseFile::PREFERRED_EXT = T.let(T.unsafe(nil), Array)

# source://licensee//lib/licensee/project_files/license_file.rb#10
Licensee::ProjectFiles::LicenseFile::PREFERRED_EXT_REGEX = T.let(T.unsafe(nil), Regexp)

# source://licensee//lib/licensee/project_files/package_manager_file.rb#5
class Licensee::ProjectFiles::PackageManagerFile < ::Licensee::ProjectFiles::ProjectFile
  # source://licensee//lib/licensee/project_files/package_manager_file.rb#32
  def possible_matchers; end

  private

  # source://licensee//lib/licensee/project_files/package_manager_file.rb#44
  def extension; end

  class << self
    # source://licensee//lib/licensee/project_files/package_manager_file.rb#36
    def name_score(filename); end
  end
end

# Hash of Filename => [possible matchers]
#
# source://licensee//lib/licensee/project_files/package_manager_file.rb#15
Licensee::ProjectFiles::PackageManagerFile::FILENAMES_EXTENSIONS = T.let(T.unsafe(nil), Hash)

# source://licensee//lib/licensee/project_files/package_manager_file.rb#22
Licensee::ProjectFiles::PackageManagerFile::FILENAMES_SCORES = T.let(T.unsafe(nil), Hash)

# Hash of Extension => [possible matchers]
#
# source://licensee//lib/licensee/project_files/package_manager_file.rb#7
Licensee::ProjectFiles::PackageManagerFile::MATCHERS_EXTENSIONS = T.let(T.unsafe(nil), Hash)

# source://licensee//lib/licensee/project_files/project_file.rb#9
class Licensee::ProjectFiles::ProjectFile
  include ::Licensee::HashHelper
  extend ::Forwardable

  # source://licensee//lib/licensee/project_files/project_file.rb#37
  def initialize(content, metadata = T.unsafe(nil)); end

  # source://forwardable/1.3.3/forwardable.rb#231
  def [](*args, **_arg1, &block); end

  # source://licensee//lib/licensee/project_files/project_file.rb#105
  def attribution; end

  # Returns the percent confident with the match
  #
  # source://licensee//lib/licensee/project_files/project_file.rb#74
  def confidence; end

  # Returns the value of attribute content.
  #
  # source://licensee//lib/licensee/project_files/project_file.rb#13
  def content; end

  # source://licensee//lib/licensee/project_files/project_file.rb#97
  def content_hash; end

  # source://licensee//lib/licensee/project_files/project_file.rb#101
  def content_normalized; end

  # source://licensee//lib/licensee/project_files/project_file.rb#90
  def copyright?; end

  # source://licensee//lib/licensee/project_files/project_file.rb#55
  def dir; end

  # source://licensee//lib/licensee/project_files/project_file.rb#55
  def directory; end

  # TODO: In the next major release, filename should be the basename
  # and path should be either the absolute path or the relative path to
  # the project root, but maintaining the alias for backward compatability
  #
  # source://licensee//lib/licensee/project_files/project_file.rb#50
  def filename; end

  # source://licensee//lib/licensee/project_files/project_file.rb#78
  def license; end

  # source://licensee//lib/licensee/project_files/project_file.rb#78
  def match; end

  # source://licensee//lib/licensee/project_files/project_file.rb#84
  def matched_license; end

  # source://licensee//lib/licensee/project_files/project_file.rb#69
  def matcher; end

  # TODO: In the next major release, filename should be the basename
  # and path should be either the absolute path or the relative path to
  # the project root, but maintaining the alias for backward compatability
  #
  # source://licensee//lib/licensee/project_files/project_file.rb#50
  def path; end

  # source://licensee//lib/licensee/project_files/project_file.rb#60
  def path_relative_to_root; end

  # source://licensee//lib/licensee/project_files/project_file.rb#65
  def possible_matchers; end

  # source://licensee//lib/licensee/project_files/project_file.rb#60
  def relative_path; end
end

# source://licensee//lib/licensee/project_files/project_file.rb#21
Licensee::ProjectFiles::ProjectFile::ENCODING = T.let(T.unsafe(nil), Encoding)

# source://licensee//lib/licensee/project_files/project_file.rb#22
Licensee::ProjectFiles::ProjectFile::ENCODING_OPTIONS = T.let(T.unsafe(nil), Hash)

# source://licensee//lib/licensee/project_files/project_file.rb#16
Licensee::ProjectFiles::ProjectFile::HASH_METHODS = T.let(T.unsafe(nil), Array)

# source://licensee//lib/licensee/project_files/readme_file.rb#5
class Licensee::ProjectFiles::ReadmeFile < ::Licensee::ProjectFiles::LicenseFile
  # source://licensee//lib/licensee/project_files/readme_file.rb#32
  def possible_matchers; end

  class << self
    # source://licensee//lib/licensee/project_files/readme_file.rb#43
    def license_content(content); end

    # source://licensee//lib/licensee/project_files/readme_file.rb#36
    def name_score(filename); end
  end
end

# source://licensee//lib/licensee/project_files/readme_file.rb#14
Licensee::ProjectFiles::ReadmeFile::CONTENT_REGEX = T.let(T.unsafe(nil), Regexp)

# source://licensee//lib/licensee/project_files/readme_file.rb#6
Licensee::ProjectFiles::ReadmeFile::EXTENSIONS = T.let(T.unsafe(nil), Array)

# source://licensee//lib/licensee/project_files/readme_file.rb#7
Licensee::ProjectFiles::ReadmeFile::SCORES = T.let(T.unsafe(nil), Hash)

# source://licensee//lib/licensee/project_files/readme_file.rb#12
Licensee::ProjectFiles::ReadmeFile::TITLE_REGEX = T.let(T.unsafe(nil), Regexp)

# source://licensee//lib/licensee/project_files/readme_file.rb#13
Licensee::ProjectFiles::ReadmeFile::UNDERLINE_REGEX = T.let(T.unsafe(nil), Regexp)

# source://licensee//lib/licensee/projects.rb#4
module Licensee::Projects; end

# source://licensee//lib/licensee/projects/fs_project.rb#12
class Licensee::Projects::FSProject < ::Licensee::Projects::Project
  # @return [FSProject] a new instance of FSProject
  #
  # source://licensee//lib/licensee/projects/fs_project.rb#13
  def initialize(path, **args); end

  private

  # source://licensee//lib/licensee/projects/fs_project.rb#82
  def dir_path; end

  # Returns an array of hashes representing the project's files.
  # Hashes will have the the following keys:
  #  :name - the relative file name
  #  :dir  - the directory path containing the file
  #
  # source://licensee//lib/licensee/projects/fs_project.rb#34
  def files; end

  # Retrieve a file's content from disk, enforcing encoding
  #
  # file - the file hash, with the :name key as the file's relative path
  #
  # Returns the file contents as a string
  #
  # source://licensee//lib/licensee/projects/fs_project.rb#50
  def load_file(file); end

  # Returns the set of unique paths to search for project files
  # in order from @dir -> @root
  #
  # source://licensee//lib/licensee/projects/fs_project.rb#66
  def search_directories; end

  # Enumerates all directories to search, from @dir to @root
  #
  # source://licensee//lib/licensee/projects/fs_project.rb#73
  def search_enumerator; end

  # Returns true if @dir is @root or it's descendant
  #
  # @return [Boolean]
  #
  # source://licensee//lib/licensee/projects/fs_project.rb#60
  def valid_search_root?; end
end

# source://licensee//lib/licensee/projects/github_project.rb#14
class Licensee::Projects::GitHubProject < ::Licensee::Projects::Project
  # @raise [ArgumentError]
  # @return [GitHubProject] a new instance of GitHubProject
  #
  # source://licensee//lib/licensee/projects/github_project.rb#22
  def initialize(github_url, **args); end

  # Returns the value of attribute repo.
  #
  # source://licensee//lib/licensee/projects/github_project.rb#29
  def repo; end

  private

  # source://licensee//lib/licensee/projects/github_project.rb#62
  def access_token; end

  # source://licensee//lib/licensee/projects/github_project.rb#58
  def client; end

  # source://licensee//lib/licensee/projects/github_project.rb#48
  def dir_files(path = T.unsafe(nil)); end

  # @raise [RepoNotFound]
  #
  # source://licensee//lib/licensee/projects/github_project.rb#33
  def files; end

  # source://licensee//lib/licensee/projects/github_project.rb#43
  def load_file(file); end
end

# If there's any trailing data (e.g. `.git`) this pattern will ignore it:
# we're going to use the API rather than clone the repo.
#
# source://licensee//lib/licensee/projects/github_project.rb#17
Licensee::Projects::GitHubProject::GITHUB_REPO_PATTERN = T.let(T.unsafe(nil), Regexp)

# source://licensee//lib/licensee/projects/github_project.rb#20
class Licensee::Projects::GitHubProject::RepoNotFound < ::StandardError; end

# source://licensee//lib/licensee/projects/git_project.rb#15
class Licensee::Projects::GitProject < ::Licensee::Projects::Project
  # @raise [InvalidRepository]
  # @return [GitProject] a new instance of GitProject
  #
  # source://licensee//lib/licensee/projects/git_project.rb#20
  def initialize(repo, revision: T.unsafe(nil), **args); end

  # source://licensee//lib/licensee/projects/git_project.rb#39
  def close; end

  # source://licensee//lib/licensee/projects/git_project.rb#29
  def repository; end

  # Returns the value of attribute revision.
  #
  # source://licensee//lib/licensee/projects/git_project.rb#16
  def revision; end

  private

  # source://licensee//lib/licensee/projects/git_project.rb#45
  def commit; end

  # Returns an array of hashes representing the project's files.
  # Hashes will have the the following keys:
  #  :name - the file's path relative to the repo root
  #  :oid  - the file's OID
  #
  # source://licensee//lib/licensee/projects/git_project.rb#69
  def files; end

  # source://licensee//lib/licensee/projects/git_project.rb#73
  def files_from_tree(tree, dir = T.unsafe(nil)); end

  # Retrieve a file's content from the Git database
  #
  # file - the file hash, including the file's OID
  #
  # Returns a string representing the file's contents
  #
  # source://licensee//lib/licensee/projects/git_project.rb#60
  def load_file(file); end
end

# source://licensee//lib/licensee/projects/git_project.rb#18
class Licensee::Projects::GitProject::InvalidRepository < ::ArgumentError; end

# source://licensee//lib/licensee/projects/git_project.rb#53
Licensee::Projects::GitProject::MAX_LICENSE_SIZE = T.let(T.unsafe(nil), Integer)

# source://licensee//lib/licensee/projects/project.rb#10
class Licensee::Projects::Project
  include ::Licensee::HashHelper

  # @return [Project] a new instance of Project
  #
  # source://licensee//lib/licensee/projects/project.rb#18
  def initialize(detect_packages: T.unsafe(nil), detect_readme: T.unsafe(nil)); end

  # Returns the value of attribute detect_packages.
  #
  # source://licensee//lib/licensee/projects/project.rb#11
  def detect_packages; end

  # Returns the value of attribute detect_packages.
  #
  # source://licensee//lib/licensee/projects/project.rb#11
  def detect_packages?; end

  # Returns the value of attribute detect_readme.
  #
  # source://licensee//lib/licensee/projects/project.rb#11
  def detect_readme; end

  # Returns the value of attribute detect_readme.
  #
  # source://licensee//lib/licensee/projects/project.rb#11
  def detect_readme?; end

  # source://licensee//lib/licensee/projects/project.rb#24
  def license; end

  # source://licensee//lib/licensee/projects/project.rb#50
  def license_file; end

  # source://licensee//lib/licensee/projects/project.rb#54
  def license_files; end

  # source://licensee//lib/licensee/projects/project.rb#35
  def licenses; end

  # source://licensee//lib/licensee/projects/project.rb#40
  def matched_file; end

  # source://licensee//lib/licensee/projects/project.rb#45
  def matched_files; end

  # source://licensee//lib/licensee/projects/project.rb#85
  def package_file; end

  # source://licensee//lib/licensee/projects/project.rb#68
  def readme; end

  # source://licensee//lib/licensee/projects/project.rb#68
  def readme_file; end

  private

  # source://licensee//lib/licensee/projects/project.rb#157
  def files; end

  # Given a block, passes each filename to that block, and expects a numeric
  # score in response. Returns a hash representing the top scoring file
  # or nil, if no file scored > 0
  #
  # source://licensee//lib/licensee/projects/project.rb#122
  def find_file(&block); end

  # Given a block, passes each filename to that block, and expects a numeric
  # score in response. Returns an array of all files with a score > 0,
  # sorted by file score descending
  #
  # source://licensee//lib/licensee/projects/project.rb#111
  def find_files; end

  # @return [Boolean]
  #
  # source://licensee//lib/licensee/projects/project.rb#102
  def lgpl?; end

  # source://licensee//lib/licensee/projects/project.rb#153
  def licenses_without_copyright; end

  # source://licensee//lib/licensee/projects/project.rb#161
  def load_file(_file); end

  # source://licensee//lib/licensee/projects/project.rb#137
  def prioritize_lgpl(files); end

  # source://licensee//lib/licensee/projects/project.rb#147
  def project_files; end
end

# source://licensee//lib/licensee/projects/project.rb#16
Licensee::Projects::Project::HASH_METHODS = T.let(T.unsafe(nil), Array)

# source://licensee//lib/licensee/rule.rb#4
class Licensee::Rule
  include ::Licensee::HashHelper

  # @return [Rule] a new instance of Rule
  #
  # source://licensee//lib/licensee/rule.rb#10
  def initialize(tag: T.unsafe(nil), label: T.unsafe(nil), description: T.unsafe(nil), group: T.unsafe(nil)); end

  # Returns the value of attribute description.
  #
  # source://licensee//lib/licensee/rule.rb#5
  def description; end

  # Returns the value of attribute group.
  #
  # source://licensee//lib/licensee/rule.rb#5
  def group; end

  # source://licensee//lib/licensee/rule.rb#17
  def inspect; end

  # Returns the value of attribute label.
  #
  # source://licensee//lib/licensee/rule.rb#5
  def label; end

  # Returns the value of attribute tag.
  #
  # source://licensee//lib/licensee/rule.rb#5
  def tag; end

  class << self
    # source://licensee//lib/licensee/rule.rb#22
    def all; end

    # source://licensee//lib/licensee/rule.rb#40
    def file_path; end

    # source://licensee//lib/licensee/rule.rb#35
    def find_by_tag(tag, group = T.unsafe(nil)); end

    # source://licensee//lib/licensee/rule.rb#35
    def find_by_tag_and_group(tag, group = T.unsafe(nil)); end

    # source://licensee//lib/licensee/rule.rb#49
    def groups; end

    # source://licensee//lib/licensee/rule.rb#45
    def raw_rules; end
  end
end

# source://licensee//lib/licensee/rule.rb#8
Licensee::Rule::HASH_METHODS = T.let(T.unsafe(nil), Array)

# source://licensee//lib/licensee/version.rb#4
Licensee::VERSION = T.let(T.unsafe(nil), String)
