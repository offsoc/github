{"version":3,"file":"chunk-app_components_notifications_notification-shelf-watcher-element_ts-xxxxxxxxxxxx.js","mappings":"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","sources":["app/assets/modules/github/notifications/v2/notification-shelf-referrer-params.ts","app/components/notifications/notification-shelf-watcher-element.ts"],"sourcesContent":["import {getItem, removeItem, setItem} from '@github-ui/safe-storage/session-storage'\n\ntype ShelfReferrerParams = {\n  notification_referrer_id?: string\n  notifications_before?: string\n  notifications_after?: string\n  notifications_query?: string\n}\n\nconst shelfParams: Array<keyof ShelfReferrerParams> = [\n  'notification_referrer_id',\n  'notifications_before',\n  'notifications_after',\n  'notifications_query',\n]\n\nconst sessionStorageKey = 'notification_shelf'\n\n/*\n * Stores url params for the shelf in session storage if present, and returns\n * search params without any shelf params.\n */\nexport function storeAndStripShelfParams(\n  searchParams: URLSearchParams,\n  pathname: string | null = null,\n): URLSearchParams | null {\n  if (searchParams.has('notification_referrer_id')) {\n    storeShelfParams(searchParams, pathname)\n    return deleteShelfParams(searchParams)\n  }\n  return null\n}\n\n/*\n * Loads the shelf params from sessionStorage if they are there and they match\n * the current pull request page, clear them otherwise.\n */\nexport function getStoredShelfParamsForCurrentPage(pathname: string | null = null): ShelfReferrerParams | null {\n  // If the current page is not a pull request, then the stored data will\n  // not match, so clear it and move on.\n  const currentPullRequestPathname = getCurrentPullRequestPathname(pathname)\n  if (!currentPullRequestPathname) {\n    removeItem(sessionStorageKey)\n    return null\n  }\n\n  try {\n    const str = getItem(sessionStorageKey)\n    if (!str) return null\n\n    const stored = JSON.parse(str)\n    if (!stored || !stored.pathname) throw new Error('Must have a pathname')\n\n    if (stored.pathname !== currentPullRequestPathname) {\n      throw new Error('Stored pathname does not match current pathname.')\n    }\n\n    const result: ShelfReferrerParams = {}\n\n    for (const key of shelfParams) {\n      result[key] = stored[key]\n    }\n\n    return result\n  } catch (e) {\n    removeItem(sessionStorageKey)\n    return null\n  }\n}\n\nfunction storeShelfParams(searchParams: URLSearchParams, pathname: string | null) {\n  const pullRequestPathname = getCurrentPullRequestPathname(pathname)\n  if (!pullRequestPathname) return\n\n  const params: {[key: string]: string} = {\n    pathname: pullRequestPathname,\n  }\n\n  for (const key of shelfParams) {\n    const value = searchParams.get(key)\n    if (value) params[key] = value\n  }\n\n  setItem(sessionStorageKey, JSON.stringify(params))\n}\n\nfunction deleteShelfParams(searchParams: URLSearchParams): URLSearchParams {\n  for (const key of shelfParams) {\n    searchParams.delete(key)\n  }\n  return searchParams\n}\n\n/*\n * Returns the base pathname of the current page if it's a pull request.\n *\n * `/github/github/pull/123/files` -> `/github/github/pull/123`\n */\nfunction getCurrentPullRequestPathname(pathname: string | null): string | null {\n  pathname = pathname || window.location.pathname\n  const pullRequestPathnameRegex = /^(\\/[^/]+\\/[^/]+\\/pull\\/[^/]+)/\n  const match = pathname.match(pullRequestPathnameRegex)\n  if (!match) return null\n\n  return match[0]\n}\n","import {attr, controller} from '@github/catalyst'\nimport {updateContent} from '@github-ui/updatable-content'\nimport {getStoredShelfParamsForCurrentPage} from '../../assets/modules/github/notifications/v2/notification-shelf-referrer-params'\n\n/**\n * NotificationShelfWatcherElement\n * This element will load the notification top shelf bar asynchronously to reduce the page dependency with notifications clusters\n * It will also listen to channel updates to update the form. This is done because some notifications are marked as read asynchronously\n * which means the form might not have the latest data on first load\n */\n@controller\nexport class NotificationShelfWatcherElement extends HTMLElement {\n  @attr baseUrl: string\n  @attr refreshDelay = 500 // ms\n\n  src: string | void\n  timeout: ReturnType<typeof setTimeout> | void\n\n  connectedCallback() {\n    this.preload()\n    this.update()\n    this.addEventListener('socket:message', this.update.bind(this))\n  }\n\n  preload() {\n    this.src = this.preloadSrc()\n  }\n\n  preloadSrc(): string {\n    const src = this.getAttribute('src')\n    if (src && src !== '') {\n      const link = this.ownerDocument.createElement('a')\n      link.href = src\n      return link.href\n    }\n\n    // Try to load the src from the storage\n    // This is useful for when the page is reloaded and it doesn't have the notification_referrer_id in the URL\n    // anymore because it was removed on first load\n    if (!this.baseUrl) {\n      return ''\n    }\n\n    const params = getStoredShelfParamsForCurrentPage()\n    if (!params) {\n      return ''\n    }\n\n    const shelfURL = new URL(this.baseUrl, window.location.origin)\n    const searchParams = new URLSearchParams(shelfURL.search)\n\n    for (const [key, value] of Object.entries(params)) {\n      if (typeof value === 'string') {\n        searchParams.set(key, value)\n      }\n    }\n    shelfURL.search = searchParams.toString()\n\n    return shelfURL.toString()\n  }\n\n  async update() {\n    if (this.timeout) {\n      clearTimeout(this.timeout)\n    }\n\n    if (!this.src || this.src === '') {\n      return\n    }\n\n    const el = this.placeholder()\n    if (!el) {\n      return\n    }\n\n    const isInitial = el.hasAttribute('data-initial')\n\n    el.setAttribute('data-url', this.src)\n    await updateContent(el)\n\n    if (isInitial) {\n      this.refresh()\n    }\n  }\n\n  placeholder(): HTMLElement | null {\n    return document.querySelector<HTMLElement>(\"[data-target='notification-shelf-watcher.placeholder']\")\n  }\n\n  refresh() {\n    const el = this.placeholder()\n    if (!el) {\n      return\n    }\n\n    const inner = el.querySelector(\"[data-notification-status='unread']\")\n\n    // First time loading and the content is shown as unread. This could be because the\n    // `mark_as_read` action in the controller was delayed. Try to fetch it again.\n    if (inner) {\n      this.timeout = setTimeout(() => this.update(), this.refreshDelay)\n    }\n  }\n}\n"],"names":["shelfParams","sessionStorageKey","storeAndStripShelfParams","searchParams","pathname","has","storeShelfParams","pullRequestPathname","getCurrentPullRequestPathname","params","key","value","get","setItem","JSON","stringify","deleteShelfParams","delete","getStoredShelfParamsForCurrentPage","currentPullRequestPathname","removeItem","str","getItem","stored","parse","result","e","match","window","location","NotificationShelfWatcherElement","HTMLElement","connectedCallback","preload","update","addEventListener","bind","src","preloadSrc","getAttribute","link","ownerDocument","createElement","href","baseUrl","shelfURL","URL","origin","URLSearchParams","search","Object","entries","set","toString","timeout","clearTimeout","el","placeholder","isInitial","hasAttribute","setAttribute","updateContent","refresh","document","querySelector","setTimeout","refreshDelay","attr","controller"],"sourceRoot":""}