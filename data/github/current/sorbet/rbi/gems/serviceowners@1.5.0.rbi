# typed: true

# DO NOT EDIT MANUALLY
# This is an autogenerated file for types exported from the `serviceowners` gem.
# Please instead update this file by running `bin/tapioca gem serviceowners`.

# source://serviceowners//lib/serviceowners/error.rb#4
module Serviceowners; end

# source://serviceowners//lib/serviceowners/concerns/presence.rb#5
module Serviceowners::Concerns; end

# A simple mixin to roughly match Rails' `presence` method.
#
# source://serviceowners//lib/serviceowners/concerns/presence.rb#7
module Serviceowners::Concerns::Presence
  # source://serviceowners//lib/serviceowners/concerns/presence.rb#11
  sig { params(val: T.nilable(::String)).returns(T.nilable(::String)) }
  def presence(val); end
end

# source://serviceowners//lib/serviceowners/error.rb#5
class Serviceowners::Error < ::StandardError; end

# Representation of an escalation policy for a given severity
#
# source://serviceowners//lib/serviceowners/escalation_policy.rb#8
class Serviceowners::EscalationPolicy
  include ::Serviceowners::Concerns::Presence

  # source://serviceowners//lib/serviceowners/escalation_policy.rb#13
  sig { params(properties: T::Hash[::Symbol, ::String]).void }
  def initialize(properties); end

  # source://serviceowners//lib/serviceowners/escalation_policy.rb#18
  sig { returns(T.nilable(::String)) }
  def alert_slack; end
end

# A faster way to get a list of files for a given subdirectory than iterating through the entire list of paths
#
# source://serviceowners//lib/serviceowners/file_index.rb#6
class Serviceowners::FileIndex
  # @return [FileIndex] a new instance of FileIndex
  #
  # source://serviceowners//lib/serviceowners/file_index.rb#7
  def initialize(file_list); end

  # Returns true if any file matches `pattern`
  #
  # @return [Boolean]
  #
  # source://serviceowners//lib/serviceowners/file_index.rb#24
  def any_file?(pattern); end

  # source://serviceowners//lib/serviceowners/file_index.rb#28
  def files; end

  # @return [Array<String>] Filenames that _might_ match `pattern`. (If `pattern` is a glob,
  #   the returned files should be searched again.)
  #
  # source://serviceowners//lib/serviceowners/file_index.rb#13
  def potential_matches(pattern); end

  # Eagerly load the entire file index. Useful when checking file index in parallel
  # to avoid loading the index in each subprocess.
  #
  # source://serviceowners//lib/serviceowners/file_index.rb#34
  def preload_all_files!; end

  private

  # source://serviceowners//lib/serviceowners/file_index.rb#43
  def add_path(path); end

  # source://serviceowners//lib/serviceowners/file_index.rb#55
  def file_index; end

  # source://serviceowners//lib/serviceowners/file_index.rb#65
  def freeze_directory_tree!(dir); end

  # source://serviceowners//lib/serviceowners/file_index.rb#72
  def make_directory_index; end
end

# Data provider to allow service instances access to global data.
#
# @abstract Subclasses must implement the `abstract` methods below.
#
# source://serviceowners//lib/serviceowners/i_service_data_provider.rb#6
module Serviceowners::IServiceDataProvider
  interface!

  # @abstract
  #
  # source://serviceowners//lib/serviceowners/i_service_data_provider.rb#13
  sig { abstract.params(org_name: T.any(::String, ::Symbol)).returns(::String) }
  def exec_for(org_name); end

  # @abstract
  #
  # source://serviceowners//lib/serviceowners/i_service_data_provider.rb#19
  sig { abstract.params(package_name: ::String).returns(T.nilable(::Serviceowners::Service)) }
  def service_for_package(package_name); end

  # @abstract
  #
  # source://serviceowners//lib/serviceowners/i_service_data_provider.rb#16
  sig { abstract.params(team_name: T.any(::String, ::Symbol)).returns(T.nilable(::Serviceowners::Team)) }
  def team_for(team_name); end
end

# source://serviceowners//lib/serviceowners/internal/class_parser.rb#10
module Serviceowners::Internal; end

# NOTE: this was inspired by and shares a lot of code with GitHub::BonesExporter::TestSuiteParser
# a good opportunity for refactoring if anyone wants to get into some AST and refactoring!
#
# source://serviceowners//lib/serviceowners/internal/class_parser.rb#13
class Serviceowners::Internal::ClassParser
  # @return [ClassParser] a new instance of ClassParser
  #
  # source://serviceowners//lib/serviceowners/internal/class_parser.rb#18
  def initialize(path, source = T.unsafe(nil)); end

  # source://serviceowners//lib/serviceowners/internal/class_parser.rb#23
  def parse; end

  # Returns the value of attribute path.
  #
  # source://serviceowners//lib/serviceowners/internal/class_parser.rb#14
  def path; end

  # Sets the attribute path
  #
  # @param value the value to set the attribute path to.
  #
  # source://serviceowners//lib/serviceowners/internal/class_parser.rb#14
  def path=(_arg0); end

  # Returns the value of attribute source.
  #
  # source://serviceowners//lib/serviceowners/internal/class_parser.rb#14
  def source; end

  # Sets the attribute source
  #
  # @param value the value to set the attribute source to.
  #
  # source://serviceowners//lib/serviceowners/internal/class_parser.rb#14
  def source=(_arg0); end

  private

  # source://serviceowners//lib/serviceowners/internal/class_parser.rb#69
  def builder; end

  # source://serviceowners//lib/serviceowners/internal/class_parser.rb#38
  def class_name(node); end

  # @return [Boolean]
  #
  # source://serviceowners//lib/serviceowners/internal/class_parser.rb#89
  def class_or_module?(node); end

  # source://serviceowners//lib/serviceowners/internal/class_parser.rb#76
  def extract_klass_and_module_nodes(node); end
end

# source://serviceowners//lib/serviceowners/internal/class_parser.rb#16
Serviceowners::Internal::ClassParser::EMPTY = T.let(T.unsafe(nil), Array)

# An internal class encapsulating the logic for generating service links
#
# source://serviceowners//lib/serviceowners/internal/service_links.rb#7
class Serviceowners::Internal::ServiceLinks
  # @return [ServiceLinks] a new instance of ServiceLinks
  #
  # source://serviceowners//lib/serviceowners/internal/service_links.rb#8
  def initialize(service); end

  # source://serviceowners//lib/serviceowners/internal/service_links.rb#12
  def to_a; end

  private

  # source://serviceowners//lib/serviceowners/internal/service_links.rb#58
  def ae_dashboard; end

  # source://serviceowners//lib/serviceowners/internal/service_links.rb#84
  def ae_playbook; end

  # source://serviceowners//lib/serviceowners/internal/service_links.rb#98
  def bones; end

  # source://serviceowners//lib/serviceowners/internal/service_links.rb#34
  def datadog; end

  # source://serviceowners//lib/serviceowners/internal/service_links.rb#108
  def description; end

  # source://serviceowners//lib/serviceowners/internal/service_links.rb#46
  def looker; end

  # source://serviceowners//lib/serviceowners/internal/service_links.rb#72
  def playbook; end

  # source://serviceowners//lib/serviceowners/internal/service_links.rb#24
  def sentry; end

  # Returns the value of attribute service.
  #
  # source://serviceowners//lib/serviceowners/internal/service_links.rb#22
  def service; end
end

# Primary entrypoint
#
# source://serviceowners//lib/serviceowners.rb#19
class Serviceowners::Main
  extend ::Forwardable

  # source://serviceowners//lib/serviceowners.rb#24
  sig { params(runtime_env: ::Serviceowners::RuntimeEnv).void }
  def initialize(runtime_env: T.unsafe(nil)); end

  # source://serviceowners//lib/serviceowners.rb#95
  sig { returns(::Serviceowners::FileIndex) }
  def file_index; end

  # source://serviceowners//lib/serviceowners.rb#82
  sig { returns(::Serviceowners::PathData) }
  def path_data; end

  # source://serviceowners//lib/serviceowners.rb#77
  sig { returns(T::Array[::String]) }
  def paths; end

  # source://serviceowners//lib/serviceowners.rb#38
  sig { params(klass: ::String).returns(T.nilable(::Serviceowners::Service)) }
  def service_for_class(klass); end

  # source://forwardable/1.3.3/forwardable.rb#231
  def service_mappings(*args, **_arg1, &block); end

  # source://forwardable/1.3.3/forwardable.rb#231
  def service_patterns(*args, **_arg1, &block); end

  # source://serviceowners//lib/serviceowners.rb#72
  sig { returns(T::Array[::Serviceowners::Service]) }
  def services; end

  # source://serviceowners//lib/serviceowners.rb#33
  sig { params(path: ::String).returns(T.nilable(::Serviceowners::PatternSpec)) }
  def spec_for_path(path); end

  # source://serviceowners//lib/serviceowners.rb#53
  sig { params(left_just: ::Integer).returns(::String) }
  def to_codeowners(left_just = T.unsafe(nil)); end

  # source://serviceowners//lib/serviceowners.rb#58
  sig { returns(T::Hash[::String, T.untyped]) }
  def to_ownership; end

  # source://serviceowners//lib/serviceowners.rb#65
  sig { returns(T::Hash[::String, T.untyped]) }
  def to_service_links; end

  # source://serviceowners//lib/serviceowners.rb#47
  sig { void }
  def validate!; end

  # @raise [Serviceowners::PathChangeError]
  #
  # source://serviceowners//lib/serviceowners.rb#87
  sig { returns(T::Boolean) }
  def validate_local_changes!; end

  private

  # source://serviceowners//lib/serviceowners.rb#102
  sig { returns(T::Array[::String]) }
  def find_missing_services_and_paths; end
end

# Encapsulation of metric data about the given service, based on the paths
# with which it is associated.
#
# source://serviceowners//lib/serviceowners/metrics.rb#9
class Serviceowners::Metrics
  # @return [Metrics] a new instance of Metrics
  #
  # source://serviceowners//lib/serviceowners/metrics.rb#10
  def initialize(service); end

  # source://serviceowners//lib/serviceowners/metrics.rb#33
  def <=>(other); end

  # source://serviceowners//lib/serviceowners/metrics.rb#25
  def file_count; end

  # source://serviceowners//lib/serviceowners/metrics.rb#29
  def line_count; end

  # Returns the value of attribute paths.
  #
  # source://serviceowners//lib/serviceowners/metrics.rb#15
  def paths; end

  # source://serviceowners//lib/serviceowners/metrics.rb#21
  def push_path(path); end

  # source://serviceowners//lib/serviceowners/metrics.rb#17
  def ruby_paths; end

  # Returns the value of attribute service.
  #
  # source://serviceowners//lib/serviceowners/metrics.rb#15
  def service; end

  private

  # source://serviceowners//lib/serviceowners/metrics.rb#42
  def path_line_count(path); end
end

# An internal class encapsulating generation of the ownership hash for ownership.yaml output
#
# @abstract Subclasses must implement the `abstract` methods below.
#
# source://serviceowners//lib/serviceowners/ownership.rb#8
module Serviceowners::Ownership
  include ::Kernel

  requires_ancestor { Serviceowners::ServiceProperties }

  abstract!

  # @abstract
  #
  # source://serviceowners//lib/serviceowners/ownership.rb#26
  sig { abstract.returns(::String) }
  def human_name; end

  # @abstract
  #
  # source://serviceowners//lib/serviceowners/ownership.rb#29
  sig { abstract.returns(T::Array[::String]) }
  def package_dependencies; end

  # @abstract
  #
  # source://serviceowners//lib/serviceowners/ownership.rb#23
  sig { abstract.returns(::String) }
  def qualified_name; end

  # source://serviceowners//lib/serviceowners/ownership.rb#31
  def to_ownership; end

  private

  # source://serviceowners//lib/serviceowners/ownership.rb#42
  def base_ownership; end

  # source://serviceowners//lib/serviceowners/ownership.rb#126
  sig { returns(T.nilable(T::Array[::String])) }
  def build_dependencies; end

  # source://serviceowners//lib/serviceowners/ownership.rb#62
  def detailed_ownership; end

  # source://serviceowners//lib/serviceowners/ownership.rb#81
  def optional_detailed_ownership_values; end

  # source://serviceowners//lib/serviceowners/ownership.rb#52
  def optional_ownership; end

  # source://serviceowners//lib/serviceowners/ownership.rb#102
  def sev1_escalation_policy(pagerduty); end

  # source://serviceowners//lib/serviceowners/ownership.rb#110
  def sev2_escalation_policy; end

  # source://serviceowners//lib/serviceowners/ownership.rb#118
  def sev3_escalation_policy(team_slack); end

  # source://serviceowners//lib/serviceowners/ownership.rb#72
  def sort_ownership(ownership); end

  # source://serviceowners//lib/serviceowners/ownership.rb#91
  def team_escalations; end
end

# source://serviceowners//lib/serviceowners/ownership.rb#12
Serviceowners::Ownership::KEY_ORDER = T.let(T.unsafe(nil), Array)

# source://serviceowners//lib/serviceowners/parse_error.rb#7
class Serviceowners::ParseError < ::Serviceowners::Error; end

# Error raised when one of the files being examined (changed) doesn't match serviceowner expectations.
#
# source://serviceowners//lib/serviceowners/path_change_error.rb#8
class Serviceowners::PathChangeError < ::Serviceowners::Error
  # @return [PathChangeError] a new instance of PathChangeError
  #
  # source://serviceowners//lib/serviceowners/path_change_error.rb#14
  def initialize(path_status_messages); end

  # Returns the value of attribute path_status_messages.
  #
  # source://serviceowners//lib/serviceowners/path_change_error.rb#19
  def path_status_messages; end
end

# source://serviceowners//lib/serviceowners/path_change_error.rb#9
Serviceowners::PathChangeError::MESSAGE = T.let(T.unsafe(nil), String)

# This class manages the association between paths and the services that they belong to
# according to the rules in the provided service_patterns object.
#
# source://serviceowners//lib/serviceowners/path_data.rb#12
class Serviceowners::PathData
  # @return [PathData] a new instance of PathData
  #
  # source://serviceowners//lib/serviceowners/path_data.rb#13
  def initialize(paths, service_patterns); end

  # Deprecated: Builds a "best guess" map of classes to paths. It's just a guess because Ruby
  # allows us to reopen classes as many times as we like so some of our classes are defined in
  # dozens of files with varying serviceowners.
  #
  # source://serviceowners//lib/serviceowners/path_data.rb#23
  def build_class_cache; end

  # source://serviceowners//lib/serviceowners/path_data.rb#44
  def build_path_cache; end

  # source://serviceowners//lib/serviceowners/path_data.rb#67
  def metrics; end

  # source://serviceowners//lib/serviceowners/path_data.rb#56
  def path_specs; end

  # Returns the value of attribute paths.
  #
  # source://serviceowners//lib/serviceowners/path_data.rb#18
  def paths; end

  # Returns the value of attribute service_patterns.
  #
  # source://serviceowners//lib/serviceowners/path_data.rb#18
  def service_patterns; end
end

# A simple container class representing a change to a path and its git status
#
# source://serviceowners//lib/serviceowners/path_status.rb#6
class Serviceowners::PathStatus
  # @return [PathStatus] a new instance of PathStatus
  #
  # source://serviceowners//lib/serviceowners/path_status.rb#7
  def initialize(path_status_line); end

  # @return [Boolean]
  #
  # source://serviceowners//lib/serviceowners/path_status.rb#35
  def created?; end

  # @return [Boolean]
  #
  # source://serviceowners//lib/serviceowners/path_status.rb#27
  def deleted?; end

  # Public: Is this a valid change for the given service patterns? If not, returns
  # an error message describing the problem. Otherwise returns nil.
  #
  # source://serviceowners//lib/serviceowners/path_status.rb#15
  def error_message(service_patterns, file_index); end

  # @return [Boolean]
  #
  # source://serviceowners//lib/serviceowners/path_status.rb#31
  def modified?; end

  # Returns the value of attribute path.
  #
  # source://serviceowners//lib/serviceowners/path_status.rb#11
  def path; end

  # Returns the value of attribute status.
  #
  # source://serviceowners//lib/serviceowners/path_status.rb#11
  def status; end
end

# A pattern which describes a set of files
#
# source://serviceowners//lib/serviceowners/pattern.rb#6
class Serviceowners::Pattern
  # source://serviceowners//lib/serviceowners/pattern.rb#15
  sig { params(text: ::String).void }
  def initialize(text); end

  # source://serviceowners//lib/serviceowners/pattern.rb#97
  sig { params(other: ::Object).returns(T.nilable(::Integer)) }
  def <=>(other); end

  # TODO: hack for api-reviewers
  #
  # source://serviceowners//lib/serviceowners/pattern.rb#53
  sig { returns(T::Boolean) }
  def api?; end

  # TODO: hack for api-reviewers
  #
  # source://serviceowners//lib/serviceowners/pattern.rb#47
  sig { returns(T::Boolean) }
  def broad?; end

  # source://serviceowners//lib/serviceowners/pattern.rb#25
  sig { returns(T::Boolean) }
  def directory?; end

  # source://serviceowners//lib/serviceowners/pattern.rb#133
  sig { params(other: ::Object).returns(T::Boolean) }
  def eql?(other); end

  # source://serviceowners//lib/serviceowners/pattern.rb#35
  sig { returns(T::Boolean) }
  def file?; end

  # source://serviceowners//lib/serviceowners/pattern.rb#30
  sig { returns(T::Boolean) }
  def glob?; end

  # source://serviceowners//lib/serviceowners/pattern.rb#128
  sig { returns(::Integer) }
  def hash; end

  # source://serviceowners//lib/serviceowners/pattern.rb#63
  sig { params(path: ::String).returns(T::Boolean) }
  def matches?(path); end

  # source://serviceowners//lib/serviceowners/pattern.rb#81
  sig { returns(T::Array[::String]) }
  def non_glob_parts; end

  # source://serviceowners//lib/serviceowners/pattern.rb#76
  sig { returns(T::Array[::String]) }
  def parts; end

  # source://serviceowners//lib/serviceowners/pattern.rb#58
  sig { returns(T::Boolean) }
  def rest_api?; end

  # source://serviceowners//lib/serviceowners/pattern.rb#22
  sig { returns(::String) }
  def text; end

  # source://serviceowners//lib/serviceowners/pattern.rb#119
  sig { returns(::String) }
  def to_codeowners; end

  # source://serviceowners//lib/serviceowners/pattern.rb#114
  sig { returns(::String) }
  def to_s; end

  # TODO: hack for api-reviewers
  #
  # source://serviceowners//lib/serviceowners/pattern.rb#41
  sig { returns(T::Boolean) }
  def twirp?; end

  # source://serviceowners//lib/serviceowners/pattern.rb#86
  sig { returns(::Symbol) }
  def type; end

  protected

  # source://serviceowners//lib/serviceowners/pattern.rb#140
  sig { returns(::Integer) }
  def type_precedence; end

  private

  # source://serviceowners//lib/serviceowners/pattern.rb#150
  sig { params(text: ::String).returns(T::Boolean) }
  def contains_globbing?(text); end

  # Returns true if the provided path matches the glob pattern.
  #
  # source://serviceowners//lib/serviceowners/pattern.rb#156
  sig { params(path: ::String).returns(T::Boolean) }
  def glob_match?(path); end
end

# only match glob special characters:
# https://ruby-doc.org/core-2.7.0/File.html#method-c-fnmatch
#
# source://serviceowners//lib/serviceowners/pattern.rb#11
Serviceowners::Pattern::GLOB_REGEX = T.let(T.unsafe(nil), Regexp)

# source://serviceowners//lib/serviceowners/pattern.rb#12
Serviceowners::Pattern::TWIRP_PREFIX = T.let(T.unsafe(nil), String)

# A pattern, service, and reviewer group list describing a
# set of files owned by a service and reviewed by zero or more groups.
#
# source://serviceowners//lib/serviceowners/pattern_spec.rb#7
class Serviceowners::PatternSpec
  # @raise [ArgumentError]
  #
  # source://serviceowners//lib/serviceowners/pattern_spec.rb#14
  sig do
    params(
      pattern: T.any(::Serviceowners::Pattern, ::String),
      service: T.nilable(::Serviceowners::Service),
      review_groups: T::Array[[::String, ::Serviceowners::Team]],
      no_reviews: T::Boolean
    ).void
  end
  def initialize(pattern, service, review_groups: T.unsafe(nil), no_reviews: T.unsafe(nil)); end

  # source://serviceowners//lib/serviceowners/pattern_spec.rb#47
  sig { params(other: T.untyped).returns(T.nilable(::Integer)) }
  def <=>(other); end

  # source://serviceowners//lib/serviceowners/pattern_spec.rb#105
  sig { params(spec: ::Serviceowners::PatternSpec).void }
  def extend_review_groups!(spec); end

  # @return [String]
  #
  # source://sorbet-runtime/0.5.11284/lib/types/private/methods/_methods.rb#257
  def inspect(*args, **_arg1, &blk); end

  # source://serviceowners//lib/serviceowners/pattern_spec.rb#78
  sig { params(path: ::String).returns(T::Boolean) }
  def matches?(path); end

  # source://serviceowners//lib/serviceowners/pattern_spec.rb#37
  sig { returns(T::Boolean) }
  def no_reviews?; end

  # source://serviceowners//lib/serviceowners/pattern_spec.rb#28
  sig { returns(::Serviceowners::Pattern) }
  def pattern; end

  # source://serviceowners//lib/serviceowners/pattern_spec.rb#34
  sig { returns(T::Set[[T.nilable(::String), ::Serviceowners::Team]]) }
  def review_groups; end

  # source://serviceowners//lib/serviceowners/pattern_spec.rb#73
  sig { returns(T::Array[::String]) }
  def review_groups_names; end

  # source://serviceowners//lib/serviceowners/pattern_spec.rb#42
  sig { returns(T::Boolean) }
  def review_groups_only?; end

  # source://serviceowners//lib/serviceowners/pattern_spec.rb#68
  sig { returns(T::Array[::Serviceowners::Team]) }
  def review_groups_teams; end

  # source://serviceowners//lib/serviceowners/pattern_spec.rb#31
  sig { returns(T.nilable(::Serviceowners::Service)) }
  def service; end

  # source://serviceowners//lib/serviceowners/pattern_spec.rb#63
  sig { returns(T::Array[::Serviceowners::Team]) }
  def teams; end

  # source://serviceowners//lib/serviceowners/pattern_spec.rb#54
  sig { params(ljust: ::Integer).returns(T.nilable(::String)) }
  def to_codeowners(ljust = T.unsafe(nil)); end

  # source://serviceowners//lib/serviceowners/pattern_spec.rb#83
  sig { returns(::String) }
  def to_s; end

  # source://serviceowners//lib/serviceowners/pattern_spec.rb#94
  sig { returns(::String) }
  def to_serviceowners; end

  private

  # source://serviceowners//lib/serviceowners/pattern_spec.rb#119
  sig { params(name: ::String, team: ::Serviceowners::Team).void }
  def add_group(name, team); end
end

# Contains all user-configurable properties used in serviceowner evaluation.
#
# source://serviceowners//lib/serviceowners/runtime_env.rb#12
class Serviceowners::RuntimeEnv
  # @return [RuntimeEnv] a new instance of RuntimeEnv
  #
  # source://serviceowners//lib/serviceowners/runtime_env.rb#21
  def initialize(config = T.unsafe(nil)); end

  # source://serviceowners//lib/serviceowners/runtime_env.rb#70
  def changed_paths; end

  # source://serviceowners//lib/serviceowners/runtime_env.rb#74
  def class_cache; end

  # Returns the value of attribute mappings_path.
  #
  # source://serviceowners//lib/serviceowners/runtime_env.rb#31
  def mappings_path; end

  # @return [Boolean]
  #
  # source://serviceowners//lib/serviceowners/runtime_env.rb#99
  def path_changed?(path); end

  # @raise [Error]
  #
  # source://serviceowners//lib/serviceowners/runtime_env.rb#80
  def path_status_lines; end

  # source://serviceowners//lib/serviceowners/runtime_env.rb#92
  def paths; end

  # Returns the value of attribute patterns_path.
  #
  # source://serviceowners//lib/serviceowners/runtime_env.rb#31
  def patterns_path; end

  # source://serviceowners//lib/serviceowners/runtime_env.rb#33
  def service_mappings; end

  # source://serviceowners//lib/serviceowners/runtime_env.rb#45
  def service_patterns; end

  # @return [Boolean]
  #
  # source://serviceowners//lib/serviceowners/runtime_env.rb#66
  def skip_modified?; end

  # @return [Boolean]
  #
  # source://serviceowners//lib/serviceowners/runtime_env.rb#54
  def validate_mappings?; end

  # @return [Boolean]
  #
  # source://serviceowners//lib/serviceowners/runtime_env.rb#60
  def validate_patterns?; end

  class << self
    # source://serviceowners//lib/serviceowners/runtime_env.rb#41
    sig { params(path: ::String).returns(T.nilable(T::Hash[::Symbol, T.untyped])) }
    def load_yaml(path); end
  end
end

# source://serviceowners//lib/serviceowners/runtime_env.rb#15
Serviceowners::RuntimeEnv::DEFAULT_MAPPINGS_PATH = T.let(T.unsafe(nil), String)

# source://serviceowners//lib/serviceowners/runtime_env.rb#16
Serviceowners::RuntimeEnv::DEFAULT_PATTERNS_PATH = T.let(T.unsafe(nil), String)

# source://serviceowners//lib/serviceowners/runtime_env.rb#18
Serviceowners::RuntimeEnv::PUBLIC_ATTRIBUTES = T.let(T.unsafe(nil), Array)

# A service has a very large public method surface area which is dictated by the service catalog's
# requirements for ownership.yaml. As a result, we can't do much about this class being so long.
#
# source://serviceowners//lib/serviceowners/service.rb#16
class Serviceowners::Service
  include ::Serviceowners::Concerns::Presence
  include ::Serviceowners::ServiceProperties
  include ::Serviceowners::Ownership

  # source://serviceowners//lib/serviceowners/service.rb#35
  sig do
    params(
      name: ::Symbol,
      properties: T::Hash[::Symbol, T.untyped],
      service_data_provider: ::Serviceowners::IServiceDataProvider
    ).void
  end
  def initialize(name, properties, service_data_provider); end

  # source://serviceowners//lib/serviceowners/service.rb#108
  sig { params(other: ::Serviceowners::Service).returns(T.nilable(::Integer)) }
  def <=>(other); end

  # source://serviceowners//lib/serviceowners/service.rb#75
  sig { returns(T::Boolean) }
  def github_service?; end

  # source://serviceowners//lib/serviceowners/service.rb#54
  sig { override.returns(::String) }
  def human_name; end

  # source://serviceowners//lib/serviceowners/service.rb#48
  sig { returns(::Symbol) }
  def name; end

  # Returns the package's dependencies that are also services. External dependencies
  # are included as specified in the package's YAML file.
  #
  # source://serviceowners//lib/serviceowners/service.rb#82
  sig { override.returns(T::Array[::String]) }
  def package_dependencies; end

  # source://serviceowners//lib/serviceowners/service.rb#51
  sig { override.returns(T::Hash[::Symbol, T.untyped]) }
  def properties; end

  # source://serviceowners//lib/serviceowners/service.rb#67
  sig { override.returns(::String) }
  def qualified_name; end

  # source://serviceowners//lib/serviceowners/service.rb#72
  sig { override.returns(::Serviceowners::IServiceDataProvider) }
  def service_data_provider; end

  # source://serviceowners//lib/serviceowners/service.rb#97
  sig { returns(T::Array[T::Hash[::String, T.untyped]]) }
  def to_service_links; end

  # source://serviceowners//lib/serviceowners/service.rb#102
  sig { void }
  def validate!; end

  private

  # source://serviceowners//lib/serviceowners/service.rb#115
  sig { returns(T.nilable(T::Hash[::Symbol, T.untyped])) }
  def package_data; end

  # source://serviceowners//lib/serviceowners/service.rb#122
  sig { returns(T::Array[::String]) }
  def package_external_dependencies; end
end

# source://serviceowners//lib/serviceowners/service.rb#22
Serviceowners::Service::NAME_MAPPINGS = T.let(T.unsafe(nil), Hash)

# A YAML file containing data mapping services to teams.
#
# source://serviceowners//lib/serviceowners/service_mappings.rb#13
class Serviceowners::ServiceMappings
  include ::Serviceowners::IServiceDataProvider

  # @return [ServiceMappings] a new instance of ServiceMappings
  #
  # source://serviceowners//lib/serviceowners/service_mappings.rb#18
  def initialize(mapping_data); end

  # source://serviceowners//lib/serviceowners/service_mappings.rb#55
  sig { override.params(org_name: T.any(::String, ::Symbol)).returns(::String) }
  def exec_for(org_name); end

  # source://serviceowners//lib/serviceowners/service_mappings.rb#72
  def inspect; end

  # source://serviceowners//lib/serviceowners/service_mappings.rb#41
  def review_group_for(name); end

  # source://serviceowners//lib/serviceowners/service_mappings.rb#45
  def review_group_names; end

  # source://serviceowners//lib/serviceowners/service_mappings.rb#50
  sig { params(name: T.any(::String, ::Symbol)).returns(T.nilable(::Serviceowners::Service)) }
  def service_for(name); end

  # source://serviceowners//lib/serviceowners/service_mappings.rb#60
  sig { override.params(package_name: ::String).returns(T.nilable(::Serviceowners::Service)) }
  def service_for_package(package_name); end

  # source://serviceowners//lib/serviceowners/service_mappings.rb#33
  sig { returns(T::Array[::Serviceowners::Service]) }
  def services; end

  # source://serviceowners//lib/serviceowners/service_mappings.rb#37
  def team_for(name); end

  # source://serviceowners//lib/serviceowners/service_mappings.rb#64
  def validate!; end

  private

  # source://serviceowners//lib/serviceowners/service_mappings.rb#145
  def assert_order(hash); end

  # source://serviceowners//lib/serviceowners/service_mappings.rb#111
  def build_services_from_hash(hash); end

  # source://serviceowners//lib/serviceowners/service_mappings.rb#117
  def review_groups_from_hash(hash); end

  # source://serviceowners//lib/serviceowners/service_mappings.rb#105
  def teams_from_hash(hash); end

  # Internal: validates the structure of the mapping data itself.
  #
  # source://serviceowners//lib/serviceowners/service_mappings.rb#129
  def validate_mapping_data(mapping_data); end

  # source://serviceowners//lib/serviceowners/service_mappings.rb#93
  def validate_package_assignments!; end

  # @raise [Error]
  #
  # source://serviceowners//lib/serviceowners/service_mappings.rb#78
  def validate_unused_orgs!; end

  # @raise [Error]
  #
  # source://serviceowners//lib/serviceowners/service_mappings.rb#85
  def validate_unused_teams!; end
end

# source://serviceowners//lib/serviceowners/service_mappings.rb#30
Serviceowners::ServiceMappings::ORG_DEFAULT_KEY = T.let(T.unsafe(nil), String)

# The collection of PatternSpec objects as described in a mapping file
# Example `SERVICEOWNERS`
#
# source://serviceowners//lib/serviceowners/service_patterns.rb#13
class Serviceowners::ServicePatterns
  extend T::Generic
  include ::Prelude::Enumerator
  include ::Enumerable
  extend ::Forwardable

  Elem = type_member { { fixed: Serviceowners::PatternSpec } }

  # source://serviceowners//lib/serviceowners/service_patterns.rb#29
  sig { params(service_mappings: ::Serviceowners::ServiceMappings).void }
  def initialize(service_mappings); end

  # @raise [Error]
  #
  # source://serviceowners//lib/serviceowners/service_patterns.rb#44
  sig { params(spec: ::Serviceowners::PatternSpec).void }
  def add_spec(spec); end

  # Internal: Compiles review-groups-only specs into the specs they apply to.
  #
  # source://serviceowners//lib/serviceowners/service_patterns.rb#89
  sig { void }
  def compile!; end

  # source://forwardable/1.3.3/forwardable.rb#231
  def each(*args, **_arg1, &block); end

  # source://serviceowners//lib/serviceowners/service_patterns.rb#107
  sig { void }
  def freeze; end

  # source://serviceowners//lib/serviceowners/service_patterns.rb#114
  sig { returns(::String) }
  def inspect; end

  # source://serviceowners//lib/serviceowners/service_patterns.rb#59
  sig { params(path: ::String).returns(T.nilable(::Serviceowners::PatternSpec)) }
  def match(path); end

  # source://serviceowners//lib/serviceowners/service_patterns.rb#74
  sig { void }
  def prepare!; end

  # source://serviceowners//lib/serviceowners/service_patterns.rb#25
  sig { returns(::Serviceowners::ServiceMappings) }
  def service_mappings; end

  # source://serviceowners//lib/serviceowners/service_patterns.rb#81
  sig { void }
  def sort!; end

  # Internal: Returning the spec itself from a subprocess is expensive as it is a complex object to serialize.
  # Instead, we return the object id and let the parent process look the spec up by that in a hash.
  #
  # source://serviceowners//lib/serviceowners/service_patterns.rb#69
  sig { params(id: ::Integer).returns(T.nilable(::Serviceowners::PatternSpec)) }
  def spec_for_object_id(id); end

  # source://serviceowners//lib/serviceowners/service_patterns.rb#54
  sig { params(left_just: ::Integer).returns(::String) }
  def to_codeowners(left_just = T.unsafe(nil)); end

  # source://serviceowners//lib/serviceowners/service_patterns.rb#119
  sig { params(file_index: ::Serviceowners::FileIndex).returns(T::Array[::Serviceowners::PatternSpec]) }
  def unmatched(file_index); end

  private

  # source://serviceowners//lib/serviceowners/service_patterns.rb#131
  sig { params(path: ::String).returns(T.nilable(::Serviceowners::PatternSpec)) }
  def direct_match_for(path); end

  # source://serviceowners//lib/serviceowners/service_patterns.rb#141
  sig { params(path: ::String).returns(T.nilable(::Serviceowners::PatternSpec)) }
  def indirect_match_for(path); end

  # source://serviceowners//lib/serviceowners/service_patterns.rb#136
  sig { params(path: ::String).returns(::String) }
  def prefix(path); end

  # source://serviceowners//lib/serviceowners/service_patterns.rb#154
  sig { params(spec: ::Serviceowners::PatternSpec).void }
  def update_caches(spec); end
end

# Canonical representation of the service properties originating from the service mappings yaml file.
#
# @abstract Subclasses must implement the `abstract` methods below.
#
# source://serviceowners//lib/serviceowners/service_properties.rb#6
module Serviceowners::ServiceProperties
  include ::Serviceowners::Concerns::Presence
  include ::Kernel

  abstract!

  # source://serviceowners//lib/serviceowners/service_properties.rb#32
  sig { returns(T.nilable(::Serviceowners::Team)) }
  def additional_review_team; end

  # source://serviceowners//lib/serviceowners/service_properties.rb#75
  sig { returns(T.nilable(::String)) }
  def ae_dashboard; end

  # source://serviceowners//lib/serviceowners/service_properties.rb#85
  sig { returns(T.nilable(::String)) }
  def ae_playbook; end

  # source://serviceowners//lib/serviceowners/service_properties.rb#118
  sig { returns(T.nilable(::String)) }
  def alert_issues; end

  # source://serviceowners//lib/serviceowners/service_properties.rb#143
  sig { returns(T.nilable(::String)) }
  def alert_slack; end

  # source://serviceowners//lib/serviceowners/service_properties.rb#148
  sig { params(severity: ::Serviceowners::Severity).returns(T.nilable(::String)) }
  def alert_slack_for_severity(severity); end

  # source://serviceowners//lib/serviceowners/service_properties.rb#95
  sig { returns(T::Boolean) }
  def component?; end

  # source://serviceowners//lib/serviceowners/service_properties.rb#41
  def component_of; end

  # source://serviceowners//lib/serviceowners/service_properties.rb#65
  sig { returns(T.nilable(::String)) }
  def datadog_dashboard; end

  # source://serviceowners//lib/serviceowners/service_properties.rb#60
  sig { returns(T::Array[::String]) }
  def dependencies; end

  # source://serviceowners//lib/serviceowners/service_properties.rb#50
  def description; end

  # source://serviceowners//lib/serviceowners/service_properties.rb#128
  sig { returns(::String) }
  def exec_sponsor; end

  # source://serviceowners//lib/serviceowners/service_properties.rb#22
  sig { returns(T.nilable(::String)) }
  def explicit_name; end

  # source://serviceowners//lib/serviceowners/service_properties.rb#110
  sig { returns(::String) }
  def issues; end

  # source://serviceowners//lib/serviceowners/service_properties.rb#90
  sig { returns(::String) }
  def kind; end

  # source://serviceowners//lib/serviceowners/service_properties.rb#70
  sig { returns(T.nilable(::String)) }
  def looker_dashboard; end

  # source://serviceowners//lib/serviceowners/service_properties.rb#27
  sig { returns(T.nilable(::Serviceowners::Team)) }
  def maintainers; end

  # source://serviceowners//lib/serviceowners/service_properties.rb#46
  sig { returns(T.nilable(::String)) }
  def package; end

  # source://serviceowners//lib/serviceowners/service_properties.rb#80
  sig { returns(T.nilable(::String)) }
  def playbook; end

  # source://serviceowners//lib/serviceowners/service_properties.rb#123
  sig { returns(T.nilable(::String)) }
  def product_manager; end

  # @abstract
  #
  # source://serviceowners//lib/serviceowners/service_properties.rb#16
  sig { abstract.returns(T::Hash[::Symbol, T.untyped]) }
  def properties; end

  # source://serviceowners//lib/serviceowners/service_properties.rb#105
  sig { returns(::String) }
  def qos; end

  # source://serviceowners//lib/serviceowners/service_properties.rb#100
  sig { returns(::String) }
  def repo; end

  # @abstract
  #
  # source://serviceowners//lib/serviceowners/service_properties.rb#19
  sig { abstract.returns(::Serviceowners::IServiceDataProvider) }
  def service_data_provider; end

  # source://serviceowners//lib/serviceowners/service_properties.rb#138
  sig { returns(T.nilable(::String)) }
  def support_squad_slack; end

  # source://serviceowners//lib/serviceowners/service_properties.rb#153
  sig { returns(T.nilable(T::Array[::String])) }
  def tags; end

  # source://serviceowners//lib/serviceowners/service_properties.rb#37
  sig { returns(T::Set[::Serviceowners::Team]) }
  def teams; end

  # source://serviceowners//lib/serviceowners/service_properties.rb#55
  sig { returns(T.nilable(::Integer)) }
  def tier; end

  protected

  # @raise [Error]
  #
  # source://serviceowners//lib/serviceowners/service_properties.rb#160
  sig { params(property: ::Symbol).returns(T.nilable(::Serviceowners::Team)) }
  def team_for(property); end
end

# The set of allowed severity levels
#
# source://serviceowners//lib/serviceowners/severity.rb#6
class Serviceowners::Severity < ::T::Enum
  enums do
    Sev1 = new
    Sev2 = new
    Sev3 = new
  end

  # source://serviceowners//lib/serviceowners/severity.rb#16
  sig { returns(::Symbol) }
  def to_sym; end
end

# A builder class responsible for generating a ServicePatterns instance
#
# source://serviceowners//lib/serviceowners/spec_builder.rb#10
class Serviceowners::SpecBuilder
  # source://serviceowners//lib/serviceowners/spec_builder.rb#18
  sig { params(service_mappings: ::Serviceowners::ServiceMappings).void }
  def initialize(service_mappings); end

  # source://serviceowners//lib/serviceowners/spec_builder.rb#41
  sig { params(content: ::String).void }
  def add_content(content); end

  # source://serviceowners//lib/serviceowners/spec_builder.rb#34
  sig { params(path: ::String).void }
  def add_directory(path); end

  # source://serviceowners//lib/serviceowners/spec_builder.rb#29
  sig { params(path: ::String).void }
  def add_file(path); end

  # source://serviceowners//lib/serviceowners/spec_builder.rb#24
  sig { params(path: ::String).void }
  def add_path(path); end

  # source://serviceowners//lib/serviceowners/spec_builder.rb#46
  sig { returns(Serviceowners::ServicePatterns) }
  def to_service_patterns; end

  private

  # @raise [Error]
  #
  # source://serviceowners//lib/serviceowners/spec_builder.rb#58
  sig { params(line: ::String).void }
  def add_line(line); end

  # source://serviceowners//lib/serviceowners/spec_builder.rb#92
  sig do
    params(
      pattern: ::Serviceowners::Pattern,
      service: T.nilable(::Serviceowners::Service),
      review_group_names: T::Array[::String]
    ).returns(::Serviceowners::PatternSpec)
  end
  def build_pattern_spec(pattern, service, review_group_names); end

  # @raise [Error]
  #
  # source://serviceowners//lib/serviceowners/spec_builder.rb#72
  sig { params(pattern_text: ::String, service_text: ::String).returns(::Serviceowners::PatternSpec) }
  def build_spec(pattern_text, service_text); end
end

# source://serviceowners//lib/serviceowners/spec_builder.rb#15
Serviceowners::SpecBuilder::NO_REVIEW_GROUP_NAME = T.let(T.unsafe(nil), String)

# source://serviceowners//lib/serviceowners/spec_builder.rb#13
Serviceowners::SpecBuilder::SERVICE_DEFINITION_REGEX = T.let(T.unsafe(nil), Regexp)

# A validator class responsible for checking a ServicePatterns instance
#
# source://serviceowners//lib/serviceowners/spec_validator.rb#6
class Serviceowners::SpecValidator
  # source://serviceowners//lib/serviceowners/spec_validator.rb#16
  sig { params(service_patterns: Serviceowners::ServicePatterns).void }
  def initialize(service_patterns); end

  # source://serviceowners//lib/serviceowners/spec_validator.rb#22
  sig { params(file_index: T.nilable(::Serviceowners::FileIndex)).void }
  def validate!(file_index = T.unsafe(nil)); end

  private

  # @raise [Error]
  #
  # source://serviceowners//lib/serviceowners/spec_validator.rb#49
  sig { params(file_index: T.nilable(::Serviceowners::FileIndex)).void }
  def validate_unmatched_patterns!(file_index); end

  # @raise [Error]
  #
  # source://serviceowners//lib/serviceowners/spec_validator.rb#40
  sig { void }
  def validate_unused_review_groups!; end

  # @raise [Error]
  #
  # source://serviceowners//lib/serviceowners/spec_validator.rb#32
  sig { void }
  def validate_unused_services!; end
end

# source://serviceowners//lib/serviceowners/spec_validator.rb#9
Serviceowners::SpecValidator::UNMATCHED_PATTERNS_ERROR = T.let(T.unsafe(nil), String)

# A team as described in a service mappings file
#
# source://serviceowners//lib/serviceowners/team.rb#9
class Serviceowners::Team
  include ::Serviceowners::Concerns::Presence

  # source://serviceowners//lib/serviceowners/team.rb#14
  sig { params(name: ::Symbol, properties: T::Hash[::Symbol, T.untyped]).void }
  def initialize(name, properties); end

  # source://serviceowners//lib/serviceowners/team.rb#90
  sig { returns(T.nilable(::String)) }
  def alert_issues; end

  # source://serviceowners//lib/serviceowners/team.rb#60
  sig { returns(T.nilable(::String)) }
  def alert_slack; end

  # source://serviceowners//lib/serviceowners/team.rb#65
  sig { params(severity: ::Serviceowners::Severity).returns(T.nilable(::String)) }
  def alert_slack_for_severity(severity); end

  # source://serviceowners//lib/serviceowners/team.rb#37
  sig { returns(::String) }
  def handle; end

  # source://serviceowners//lib/serviceowners/team.rb#85
  sig { returns(T.nilable(::String)) }
  def issues; end

  # source://serviceowners//lib/serviceowners/team.rb#25
  sig { returns(::Symbol) }
  def name; end

  # source://serviceowners//lib/serviceowners/team.rb#34
  sig { returns(::String) }
  def org_name; end

  # source://serviceowners//lib/serviceowners/team.rb#80
  sig { returns(T.nilable(::String)) }
  def pagerduty_escalation_policy; end

  # source://serviceowners//lib/serviceowners/team.rb#70
  sig { returns(T.nilable(::String)) }
  def product_manager; end

  # source://serviceowners//lib/serviceowners/team.rb#28
  sig { returns(T::Hash[::Symbol, ::String]) }
  def properties; end

  # source://serviceowners//lib/serviceowners/team.rb#50
  sig { returns(::String) }
  def qualified_name; end

  # source://serviceowners//lib/serviceowners/team.rb#55
  sig { returns(T.nilable(::String)) }
  def repo; end

  # source://serviceowners//lib/serviceowners/team.rb#31
  sig { returns(::String) }
  def slack; end

  # source://serviceowners//lib/serviceowners/team.rb#75
  sig { returns(T.nilable(::String)) }
  def support_squad_slack; end

  private

  # source://serviceowners//lib/serviceowners/team.rb#97
  sig { params(severity: ::Serviceowners::Severity).returns(T.nilable(::Serviceowners::EscalationPolicy)) }
  def escalation_policy(severity); end

  # handle properties required to be present by service-mappings-schema.json
  #
  # @raise [ArgumentError]
  #
  # source://serviceowners//lib/serviceowners/team.rb#107
  sig { params(name: ::Symbol).returns(::String) }
  def required_property(name); end
end

# source://serviceowners//lib/serviceowners/version.rb#5
Serviceowners::VERSION = T.let(T.unsafe(nil), String)

# source://serviceowners//lib/serviceowners/type_aliases.rb#4
StringSym = T.type_alias { T.any(::String, ::Symbol) }
