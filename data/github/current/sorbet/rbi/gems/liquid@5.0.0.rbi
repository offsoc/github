# typed: true

# DO NOT EDIT MANUALLY
# This is an autogenerated file for types exported from the `liquid` gem.
# Please instead update this file by running `bin/tapioca gem liquid`.

# source://liquid//lib/liquid/extensions.rb#18
class Array
  include ::Prelude::Enumerator
  include ::Enumerable
  include ::MessagePack::CoreExt
  include ::JSON::Ext::Generator::GeneratorMethods::Array

  # source://liquid//lib/liquid/extensions.rb#19
  def to_liquid; end
end

# source://liquid//lib/liquid/extensions.rb#54
class Date
  include ::Comparable
  include ::DateAndTime::Zones
  include ::DateAndTime::Calculations

  # source://liquid//lib/liquid/extensions.rb#55
  def to_liquid; end
end

# source://liquid//lib/liquid/extensions.rb#48
class DateTime < ::Date
  # source://liquid//lib/liquid/extensions.rb#49
  def to_liquid; end
end

# source://liquid//lib/liquid/extensions.rb#66
class FalseClass
  include ::MessagePack::CoreExt
  include ::JSON::Ext::Generator::GeneratorMethods::FalseClass

  # source://liquid//lib/liquid/extensions.rb#67
  def to_liquid; end
end

# source://liquid//lib/liquid/extensions.rb#24
class Hash
  include ::Prelude::Enumerator
  include ::Enumerable
  include ::MessagePack::CoreExt
  include ::JSON::Ext::Generator::GeneratorMethods::Hash
  include ::ActiveSupport::DeepMergeable

  # source://liquid//lib/liquid/extensions.rb#25
  def to_liquid; end
end

# source://liquid//lib/liquid.rb#24
module Liquid
  class << self
    # source://liquid//lib/liquid.rb#47
    def cache_classes; end

    # source://liquid//lib/liquid.rb#47
    def cache_classes=(_arg0); end
  end
end

# source://liquid//lib/liquid.rb#40
Liquid::AnyStartingTag = T.let(T.unsafe(nil), Regexp)

# source://liquid//lib/liquid/errors.rb#43
class Liquid::ArgumentError < ::Liquid::Error; end

# source://liquid//lib/liquid.rb#26
Liquid::ArgumentSeparator = T.let(T.unsafe(nil), String)

# Assign sets a variable in your template.
#
#   {% assign foo = 'monkey' %}
#
# You can then use the variable later in the page.
#
#  {{ foo }}
#
# source://liquid//lib/liquid/tags/assign.rb#12
class Liquid::Assign < ::Liquid::Tag
  # @return [Assign] a new instance of Assign
  #
  # source://liquid//lib/liquid/tags/assign.rb#22
  def initialize(tag_name, markup, parse_context); end

  # @return [Boolean]
  #
  # source://liquid//lib/liquid/tags/assign.rb#39
  def blank?; end

  # Returns the value of attribute from.
  #
  # source://liquid//lib/liquid/tags/assign.rb#20
  def from; end

  # source://liquid//lib/liquid/tags/assign.rb#32
  def render_to_output_buffer(context, output); end

  # Returns the value of attribute to.
  #
  # source://liquid//lib/liquid/tags/assign.rb#20
  def to; end

  private

  # source://liquid//lib/liquid/tags/assign.rb#45
  def assign_score_of(val); end

  class << self
    # @api private
    # @raise [Liquid::SyntaxError]
    #
    # source://liquid//lib/liquid/tags/assign.rb#16
    def raise_syntax_error(parse_context); end
  end
end

# source://liquid//lib/liquid/tags/assign.rb#65
class Liquid::Assign::ParseTreeVisitor < ::Liquid::ParseTreeVisitor
  # source://liquid//lib/liquid/tags/assign.rb#66
  def children; end
end

# source://liquid//lib/liquid/tags/assign.rb#13
Liquid::Assign::Syntax = T.let(T.unsafe(nil), Regexp)

# A Liquid file system is a way to let your templates retrieve other templates for use with the include tag.
#
# You can implement subclasses that retrieve templates from the database, from the file system using a different
# path structure, you can provide them as hard-coded inline strings, or any manner that you see fit.
#
# You can add additional instance variables, arguments, or methods as needed.
#
# Example:
#
#   Liquid::Template.file_system = Liquid::LocalFileSystem.new(template_path)
#   liquid = Liquid::Template.parse(template)
#
# This will parse the template with a LocalFileSystem implementation rooted at 'template_path'.
#
# source://liquid//lib/liquid/file_system.rb#17
class Liquid::BlankFileSystem
  # Called by Liquid to retrieve a template file
  #
  # @raise [FileSystemError]
  #
  # source://liquid//lib/liquid/file_system.rb#19
  def read_template_file(_template_path); end
end

# source://liquid//lib/liquid/block.rb#4
class Liquid::Block < ::Liquid::Tag
  # @return [Block] a new instance of Block
  #
  # source://liquid//lib/liquid/block.rb#7
  def initialize(tag_name, markup, options); end

  # @return [Boolean]
  #
  # source://liquid//lib/liquid/block.rb#24
  def blank?; end

  # source://liquid//lib/liquid/block.rb#59
  def block_delimiter; end

  # source://liquid//lib/liquid/block.rb#55
  def block_name; end

  # source://liquid//lib/liquid/block.rb#28
  def nodelist; end

  # source://liquid//lib/liquid/block.rb#12
  def parse(tokens); end

  # @raise [SyntaxError]
  #
  # source://liquid//lib/liquid/block.rb#51
  def raise_tag_never_closed(block_name); end

  # For backwards compatibility
  #
  # source://liquid//lib/liquid/block.rb#20
  def render(context); end

  # source://liquid//lib/liquid/block.rb#32
  def unknown_tag(tag_name, _markup, _tokenizer); end

  private

  # @api public
  #
  # source://liquid//lib/liquid/block.rb#66
  def new_body; end

  # @api public
  #
  # source://liquid//lib/liquid/block.rb#71
  def parse_body(body, tokens); end

  class << self
    # @api private
    #
    # source://liquid//lib/liquid/block.rb#37
    def raise_unknown_tag(tag, block_name, block_delimiter, parse_context); end
  end
end

# source://liquid//lib/liquid/block.rb#5
Liquid::Block::MAX_DEPTH = T.let(T.unsafe(nil), Integer)

# source://liquid//lib/liquid/block_body.rb#6
class Liquid::BlockBody
  # @return [BlockBody] a new instance of BlockBody
  #
  # source://liquid//lib/liquid/block_body.rb#16
  def initialize; end

  # @return [Boolean]
  #
  # source://liquid//lib/liquid/block_body.rb#173
  def blank?; end

  # source://liquid//lib/liquid/block_body.rb#33
  def freeze; end

  # Returns the value of attribute nodelist.
  #
  # source://liquid//lib/liquid/block_body.rb#14
  def nodelist; end

  # @raise [FrozenError]
  #
  # source://liquid//lib/liquid/block_body.rb#21
  def parse(tokenizer, parse_context, &block); end

  # Remove blank strings in the block body for a control flow tag (e.g. `if`, `for`, `case`, `unless`)
  # with a blank body.
  #
  # For example, in a conditional assignment like the following
  #
  # ```
  # {% if size > max_size %}
  #   {% assign size = max_size %}
  # {% endif %}
  # ```
  #
  # we assume the intention wasn't to output the blank spaces in the `if` tag's block body, so this method
  # will remove them to reduce the render output size.
  #
  # Note that it is now preferred to use the `liquid` tag for this use case.
  #
  # source://liquid//lib/liquid/block_body.rb#192
  def remove_blank_strings; end

  # source://liquid//lib/liquid/block_body.rb#197
  def render(context); end

  # source://liquid//lib/liquid/block_body.rb#201
  def render_to_output_buffer(context, output); end

  # source://liquid//lib/liquid/block_body.rb#159
  def whitespace_handler(token, parse_context); end

  private

  # source://liquid//lib/liquid/block_body.rb#231
  def create_variable(token, parse_context); end

  # @yield [nil, nil]
  #
  # source://liquid//lib/liquid/block_body.rb#110
  def parse_for_document(tokenizer, parse_context); end

  # @yield [nil, nil]
  #
  # source://liquid//lib/liquid/block_body.rb#38
  def parse_for_liquid_tag(tokenizer, parse_context); end

  # source://liquid//lib/liquid/block_body.rb#101
  def parse_liquid_tag(markup, parse_context); end

  # @deprecated Use {.raise_missing_tag_terminator} instead
  #
  # source://liquid//lib/liquid/block_body.rb#240
  def raise_missing_tag_terminator(token, parse_context); end

  # @deprecated Use {.raise_missing_variable_terminator} instead
  #
  # source://liquid//lib/liquid/block_body.rb#245
  def raise_missing_variable_terminator(token, parse_context); end

  # source://liquid//lib/liquid/block_body.rb#249
  def registered_tags; end

  # source://liquid//lib/liquid/block_body.rb#227
  def render_node(context, output, node); end

  class << self
    # @api private
    # @raise [SyntaxError]
    #
    # source://liquid//lib/liquid/block_body.rb#69
    def raise_missing_tag_terminator(token, parse_context); end

    # @api private
    # @raise [SyntaxError]
    #
    # source://liquid//lib/liquid/block_body.rb#74
    def raise_missing_variable_terminator(token, parse_context); end

    # @api private
    #
    # source://liquid//lib/liquid/block_body.rb#79
    def render_node(context, output, node); end

    # @api private
    #
    # source://liquid//lib/liquid/block_body.rb#87
    def rescue_render_node(context, output, line_number, exc, blank_tag); end

    # @api private
    #
    # source://liquid//lib/liquid/block_body.rb#64
    def unknown_tag_in_liquid_tag(tag, parse_context); end
  end
end

# source://liquid//lib/liquid/block_body.rb#9
Liquid::BlockBody::ContentOfVariable = T.let(T.unsafe(nil), Regexp)

# source://liquid//lib/liquid/block_body.rb#8
Liquid::BlockBody::FullToken = T.let(T.unsafe(nil), Regexp)

# source://liquid//lib/liquid/block_body.rb#7
Liquid::BlockBody::LiquidTagToken = T.let(T.unsafe(nil), Regexp)

# source://liquid//lib/liquid/block_body.rb#11
Liquid::BlockBody::TAGSTART = T.let(T.unsafe(nil), String)

# source://liquid//lib/liquid/block_body.rb#12
Liquid::BlockBody::VARSTART = T.let(T.unsafe(nil), String)

# source://liquid//lib/liquid/block_body.rb#10
Liquid::BlockBody::WhitespaceOrNothing = T.let(T.unsafe(nil), Regexp)

# Break tag to be used to break out of a for loop.
#
# == Basic Usage:
#    {% for item in collection %}
#      {% if item.condition %}
#        {% break %}
#      {% endif %}
#    {% endfor %}
#
# source://liquid//lib/liquid/tags/break.rb#13
class Liquid::Break < ::Liquid::Tag
  # source://liquid//lib/liquid/tags/break.rb#16
  def render_to_output_buffer(context, output); end
end

# source://liquid//lib/liquid/tags/break.rb#14
Liquid::Break::INTERRUPT = T.let(T.unsafe(nil), Liquid::BreakInterrupt)

# Interrupt that is thrown whenever a {% break %} is called.
#
# source://liquid//lib/liquid/interrupts.rb#14
class Liquid::BreakInterrupt < ::Liquid::Interrupt; end

# Capture stores the result of a block into a variable without rendering it inplace.
#
#   {% capture heading %}
#     Monkeys!
#   {% endcapture %}
#   ...
#   <h1>{{ heading }}</h1>
#
# Capture is useful for saving content for use later in your template, such as
# in a sidebar or footer.
#
# source://liquid//lib/liquid/tags/capture.rb#15
class Liquid::Capture < ::Liquid::Block
  # @return [Capture] a new instance of Capture
  #
  # source://liquid//lib/liquid/tags/capture.rb#18
  def initialize(tag_name, markup, options); end

  # @return [Boolean]
  #
  # source://liquid//lib/liquid/tags/capture.rb#35
  def blank?; end

  # source://liquid//lib/liquid/tags/capture.rb#27
  def render_to_output_buffer(context, output); end
end

# source://liquid//lib/liquid/tags/capture.rb#16
Liquid::Capture::Syntax = T.let(T.unsafe(nil), Regexp)

# source://liquid//lib/liquid/tags/case.rb#4
class Liquid::Case < ::Liquid::Block
  # @return [Case] a new instance of Case
  #
  # source://liquid//lib/liquid/tags/case.rb#10
  def initialize(tag_name, markup, options); end

  # Returns the value of attribute blocks.
  #
  # source://liquid//lib/liquid/tags/case.rb#8
  def blocks; end

  # Returns the value of attribute left.
  #
  # source://liquid//lib/liquid/tags/case.rb#8
  def left; end

  # source://liquid//lib/liquid/tags/case.rb#34
  def nodelist; end

  # source://liquid//lib/liquid/tags/case.rb#21
  def parse(tokens); end

  # source://liquid//lib/liquid/tags/case.rb#49
  def render_to_output_buffer(context, output); end

  # source://liquid//lib/liquid/tags/case.rb#38
  def unknown_tag(tag, markup, tokens); end

  private

  # source://liquid//lib/liquid/tags/case.rb#82
  def record_else_condition(markup); end

  # source://liquid//lib/liquid/tags/case.rb#66
  def record_when_condition(markup); end
end

# source://liquid//lib/liquid/tags/case.rb#92
class Liquid::Case::ParseTreeVisitor < ::Liquid::ParseTreeVisitor
  # source://liquid//lib/liquid/tags/case.rb#93
  def children; end
end

# source://liquid//lib/liquid/tags/case.rb#5
Liquid::Case::Syntax = T.let(T.unsafe(nil), Regexp)

# source://liquid//lib/liquid/tags/case.rb#6
Liquid::Case::WhenSyntax = T.let(T.unsafe(nil), Regexp)

# source://liquid//lib/liquid/tags/comment.rb#4
class Liquid::Comment < ::Liquid::Block
  # @return [Boolean]
  #
  # source://liquid//lib/liquid/tags/comment.rb#12
  def blank?; end

  # source://liquid//lib/liquid/tags/comment.rb#5
  def render_to_output_buffer(_context, output); end

  # source://liquid//lib/liquid/tags/comment.rb#9
  def unknown_tag(_tag, _markup, _tokens); end
end

# Container for liquid nodes which conveniently wraps decision making logic
#
# Example:
#
#   c = Condition.new(1, '==', 1)
#   c.evaluate #=> true
#
# source://liquid//lib/liquid/condition.rb#11
class Liquid::Condition
  # @return [Condition] a new instance of Condition
  #
  # source://liquid//lib/liquid/condition.rb#55
  def initialize(left = T.unsafe(nil), operator = T.unsafe(nil), right = T.unsafe(nil)); end

  # source://liquid//lib/liquid/condition.rb#88
  def and(condition); end

  # source://liquid//lib/liquid/condition.rb#93
  def attach(attachment); end

  # Returns the value of attribute attachment.
  #
  # source://liquid//lib/liquid/condition.rb#52
  def attachment; end

  # Returns the value of attribute child_condition.
  #
  # source://liquid//lib/liquid/condition.rb#52
  def child_condition; end

  # @return [Boolean]
  #
  # source://liquid//lib/liquid/condition.rb#97
  def else?; end

  # source://liquid//lib/liquid/condition.rb#64
  def evaluate(context = T.unsafe(nil)); end

  # source://liquid//lib/liquid/condition.rb#101
  def inspect; end

  # Returns the value of attribute left.
  #
  # source://liquid//lib/liquid/condition.rb#53
  def left; end

  # Sets the attribute left
  #
  # @param value the value to set the attribute left to.
  #
  # source://liquid//lib/liquid/condition.rb#53
  def left=(_arg0); end

  # Returns the value of attribute operator.
  #
  # source://liquid//lib/liquid/condition.rb#53
  def operator; end

  # Sets the attribute operator
  #
  # @param value the value to set the attribute operator to.
  #
  # source://liquid//lib/liquid/condition.rb#53
  def operator=(_arg0); end

  # source://liquid//lib/liquid/condition.rb#83
  def or(condition); end

  # Returns the value of attribute right.
  #
  # source://liquid//lib/liquid/condition.rb#53
  def right; end

  # Sets the attribute right
  #
  # @param value the value to set the attribute right to.
  #
  # source://liquid//lib/liquid/condition.rb#53
  def right=(_arg0); end

  protected

  # Returns the value of attribute child_relation.
  #
  # source://liquid//lib/liquid/condition.rb#107
  def child_relation; end

  private

  # source://liquid//lib/liquid/condition.rb#111
  def equal_variables(left, right); end

  # source://liquid//lib/liquid/condition.rb#131
  def interpret_condition(left, right, op, context); end

  class << self
    # source://liquid//lib/liquid/condition.rb#44
    def operators; end

    # source://liquid//lib/liquid/condition.rb#48
    def parse_expression(parse_context, markup); end
  end
end

# source://liquid//lib/liquid/condition.rb#30
class Liquid::Condition::MethodLiteral
  # @return [MethodLiteral] a new instance of MethodLiteral
  #
  # source://liquid//lib/liquid/condition.rb#33
  def initialize(method_name, to_s); end

  # Returns the value of attribute method_name.
  #
  # source://liquid//lib/liquid/condition.rb#31
  def method_name; end

  # Returns the value of attribute to_s.
  #
  # source://liquid//lib/liquid/condition.rb#31
  def to_s; end
end

# source://liquid//lib/liquid/condition.rb#153
class Liquid::Condition::ParseTreeVisitor < ::Liquid::ParseTreeVisitor
  # source://liquid//lib/liquid/condition.rb#154
  def children; end
end

# Context keeps the variable stack and resolves variables, as well as keywords
#
#   context['variable'] = 'testing'
#   context['variable'] #=> 'testing'
#   context['true']     #=> true
#   context['10.2232']  #=> 10.2232
#
#   context.stack do
#      context['bob'] = 'bobsen'
#   end
#
#   context['bob']  #=> nil  class Context
#
# source://liquid//lib/liquid/context.rb#16
class Liquid::Context
  # @return [Context] a new instance of Context
  # @yield [_self]
  # @yieldparam _self [Liquid::Context] the object that the method was called on
  #
  # source://liquid//lib/liquid/context.rb#25
  def initialize(environments = T.unsafe(nil), outer_scope = T.unsafe(nil), registers = T.unsafe(nil), rethrow_errors = T.unsafe(nil), resource_limits = T.unsafe(nil), static_environments = T.unsafe(nil)); end

  # Look up variable, either resolve directly after considering the name. We can directly handle
  # Strings, digits, floats and booleans (true,false).
  # If no match is made we lookup the variable in the current scope and
  # later move up to the parent blocks to see if we can resolve the variable somewhere up the tree.
  # Some special keywords return symbols. Those symbols are to be called on the rhs object in expressions
  #
  # Example:
  #   products == empty #=> products.empty?
  #
  # source://liquid//lib/liquid/context.rb#172
  def [](expression); end

  # Only allow String, Numeric, Hash, Array, Proc, Boolean or <tt>Liquid::Drop</tt>
  #
  # source://liquid//lib/liquid/context.rb#160
  def []=(key, value); end

  # Adds filters to this context.
  #
  # Note that this does not register the filters with the main Template object. see <tt>Template.register_filter</tt>
  # for that
  #
  # source://liquid//lib/liquid/context.rb#66
  def add_filters(filters); end

  # source://liquid//lib/liquid/context.rb#72
  def apply_global_filter(obj); end

  # source://liquid//lib/liquid/context.rb#155
  def clear_instance_assigns; end

  # Returns the value of attribute environments.
  #
  # source://liquid//lib/liquid/context.rb#17
  def environments; end

  # Returns the value of attribute errors.
  #
  # source://liquid//lib/liquid/context.rb#17
  def errors; end

  # source://liquid//lib/liquid/context.rb#180
  def evaluate(object); end

  # Returns the value of attribute exception_renderer.
  #
  # source://liquid//lib/liquid/context.rb#18
  def exception_renderer; end

  # Sets the attribute exception_renderer
  #
  # @param value the value to set the attribute exception_renderer to.
  #
  # source://liquid//lib/liquid/context.rb#18
  def exception_renderer=(_arg0); end

  # Fetches an object starting at the local scope and then moving up the hierachy
  #
  # source://liquid//lib/liquid/context.rb#185
  def find_variable(key, raise_on_not_found: T.unsafe(nil)); end

  # Returns the value of attribute global_filter.
  #
  # source://liquid//lib/liquid/context.rb#18
  def global_filter; end

  # Sets the attribute global_filter
  #
  # @param value the value to set the attribute global_filter to.
  #
  # source://liquid//lib/liquid/context.rb#18
  def global_filter=(_arg0); end

  # source://liquid//lib/liquid/context.rb#91
  def handle_error(e, line_number = T.unsafe(nil)); end

  # are there any not handled interrupts?
  #
  # @return [Boolean]
  #
  # source://liquid//lib/liquid/context.rb#77
  def interrupt?; end

  # source://liquid//lib/liquid/context.rb#99
  def invoke(method, *args); end

  # @return [Boolean]
  #
  # source://liquid//lib/liquid/context.rb#176
  def key?(key); end

  # source://liquid//lib/liquid/context.rb#202
  def lookup_and_evaluate(obj, key, raise_on_not_found: T.unsafe(nil)); end

  # Merge a hash of variables in the current local scope
  #
  # source://liquid//lib/liquid/context.rb#110
  def merge(new_scopes); end

  # Creates a new context inheriting resource limits, filters, environment etc.,
  # but with an isolated scope.
  #
  # source://liquid//lib/liquid/context.rb#137
  def new_isolated_subcontext; end

  # Returns the value of attribute partial.
  #
  # source://liquid//lib/liquid/context.rb#18
  def partial; end

  # Sets the attribute partial
  #
  # @param value the value to set the attribute partial to.
  #
  # source://liquid//lib/liquid/context.rb#18
  def partial=(_arg0); end

  # Pop from the stack. use <tt>Context#stack</tt> instead
  #
  # @raise [ContextError]
  #
  # source://liquid//lib/liquid/context.rb#115
  def pop; end

  # pop an interrupt from the stack
  #
  # source://liquid//lib/liquid/context.rb#87
  def pop_interrupt; end

  # Push new local scope on the stack. use <tt>Context#stack</tt> instead
  #
  # source://liquid//lib/liquid/context.rb#104
  def push(new_scope = T.unsafe(nil)); end

  # push an interrupt to the stack. this interrupt is considered not handled.
  #
  # source://liquid//lib/liquid/context.rb#82
  def push_interrupt(e); end

  # Returns the value of attribute registers.
  #
  # source://liquid//lib/liquid/context.rb#17
  def registers; end

  # Returns the value of attribute resource_limits.
  #
  # source://liquid//lib/liquid/context.rb#17
  def resource_limits; end

  # Returns the value of attribute scopes.
  #
  # source://liquid//lib/liquid/context.rb#17
  def scopes; end

  # Pushes a new local scope on the stack, pops it at the end of the block
  #
  # Example:
  #   context.stack do
  #      context['var'] = 'hi'
  #   end
  #
  #   context['var]  #=> nil
  #
  # source://liquid//lib/liquid/context.rb#128
  def stack(new_scope = T.unsafe(nil)); end

  # Returns the value of attribute static_environments.
  #
  # source://liquid//lib/liquid/context.rb#17
  def static_environments; end

  # Returns the value of attribute static_registers.
  #
  # source://liquid//lib/liquid/context.rb#17
  def static_registers; end

  # source://liquid//lib/liquid/context.rb#58
  def strainer; end

  # Returns the value of attribute strict_filters.
  #
  # source://liquid//lib/liquid/context.rb#18
  def strict_filters; end

  # Sets the attribute strict_filters
  #
  # @param value the value to set the attribute strict_filters to.
  #
  # source://liquid//lib/liquid/context.rb#18
  def strict_filters=(_arg0); end

  # Returns the value of attribute strict_variables.
  #
  # source://liquid//lib/liquid/context.rb#18
  def strict_variables; end

  # Sets the attribute strict_variables
  #
  # @param value the value to set the attribute strict_variables to.
  #
  # source://liquid//lib/liquid/context.rb#18
  def strict_variables=(_arg0); end

  # @return [Boolean]
  #
  # source://liquid//lib/liquid/context.rb#227
  def tag_disabled?(tag_name); end

  # Returns the value of attribute template_name.
  #
  # source://liquid//lib/liquid/context.rb#18
  def template_name; end

  # Sets the attribute template_name
  #
  # @param value the value to set the attribute template_name to.
  #
  # source://liquid//lib/liquid/context.rb#18
  def template_name=(_arg0); end

  # source://liquid//lib/liquid/context.rb#54
  def warnings; end

  # source://liquid//lib/liquid/context.rb#216
  def with_disabled_tags(tag_names); end

  protected

  # Sets the attribute base_scope_depth
  #
  # @param value the value to set the attribute base_scope_depth to.
  #
  # source://liquid//lib/liquid/context.rb#233
  def base_scope_depth=(_arg0); end

  # Sets the attribute disabled_tags
  #
  # @param value the value to set the attribute disabled_tags to.
  #
  # source://liquid//lib/liquid/context.rb#233
  def disabled_tags=(_arg0); end

  # Sets the attribute errors
  #
  # @param value the value to set the attribute errors to.
  #
  # source://liquid//lib/liquid/context.rb#233
  def errors=(_arg0); end

  # Sets the attribute filters
  #
  # @param value the value to set the attribute filters to.
  #
  # source://liquid//lib/liquid/context.rb#233
  def filters=(_arg0); end

  # Sets the attribute strainer
  #
  # @param value the value to set the attribute strainer to.
  #
  # source://liquid//lib/liquid/context.rb#233
  def strainer=(_arg0); end

  # Sets the attribute warnings
  #
  # @param value the value to set the attribute warnings to.
  #
  # source://liquid//lib/liquid/context.rb#233
  def warnings=(_arg0); end

  private

  # Returns the value of attribute base_scope_depth.
  #
  # source://liquid//lib/liquid/context.rb#237
  def base_scope_depth; end

  # @raise [StackLevelError]
  #
  # source://liquid//lib/liquid/context.rb#255
  def check_overflow; end

  # source://liquid//lib/liquid/context.rb#263
  def internal_error; end

  # @return [Boolean]
  #
  # source://liquid//lib/liquid/context.rb#259
  def overflow?; end

  # source://liquid//lib/liquid/context.rb#270
  def squash_instance_assigns_with_environments; end

  # source://liquid//lib/liquid/context.rb#239
  def try_variable_find_in_environments(key, raise_on_not_found:); end

  class << self
    # source://liquid//lib/liquid/context.rb#21
    def build(environments: T.unsafe(nil), outer_scope: T.unsafe(nil), registers: T.unsafe(nil), rethrow_errors: T.unsafe(nil), resource_limits: T.unsafe(nil), static_environments: T.unsafe(nil), &block); end
  end
end

# source://liquid//lib/liquid/errors.rb#44
class Liquid::ContextError < ::Liquid::Error; end

# Continue tag to be used to break out of a for loop.
#
# == Basic Usage:
#    {% for item in collection %}
#      {% if item.condition %}
#        {% continue %}
#      {% endif %}
#    {% endfor %}
#
# source://liquid//lib/liquid/tags/continue.rb#13
class Liquid::Continue < ::Liquid::Tag
  # source://liquid//lib/liquid/tags/continue.rb#16
  def render_to_output_buffer(context, output); end
end

# source://liquid//lib/liquid/tags/continue.rb#14
Liquid::Continue::INTERRUPT = T.let(T.unsafe(nil), Liquid::ContinueInterrupt)

# Interrupt that is thrown whenever a {% continue %} is called.
#
# source://liquid//lib/liquid/interrupts.rb#17
class Liquid::ContinueInterrupt < ::Liquid::Interrupt; end

# Cycle is usually used within a loop to alternate between values, like colors or DOM classes.
#
#   {% for item in items %}
#     <div class="{% cycle 'red', 'green', 'blue' %}"> {{ item }} </div>
#   {% end %}
#
#    <div class="red"> Item one </div>
#    <div class="green"> Item two </div>
#    <div class="blue"> Item three </div>
#    <div class="red"> Item four </div>
#    <div class="green"> Item five</div>
#
# source://liquid//lib/liquid/tags/cycle.rb#16
class Liquid::Cycle < ::Liquid::Tag
  # @return [Cycle] a new instance of Cycle
  #
  # source://liquid//lib/liquid/tags/cycle.rb#22
  def initialize(tag_name, markup, options); end

  # source://liquid//lib/liquid/tags/cycle.rb#36
  def render_to_output_buffer(context, output); end

  # Returns the value of attribute variables.
  #
  # source://liquid//lib/liquid/tags/cycle.rb#20
  def variables; end

  private

  # source://liquid//lib/liquid/tags/cycle.rb#61
  def variables_from_string(markup); end
end

# source://liquid//lib/liquid/tags/cycle.rb#18
Liquid::Cycle::NamedSyntax = T.let(T.unsafe(nil), Regexp)

# source://liquid//lib/liquid/tags/cycle.rb#68
class Liquid::Cycle::ParseTreeVisitor < ::Liquid::ParseTreeVisitor
  # source://liquid//lib/liquid/tags/cycle.rb#69
  def children; end
end

# source://liquid//lib/liquid/tags/cycle.rb#17
Liquid::Cycle::SimpleSyntax = T.let(T.unsafe(nil), Regexp)

# Hello: {% decrement variable %}
#
# gives you:
#
#    Hello: -1
#    Hello: -2
#    Hello: -3
#
# source://liquid//lib/liquid/tags/decrement.rb#22
class Liquid::Decrement < ::Liquid::Tag
  # @return [Decrement] a new instance of Decrement
  #
  # source://liquid//lib/liquid/tags/decrement.rb#23
  def initialize(tag_name, markup, options); end

  # source://liquid//lib/liquid/tags/decrement.rb#28
  def render_to_output_buffer(context, output); end
end

# source://liquid//lib/liquid/errors.rb#56
class Liquid::DisabledError < ::Liquid::Error; end

# source://liquid//lib/liquid/document.rb#4
class Liquid::Document
  # @return [Document] a new instance of Document
  #
  # source://liquid//lib/liquid/document.rb#13
  def initialize(parse_context); end

  # Returns the value of attribute body.
  #
  # source://liquid//lib/liquid/document.rb#11
  def body; end

  # source://liquid//lib/liquid/document.rb#18
  def nodelist; end

  # source://liquid//lib/liquid/document.rb#22
  def parse(tokenizer, parse_context); end

  # Returns the value of attribute parse_context.
  #
  # source://liquid//lib/liquid/document.rb#11
  def parse_context; end

  # source://liquid//lib/liquid/document.rb#44
  def render(context); end

  # source://liquid//lib/liquid/document.rb#40
  def render_to_output_buffer(context, output); end

  # source://liquid//lib/liquid/document.rb#31
  def unknown_tag(tag, _markup, _tokenizer); end

  private

  # source://liquid//lib/liquid/document.rb#50
  def new_body; end

  # source://liquid//lib/liquid/document.rb#54
  def parse_body(tokenizer); end

  class << self
    # source://liquid//lib/liquid/document.rb#5
    def parse(tokens, parse_context); end
  end
end

# A drop in liquid is a class which allows you to export DOM like things to liquid.
# Methods of drops are callable.
# The main use for liquid drops is to implement lazy loaded objects.
# If you would like to make data available to the web designers which you don't want loaded unless needed then
# a drop is a great way to do that.
#
# Example:
#
#   class ProductDrop < Liquid::Drop
#     def top_sales
#       Shop.current.products.find(:all, :order => 'sales', :limit => 10 )
#     end
#   end
#
#   tmpl = Liquid::Template.parse( ' {% for product in product.top_sales %} {{ product.name }} {%endfor%} '  )
#   tmpl.render('product' => ProductDrop.new ) # will invoke top_sales query.
#
# Your drop can either implement the methods sans any parameters
# or implement the liquid_method_missing(name) method which is a catch all.
#
# source://liquid//lib/liquid/drop.rb#25
class Liquid::Drop
  # called by liquid to invoke a drop
  #
  # source://liquid//lib/liquid/drop.rb#35
  def [](method_or_key); end

  # Sets the attribute context
  #
  # @param value the value to set the attribute context to.
  #
  # source://liquid//lib/liquid/drop.rb#26
  def context=(_arg0); end

  # source://liquid//lib/liquid/drop.rb#47
  def inspect; end

  # called by liquid to invoke a drop
  #
  # source://liquid//lib/liquid/drop.rb#35
  def invoke_drop(method_or_key); end

  # @return [Boolean]
  #
  # source://liquid//lib/liquid/drop.rb#43
  def key?(_name); end

  # Catch all for the method
  #
  # @raise [Liquid::UndefinedDropMethod]
  #
  # source://liquid//lib/liquid/drop.rb#29
  def liquid_method_missing(method); end

  # source://liquid//lib/liquid/drop.rb#51
  def to_liquid; end

  # source://liquid//lib/liquid/drop.rb#55
  def to_s; end

  class << self
    # Check for method existence without invoking respond_to?, which creates symbols
    #
    # @return [Boolean]
    #
    # source://liquid//lib/liquid/drop.rb#62
    def invokable?(method_name); end

    # source://liquid//lib/liquid/drop.rb#66
    def invokable_methods; end
  end
end

# Echo outputs an expression
#
#   {% echo monkey %}
#   {% echo user.name %}
#
# This is identical to variable output syntax, like {{ foo }}, but works
# inside {% liquid %} tags. The full syntax is supported, including filters:
#
#   {% echo user | link %}
#
# source://liquid//lib/liquid/tags/echo.rb#14
class Liquid::Echo < ::Liquid::Tag
  # @return [Echo] a new instance of Echo
  #
  # source://liquid//lib/liquid/tags/echo.rb#15
  def initialize(tag_name, markup, parse_context); end

  # source://liquid//lib/liquid/tags/echo.rb#20
  def render(context); end
end

# source://liquid//lib/liquid/condition.rb#163
class Liquid::ElseCondition < ::Liquid::Condition
  # @return [Boolean]
  #
  # source://liquid//lib/liquid/condition.rb#164
  def else?; end

  # source://liquid//lib/liquid/condition.rb#168
  def evaluate(_context); end
end

# source://liquid//lib/liquid/errors.rb#4
class Liquid::Error < ::StandardError
  # Returns the value of attribute line_number.
  #
  # source://liquid//lib/liquid/errors.rb#5
  def line_number; end

  # Sets the attribute line_number
  #
  # @param value the value to set the attribute line_number to.
  #
  # source://liquid//lib/liquid/errors.rb#5
  def line_number=(_arg0); end

  # Returns the value of attribute markup_context.
  #
  # source://liquid//lib/liquid/errors.rb#7
  def markup_context; end

  # Sets the attribute markup_context
  #
  # @param value the value to set the attribute markup_context to.
  #
  # source://liquid//lib/liquid/errors.rb#7
  def markup_context=(_arg0); end

  # Returns the value of attribute template_name.
  #
  # source://liquid//lib/liquid/errors.rb#6
  def template_name; end

  # Sets the attribute template_name
  #
  # @param value the value to set the attribute template_name to.
  #
  # source://liquid//lib/liquid/errors.rb#6
  def template_name=(_arg0); end

  # source://liquid//lib/liquid/errors.rb#9
  def to_s(with_prefix = T.unsafe(nil)); end

  private

  # source://liquid//lib/liquid/errors.rb#24
  def message_prefix; end
end

# source://liquid//lib/liquid/expression.rb#4
class Liquid::Expression
  class << self
    # source://liquid//lib/liquid/expression.rb#22
    def parse(markup); end
  end
end

# source://liquid//lib/liquid/expression.rb#14
Liquid::Expression::DOUBLE_QUOTED_STRING = T.let(T.unsafe(nil), Regexp)

# source://liquid//lib/liquid/expression.rb#16
Liquid::Expression::FLOATS_REGEX = T.let(T.unsafe(nil), Regexp)

# source://liquid//lib/liquid/expression.rb#15
Liquid::Expression::INTEGERS_REGEX = T.let(T.unsafe(nil), Regexp)

# source://liquid//lib/liquid/expression.rb#5
Liquid::Expression::LITERALS = T.let(T.unsafe(nil), Hash)

# Use an atomic group (?>...) to avoid pathological backtracing from
# malicious input as described in https://github.com/Shopify/liquid/issues/1357
#
# source://liquid//lib/liquid/expression.rb#20
Liquid::Expression::RANGES_REGEX = T.let(T.unsafe(nil), Regexp)

# source://liquid//lib/liquid/expression.rb#13
Liquid::Expression::SINGLE_QUOTED_STRING = T.let(T.unsafe(nil), Regexp)

# source://liquid//lib/liquid/errors.rb#45
class Liquid::FileSystemError < ::Liquid::Error; end

# source://liquid//lib/liquid.rb#27
Liquid::FilterArgumentSeparator = T.let(T.unsafe(nil), String)

# source://liquid//lib/liquid.rb#25
Liquid::FilterSeparator = T.let(T.unsafe(nil), Regexp)

# source://liquid//lib/liquid/errors.rb#51
class Liquid::FloatDomainError < ::Liquid::Error; end

# "For" iterates over an array or collection.
# Several useful variables are available to you within the loop.
#
# == Basic usage:
#    {% for item in collection %}
#      {{ forloop.index }}: {{ item.name }}
#    {% endfor %}
#
# == Advanced usage:
#    {% for item in collection %}
#      <div {% if forloop.first %}class="first"{% endif %}>
#        Item {{ forloop.index }}: {{ item.name }}
#      </div>
#    {% else %}
#      There is nothing in the collection.
#    {% endfor %}
#
# You can also define a limit and offset much like SQL.  Remember
# that offset starts at 0 for the first item.
#
#    {% for item in collection limit:5 offset:10 %}
#      {{ item.name }}
#    {% end %}
#
#  To reverse the for loop simply use {% for item in collection reversed %} (note that the flag's spelling is different to the filter `reverse`)
#
# == Available variables:
#
# forloop.name:: 'item-collection'
# forloop.length:: Length of the loop
# forloop.index:: The current item's position in the collection;
#                 forloop.index starts at 1.
#                 This is helpful for non-programmers who start believe
#                 the first item in an array is 1, not 0.
# forloop.index0:: The current item's position in the collection
#                  where the first item is 0
# forloop.rindex:: Number of items remaining in the loop
#                  (length - index) where 1 is the last item.
# forloop.rindex0:: Number of items remaining in the loop
#                   where 0 is the last item.
# forloop.first:: Returns true if the item is the first item.
# forloop.last:: Returns true if the item is the last item.
# forloop.parentloop:: Provides access to the parent loop, if present.
#
# source://liquid//lib/liquid/tags/for.rb#48
class Liquid::For < ::Liquid::Block
  # @return [For] a new instance of For
  #
  # source://liquid//lib/liquid/tags/for.rb#53
  def initialize(tag_name, markup, options); end

  # Returns the value of attribute collection_name.
  #
  # source://liquid//lib/liquid/tags/for.rb#51
  def collection_name; end

  # Returns the value of attribute from.
  #
  # source://liquid//lib/liquid/tags/for.rb#51
  def from; end

  # Returns the value of attribute limit.
  #
  # source://liquid//lib/liquid/tags/for.rb#51
  def limit; end

  # source://liquid//lib/liquid/tags/for.rb#73
  def nodelist; end

  # source://liquid//lib/liquid/tags/for.rb#61
  def parse(tokens); end

  # source://liquid//lib/liquid/tags/for.rb#82
  def render_to_output_buffer(context, output); end

  # source://liquid//lib/liquid/tags/for.rb#77
  def unknown_tag(tag, markup, tokens); end

  # Returns the value of attribute variable_name.
  #
  # source://liquid//lib/liquid/tags/for.rb#51
  def variable_name; end

  protected

  # source://liquid//lib/liquid/tags/for.rb#96
  def lax_parse(markup); end

  # @raise [SyntaxError]
  #
  # source://liquid//lib/liquid/tags/for.rb#111
  def strict_parse(markup); end

  private

  # source://liquid//lib/liquid/tags/for.rb#134
  def collection_segment(context); end

  # source://liquid//lib/liquid/tags/for.rb#211
  def render_else(context, output); end

  # source://liquid//lib/liquid/tags/for.rb#166
  def render_segment(context, output, segment); end

  # source://liquid//lib/liquid/tags/for.rb#197
  def set_attribute(key, expr); end
end

# source://liquid//lib/liquid/tags/for.rb#219
class Liquid::For::ParseTreeVisitor < ::Liquid::ParseTreeVisitor
  # source://liquid//lib/liquid/tags/for.rb#220
  def children; end
end

# source://liquid//lib/liquid/tags/for.rb#49
Liquid::For::Syntax = T.let(T.unsafe(nil), Regexp)

# source://liquid//lib/liquid/forloop_drop.rb#4
class Liquid::ForloopDrop < ::Liquid::Drop
  # @return [ForloopDrop] a new instance of ForloopDrop
  #
  # source://liquid//lib/liquid/forloop_drop.rb#5
  def initialize(name, length, parentloop); end

  # source://liquid//lib/liquid/forloop_drop.rb#35
  def first; end

  # source://liquid//lib/liquid/forloop_drop.rb#19
  def index; end

  # source://liquid//lib/liquid/forloop_drop.rb#23
  def index0; end

  # source://liquid//lib/liquid/forloop_drop.rb#39
  def last; end

  # Returns the value of attribute length.
  #
  # source://liquid//lib/liquid/forloop_drop.rb#12
  def length; end

  # source://liquid//lib/liquid/forloop_drop.rb#14
  def name; end

  # Returns the value of attribute parentloop.
  #
  # source://liquid//lib/liquid/forloop_drop.rb#12
  def parentloop; end

  # source://liquid//lib/liquid/forloop_drop.rb#27
  def rindex; end

  # source://liquid//lib/liquid/forloop_drop.rb#31
  def rindex0; end

  protected

  # source://liquid//lib/liquid/forloop_drop.rb#45
  def increment!; end
end

# source://liquid//lib/liquid/i18n.rb#6
class Liquid::I18n
  # @return [I18n] a new instance of I18n
  #
  # source://liquid//lib/liquid/i18n.rb#13
  def initialize(path = T.unsafe(nil)); end

  # source://liquid//lib/liquid/i18n.rb#22
  def locale; end

  # Returns the value of attribute path.
  #
  # source://liquid//lib/liquid/i18n.rb#11
  def path; end

  # source://liquid//lib/liquid/i18n.rb#17
  def t(name, vars = T.unsafe(nil)); end

  # source://liquid//lib/liquid/i18n.rb#17
  def translate(name, vars = T.unsafe(nil)); end

  private

  # source://liquid//lib/liquid/i18n.rb#35
  def deep_fetch_translation(name); end

  # source://liquid//lib/liquid/i18n.rb#28
  def interpolate(name, vars); end
end

# source://liquid//lib/liquid/i18n.rb#7
Liquid::I18n::DEFAULT_LOCALE = T.let(T.unsafe(nil), String)

# source://liquid//lib/liquid/i18n.rb#9
class Liquid::I18n::TranslationError < ::StandardError; end

# If is the conditional block
#
#   {% if user.admin %}
#     Admin user!
#   {% else %}
#     Not admin user
#   {% endif %}
#
#    There are {% if count < 5 %} less {% else %} more {% endif %} items than you need.
#
# source://liquid//lib/liquid/tags/if.rb#14
class Liquid::If < ::Liquid::Block
  # @return [If] a new instance of If
  #
  # source://liquid//lib/liquid/tags/if.rb#21
  def initialize(tag_name, markup, options); end

  # Returns the value of attribute blocks.
  #
  # source://liquid//lib/liquid/tags/if.rb#19
  def blocks; end

  # source://liquid//lib/liquid/tags/if.rb#27
  def nodelist; end

  # source://liquid//lib/liquid/tags/if.rb#31
  def parse(tokens); end

  # source://liquid//lib/liquid/tags/if.rb#51
  def render_to_output_buffer(context, output); end

  # source://liquid//lib/liquid/tags/if.rb#43
  def unknown_tag(tag, markup, tokens); end

  private

  # @raise [SyntaxError]
  #
  # source://liquid//lib/liquid/tags/if.rb#78
  def lax_parse(markup); end

  # source://liquid//lib/liquid/tags/if.rb#105
  def parse_binary_comparisons(p); end

  # source://liquid//lib/liquid/tags/if.rb#116
  def parse_comparison(p); end

  # source://liquid//lib/liquid/tags/if.rb#74
  def parse_expression(markup); end

  # source://liquid//lib/liquid/tags/if.rb#63
  def push_block(tag, markup); end

  # source://liquid//lib/liquid/tags/if.rb#98
  def strict_parse(markup); end
end

# source://liquid//lib/liquid/tags/if.rb#17
Liquid::If::BOOLEAN_OPERATORS = T.let(T.unsafe(nil), Array)

# source://liquid//lib/liquid/tags/if.rb#40
Liquid::If::ELSE_TAG_NAMES = T.let(T.unsafe(nil), Array)

# source://liquid//lib/liquid/tags/if.rb#16
Liquid::If::ExpressionsAndOperators = T.let(T.unsafe(nil), Regexp)

# source://liquid//lib/liquid/tags/if.rb#126
class Liquid::If::ParseTreeVisitor < ::Liquid::ParseTreeVisitor
  # source://liquid//lib/liquid/tags/if.rb#127
  def children; end
end

# source://liquid//lib/liquid/tags/if.rb#15
Liquid::If::Syntax = T.let(T.unsafe(nil), Regexp)

# source://liquid//lib/liquid/tags/ifchanged.rb#4
class Liquid::Ifchanged < ::Liquid::Block
  # source://liquid//lib/liquid/tags/ifchanged.rb#5
  def render_to_output_buffer(context, output); end
end

# Include allows templates to relate with other templates
#
# Simply include another template:
#
#   {% include 'product' %}
#
# Include a template with a local variable:
#
#   {% include 'product' with products[0] %}
#
# Include a template for a collection:
#
#   {% include 'product' for products %}
#
# source://liquid//lib/liquid/tags/include.rb#18
class Liquid::Include < ::Liquid::Tag
  include ::Liquid::Tag::Disableable

  # @return [Include] a new instance of Include
  #
  # source://liquid//lib/liquid/tags/include.rb#26
  def initialize(tag_name, markup, options); end

  # Returns the value of attribute attributes.
  #
  # source://liquid//lib/liquid/tags/include.rb#24
  def attributes; end

  # source://liquid//lib/liquid/tags/include.rb#48
  def parse(_tokens); end

  # @raise [ArgumentError]
  #
  # source://liquid//lib/liquid/tag/disableable.rb#6
  def render_to_output_buffer(context, output); end

  # Returns the value of attribute template_name_expr.
  #
  # source://liquid//lib/liquid/tags/include.rb#24
  def template_name_expr; end

  # Returns the value of attribute variable_name_expr.
  #
  # source://liquid//lib/liquid/tags/include.rb#24
  def variable_name_expr; end

  private

  # source://liquid//lib/liquid/tag.rb#5
  def parse_context; end
end

# source://liquid//lib/liquid/tags/include.rb#100
class Liquid::Include::ParseTreeVisitor < ::Liquid::ParseTreeVisitor
  # source://liquid//lib/liquid/tags/include.rb#101
  def children; end
end

# source://liquid//lib/liquid/tags/include.rb#21
Liquid::Include::SYNTAX = T.let(T.unsafe(nil), Regexp)

# source://liquid//lib/liquid/tags/include.rb#22
Liquid::Include::Syntax = T.let(T.unsafe(nil), Regexp)

# increment is used in a place where one needs to insert a counter
#     into a template, and needs the counter to survive across
#     multiple instantiations of the template.
#     (To achieve the survival, the application must keep the context)
#
#     if the variable does not exist, it is created with value 0.
#
#   Hello: {% increment variable %}
#
# gives you:
#
#    Hello: 0
#    Hello: 1
#    Hello: 2
#
# source://liquid//lib/liquid/tags/increment.rb#19
class Liquid::Increment < ::Liquid::Tag
  # @return [Increment] a new instance of Increment
  #
  # source://liquid//lib/liquid/tags/increment.rb#20
  def initialize(tag_name, markup, options); end

  # source://liquid//lib/liquid/tags/increment.rb#25
  def render_to_output_buffer(context, output); end
end

# source://liquid//lib/liquid/errors.rb#57
class Liquid::InternalError < ::Liquid::Error; end

# An interrupt is any command that breaks processing of a block (ex: a for loop).
#
# source://liquid//lib/liquid/interrupts.rb#5
class Liquid::Interrupt
  # @return [Interrupt] a new instance of Interrupt
  #
  # source://liquid//lib/liquid/interrupts.rb#8
  def initialize(message = T.unsafe(nil)); end

  # Returns the value of attribute message.
  #
  # source://liquid//lib/liquid/interrupts.rb#6
  def message; end
end

# source://liquid//lib/liquid/lexer.rb#5
class Liquid::Lexer
  # @return [Lexer] a new instance of Lexer
  #
  # source://liquid//lib/liquid/lexer.rb#26
  def initialize(input); end

  # source://liquid//lib/liquid/lexer.rb#30
  def tokenize; end
end

# source://liquid//lib/liquid/lexer.rb#23
Liquid::Lexer::COMPARISON_OPERATOR = T.let(T.unsafe(nil), Regexp)

# source://liquid//lib/liquid/lexer.rb#22
Liquid::Lexer::DOTDOT = T.let(T.unsafe(nil), Regexp)

# source://liquid//lib/liquid/lexer.rb#20
Liquid::Lexer::DOUBLE_STRING_LITERAL = T.let(T.unsafe(nil), Regexp)

# source://liquid//lib/liquid/lexer.rb#18
Liquid::Lexer::IDENTIFIER = T.let(T.unsafe(nil), Regexp)

# source://liquid//lib/liquid/lexer.rb#21
Liquid::Lexer::NUMBER_LITERAL = T.let(T.unsafe(nil), Regexp)

# source://liquid//lib/liquid/lexer.rb#19
Liquid::Lexer::SINGLE_STRING_LITERAL = T.let(T.unsafe(nil), Regexp)

# source://liquid//lib/liquid/lexer.rb#6
Liquid::Lexer::SPECIALS = T.let(T.unsafe(nil), Hash)

# source://liquid//lib/liquid/lexer.rb#24
Liquid::Lexer::WHITESPACE_OR_NOTHING = T.let(T.unsafe(nil), Regexp)

# This implements an abstract file system which retrieves template files named in a manner similar to Rails partials,
# ie. with the template name prefixed with an underscore. The extension ".liquid" is also added.
#
# For security reasons, template paths are only allowed to contain letters, numbers, and underscore.
#
# Example:
#
#   file_system = Liquid::LocalFileSystem.new("/some/path")
#
#   file_system.full_path("mypartial")       # => "/some/path/_mypartial.liquid"
#   file_system.full_path("dir/mypartial")   # => "/some/path/dir/_mypartial.liquid"
#
# Optionally in the second argument you can specify a custom pattern for template filenames.
# The Kernel::sprintf format specification is used.
# Default pattern is "_%s.liquid".
#
# Example:
#
#   file_system = Liquid::LocalFileSystem.new("/some/path", "%s.html")
#
#   file_system.full_path("index") # => "/some/path/index.html"
#
# source://liquid//lib/liquid/file_system.rb#46
class Liquid::LocalFileSystem
  # @return [LocalFileSystem] a new instance of LocalFileSystem
  #
  # source://liquid//lib/liquid/file_system.rb#49
  def initialize(root, pattern = T.unsafe(nil)); end

  # @raise [FileSystemError]
  #
  # source://liquid//lib/liquid/file_system.rb#61
  def full_path(template_path); end

  # @raise [FileSystemError]
  #
  # source://liquid//lib/liquid/file_system.rb#54
  def read_template_file(template_path); end

  # Returns the value of attribute root.
  #
  # source://liquid//lib/liquid/file_system.rb#47
  def root; end

  # Sets the attribute root
  #
  # @param value the value to set the attribute root to.
  #
  # source://liquid//lib/liquid/file_system.rb#47
  def root=(_arg0); end
end

# source://liquid//lib/liquid/errors.rb#49
class Liquid::MemoryError < ::Liquid::Error; end

# source://liquid//lib/liquid/errors.rb#55
class Liquid::MethodOverrideError < ::Liquid::Error; end

# source://liquid//lib/liquid/parse_context.rb#4
class Liquid::ParseContext
  # @return [ParseContext] a new instance of ParseContext
  #
  # source://liquid//lib/liquid/parse_context.rb#8
  def initialize(options = T.unsafe(nil)); end

  # source://liquid//lib/liquid/parse_context.rb#18
  def [](option_key); end

  # Returns the value of attribute depth.
  #
  # source://liquid//lib/liquid/parse_context.rb#5
  def depth; end

  # Sets the attribute depth
  #
  # @param value the value to set the attribute depth to.
  #
  # source://liquid//lib/liquid/parse_context.rb#5
  def depth=(_arg0); end

  # Returns the value of attribute error_mode.
  #
  # source://liquid//lib/liquid/parse_context.rb#6
  def error_mode; end

  # Returns the value of attribute line_number.
  #
  # source://liquid//lib/liquid/parse_context.rb#5
  def line_number; end

  # Sets the attribute line_number
  #
  # @param value the value to set the attribute line_number to.
  #
  # source://liquid//lib/liquid/parse_context.rb#5
  def line_number=(_arg0); end

  # Returns the value of attribute locale.
  #
  # source://liquid//lib/liquid/parse_context.rb#5
  def locale; end

  # Sets the attribute locale
  #
  # @param value the value to set the attribute locale to.
  #
  # source://liquid//lib/liquid/parse_context.rb#5
  def locale=(_arg0); end

  # source://liquid//lib/liquid/parse_context.rb#22
  def new_block_body; end

  # source://liquid//lib/liquid/parse_context.rb#26
  def parse_expression(markup); end

  # Returns the value of attribute partial.
  #
  # source://liquid//lib/liquid/parse_context.rb#6
  def partial; end

  # source://liquid//lib/liquid/parse_context.rb#30
  def partial=(value); end

  # source://liquid//lib/liquid/parse_context.rb#37
  def partial_options; end

  # Returns the value of attribute trim_whitespace.
  #
  # source://liquid//lib/liquid/parse_context.rb#5
  def trim_whitespace; end

  # Sets the attribute trim_whitespace
  #
  # @param value the value to set the attribute trim_whitespace to.
  #
  # source://liquid//lib/liquid/parse_context.rb#5
  def trim_whitespace=(_arg0); end

  # Returns the value of attribute warnings.
  #
  # source://liquid//lib/liquid/parse_context.rb#6
  def warnings; end
end

# source://liquid//lib/liquid/parse_tree_visitor.rb#4
class Liquid::ParseTreeVisitor
  # @return [ParseTreeVisitor] a new instance of ParseTreeVisitor
  #
  # source://liquid//lib/liquid/parse_tree_visitor.rb#13
  def initialize(node, callbacks); end

  # source://liquid//lib/liquid/parse_tree_visitor.rb#18
  def add_callback_for(*classes, &block); end

  # source://liquid//lib/liquid/parse_tree_visitor.rb#26
  def visit(context = T.unsafe(nil)); end

  protected

  # source://liquid//lib/liquid/parse_tree_visitor.rb#38
  def children; end

  class << self
    # source://liquid//lib/liquid/parse_tree_visitor.rb#5
    def for(node, callbacks = T.unsafe(nil)); end
  end
end

# source://liquid//lib/liquid/parser.rb#4
class Liquid::Parser
  # @return [Parser] a new instance of Parser
  #
  # source://liquid//lib/liquid/parser.rb#5
  def initialize(input); end

  # source://liquid//lib/liquid/parser.rb#74
  def argument; end

  # source://liquid//lib/liquid/parser.rb#15
  def consume(type = T.unsafe(nil)); end

  # Only consumes the token if it matches the type
  # Returns the token's contents if it was consumed
  # or false otherwise.
  #
  # @return [Boolean]
  #
  # source://liquid//lib/liquid/parser.rb#27
  def consume?(type); end

  # source://liquid//lib/liquid/parser.rb#49
  def expression; end

  # Like consume? Except for an :id token of a certain name
  #
  # @return [Boolean]
  #
  # source://liquid//lib/liquid/parser.rb#35
  def id?(str); end

  # source://liquid//lib/liquid/parser.rb#11
  def jump(point); end

  # source://liquid//lib/liquid/parser.rb#43
  def look(type, ahead = T.unsafe(nil)); end

  # source://liquid//lib/liquid/parser.rb#85
  def variable_lookups; end
end

# source://liquid//lib/liquid/parser_switching.rb#4
module Liquid::ParserSwitching
  # source://liquid//lib/liquid/parser_switching.rb#17
  def parse_with_selected_parser(markup); end

  # source://liquid//lib/liquid/parser_switching.rb#5
  def strict_parse_with_error_mode_fallback(markup); end

  private

  # source://liquid//lib/liquid/parser_switching.rb#41
  def markup_context(markup); end

  # source://liquid//lib/liquid/parser_switching.rb#33
  def strict_parse_with_error_context(markup); end
end

# source://liquid//lib/liquid/partial_cache.rb#4
class Liquid::PartialCache
  class << self
    # source://liquid//lib/liquid/partial_cache.rb#5
    def load(template_name, context:, parse_context:); end
  end
end

# source://liquid//lib/liquid.rb#41
Liquid::PartialTemplateParser = T.let(T.unsafe(nil), Regexp)

# source://liquid//lib/liquid.rb#38
Liquid::QuotedFragment = T.let(T.unsafe(nil), Regexp)

# source://liquid//lib/liquid.rb#37
Liquid::QuotedString = T.let(T.unsafe(nil), Regexp)

# source://liquid//lib/liquid.rb#45
Liquid::RAISE_EXCEPTION_LAMBDA = T.let(T.unsafe(nil), Proc)

# source://liquid//lib/liquid/range_lookup.rb#4
class Liquid::RangeLookup
  # @return [RangeLookup] a new instance of RangeLookup
  #
  # source://liquid//lib/liquid/range_lookup.rb#15
  def initialize(start_obj, end_obj); end

  # source://liquid//lib/liquid/range_lookup.rb#20
  def evaluate(context); end

  private

  # source://liquid//lib/liquid/range_lookup.rb#28
  def to_integer(input); end

  class << self
    # source://liquid//lib/liquid/range_lookup.rb#5
    def parse(start_markup, end_markup); end
  end
end

# source://liquid//lib/liquid/tags/raw.rb#4
class Liquid::Raw < ::Liquid::Block
  # @return [Raw] a new instance of Raw
  #
  # source://liquid//lib/liquid/tags/raw.rb#8
  def initialize(tag_name, markup, parse_context); end

  # @return [Boolean]
  #
  # source://liquid//lib/liquid/tags/raw.rb#36
  def blank?; end

  # source://liquid//lib/liquid/tags/raw.rb#32
  def nodelist; end

  # source://liquid//lib/liquid/tags/raw.rb#14
  def parse(tokens); end

  # source://liquid//lib/liquid/tags/raw.rb#27
  def render_to_output_buffer(_context, output); end

  protected

  # source://liquid//lib/liquid/tags/raw.rb#42
  def ensure_valid_markup(tag_name, markup, parse_context); end
end

# source://liquid//lib/liquid/tags/raw.rb#6
Liquid::Raw::FullTokenPossiblyInvalid = T.let(T.unsafe(nil), Regexp)

# source://liquid//lib/liquid/tags/raw.rb#5
Liquid::Raw::Syntax = T.let(T.unsafe(nil), Regexp)

# source://liquid//lib/liquid/register.rb#4
class Liquid::Register; end

# source://liquid//lib/liquid/tags/render.rb#4
class Liquid::Render < ::Liquid::Tag
  include ::Liquid::Tag::Disabler
  extend ::Liquid::Tag::Disabler::ClassMethods

  # @raise [SyntaxError]
  # @return [Render] a new instance of Render
  #
  # source://liquid//lib/liquid/tags/render.rb#12
  def initialize(tag_name, markup, options); end

  # Returns the value of attribute attributes.
  #
  # source://liquid//lib/liquid/tags/render.rb#10
  def attributes; end

  # @raise [ArgumentError]
  #
  # source://liquid//lib/liquid/tags/render.rb#36
  def render_tag(context, output); end

  # source://liquid//lib/liquid/tag/disabler.rb#14
  def render_to_output_buffer(context, output); end

  # Returns the value of attribute template_name_expr.
  #
  # source://liquid//lib/liquid/tags/render.rb#10
  def template_name_expr; end
end

# source://liquid//lib/liquid/tags/render.rb#5
Liquid::Render::FOR = T.let(T.unsafe(nil), String)

# source://liquid//lib/liquid/tags/render.rb#74
class Liquid::Render::ParseTreeVisitor < ::Liquid::ParseTreeVisitor
  # source://liquid//lib/liquid/tags/render.rb#75
  def children; end
end

# source://liquid//lib/liquid/tags/render.rb#6
Liquid::Render::SYNTAX = T.let(T.unsafe(nil), Regexp)

# source://liquid//lib/liquid/resource_limits.rb#4
class Liquid::ResourceLimits
  # @return [ResourceLimits] a new instance of ResourceLimits
  #
  # source://liquid//lib/liquid/resource_limits.rb#8
  def initialize(limits); end

  # Returns the value of attribute assign_score.
  #
  # source://liquid//lib/liquid/resource_limits.rb#6
  def assign_score; end

  # Returns the value of attribute assign_score_limit.
  #
  # source://liquid//lib/liquid/resource_limits.rb#5
  def assign_score_limit; end

  # Sets the attribute assign_score_limit
  #
  # @param value the value to set the attribute assign_score_limit to.
  #
  # source://liquid//lib/liquid/resource_limits.rb#5
  def assign_score_limit=(_arg0); end

  # source://liquid//lib/liquid/resource_limits.rb#20
  def increment_assign_score(amount); end

  # source://liquid//lib/liquid/resource_limits.rb#15
  def increment_render_score(amount); end

  # update either render_length or assign_score based on whether or not the writes are captured
  #
  # source://liquid//lib/liquid/resource_limits.rb#26
  def increment_write_score(output); end

  # @raise [MemoryError]
  #
  # source://liquid//lib/liquid/resource_limits.rb#37
  def raise_limits_reached; end

  # @return [Boolean]
  #
  # source://liquid//lib/liquid/resource_limits.rb#42
  def reached?; end

  # Returns the value of attribute render_length_limit.
  #
  # source://liquid//lib/liquid/resource_limits.rb#5
  def render_length_limit; end

  # Sets the attribute render_length_limit
  #
  # @param value the value to set the attribute render_length_limit to.
  #
  # source://liquid//lib/liquid/resource_limits.rb#5
  def render_length_limit=(_arg0); end

  # Returns the value of attribute render_score.
  #
  # source://liquid//lib/liquid/resource_limits.rb#6
  def render_score; end

  # Returns the value of attribute render_score_limit.
  #
  # source://liquid//lib/liquid/resource_limits.rb#5
  def render_score_limit; end

  # Sets the attribute render_score_limit
  #
  # @param value the value to set the attribute render_score_limit to.
  #
  # source://liquid//lib/liquid/resource_limits.rb#5
  def render_score_limit=(_arg0); end

  # source://liquid//lib/liquid/resource_limits.rb#46
  def reset; end

  # source://liquid//lib/liquid/resource_limits.rb#52
  def with_capture; end
end

# source://liquid//lib/liquid/errors.rb#48
class Liquid::StackLevelError < ::Liquid::Error; end

# source://liquid//lib/liquid/errors.rb#46
class Liquid::StandardError < ::Liquid::Error; end

# source://liquid//lib/liquid/standardfilters.rb#7
module Liquid::StandardFilters
  # absolute value
  #
  # source://liquid//lib/liquid/standardfilters.rb#359
  def abs(input); end

  # add one string to another
  #
  # source://liquid//lib/liquid/standardfilters.rb#280
  def append(input, string); end

  # source://liquid//lib/liquid/standardfilters.rb#413
  def at_least(input, n); end

  # source://liquid//lib/liquid/standardfilters.rb#421
  def at_most(input, n); end

  # capitalize words in the input centence
  #
  # source://liquid//lib/liquid/standardfilters.rb#39
  def capitalize(input); end

  # source://liquid//lib/liquid/standardfilters.rb#401
  def ceil(input); end

  # Remove nils within an array
  # provide optional property with which to check for nil
  #
  # source://liquid//lib/liquid/standardfilters.rb#243
  def compact(input, property = T.unsafe(nil)); end

  # source://liquid//lib/liquid/standardfilters.rb#284
  def concat(input, array); end

  # Reformat a date using Ruby's core Time#strftime( string ) -> string
  #
  #   %a - The abbreviated weekday name (``Sun'')
  #   %A - The  full  weekday  name (``Sunday'')
  #   %b - The abbreviated month name (``Jan'')
  #   %B - The  full  month  name (``January'')
  #   %c - The preferred local date and time representation
  #   %d - Day of the month (01..31)
  #   %H - Hour of the day, 24-hour clock (00..23)
  #   %I - Hour of the day, 12-hour clock (01..12)
  #   %j - Day of the year (001..366)
  #   %m - Month of the year (01..12)
  #   %M - Minute of the hour (00..59)
  #   %p - Meridian indicator (``AM''  or  ``PM'')
  #   %s - Number of seconds since 1970-01-01 00:00:00 UTC.
  #   %S - Second of the minute (00..60)
  #   %U - Week  number  of the current year,
  #           starting with the first Sunday as the first
  #           day of the first week (00..53)
  #   %W - Week  number  of the current year,
  #           starting with the first Monday as the first
  #           day of the first week (00..53)
  #   %w - Day of the week (Sunday is 0, 0..6)
  #   %x - Preferred representation for the date alone, no time
  #   %X - Preferred representation for the time alone, no date
  #   %y - Year without a century (00..99)
  #   %Y - Year with century
  #   %Z - Time zone name
  #   %% - Literal ``%'' character
  #
  #   See also: http://www.ruby-doc.org/core/Time.html#method-i-strftime
  #
  # source://liquid//lib/liquid/standardfilters.rb#332
  def date(input, format); end

  # Set a default value when the input is nil, false or empty
  #
  # Example:
  #    {{ product.title | default: "No Title" }}
  #
  # Use `allow_false` when an input should only be tested against nil or empty and not false.
  #
  # Example:
  #    {{ product.title | default: "No Title", allow_false: true }}
  #
  # source://liquid//lib/liquid/standardfilters.rb#439
  def default(input, default_value = T.unsafe(nil), options = T.unsafe(nil)); end

  # division
  #
  # source://liquid//lib/liquid/standardfilters.rb#380
  def divided_by(input, operand); end

  # convert an input string to DOWNCASE
  #
  # source://liquid//lib/liquid/standardfilters.rb#29
  def downcase(input); end

  # source://liquid//lib/liquid/standardfilters.rb#43
  def escape(input); end

  # source://liquid//lib/liquid/standardfilters.rb#48
  def escape_once(input); end

  # Get the first element of the passed in array
  #
  # Example:
  #    {{ product.images | first | to_img }}
  #
  # source://liquid//lib/liquid/standardfilters.rb#345
  def first(array); end

  # source://liquid//lib/liquid/standardfilters.rb#407
  def floor(input); end

  # source://liquid//lib/liquid/standardfilters.rb#43
  def h(input); end

  # Join elements of the array with certain character between them
  #
  # source://liquid//lib/liquid/standardfilters.rb#135
  def join(input, glue = T.unsafe(nil)); end

  # Get the last element of the passed in array
  #
  # Example:
  #    {{ product.images | last | to_img }}
  #
  # source://liquid//lib/liquid/standardfilters.rb#354
  def last(array); end

  # source://liquid//lib/liquid/standardfilters.rb#114
  def lstrip(input); end

  # map/collect on a given property
  #
  # source://liquid//lib/liquid/standardfilters.rb#226
  def map(input, property); end

  # subtraction
  #
  # source://liquid//lib/liquid/standardfilters.rb#370
  def minus(input, operand); end

  # source://liquid//lib/liquid/standardfilters.rb#386
  def modulo(input, operand); end

  # Add <br /> tags in front of all newlines in input string
  #
  # source://liquid//lib/liquid/standardfilters.rb#297
  def newline_to_br(input); end

  # addition
  #
  # source://liquid//lib/liquid/standardfilters.rb#365
  def plus(input, operand); end

  # prepend a string to another
  #
  # source://liquid//lib/liquid/standardfilters.rb#292
  def prepend(input, string); end

  # remove a substring
  #
  # source://liquid//lib/liquid/standardfilters.rb#270
  def remove(input, string); end

  # remove the first occurrences of a substring
  #
  # source://liquid//lib/liquid/standardfilters.rb#275
  def remove_first(input, string); end

  # Replace occurrences of a string with another
  #
  # source://liquid//lib/liquid/standardfilters.rb#260
  def replace(input, string, replacement = T.unsafe(nil)); end

  # Replace the first occurrences of a string with another
  #
  # source://liquid//lib/liquid/standardfilters.rb#265
  def replace_first(input, string, replacement = T.unsafe(nil)); end

  # Reverse the elements of an array
  #
  # source://liquid//lib/liquid/standardfilters.rb#220
  def reverse(input); end

  # source://liquid//lib/liquid/standardfilters.rb#392
  def round(input, n = T.unsafe(nil)); end

  # source://liquid//lib/liquid/standardfilters.rb#118
  def rstrip(input); end

  # Return the size of an array or of an string
  #
  # source://liquid//lib/liquid/standardfilters.rb#24
  def size(input); end

  # source://liquid//lib/liquid/standardfilters.rb#65
  def slice(input, offset, length = T.unsafe(nil)); end

  # Sort elements of the array
  # provide optional property with which to sort an array of hashes or drops
  #
  # source://liquid//lib/liquid/standardfilters.rb#141
  def sort(input, property = T.unsafe(nil)); end

  # Sort elements of an array ignoring case if strings
  # provide optional property with which to sort an array of hashes or drops
  #
  # source://liquid//lib/liquid/standardfilters.rb#161
  def sort_natural(input, property = T.unsafe(nil)); end

  # Split input string into an array of substrings separated by given pattern.
  #
  # Example:
  #   <div class="summary">{{ post | split '//' | first }}</div>
  #
  # source://liquid//lib/liquid/standardfilters.rb#106
  def split(input, pattern); end

  # source://liquid//lib/liquid/standardfilters.rb#110
  def strip(input); end

  # source://liquid//lib/liquid/standardfilters.rb#122
  def strip_html(input); end

  # Remove all newlines from the string
  #
  # source://liquid//lib/liquid/standardfilters.rb#130
  def strip_newlines(input); end

  # multiplication
  #
  # source://liquid//lib/liquid/standardfilters.rb#375
  def times(input, operand); end

  # Truncate a string down to x characters
  #
  # source://liquid//lib/liquid/standardfilters.rb#77
  def truncate(input, length = T.unsafe(nil), truncate_string = T.unsafe(nil)); end

  # source://liquid//lib/liquid/standardfilters.rb#90
  def truncatewords(input, words = T.unsafe(nil), truncate_string = T.unsafe(nil)); end

  # Remove duplicate elements from an array
  # provide optional property with which to determine uniqueness
  #
  # source://liquid//lib/liquid/standardfilters.rb#203
  def uniq(input, property = T.unsafe(nil)); end

  # convert an input string to UPCASE
  #
  # source://liquid//lib/liquid/standardfilters.rb#34
  def upcase(input); end

  # @raise [Liquid::ArgumentError]
  #
  # source://liquid//lib/liquid/standardfilters.rb#56
  def url_decode(input); end

  # source://liquid//lib/liquid/standardfilters.rb#52
  def url_encode(input); end

  # Filter the elements of an array to those with a certain property value.
  # By default the target is any truthy value.
  #
  # source://liquid//lib/liquid/standardfilters.rb#181
  def where(input, property, target_value = T.unsafe(nil)); end

  private

  # source://liquid//lib/liquid/standardfilters.rb#453
  def apply_operation(input, operand, operation); end

  # Returns the value of attribute context.
  #
  # source://liquid//lib/liquid/standardfilters.rb#447
  def context; end

  # source://liquid//lib/liquid/standardfilters.rb#466
  def nil_safe_casecmp(a, b); end

  # source://liquid//lib/liquid/standardfilters.rb#458
  def nil_safe_compare(a, b); end

  # @raise [Liquid::ArgumentError]
  #
  # source://liquid//lib/liquid/standardfilters.rb#449
  def raise_property_error(property); end
end

# source://liquid//lib/liquid/standardfilters.rb#8
Liquid::StandardFilters::HTML_ESCAPE = T.let(T.unsafe(nil), Hash)

# source://liquid//lib/liquid/standardfilters.rb#15
Liquid::StandardFilters::HTML_ESCAPE_ONCE_REGEXP = T.let(T.unsafe(nil), Regexp)

# source://liquid//lib/liquid/standardfilters.rb#474
class Liquid::StandardFilters::InputIterator
  include ::Prelude::Enumerator
  include ::Enumerable

  # @return [InputIterator] a new instance of InputIterator
  #
  # source://liquid//lib/liquid/standardfilters.rb#477
  def initialize(input, context); end

  # source://liquid//lib/liquid/standardfilters.rb#506
  def compact; end

  # source://liquid//lib/liquid/standardfilters.rb#494
  def concat(args); end

  # source://liquid//lib/liquid/standardfilters.rb#515
  def each; end

  # @return [Boolean]
  #
  # source://liquid//lib/liquid/standardfilters.rb#510
  def empty?; end

  # source://liquid//lib/liquid/standardfilters.rb#490
  def join(glue); end

  # source://liquid//lib/liquid/standardfilters.rb#498
  def reverse; end

  # source://liquid//lib/liquid/standardfilters.rb#502
  def uniq(&block); end
end

# source://liquid//lib/liquid/standardfilters.rb#16
Liquid::StandardFilters::STRIP_HTML_BLOCKS = T.let(T.unsafe(nil), Regexp)

# source://liquid//lib/liquid/standardfilters.rb#21
Liquid::StandardFilters::STRIP_HTML_TAGS = T.let(T.unsafe(nil), Regexp)

# source://liquid//lib/liquid/static_registers.rb#4
class Liquid::StaticRegisters
  # @return [StaticRegisters] a new instance of StaticRegisters
  #
  # source://liquid//lib/liquid/static_registers.rb#7
  def initialize(registers = T.unsafe(nil)); end

  # source://liquid//lib/liquid/static_registers.rb#16
  def [](key); end

  # source://liquid//lib/liquid/static_registers.rb#12
  def []=(key, value); end

  # source://liquid//lib/liquid/static_registers.rb#24
  def delete(key); end

  # source://liquid//lib/liquid/static_registers.rb#30
  def fetch(key, default = T.unsafe(nil), &block); end

  # @return [Boolean]
  #
  # source://liquid//lib/liquid/static_registers.rb#40
  def key?(key); end

  # Returns the value of attribute static.
  #
  # source://liquid//lib/liquid/static_registers.rb#5
  def static; end
end

# source://liquid//lib/liquid/static_registers.rb#28
Liquid::StaticRegisters::UNDEFINED = T.let(T.unsafe(nil), Object)

# StrainerFactory is the factory for the filters system.
#
# source://liquid//lib/liquid/strainer_factory.rb#5
module Liquid::StrainerFactory
  extend ::Liquid::StrainerFactory

  # source://liquid//lib/liquid/strainer_factory.rb#8
  def add_global_filter(filter); end

  # source://liquid//lib/liquid/strainer_factory.rb#13
  def create(context, filters = T.unsafe(nil)); end

  private

  # source://liquid//lib/liquid/strainer_factory.rb#19
  def global_filters; end

  # source://liquid//lib/liquid/strainer_factory.rb#32
  def strainer_class_cache; end

  # source://liquid//lib/liquid/strainer_factory.rb#23
  def strainer_from_cache(filters); end
end

# StrainerTemplate is the computed class for the filters system.
# New filters are mixed into the strainer class which is then instantiated for each liquid template render run.
#
# The Strainer only allows method calls defined in filters given to it via StrainerFactory.add_global_filter,
# Context#add_filters or Template.register_filter
#
# source://liquid//lib/liquid/strainer_template.rb#11
class Liquid::StrainerTemplate
  # @return [StrainerTemplate] a new instance of StrainerTemplate
  #
  # source://liquid//lib/liquid/strainer_template.rb#12
  def initialize(context); end

  # source://liquid//lib/liquid/strainer_template.rb#41
  def invoke(method, *args); end

  class << self
    # source://liquid//lib/liquid/strainer_template.rb#17
    def add_filter(filter); end

    # @return [Boolean]
    #
    # source://liquid//lib/liquid/strainer_template.rb#30
    def invokable?(method); end

    private

    # source://liquid//lib/liquid/strainer_template.rb#36
    def filter_methods; end
  end
end

# source://liquid//lib/liquid/errors.rb#47
class Liquid::SyntaxError < ::Liquid::Error; end

# source://liquid//lib/liquid/tags/table_row.rb#4
class Liquid::TableRow < ::Liquid::Block
  # @return [TableRow] a new instance of TableRow
  #
  # source://liquid//lib/liquid/tags/table_row.rb#9
  def initialize(tag_name, markup, options); end

  # Returns the value of attribute attributes.
  #
  # source://liquid//lib/liquid/tags/table_row.rb#7
  def attributes; end

  # Returns the value of attribute collection_name.
  #
  # source://liquid//lib/liquid/tags/table_row.rb#7
  def collection_name; end

  # source://liquid//lib/liquid/tags/table_row.rb#23
  def render_to_output_buffer(context, output); end

  # Returns the value of attribute variable_name.
  #
  # source://liquid//lib/liquid/tags/table_row.rb#7
  def variable_name; end
end

# source://liquid//lib/liquid/tags/table_row.rb#58
class Liquid::TableRow::ParseTreeVisitor < ::Liquid::ParseTreeVisitor
  # source://liquid//lib/liquid/tags/table_row.rb#59
  def children; end
end

# source://liquid//lib/liquid/tags/table_row.rb#5
Liquid::TableRow::Syntax = T.let(T.unsafe(nil), Regexp)

# source://liquid//lib/liquid/tablerowloop_drop.rb#4
class Liquid::TablerowloopDrop < ::Liquid::Drop
  # @return [TablerowloopDrop] a new instance of TablerowloopDrop
  #
  # source://liquid//lib/liquid/tablerowloop_drop.rb#5
  def initialize(length, cols); end

  # Returns the value of attribute col.
  #
  # source://liquid//lib/liquid/tablerowloop_drop.rb#13
  def col; end

  # source://liquid//lib/liquid/tablerowloop_drop.rb#23
  def col0; end

  # source://liquid//lib/liquid/tablerowloop_drop.rb#43
  def col_first; end

  # source://liquid//lib/liquid/tablerowloop_drop.rb#47
  def col_last; end

  # source://liquid//lib/liquid/tablerowloop_drop.rb#35
  def first; end

  # source://liquid//lib/liquid/tablerowloop_drop.rb#15
  def index; end

  # source://liquid//lib/liquid/tablerowloop_drop.rb#19
  def index0; end

  # source://liquid//lib/liquid/tablerowloop_drop.rb#39
  def last; end

  # Returns the value of attribute length.
  #
  # source://liquid//lib/liquid/tablerowloop_drop.rb#13
  def length; end

  # source://liquid//lib/liquid/tablerowloop_drop.rb#27
  def rindex; end

  # source://liquid//lib/liquid/tablerowloop_drop.rb#31
  def rindex0; end

  # Returns the value of attribute row.
  #
  # source://liquid//lib/liquid/tablerowloop_drop.rb#13
  def row; end

  protected

  # source://liquid//lib/liquid/tablerowloop_drop.rb#53
  def increment!; end
end

# source://liquid//lib/liquid/tag.rb#4
class Liquid::Tag
  include ::Liquid::ParserSwitching

  # @return [Tag] a new instance of Tag
  #
  # source://liquid//lib/liquid/tag.rb#25
  def initialize(tag_name, markup, parse_context); end

  # @return [Boolean]
  #
  # source://liquid//lib/liquid/tag.rb#55
  def blank?; end

  # Returns the value of attribute line_number.
  #
  # source://liquid//lib/liquid/tag.rb#5
  def line_number; end

  # source://liquid//lib/liquid/tag.rb#39
  def name; end

  # Returns the value of attribute nodelist.
  #
  # source://liquid//lib/liquid/tag.rb#5
  def nodelist; end

  # Returns the value of attribute parse_context.
  #
  # source://liquid//lib/liquid/tag.rb#5
  def options; end

  # source://liquid//lib/liquid/tag.rb#32
  def parse(_tokens); end

  # Returns the value of attribute parse_context.
  #
  # source://liquid//lib/liquid/tag.rb#5
  def parse_context; end

  # source://liquid//lib/liquid/tag.rb#35
  def raw; end

  # source://liquid//lib/liquid/tag.rb#43
  def render(_context); end

  # For backwards compatibility with custom tags. In a future release, the semantics
  # of the `render_to_output_buffer` method will become the default and the `render`
  # method will be removed.
  #
  # source://liquid//lib/liquid/tag.rb#50
  def render_to_output_buffer(context, output); end

  # Returns the value of attribute tag_name.
  #
  # source://liquid//lib/liquid/tag.rb#5
  def tag_name; end

  private

  # source://liquid//lib/liquid/tag.rb#61
  def parse_expression(markup); end

  class << self
    # source://liquid//lib/liquid/tag.rb#16
    def disable_tags(*tag_names); end

    # source://liquid//lib/liquid/tag.rb#10
    def parse(tag_name, markup, tokenizer, parse_context); end

    private

    def new(*_arg0); end
  end
end

# source://liquid//lib/liquid/tag/disableable.rb#5
module Liquid::Tag::Disableable
  # source://liquid//lib/liquid/tag/disableable.rb#14
  def disabled_error(context); end

  # source://liquid//lib/liquid/tag/disableable.rb#6
  def render_to_output_buffer(context, output); end
end

# source://liquid//lib/liquid/tag/disabler.rb#5
module Liquid::Tag::Disabler
  # source://liquid//lib/liquid/tag/disabler.rb#14
  def render_to_output_buffer(context, output); end

  class << self
    # source://liquid//lib/liquid/tag/disabler.rb#10
    def prepended(base); end
  end
end

# source://liquid//lib/liquid/tag/disabler.rb#6
module Liquid::Tag::Disabler::ClassMethods
  # Returns the value of attribute disabled_tags.
  #
  # source://liquid//lib/liquid/tag/disabler.rb#7
  def disabled_tags; end
end

# source://liquid//lib/liquid.rb#39
Liquid::TagAttributes = T.let(T.unsafe(nil), Regexp)

# source://liquid//lib/liquid.rb#31
Liquid::TagEnd = T.let(T.unsafe(nil), Regexp)

# source://liquid//lib/liquid.rb#30
Liquid::TagStart = T.let(T.unsafe(nil), Regexp)

# Templates are central to liquid.
# Interpretating templates is a two step process. First you compile the
# source code you got. During compile time some extensive error checking is performed.
# your code should expect to get some SyntaxErrors.
#
# After you have a compiled template you can then <tt>render</tt> it.
# You can use a compiled template over and over again and keep it cached.
#
# Example:
#
#   template = Liquid::Template.parse(source)
#   template.render('user_name' => 'bob')
#
# source://liquid//lib/liquid/template.rb#17
class Liquid::Template
  # @return [Template] a new instance of Template
  #
  # source://liquid//lib/liquid/template.rb#101
  def initialize; end

  # source://liquid//lib/liquid/template.rb#118
  def assigns; end

  # source://liquid//lib/liquid/template.rb#126
  def errors; end

  # source://liquid//lib/liquid/template.rb#122
  def instance_assigns; end

  # Parse source code.
  # Returns self for easy chaining
  #
  # source://liquid//lib/liquid/template.rb#108
  def parse(source, options = T.unsafe(nil)); end

  # Returns the value of attribute profiler.
  #
  # source://liquid//lib/liquid/template.rb#57
  def profiler; end

  # source://liquid//lib/liquid/template.rb#114
  def registers; end

  # Render takes a hash with local variables.
  #
  # if you use the same filters over and over again consider registering them globally
  # with <tt>Template.register_filter</tt>
  #
  # if profiling was enabled in <tt>Template#parse</tt> then the resulting profiling information
  # will be available via <tt>Template#profiler</tt>
  #
  # Following options can be passed:
  #
  #  * <tt>filters</tt> : array with local filters
  #  * <tt>registers</tt> : hash with register variables. Those can be accessed from
  #    filters and tags and might be useful to integrate liquid more with its host application
  #
  # source://liquid//lib/liquid/template.rb#144
  def render(*args); end

  # source://liquid//lib/liquid/template.rb#202
  def render!(*args); end

  # source://liquid//lib/liquid/template.rb#207
  def render_to_output_buffer(context, output); end

  # Returns the value of attribute resource_limits.
  #
  # source://liquid//lib/liquid/template.rb#19
  def resource_limits; end

  # Returns the value of attribute root.
  #
  # source://liquid//lib/liquid/template.rb#18
  def root; end

  # Sets the attribute root
  #
  # @param value the value to set the attribute root to.
  #
  # source://liquid//lib/liquid/template.rb#18
  def root=(_arg0); end

  # Returns the value of attribute warnings.
  #
  # source://liquid//lib/liquid/template.rb#19
  def warnings; end

  private

  # source://liquid//lib/liquid/template.rb#230
  def apply_options_to_context(context, options); end

  # source://liquid//lib/liquid/template.rb#213
  def configure_options(options); end

  # source://liquid//lib/liquid/template.rb#226
  def tokenize(source); end

  class << self
    # Returns the value of attribute default_exception_renderer.
    #
    # source://liquid//lib/liquid/template.rb#67
    def default_exception_renderer; end

    # Sets the attribute default_exception_renderer
    #
    # @param value the value to set the attribute default_exception_renderer to.
    #
    # source://liquid//lib/liquid/template.rb#67
    def default_exception_renderer=(_arg0); end

    # Returns the value of attribute default_resource_limits.
    #
    # source://liquid//lib/liquid/template.rb#89
    def default_resource_limits; end

    # Sets how strict the parser should be.
    # :lax acts like liquid 2.5 and silently ignores malformed tags in most cases.
    # :warn is the default and will give deprecation warnings when invalid syntax is used.
    # :strict will enforce correct syntax.
    #
    # source://liquid//lib/liquid/template.rb#64
    def error_mode; end

    # Sets how strict the parser should be.
    # :lax acts like liquid 2.5 and silently ignores malformed tags in most cases.
    # :warn is the default and will give deprecation warnings when invalid syntax is used.
    # :strict will enforce correct syntax.
    #
    # source://liquid//lib/liquid/template.rb#64
    def error_mode=(_arg0); end

    # Returns the value of attribute file_system.
    #
    # source://liquid//lib/liquid/template.rb#72
    def file_system; end

    # Sets the attribute file_system
    #
    # @param value the value to set the attribute file_system to.
    #
    # source://liquid//lib/liquid/template.rb#72
    def file_system=(_arg0); end

    # creates a new <tt>Template</tt> object from liquid source code
    # To enable profiling, pass in <tt>profile: true</tt> as an option.
    # See Liquid::Profiler for more information
    #
    # source://liquid//lib/liquid/template.rb#96
    def parse(source, options = T.unsafe(nil)); end

    # Pass a module with filter methods which should be available
    # to all liquid views. Good for registering the standard library
    #
    # source://liquid//lib/liquid/template.rb#85
    def register_filter(mod); end

    # source://liquid//lib/liquid/template.rb#79
    def register_tag(name, klass); end

    # Returns the value of attribute tags.
    #
    # source://liquid//lib/liquid/template.rb#75
    def tags; end

    private

    # Sets the attribute default_resource_limits
    #
    # @param value the value to set the attribute default_resource_limits to.
    #
    # source://liquid//lib/liquid/template.rb#89
    def default_resource_limits=(_arg0); end

    # Sets the attribute tags
    #
    # @param value the value to set the attribute tags to.
    #
    # source://liquid//lib/liquid/template.rb#75
    def tags=(_arg0); end
  end
end

# source://liquid//lib/liquid/template.rb#21
class Liquid::Template::TagRegistry
  include ::Prelude::Enumerator
  include ::Enumerable

  # @return [TagRegistry] a new instance of TagRegistry
  #
  # source://liquid//lib/liquid/template.rb#24
  def initialize; end

  # source://liquid//lib/liquid/template.rb#29
  def [](tag_name); end

  # source://liquid//lib/liquid/template.rb#36
  def []=(tag_name, klass); end

  # source://liquid//lib/liquid/template.rb#41
  def delete(tag_name); end

  # source://liquid//lib/liquid/template.rb#46
  def each(&block); end

  private

  # source://liquid//lib/liquid/template.rb#52
  def lookup_class(name); end
end

# source://liquid//lib/liquid/template_factory.rb#4
class Liquid::TemplateFactory
  # source://liquid//lib/liquid/template_factory.rb#5
  def for(_template_name); end
end

# source://liquid//lib/liquid.rb#42
Liquid::TemplateParser = T.let(T.unsafe(nil), Regexp)

# source://liquid//lib/liquid/tokenizer.rb#4
class Liquid::Tokenizer
  # @return [Tokenizer] a new instance of Tokenizer
  #
  # source://liquid//lib/liquid/tokenizer.rb#7
  def initialize(source, line_numbers = T.unsafe(nil), line_number: T.unsafe(nil), for_liquid_tag: T.unsafe(nil)); end

  # Returns the value of attribute for_liquid_tag.
  #
  # source://liquid//lib/liquid/tokenizer.rb#5
  def for_liquid_tag; end

  # Returns the value of attribute line_number.
  #
  # source://liquid//lib/liquid/tokenizer.rb#5
  def line_number; end

  # source://liquid//lib/liquid/tokenizer.rb#14
  def shift; end

  private

  # source://liquid//lib/liquid/tokenizer.rb#26
  def tokenize; end
end

# source://liquid//lib/liquid/errors.rb#53
class Liquid::UndefinedDropMethod < ::Liquid::Error; end

# source://liquid//lib/liquid/errors.rb#54
class Liquid::UndefinedFilter < ::Liquid::Error; end

# source://liquid//lib/liquid/errors.rb#52
class Liquid::UndefinedVariable < ::Liquid::Error; end

# Unless is a conditional just like 'if' but works on the inverse logic.
#
#   {% unless x < 0 %} x is greater than zero {% endunless %}
#
# source://liquid//lib/liquid/tags/unless.rb#10
class Liquid::Unless < ::Liquid::If
  # source://liquid//lib/liquid/tags/unless.rb#11
  def render_to_output_buffer(context, output); end
end

# source://liquid//lib/liquid/usage.rb#4
module Liquid::Usage
  class << self
    # source://liquid//lib/liquid/usage.rb#5
    def increment(name); end
  end
end

# source://liquid//lib/liquid/utils.rb#4
module Liquid::Utils
  class << self
    # source://liquid//lib/liquid/utils.rb#5
    def slice_collection(collection, from, to); end

    # source://liquid//lib/liquid/utils.rb#13
    def slice_collection_using_each(collection, from, to); end

    # source://liquid//lib/liquid/utils.rb#65
    def to_date(obj); end

    # source://liquid//lib/liquid/utils.rb#38
    def to_integer(num); end

    # source://liquid//lib/liquid/utils.rb#48
    def to_number(obj); end
  end
end

# source://liquid//lib/liquid/version.rb#5
Liquid::VERSION = T.let(T.unsafe(nil), String)

# Holds variables. Variables are only loaded "just in time"
# and are not evaluated as part of the render stage
#
#   {{ monkey }}
#   {{ user.name }}
#
# Variables can be combined with filters:
#
#   {{ user | link }}
#
# source://liquid//lib/liquid/variable.rb#14
class Liquid::Variable
  include ::Liquid::ParserSwitching

  # @return [Variable] a new instance of Variable
  #
  # source://liquid//lib/liquid/variable.rb#27
  def initialize(markup, parse_context); end

  # @return [Boolean]
  #
  # source://liquid//lib/liquid/variable.rb#109
  def disabled?(_context); end

  # source://liquid//lib/liquid/variable.rb#113
  def disabled_tags; end

  # Returns the value of attribute filters.
  #
  # source://liquid//lib/liquid/variable.rb#21
  def filters; end

  # Sets the attribute filters
  #
  # @param value the value to set the attribute filters to.
  #
  # source://liquid//lib/liquid/variable.rb#21
  def filters=(_arg0); end

  # source://liquid//lib/liquid/variable.rb#44
  def lax_parse(markup); end

  # Returns the value of attribute line_number.
  #
  # source://liquid//lib/liquid/variable.rb#21
  def line_number; end

  # Sets the attribute line_number
  #
  # @param value the value to set the attribute line_number to.
  #
  # source://liquid//lib/liquid/variable.rb#21
  def line_number=(_arg0); end

  # source://liquid//lib/liquid/variable.rb#40
  def markup_context(markup); end

  # Returns the value of attribute name.
  #
  # source://liquid//lib/liquid/variable.rb#21
  def name; end

  # Sets the attribute name
  #
  # @param value the value to set the attribute name to.
  #
  # source://liquid//lib/liquid/variable.rb#21
  def name=(_arg0); end

  # Returns the value of attribute parse_context.
  #
  # source://liquid//lib/liquid/variable.rb#22
  def options; end

  # Returns the value of attribute parse_context.
  #
  # source://liquid//lib/liquid/variable.rb#22
  def parse_context; end

  # source://liquid//lib/liquid/variable.rb#77
  def parse_filterargs(p); end

  # source://liquid//lib/liquid/variable.rb#36
  def raw; end

  # source://liquid//lib/liquid/variable.rb#85
  def render(context); end

  # source://liquid//lib/liquid/variable.rb#96
  def render_to_output_buffer(context, output); end

  # source://liquid//lib/liquid/variable.rb#62
  def strict_parse(markup); end

  private

  # source://liquid//lib/liquid/variable.rb#135
  def evaluate_filter_expressions(context, filter_args, filter_kwargs); end

  # source://liquid//lib/liquid/variable.rb#119
  def parse_filter_expressions(filter_name, unparsed_args); end
end

# source://liquid//lib/liquid/variable.rb#17
Liquid::Variable::FilterArgsRegex = T.let(T.unsafe(nil), Regexp)

# source://liquid//lib/liquid/variable.rb#15
Liquid::Variable::FilterMarkupRegex = T.let(T.unsafe(nil), Regexp)

# source://liquid//lib/liquid/variable.rb#16
Liquid::Variable::FilterParser = T.let(T.unsafe(nil), Regexp)

# source://liquid//lib/liquid/variable.rb#18
Liquid::Variable::JustTagAttributes = T.let(T.unsafe(nil), Regexp)

# source://liquid//lib/liquid/variable.rb#19
Liquid::Variable::MarkupWithQuotedFragment = T.let(T.unsafe(nil), Regexp)

# source://liquid//lib/liquid/variable.rb#147
class Liquid::Variable::ParseTreeVisitor < ::Liquid::ParseTreeVisitor
  # source://liquid//lib/liquid/variable.rb#148
  def children; end
end

# source://liquid//lib/liquid.rb#28
Liquid::VariableAttributeSeparator = T.let(T.unsafe(nil), String)

# source://liquid//lib/liquid.rb#35
Liquid::VariableEnd = T.let(T.unsafe(nil), Regexp)

# source://liquid//lib/liquid.rb#36
Liquid::VariableIncompleteEnd = T.let(T.unsafe(nil), Regexp)

# source://liquid//lib/liquid/variable_lookup.rb#4
class Liquid::VariableLookup
  # @return [VariableLookup] a new instance of VariableLookup
  #
  # source://liquid//lib/liquid/variable_lookup.rb#14
  def initialize(markup); end

  # source://liquid//lib/liquid/variable_lookup.rb#74
  def ==(other); end

  # source://liquid//lib/liquid/variable_lookup.rb#36
  def evaluate(context); end

  # Returns the value of attribute lookups.
  #
  # source://liquid//lib/liquid/variable_lookup.rb#8
  def lookups; end

  # Returns the value of attribute name.
  #
  # source://liquid//lib/liquid/variable_lookup.rb#8
  def name; end

  protected

  # source://liquid//lib/liquid/variable_lookup.rb#80
  def state; end

  class << self
    # source://liquid//lib/liquid/variable_lookup.rb#10
    def parse(markup); end
  end
end

# source://liquid//lib/liquid/variable_lookup.rb#6
Liquid::VariableLookup::COMMAND_METHODS = T.let(T.unsafe(nil), Array)

# source://liquid//lib/liquid/variable_lookup.rb#84
class Liquid::VariableLookup::ParseTreeVisitor < ::Liquid::ParseTreeVisitor
  # source://liquid//lib/liquid/variable_lookup.rb#85
  def children; end
end

# source://liquid//lib/liquid/variable_lookup.rb#5
Liquid::VariableLookup::SQUARE_BRACKETED = T.let(T.unsafe(nil), Regexp)

# source://liquid//lib/liquid.rb#43
Liquid::VariableParser = T.let(T.unsafe(nil), Regexp)

# source://liquid//lib/liquid.rb#33
Liquid::VariableSegment = T.let(T.unsafe(nil), Regexp)

# source://liquid//lib/liquid.rb#32
Liquid::VariableSignature = T.let(T.unsafe(nil), Regexp)

# source://liquid//lib/liquid.rb#34
Liquid::VariableStart = T.let(T.unsafe(nil), Regexp)

# source://liquid//lib/liquid.rb#29
Liquid::WhitespaceControl = T.let(T.unsafe(nil), String)

# source://liquid//lib/liquid/errors.rb#50
class Liquid::ZeroDivisionError < ::Liquid::Error; end

# source://liquid//lib/liquid/extensions.rb#72
class NilClass
  include ::MessagePack::CoreExt
  include ::JSON::Ext::Generator::GeneratorMethods::NilClass

  # source://liquid//lib/liquid/extensions.rb#73
  def to_liquid; end
end

# source://liquid//lib/liquid/extensions.rb#30
class Numeric
  include ::Comparable

  # source://liquid//lib/liquid/extensions.rb#31
  def to_liquid; end
end

# source://liquid//lib/liquid/extensions.rb#36
class Range
  include ::Prelude::Enumerator
  include ::Enumerable

  # source://liquid//lib/liquid/extensions.rb#37
  def to_liquid; end
end

# source://liquid//lib/liquid/extensions.rb#6
class String
  include ::Comparable
  include ::MessagePack::CoreExt
  include ::JSON::Ext::Generator::GeneratorMethods::String
  extend ::JSON::Ext::Generator::GeneratorMethods::String::Extend

  # source://liquid//lib/liquid/extensions.rb#7
  def to_liquid; end
end

# source://liquid//lib/liquid/extensions.rb#12
class Symbol
  include ::Comparable
  include ::MessagePack::CoreExt

  # source://liquid//lib/liquid/extensions.rb#13
  def to_liquid; end
end

# source://liquid//lib/liquid/extensions.rb#42
class Time
  include ::Comparable
  include ::DateAndTime::Zones
  include ::DateAndTime::Calculations

  # source://liquid//lib/liquid/extensions.rb#43
  def to_liquid; end
end

# source://liquid//lib/liquid/extensions.rb#60
class TrueClass
  include ::MessagePack::CoreExt
  include ::JSON::Ext::Generator::GeneratorMethods::TrueClass

  # source://liquid//lib/liquid/extensions.rb#61
  def to_liquid; end
end
