{"version":3,"file":"chunk-node_modules_codemirror_legacy-modes_mode_haxe_js-xxxxxxxxxxxx.js","mappings":"gJAEA,SAASA,EAAGC,CAAI,EAAG,MAAO,CAACA,KAAMA,EAAMC,MAAO,SAAS,CAAE,C,wCACzD,IAiCID,EAAME,EAjCNC,EAAIJ,EAAG,aAAcK,EAAIL,EAAG,aAAcM,EAAIN,EAAG,aACjDO,EAAWP,EAAG,YAAaQ,EAAO,CAACP,KAAM,OAAQC,MAAO,MAAM,EAAGO,EAAY,CAACR,KAAK,YAAaC,MAAO,WAAW,EAClHD,EAAOD,EAAG,WACVU,EAAW,CACb,GAAMN,EAAG,MAASA,EAAG,KAAQC,EAAG,GAAMA,EAAG,IAAOA,EAChD,OAAUC,EAAG,MAASA,EAAG,SAAYA,EAAG,IAAOA,EAAG,MAASA,EAC3D,IAAON,EAAG,OAAQ,OAASS,EAAW,OAAUA,EAAW,MAAQT,EAAG,UACtE,OAAUS,EAAW,QAAWA,EAAW,KAAQT,EAAG,QAAS,OAAUA,EAAG,UAAW,MAASA,EAAG,SACnG,SAAYA,EAAG,YAAa,MAASA,EAAG,SAAU,QAAWA,EAAG,WAAY,SAAYA,EAAG,MAC3F,IAAOA,EAAG,OAAQ,OAAUA,EAAG,UAAW,KAAQA,EAAG,QAAS,QAAWA,EAAG,WAC5E,GAAMO,EAAU,MAASP,EAAG,mBAAoB,MAAQA,EAAG,SAC3D,MAASC,EAAM,SAAWA,EAAM,KAAOA,EAAM,UAAYA,EAAM,QAAUA,EAAM,QAAUA,EAAM,WAAaA,EAAM,QAAUA,EAC5H,KAAQO,EAAM,MAASA,EAAM,KAAQA,CACvC,EAEIG,EAAiB,iBAErB,SAASC,EAAMC,CAAM,CAAEC,CAAK,CAAEC,CAAC,EAE7B,OADAD,EAAME,QAAQ,CAAGD,EACVA,EAAEF,EAAQC,EACnB,CAEA,SAASG,EAAYJ,CAAM,CAAEK,CAAG,EAE9B,IADA,IAAqBC,EAAjBC,EAAU,GACP,MAACD,CAAAA,EAAON,EAAOM,IAAI,EAAC,GAAY,CACrC,GAAIA,GAAQD,GAAO,CAACE,EAClB,MAAO,GACTA,EAAU,CAACA,GAAWD,MAAAA,CACxB,CACF,CAUA,SAASE,EAAcR,CAAM,CAAEC,CAAK,EAClC,IAoCMQ,EApCFC,EAAKV,EAAOM,IAAI,GACpB,GAAII,KAAAA,GAAaA,KAAAA,EACf,OAAOX,EAAMC,EAAQC,EAiDhB,SAASD,CAAM,CAAEC,CAAK,EAG3B,OAFIG,EAAYJ,EAlD4BU,IAmD1CT,CAAAA,EAAME,QAAQ,CAAGK,CAAY,EA1DjCpB,EA2Da,SA3DFE,EADWqB,KAAAA,EA4DC,QACvB,GApDO,GAAI,qBAAqBC,IAAI,CAACF,GACnC,OATFtB,EASasB,MATFpB,CAAAA,EADWqB,KAAAA,CACE,EAUjB,GAAID,KAAAA,GAAaV,EAAOa,GAAG,CAAC,MAEjC,OADAb,EAAOc,QAAQ,CAAC,YAXlB1B,EAYa,SAZFE,EADWqB,KAAAA,EAaC,SAChB,GAAI,KAAKC,IAAI,CAACF,IAAOA,KAAAA,GAAaV,EAAOa,GAAG,CAAC,MAElD,OADAb,EAAOe,KAAK,CAAC,0CAdf3B,EAea,SAfFE,EADWqB,KAAAA,EAgBC,SAChB,GAAIV,EAAMe,SAAS,EAAKN,KAAAA,GAAaV,EAAOa,GAAG,CAAC,MAGrD,OAFAT,EAAYJ,EAAQ,KACpBA,EAAOc,QAAQ,CAAC,WAlBlB1B,EAmBa,SAnBFE,EADWqB,KAAAA,EAoBC,iBAChB,GAAID,KAAAA,SACT,EAAWG,GAAG,CAAC,KACNd,EAAMC,EAAQC,EAAOgB,GACnBjB,EAAOa,GAAG,CAAC,MACpBb,EAAOkB,SAAS,GAxBpB9B,EAyBe,UAzBJE,EADWqB,KAAAA,EA0BI,YAEtBX,EAAOc,QAAQ,CAAChB,GA5BEa,EA6BWX,EAAOmB,OAAO,GA5B/C/B,EA4Be,WA5BJE,EAAUqB,EA4BM,MAEpB,GAAID,KAAAA,EAET,OADAV,EAAOkB,SAAS,GA/BlB9B,EAgCa,cAhCFE,EADWqB,KAAAA,EAiCM,OACrB,GAAID,KAAAA,EAGT,OAFAV,EAAOa,GAAG,CAAC,KACXb,EAAOc,QAAQ,CAAC,SAnClB1B,EAoCc,WApCHE,EADWqB,KAAAA,EAqCI,OACnB,GAAIb,EAAec,IAAI,CAACF,GAE7B,OADAV,EAAOc,QAAQ,CAAChB,GAvCIa,EAwCSX,EAAOmB,OAAO,GAvC7C/B,EAuCa,WAvCFE,EAAUqB,EAuCI,KAGvB,GAAG,QAAQC,IAAI,CAACF,GAGd,OAFAV,EAAOc,QAAQ,CAAC,WA5CEH,EA6ClBF,EAAOT,EAAOmB,OAAO,GA5CzB/B,EA6Ce,OA7CJE,EAAUqB,EA6CE,OAEnBX,EAAOc,QAAQ,CAAC,SAChB,IAjDkBH,EAAAA,EAAAA,EAAXS,EAAI/B,EAAOsB,EAiDdF,EAAOT,EAAOmB,OAAO,GAAIE,EAAQxB,EAASyB,oBAAoB,CAACb,IAASZ,CAAQ,CAACY,EAAK,CAC1F,OAAO,GAAUR,EAAMsB,SAAS,EAlDzBH,EAkDiCC,EAAMjC,IAAI,CAlDvCC,EAkDyCgC,EAAMhC,KAAK,CAlD7CsB,EAkD+CF,EAjDrErB,EAAOgC,EAAI9B,EAAUqB,EACdtB,IADPD,EAkDU,WAlDCE,EAkDuBmB,EAAZ,WAGxB,CAUA,SAASQ,EAAiBjB,CAAM,CAAEC,CAAK,EAErC,IADA,IAAsBS,EAAlBc,EAAW,GACRd,EAAKV,EAAOM,IAAI,IAAI,CACzB,GAAII,KAAAA,GAAac,EAAU,CACzBvB,EAAME,QAAQ,CAAGK,EACjB,KACF,CACAgB,EAAYd,KAAAA,CACd,CACA,OAxEAtB,EAwEW,UAxEAE,EADWqB,KAAAA,EAyEA,SACxB,CAIA,IAAIc,EAAc,CAAC,KAAQ,GAAM,OAAU,GAAM,SAAY,GAAM,OAAU,GAAM,OAAU,EAAI,EAEjG,SAASC,EAAYC,CAAQ,CAAEC,CAAM,CAAExC,CAAI,CAAEyC,CAAK,CAAEC,CAAI,CAAEC,CAAI,EAC5D,IAAI,CAACJ,QAAQ,CAAGA,EAChB,IAAI,CAACC,MAAM,CAAGA,EACd,IAAI,CAACxC,IAAI,CAAGA,EACZ,IAAI,CAAC0C,IAAI,CAAGA,EACZ,IAAI,CAACC,IAAI,CAAGA,EACC,MAATF,GAAe,KAAI,CAACA,KAAK,CAAGA,CAAI,CACtC,CAqCA,SAASG,EAAeC,CAAU,EAEhC,IAAK,IADDhC,EAAQiC,EAAGjC,KAAK,CACXkC,EAAIlC,EAAMmC,aAAa,CAAED,EAAGA,EAAIA,EAAE7B,IAAI,CAC7C,GAAG6B,EAAEE,IAAI,EAAIJ,EAAY,MAC3BhC,CAAAA,EAAMmC,aAAa,CAAG,CAAEC,KAAMJ,EAAY3B,KAAML,EAAMmC,aAAa,CACrE,CAGA,IAAIF,EAAK,CAACjC,MAAO,KAAM2B,OAAQ,KAAMU,OAAQ,KAAMC,GAAI,IAAI,EAC3D,SAASC,IACP,IAAK,IAAIC,EAAIC,UAAUC,MAAM,CAAG,EAAGF,GAAK,EAAGA,IAAKP,EAAGK,EAAE,CAACK,IAAI,CAACF,SAAS,CAACD,EAAE,CACzE,CACA,SAAS9B,IAEP,OADA6B,EAAKK,KAAK,CAAC,KAAMH,WACV,EACT,CACA,SAASI,EAAOT,CAAI,CAAEU,CAAI,EACxB,IAAK,IAAIC,EAAID,EAAMC,EAAGA,EAAIA,EAAE1C,IAAI,CAC9B,GAAI0C,EAAEX,IAAI,EAAIA,EAAM,MAAO,GAC7B,MAAO,EACT,CACA,SAASY,EAASC,CAAO,EACvB,IAAIjD,EAAQiC,EAAGjC,KAAK,CACpB,GAAIA,EAAMkD,OAAO,CAAE,CAEjB,GADAjB,EAAGI,MAAM,CAAG,MACRQ,EAAOI,EAASjD,EAAMmD,SAAS,EAAG,MACtCnD,CAAAA,EAAMmD,SAAS,CAAG,CAACf,KAAMa,EAAS5C,KAAML,EAAMmD,SAAS,CACzD,MAAO,GAAInD,EAAMoD,UAAU,CAAE,CAC3B,GAAIP,EAAOI,EAASjD,EAAMoD,UAAU,EAAG,MACvCpD,CAAAA,EAAMoD,UAAU,CAAG,CAAChB,KAAMa,EAAS5C,KAAML,EAAMoD,UAAU,CAC3D,CACF,CAIA,IAAIC,EAAc,CAACjB,KAAM,OAAQ/B,KAAM,IAAI,EAC3C,SAASiD,IACFrB,EAAGjC,KAAK,CAACkD,OAAO,EAAEjB,CAAAA,EAAGjC,KAAK,CAACmD,SAAS,CAAGE,CAAU,EACtDpB,EAAGjC,KAAK,CAACkD,OAAO,CAAG,CAACrB,KAAMI,EAAGjC,KAAK,CAACkD,OAAO,CAAEK,KAAMtB,EAAGjC,KAAK,CAACmD,SAAS,CACtE,CACA,SAASK,IACPvB,EAAGjC,KAAK,CAACmD,SAAS,CAAGlB,EAAGjC,KAAK,CAACkD,OAAO,CAACK,IAAI,CAC1CtB,EAAGjC,KAAK,CAACkD,OAAO,CAAGjB,EAAGjC,KAAK,CAACkD,OAAO,CAACrB,IAAI,CAG1C,SAAS4B,EAAQtE,CAAI,CAAE2C,CAAI,EACzB,IAAI4B,EAAS,WACX,IAAI1D,EAAQiC,EAAGjC,KAAK,CACpBA,EAAM2D,OAAO,CAAG,IAAIlC,EAAYzB,EAAM0B,QAAQ,CAAEO,EAAGlC,MAAM,CAAC4B,MAAM,GAAIxC,EAAM,KAAMa,EAAM2D,OAAO,CAAE7B,EACjG,EAEA,OADA4B,EAAOE,GAAG,CAAG,GACNF,CACT,CACA,SAASG,IACP,IAAI7D,EAAQiC,EAAGjC,KAAK,CAChBA,EAAM2D,OAAO,CAAC9B,IAAI,GACM,KAAtB7B,EAAM2D,OAAO,CAACxE,IAAI,EACpBa,CAAAA,EAAM0B,QAAQ,CAAG1B,EAAM2D,OAAO,CAACjC,QAAQ,EACzC1B,EAAM2D,OAAO,CAAG3D,EAAM2D,OAAO,CAAC9B,IAAI,CAEtC,CAGA,SAASiC,EAAOC,CAAM,EAMpB,OALA,SAAS9D,EAAEd,CAAI,SACb,GAAY4E,EAAerD,IAClBqD,KAAAA,EAAsBxB,IACnB7B,EAAKT,EACnB,CAEF,CAEA,SAAS+D,EAAU7E,CAAI,QACrB,KAAIA,EAAoBuB,EAAKuD,GACzB9E,OAAAA,EAAsBuB,EAAK+C,EAAQ,UAAWS,EAASJ,EAAO,KAAMD,GACpE1E,aAAAA,EAA4BuB,EAAK+C,EAAQ,QAASU,EAAYH,EAAWH,GACzE1E,aAAAA,EAA4BuB,EAAK+C,EAAQ,QAASO,EAAWH,GAC7D1E,KAAAA,EAAoBuB,EAAK+C,EAAQ,KAAMH,EAAac,EAAOP,EAAQL,GACnErE,KAAAA,EAAoBuB,IACpBvB,aAAAA,EAA4BuB,EAAK2D,GACjClF,YAAAA,EAA2BuB,EAAK4D,GAChCnF,OAAAA,EAAsBuB,EAAK+C,EAAQ,QAASK,EAAO,KAAML,EAAQ,KAAMc,EAAUT,EAAO,KAC7DD,EAAQG,EAAWH,GAC9C1E,YAAAA,EAA2BuB,EAAK+C,EAAQ,QAASe,GACjDrF,UAAAA,EAAyBuB,EAAK+C,EAAQ,QAASU,EAAYV,EAAQ,IAAK,UAAWK,EAAO,KAC5DM,EAAOP,EAAQA,GAC7C1E,QAAAA,EAAuBuB,EAAKyD,EAAYL,EAAO,MAC/C3E,WAAAA,EAA0BuB,EAAKoD,EAAO,MACtC3E,SAAAA,EAAwBuB,EAAK+C,EAAQ,QAASH,EAAaQ,EAAO,KAAMW,GAAQX,EAAO,KAC1DE,EAAWH,EAAQL,GAChDrE,UAAAA,EAAyBuB,EAAKgE,EAAWZ,EAAO,MAChD3E,WAAAA,EAA0BuB,EAAKiE,GAC5BpC,EAAKkB,EAAQ,QAASU,EAAYL,EAAO,KAAMD,EACxD,CACA,SAASM,EAAWhF,CAAI,SACtB,EAAgByF,cAAc,CAACzF,IAC3BA,QAAAA,EADyCuB,EAAKmE,GAE9C1F,YAAAA,EAA2BuB,EAAK4D,GAChCnF,aAAAA,EAA4BuB,EAAKoE,GACjC3F,KAAAA,EAAoBuB,EAAK+C,EAAQ,KAAMqB,EAAiBhB,EAAO,KAAMD,EAAQgB,GAC7E1F,YAAAA,EAA2BuB,EAAKyD,GAChChF,KAAAA,EAAoBuB,EAAK+C,EAAQ,KAAMsB,EAASD,EAAiB,KAAMjB,EAAQgB,GAC/E1F,KAAAA,EAAoBuB,EAAK+C,EAAQ,KAAMsB,EAASC,EAAS,KAAMnB,EAAQgB,GACpEnE,GACT,CACA,SAASoE,EAAgB3F,CAAI,SAC3B,EAAS2B,KAAK,CAAC,cAAsByB,IAC9BA,EAAK4B,EACd,CAEA,SAASU,EAAc1F,CAAI,CAAE8F,CAAK,EAChC,GAAI9F,YAAAA,GAAsB,UAAUwB,IAAI,CAACsE,GAAQ,OAAOvE,EAAKmE,GAC7D,GAAI1F,YAAAA,GAAsBA,KAAAA,EAAa,OAAOuB,EAAKyD,GACnD,GAAIhF,KAAAA,GACJ,GAAIA,KAAAA,EAAa,OAAOuB,EAAK+C,EAAQ,KAAMsB,EAASZ,EAAY,KAAMN,EAAQgB,GAC9E,GAAI1F,KAAAA,EAAa,OAAOuB,EAAKwE,EAAUL,GACvC,GAAI1F,KAAAA,EAAa,OAAOuB,EAAK+C,EAAQ,KAAMU,EAAYL,EAAO,KAAMD,EAAQgB,GAC9E,CAEA,SAASR,EAAelF,CAAI,QAC1B,aAAIA,EAA4BuB,EAAK2D,GACjClF,YAAAA,EAA2BuB,EAAK4D,GAChCnF,OAAAA,EAAsBuB,EAAKwD,SACjC,CAEA,SAASD,EAAQ9E,CAAI,QACnB,KAAGA,GACAA,YAAAA,EADoBuB,EAAKuD,GAEzB9E,KAAAA,EAAoBuB,EAAK+C,EAAQ,KAAMsB,EAASI,EAAU,KAAMtB,EAAQG,SAC7E,CACA,SAASmB,EAAShG,CAAI,EACpB,GAAGA,YAAAA,EAAoB,OAAOuB,GAChC,CAEA,SAASgE,EAAWvF,CAAI,CAAE8F,CAAK,QAC7B,YAAG9F,GAAsB,QAAQwB,IAAI,CAACsE,EAAMG,MAAM,CAAC,KAAOrD,EAAekD,GAAevE,KAChFvB,YAAAA,GAAsBA,YAAAA,GAAsBA,KAAAA,GAAe8F,KAAAA,EAAqBvE,EAAKgE,SAC/F,CAEA,SAASC,EAASxF,CAAI,CAAE8F,CAAK,QAE3B,YAAG9F,GAAsB,QAAQwB,IAAI,CAACsE,EAAMG,MAAM,CAAC,KAAOrD,EAAekD,GAAevE,KAC/EvB,QAAAA,GAAkB,QAAQwB,IAAI,CAACsE,EAAMG,MAAM,CAAC,IAAc1E,UACrE,CAEA,SAAS8D,EAAWrF,CAAI,QACtB,KAAIA,EAAoBuB,EAAKmD,EAAQG,GAC9BzB,EAAKsC,EAAef,EAAO,KAAMD,EAC1C,CACA,SAASqB,EAAS/F,CAAI,EACpB,GAAIA,YAAAA,EAA6C,OAAxB8C,EAAGI,MAAM,CAAG,WAAmB3B,GAC1D,CACA,SAASsE,EAAQ7F,CAAI,EAEnB,GADY,YAARA,GAAoB8C,CAAAA,EAAGI,MAAM,CAAG,UAAS,EACzCb,EAAYoD,cAAc,CAACzF,GAAO,OAAOuB,EAAKoD,EAAO,KAAMK,EACjE,CACA,SAASY,EAASM,CAAI,CAAEjF,CAAG,EACzB,SAASkF,EAAQnG,CAAI,QACnB,KAAIA,EAAoBuB,EAAK2E,EAAMC,GAC/BnG,GAAQiB,EAAYM,IACjBA,EAAKoD,EAAO1D,GACrB,CACA,OAAO,SAASjB,CAAI,SAClB,GAAYiB,EAAYM,IACZ6B,EAAK8C,EAAMC,EACzB,CACF,CACA,SAASlB,EAAMjF,CAAI,QACjB,KAAIA,EAAoBuB,IACjB6B,EAAKyB,EAAWI,EACzB,CACA,SAASF,EAAQ/E,CAAI,CAAE8F,CAAK,QAC1B,YAAI9F,GAAoB6D,EAASiC,GAAevE,EAAK6E,EAASC,IACvD9E,GACT,CACA,SAAS8E,EAAQrG,CAAI,CAAE8F,CAAK,QAC1B,KAAIA,EAAqBvE,EAAKyD,EAAYqB,GACtCrG,KAAAA,EAAoBuB,EAAKwD,SAC/B,CACA,SAASK,EAASpF,CAAI,CAAE8F,CAAK,QAC3B,YAAI9F,GACF6D,EAASiC,GACFvE,EAAK+E,EAAOtB,IAEZ5B,GAEX,CACA,SAASkD,EAAMC,CAAK,CAAET,CAAK,EACzB,GAAIA,MAAAA,EAAe,OAAOvE,GAC5B,CACA,SAAS4D,EAAYnF,CAAI,CAAE8F,CAAK,QAE9B,YAAI9F,GAAsBA,QAAAA,GAAiB6D,EAASiC,GAAevE,EAAK4D,IACpEW,OAAAA,EAAuBvE,EAAK4D,GAC5BnF,KAAAA,EAAoBuB,EAAK+C,EAAQ,KAAMH,EAAayB,EAASN,GAAQ,KAAMZ,EAAQ0B,EAASvB,EAAWR,SAC7G,CACA,SAAS+B,EAAQpG,CAAI,EACnB,GAAGA,KAAAA,EAAa,OAAOuB,EAAKiF,EAC9B,CACA,SAASA,EAAWxG,CAAI,QACtB,QAAGA,GACAA,YAAAA,EADuBuB,IAEvBvB,KAAAA,EAAoBuB,EAAK+C,EAAQ,KAAMsB,EAASa,EAAU,KAAM/B,SACrE,CACA,SAAS+B,EAASzG,CAAI,EACpB,GAAGA,YAAAA,EAAoB,OAAOuB,EAAK6E,EACrC,CACA,SAASd,GAAOtF,CAAI,CAAE8F,CAAK,EACzB,GAAI9F,YAAAA,EAAsC,OAAjB6D,EAASiC,GAAevE,EAAK6E,EACxD,CArKA/B,EAAWI,GAAG,CAAG,GAiBjBC,EAAOD,GAAG,CAAG,GAuJN,IAAMiC,GAAO,CAClBzD,KAAM,OACN0D,WAAY,SAASC,CAAU,EAY7B,MAVY,CACV7F,SAAUK,EACVQ,UAAW,GACXO,UAAW,GACXgB,GAAI,EAAE,CACNqB,QAAS,IAAIlC,EAAY,CAACsE,EAAY,EAAG,QAAS,IAClD5D,cAPiB,CAAC,MAAO,QAAS,SAAU,OAAQ,MAAO,OAAQ,UAAW,QAAQ,CAQtFe,QAAS,KACTxB,SAAU,CACZ,CAEF,EAEAsE,MAAO,SAASjG,CAAM,CAAEC,CAAK,EAM3B,GALID,EAAOkG,GAAG,KACPjG,EAAM2D,OAAO,CAACiB,cAAc,CAAC,UAChC5E,CAAAA,EAAM2D,OAAO,CAAC/B,KAAK,CAAG,EAAI,EAC5B5B,EAAM0B,QAAQ,CAAG3B,EAAOmG,WAAW,IAEjCnG,EAAOoG,QAAQ,GAAI,OAAO,KAC9B,IAAI/G,EAAQY,EAAME,QAAQ,CAACH,EAAQC,SACnC,WAAIb,EAA0BC,GAC9BY,EAAMe,SAAS,CAAG,CAAC,CAAE5B,CAAAA,YAAAA,GAAsBA,aAAAA,GAAuBA,EAAK2B,KAAK,CAAC,gBAAe,EAC5Fd,EAAMsB,SAAS,CAAGnC,KAAAA,EACXiH,SA9QQpG,CAAK,CAAEZ,CAAK,CAAED,CAAI,CAAEE,CAAO,CAAEU,CAAM,EACpD,IAAIuC,EAAKtC,EAAMsC,EAAE,CAQjB,IALAL,EAAGjC,KAAK,CAAGA,EAAOiC,EAAGlC,MAAM,CAAGA,EAAQkC,EAAGI,MAAM,CAAG,KAAMJ,EAAGK,EAAE,CAAGA,EAE3DtC,EAAM2D,OAAO,CAACiB,cAAc,CAAC,UAChC5E,CAAAA,EAAM2D,OAAO,CAAC/B,KAAK,CAAG,EAAG,IAIzB,GAAIyE,CADa/D,EAAGI,MAAM,CAAGJ,EAAGgE,GAAG,GAAKtC,CAAQ,EACjC7E,EAAME,GAAU,CAC7B,KAAMiD,EAAGI,MAAM,EAAIJ,CAAE,CAACA,EAAGI,MAAM,CAAG,EAAE,CAACkB,GAAG,EACtCtB,EAAGgE,GAAG,KACR,GAAIrE,EAAGI,MAAM,CAAE,OAAOJ,EAAGI,MAAM,CAC/B,GAAIlD,YAAAA,GAAsBoH,SApBfvG,CAAK,CAAEiD,CAAO,EAC7B,IAAK,IAAIF,EAAI/C,EAAMmD,SAAS,CAAEJ,EAAGA,EAAIA,EAAE1C,IAAI,CACzC,GAAI0C,EAAEX,IAAI,EAAIa,EAAS,MAAO,EAClC,EAiBwCjD,EAAOX,GAAU,MAAO,qBAC1D,GAAIF,YAAAA,GAAsBqH,SAMdxG,CAAK,CAAEyG,CAAQ,EAC/B,GAAI,QAAQ9F,IAAI,CAAC8F,EAASrB,MAAM,CAAC,IAC/B,MAAO,GAET,IAAK,IADDsB,EAAM1G,EAAMmC,aAAa,CAACO,MAAM,CAC3BF,EAAI,EAAGA,EAAEkE,EAAKlE,IACrB,GAAGxC,EAAMmC,aAAa,CAACK,EAAE,EAAEiE,EAAU,MAAO,EAChD,EAZyCzG,EAAOX,GAAU,MAAO,uBAC3D,OAAOD,CACT,CAEJ,EA0PqBY,EAAOZ,EAAOD,EAAME,EAASU,GAChD,EAEA4G,OAAQ,SAAS3G,CAAK,CAAE4G,CAAS,CAAE3E,CAAE,EACnC,GAAIjC,EAAME,QAAQ,EAAIK,EAAe,OAAO,EAC5C,IAAIsG,EAAYD,GAAaA,EAAUxB,MAAM,CAAC,GAAIzB,EAAU3D,EAAM2D,OAAO,CACrD,QAAhBA,EAAQxE,IAAI,EAAc0H,KAAAA,GAAkBlD,CAAAA,EAAUA,EAAQ9B,IAAI,EACtE,IAAI1C,EAAOwE,EAAQxE,IAAI,CAAE2H,EAAUD,GAAa1H,QAChD,UAAIA,EAAyBwE,EAAQjC,QAAQ,CAAG,EACvCvC,QAAAA,GAAkB0H,KAAAA,EAAyBlD,EAAQjC,QAAQ,CAC3DvC,QAAAA,GAAkBA,QAAAA,EAAuBwE,EAAQjC,QAAQ,CAAGO,EAAG8E,IAAI,CACnEpD,UAAAA,EAAQ7B,IAAI,EAAiBgF,EAE7BnD,EAAQ/B,KAAK,CAAS+B,EAAQhC,MAAM,CAAImF,CAAAA,EAAU,EAAI,GACnDnD,EAAQjC,QAAQ,CAAIoF,CAAAA,EAAU,EAAI7E,EAAG8E,IAAI,EAF5CpD,EAAQjC,QAAQ,CAAI,uBAAsBf,IAAI,CAACiG,GAAa3E,EAAG8E,IAAI,CAAG,EAAI9E,EAAG8E,IAAI,CAG5F,EAEAC,aAAc,CACZC,cAAe,YACfC,cAAe,CAACC,KAAM,KAAM/C,MAAO,CAACgD,KAAM,KAAMC,MAAO,IAAI,CAAC,CAC9D,CACF,EAEaC,GAAO,CAClBlF,KAAM,OACN0D,WAAY,WACV,MAAO,CACLyB,OAAQ,GACRC,SAAU,EACZ,CACF,EACAxB,MAAO,SAAUjG,CAAM,CAAEC,CAAK,EAC5B,IAAIS,EAAKV,EAAO0H,IAAI,GAChBxB,EAAMlG,EAAOkG,GAAG,GAGpB,GAAIxF,KAAAA,EAEF,OADAV,EAAOkB,SAAS,GACT,UAET,GAAIgF,GAAOxF,KAAAA,EAAW,CACpB,IAAIrB,EAAQ,aAgBZ,OAdAW,EAAOa,GAAG,CAAC,KAEU,KAAjBb,EAAO0H,IAAI,KACb1H,EAAOa,GAAG,CAAC,KACXxB,EAAQ,aAGW,KAAjBW,EAAO0H,IAAI,KACb1H,EAAOa,GAAG,CAAC,OACXxB,EAAQ,YACRY,EAAMuH,MAAM,CAAG,IAGjBxH,EAAOc,QAAQ,CAAC,UACTzB,CACT,CAEA,IAAIqB,EAAKV,EAAO0H,IAAI,SAOpB,CALsB,IAAlBzH,EAAMwH,QAAQ,EAAa/G,KAAAA,IAC7BT,EAAMwH,QAAQ,CAAG,GACjBzH,EAAOM,IAAI,IAGTL,CAAkB,GAAlBA,EAAMwH,QAAQ,GACZzH,EAAO2H,MAAM,CAAC,MAGhB3H,EAAOkB,SAAS,GAGG,KAAjBlB,EAAO0H,IAAI,KACb1H,EAAOM,IAAI,GACXL,EAAMwH,QAAQ,CAAG,IAGZ,WAGTzH,EAAOM,IAAI,GACJ,KACT,EACA2G,aAAc,CACZE,cAAe,CAACC,KAAM,GAAG,CAC3B,CACF,C","sources":["node_modules/@codemirror/legacy-modes/mode/haxe.js"],"sourcesContent":["// Tokenizer\n\nfunction kw(type) {return {type: type, style: \"keyword\"};}\nvar A = kw(\"keyword a\"), B = kw(\"keyword b\"), C = kw(\"keyword c\");\nvar operator = kw(\"operator\"), atom = {type: \"atom\", style: \"atom\"}, attribute = {type:\"attribute\", style: \"attribute\"};\nvar type = kw(\"typedef\");\nvar keywords = {\n  \"if\": A, \"while\": A, \"else\": B, \"do\": B, \"try\": B,\n  \"return\": C, \"break\": C, \"continue\": C, \"new\": C, \"throw\": C,\n  \"var\": kw(\"var\"), \"inline\":attribute, \"static\": attribute, \"using\":kw(\"import\"),\n  \"public\": attribute, \"private\": attribute, \"cast\": kw(\"cast\"), \"import\": kw(\"import\"), \"macro\": kw(\"macro\"),\n  \"function\": kw(\"function\"), \"catch\": kw(\"catch\"), \"untyped\": kw(\"untyped\"), \"callback\": kw(\"cb\"),\n  \"for\": kw(\"for\"), \"switch\": kw(\"switch\"), \"case\": kw(\"case\"), \"default\": kw(\"default\"),\n  \"in\": operator, \"never\": kw(\"property_access\"), \"trace\":kw(\"trace\"),\n  \"class\": type, \"abstract\":type, \"enum\":type, \"interface\":type, \"typedef\":type, \"extends\":type, \"implements\":type, \"dynamic\":type,\n  \"true\": atom, \"false\": atom, \"null\": atom\n};\n\nvar isOperatorChar = /[+\\-*&%=<>!?|]/;\n\nfunction chain(stream, state, f) {\n  state.tokenize = f;\n  return f(stream, state);\n}\n\nfunction toUnescaped(stream, end) {\n  var escaped = false, next;\n  while ((next = stream.next()) != null) {\n    if (next == end && !escaped)\n      return true;\n    escaped = !escaped && next == \"\\\\\";\n  }\n}\n\n// Used as scratch variables to communicate multiple values without\n// consing up tons of objects.\nvar type, content;\nfunction ret(tp, style, cont) {\n  type = tp; content = cont;\n  return style;\n}\n\nfunction haxeTokenBase(stream, state) {\n  var ch = stream.next();\n  if (ch == '\"' || ch == \"'\") {\n    return chain(stream, state, haxeTokenString(ch));\n  } else if (/[\\[\\]{}\\(\\),;\\:\\.]/.test(ch)) {\n    return ret(ch);\n  } else if (ch == \"0\" && stream.eat(/x/i)) {\n    stream.eatWhile(/[\\da-f]/i);\n    return ret(\"number\", \"number\");\n  } else if (/\\d/.test(ch) || ch == \"-\" && stream.eat(/\\d/)) {\n    stream.match(/^\\d*(?:\\.\\d*(?!\\.))?(?:[eE][+\\-]?\\d+)?/);\n    return ret(\"number\", \"number\");\n  } else if (state.reAllowed && (ch == \"~\" && stream.eat(/\\//))) {\n    toUnescaped(stream, \"/\");\n    stream.eatWhile(/[gimsu]/);\n    return ret(\"regexp\", \"string.special\");\n  } else if (ch == \"/\") {\n    if (stream.eat(\"*\")) {\n      return chain(stream, state, haxeTokenComment);\n    } else if (stream.eat(\"/\")) {\n      stream.skipToEnd();\n      return ret(\"comment\", \"comment\");\n    } else {\n      stream.eatWhile(isOperatorChar);\n      return ret(\"operator\", null, stream.current());\n    }\n  } else if (ch == \"#\") {\n    stream.skipToEnd();\n    return ret(\"conditional\", \"meta\");\n  } else if (ch == \"@\") {\n    stream.eat(/:/);\n    stream.eatWhile(/[\\w_]/);\n    return ret (\"metadata\", \"meta\");\n  } else if (isOperatorChar.test(ch)) {\n    stream.eatWhile(isOperatorChar);\n    return ret(\"operator\", null, stream.current());\n  } else {\n    var word;\n    if(/[A-Z]/.test(ch)) {\n      stream.eatWhile(/[\\w_<>]/);\n      word = stream.current();\n      return ret(\"type\", \"type\", word);\n    } else {\n      stream.eatWhile(/[\\w_]/);\n      var word = stream.current(), known = keywords.propertyIsEnumerable(word) && keywords[word];\n      return (known && state.kwAllowed) ? ret(known.type, known.style, word) :\n        ret(\"variable\", \"variable\", word);\n    }\n  }\n}\n\nfunction haxeTokenString(quote) {\n  return function(stream, state) {\n    if (toUnescaped(stream, quote))\n      state.tokenize = haxeTokenBase;\n    return ret(\"string\", \"string\");\n  };\n}\n\nfunction haxeTokenComment(stream, state) {\n  var maybeEnd = false, ch;\n  while (ch = stream.next()) {\n    if (ch == \"/\" && maybeEnd) {\n      state.tokenize = haxeTokenBase;\n      break;\n    }\n    maybeEnd = (ch == \"*\");\n  }\n  return ret(\"comment\", \"comment\");\n}\n\n// Parser\n\nvar atomicTypes = {\"atom\": true, \"number\": true, \"variable\": true, \"string\": true, \"regexp\": true};\n\nfunction HaxeLexical(indented, column, type, align, prev, info) {\n  this.indented = indented;\n  this.column = column;\n  this.type = type;\n  this.prev = prev;\n  this.info = info;\n  if (align != null) this.align = align;\n}\n\nfunction inScope(state, varname) {\n  for (var v = state.localVars; v; v = v.next)\n    if (v.name == varname) return true;\n}\n\nfunction parseHaxe(state, style, type, content, stream) {\n  var cc = state.cc;\n  // Communicate our context to the combinators.\n  // (Less wasteful than consing up a hundred closures on every call.)\n  cx.state = state; cx.stream = stream; cx.marked = null, cx.cc = cc;\n\n  if (!state.lexical.hasOwnProperty(\"align\"))\n    state.lexical.align = true;\n\n  while(true) {\n    var combinator = cc.length ? cc.pop() : statement;\n    if (combinator(type, content)) {\n      while(cc.length && cc[cc.length - 1].lex)\n        cc.pop()();\n      if (cx.marked) return cx.marked;\n      if (type == \"variable\" && inScope(state, content)) return \"variableName.local\";\n      if (type == \"variable\" && imported(state, content)) return \"variableName.special\";\n      return style;\n    }\n  }\n}\n\nfunction imported(state, typename) {\n  if (/[a-z]/.test(typename.charAt(0)))\n    return false;\n  var len = state.importedtypes.length;\n  for (var i = 0; i<len; i++)\n    if(state.importedtypes[i]==typename) return true;\n}\n\nfunction registerimport(importname) {\n  var state = cx.state;\n  for (var t = state.importedtypes; t; t = t.next)\n    if(t.name == importname) return;\n  state.importedtypes = { name: importname, next: state.importedtypes };\n}\n// Combinator utils\n\nvar cx = {state: null, column: null, marked: null, cc: null};\nfunction pass() {\n  for (var i = arguments.length - 1; i >= 0; i--) cx.cc.push(arguments[i]);\n}\nfunction cont() {\n  pass.apply(null, arguments);\n  return true;\n}\nfunction inList(name, list) {\n  for (var v = list; v; v = v.next)\n    if (v.name == name) return true;\n  return false;\n}\nfunction register(varname) {\n  var state = cx.state;\n  if (state.context) {\n    cx.marked = \"def\";\n    if (inList(varname, state.localVars)) return;\n    state.localVars = {name: varname, next: state.localVars};\n  } else if (state.globalVars) {\n    if (inList(varname, state.globalVars)) return;\n    state.globalVars = {name: varname, next: state.globalVars};\n  }\n}\n\n// Combinators\n\nvar defaultVars = {name: \"this\", next: null};\nfunction pushcontext() {\n  if (!cx.state.context) cx.state.localVars = defaultVars;\n  cx.state.context = {prev: cx.state.context, vars: cx.state.localVars};\n}\nfunction popcontext() {\n  cx.state.localVars = cx.state.context.vars;\n  cx.state.context = cx.state.context.prev;\n}\npopcontext.lex = true;\nfunction pushlex(type, info) {\n  var result = function() {\n    var state = cx.state;\n    state.lexical = new HaxeLexical(state.indented, cx.stream.column(), type, null, state.lexical, info);\n  };\n  result.lex = true;\n  return result;\n}\nfunction poplex() {\n  var state = cx.state;\n  if (state.lexical.prev) {\n    if (state.lexical.type == \")\")\n      state.indented = state.lexical.indented;\n    state.lexical = state.lexical.prev;\n  }\n}\npoplex.lex = true;\n\nfunction expect(wanted) {\n  function f(type) {\n    if (type == wanted) return cont();\n    else if (wanted == \";\") return pass();\n    else return cont(f);\n  }\n  return f;\n}\n\nfunction statement(type) {\n  if (type == \"@\") return cont(metadef);\n  if (type == \"var\") return cont(pushlex(\"vardef\"), vardef1, expect(\";\"), poplex);\n  if (type == \"keyword a\") return cont(pushlex(\"form\"), expression, statement, poplex);\n  if (type == \"keyword b\") return cont(pushlex(\"form\"), statement, poplex);\n  if (type == \"{\") return cont(pushlex(\"}\"), pushcontext, block, poplex, popcontext);\n  if (type == \";\") return cont();\n  if (type == \"attribute\") return cont(maybeattribute);\n  if (type == \"function\") return cont(functiondef);\n  if (type == \"for\") return cont(pushlex(\"form\"), expect(\"(\"), pushlex(\")\"), forspec1, expect(\")\"),\n                                 poplex, statement, poplex);\n  if (type == \"variable\") return cont(pushlex(\"stat\"), maybelabel);\n  if (type == \"switch\") return cont(pushlex(\"form\"), expression, pushlex(\"}\", \"switch\"), expect(\"{\"),\n                                    block, poplex, poplex);\n  if (type == \"case\") return cont(expression, expect(\":\"));\n  if (type == \"default\") return cont(expect(\":\"));\n  if (type == \"catch\") return cont(pushlex(\"form\"), pushcontext, expect(\"(\"), funarg, expect(\")\"),\n                                   statement, poplex, popcontext);\n  if (type == \"import\") return cont(importdef, expect(\";\"));\n  if (type == \"typedef\") return cont(typedef);\n  return pass(pushlex(\"stat\"), expression, expect(\";\"), poplex);\n}\nfunction expression(type) {\n  if (atomicTypes.hasOwnProperty(type)) return cont(maybeoperator);\n  if (type == \"type\" ) return cont(maybeoperator);\n  if (type == \"function\") return cont(functiondef);\n  if (type == \"keyword c\") return cont(maybeexpression);\n  if (type == \"(\") return cont(pushlex(\")\"), maybeexpression, expect(\")\"), poplex, maybeoperator);\n  if (type == \"operator\") return cont(expression);\n  if (type == \"[\") return cont(pushlex(\"]\"), commasep(maybeexpression, \"]\"), poplex, maybeoperator);\n  if (type == \"{\") return cont(pushlex(\"}\"), commasep(objprop, \"}\"), poplex, maybeoperator);\n  return cont();\n}\nfunction maybeexpression(type) {\n  if (type.match(/[;\\}\\)\\],]/)) return pass();\n  return pass(expression);\n}\n\nfunction maybeoperator(type, value) {\n  if (type == \"operator\" && /\\+\\+|--/.test(value)) return cont(maybeoperator);\n  if (type == \"operator\" || type == \":\") return cont(expression);\n  if (type == \";\") return;\n  if (type == \"(\") return cont(pushlex(\")\"), commasep(expression, \")\"), poplex, maybeoperator);\n  if (type == \".\") return cont(property, maybeoperator);\n  if (type == \"[\") return cont(pushlex(\"]\"), expression, expect(\"]\"), poplex, maybeoperator);\n}\n\nfunction maybeattribute(type) {\n  if (type == \"attribute\") return cont(maybeattribute);\n  if (type == \"function\") return cont(functiondef);\n  if (type == \"var\") return cont(vardef1);\n}\n\nfunction metadef(type) {\n  if(type == \":\") return cont(metadef);\n  if(type == \"variable\") return cont(metadef);\n  if(type == \"(\") return cont(pushlex(\")\"), commasep(metaargs, \")\"), poplex, statement);\n}\nfunction metaargs(type) {\n  if(type == \"variable\") return cont();\n}\n\nfunction importdef (type, value) {\n  if(type == \"variable\" && /[A-Z]/.test(value.charAt(0))) { registerimport(value); return cont(); }\n  else if(type == \"variable\" || type == \"property\" || type == \".\" || value == \"*\") return cont(importdef);\n}\n\nfunction typedef (type, value)\n{\n  if(type == \"variable\" && /[A-Z]/.test(value.charAt(0))) { registerimport(value); return cont(); }\n  else if (type == \"type\" && /[A-Z]/.test(value.charAt(0))) { return cont(); }\n}\n\nfunction maybelabel(type) {\n  if (type == \":\") return cont(poplex, statement);\n  return pass(maybeoperator, expect(\";\"), poplex);\n}\nfunction property(type) {\n  if (type == \"variable\") {cx.marked = \"property\"; return cont();}\n}\nfunction objprop(type) {\n  if (type == \"variable\") cx.marked = \"property\";\n  if (atomicTypes.hasOwnProperty(type)) return cont(expect(\":\"), expression);\n}\nfunction commasep(what, end) {\n  function proceed(type) {\n    if (type == \",\") return cont(what, proceed);\n    if (type == end) return cont();\n    return cont(expect(end));\n  }\n  return function(type) {\n    if (type == end) return cont();\n    else return pass(what, proceed);\n  };\n}\nfunction block(type) {\n  if (type == \"}\") return cont();\n  return pass(statement, block);\n}\nfunction vardef1(type, value) {\n  if (type == \"variable\"){register(value); return cont(typeuse, vardef2);}\n  return cont();\n}\nfunction vardef2(type, value) {\n  if (value == \"=\") return cont(expression, vardef2);\n  if (type == \",\") return cont(vardef1);\n}\nfunction forspec1(type, value) {\n  if (type == \"variable\") {\n    register(value);\n    return cont(forin, expression)\n  } else {\n    return pass()\n  }\n}\nfunction forin(_type, value) {\n  if (value == \"in\") return cont();\n}\nfunction functiondef(type, value) {\n  //function names starting with upper-case letters are recognised as types, so cludging them together here.\n  if (type == \"variable\" || type == \"type\") {register(value); return cont(functiondef);}\n  if (value == \"new\") return cont(functiondef);\n  if (type == \"(\") return cont(pushlex(\")\"), pushcontext, commasep(funarg, \")\"), poplex, typeuse, statement, popcontext);\n}\nfunction typeuse(type) {\n  if(type == \":\") return cont(typestring);\n}\nfunction typestring(type) {\n  if(type == \"type\") return cont();\n  if(type == \"variable\") return cont();\n  if(type == \"{\") return cont(pushlex(\"}\"), commasep(typeprop, \"}\"), poplex);\n}\nfunction typeprop(type) {\n  if(type == \"variable\") return cont(typeuse);\n}\nfunction funarg(type, value) {\n  if (type == \"variable\") {register(value); return cont(typeuse);}\n}\n\n// Interface\nexport const haxe = {\n  name: \"haxe\",\n  startState: function(indentUnit) {\n    var defaulttypes = [\"Int\", \"Float\", \"String\", \"Void\", \"Std\", \"Bool\", \"Dynamic\", \"Array\"];\n    var state = {\n      tokenize: haxeTokenBase,\n      reAllowed: true,\n      kwAllowed: true,\n      cc: [],\n      lexical: new HaxeLexical(-indentUnit, 0, \"block\", false),\n      importedtypes: defaulttypes,\n      context: null,\n      indented: 0\n    };\n    return state;\n  },\n\n  token: function(stream, state) {\n    if (stream.sol()) {\n      if (!state.lexical.hasOwnProperty(\"align\"))\n        state.lexical.align = false;\n      state.indented = stream.indentation();\n    }\n    if (stream.eatSpace()) return null;\n    var style = state.tokenize(stream, state);\n    if (type == \"comment\") return style;\n    state.reAllowed = !!(type == \"operator\" || type == \"keyword c\" || type.match(/^[\\[{}\\(,;:]$/));\n    state.kwAllowed = type != '.';\n    return parseHaxe(state, style, type, content, stream);\n  },\n\n  indent: function(state, textAfter, cx) {\n    if (state.tokenize != haxeTokenBase) return 0;\n    var firstChar = textAfter && textAfter.charAt(0), lexical = state.lexical;\n    if (lexical.type == \"stat\" && firstChar == \"}\") lexical = lexical.prev;\n    var type = lexical.type, closing = firstChar == type;\n    if (type == \"vardef\") return lexical.indented + 4;\n    else if (type == \"form\" && firstChar == \"{\") return lexical.indented;\n    else if (type == \"stat\" || type == \"form\") return lexical.indented + cx.unit;\n    else if (lexical.info == \"switch\" && !closing)\n      return lexical.indented + (/^(?:case|default)\\b/.test(textAfter) ? cx.unit : 2 * cx.unit);\n    else if (lexical.align) return lexical.column + (closing ? 0 : 1);\n    else return lexical.indented + (closing ? 0 : cx.unit);\n  },\n\n  languageData: {\n    indentOnInput: /^\\s*[{}]$/,\n    commentTokens: {line: \"//\", block: {open: \"/*\", close: \"*/\"}}\n  }\n};\n\nexport const hxml = {\n  name: \"hxml\",\n  startState: function () {\n    return {\n      define: false,\n      inString: false\n    };\n  },\n  token: function (stream, state) {\n    var ch = stream.peek();\n    var sol = stream.sol();\n\n    ///* comments */\n    if (ch == \"#\") {\n      stream.skipToEnd();\n      return \"comment\";\n    }\n    if (sol && ch == \"-\") {\n      var style = \"variable-2\";\n\n      stream.eat(/-/);\n\n      if (stream.peek() == \"-\") {\n        stream.eat(/-/);\n        style = \"keyword a\";\n      }\n\n      if (stream.peek() == \"D\") {\n        stream.eat(/[D]/);\n        style = \"keyword c\";\n        state.define = true;\n      }\n\n      stream.eatWhile(/[A-Z]/i);\n      return style;\n    }\n\n    var ch = stream.peek();\n\n    if (state.inString == false && ch == \"'\") {\n      state.inString = true;\n      stream.next();\n    }\n\n    if (state.inString == true) {\n      if (stream.skipTo(\"'\")) {\n\n      } else {\n        stream.skipToEnd();\n      }\n\n      if (stream.peek() == \"'\") {\n        stream.next();\n        state.inString = false;\n      }\n\n      return \"string\";\n    }\n\n    stream.next();\n    return null;\n  },\n  languageData: {\n    commentTokens: {line: \"#\"}\n  }\n}\n"],"names":["kw","type","style","content","A","B","C","operator","atom","attribute","keywords","isOperatorChar","chain","stream","state","f","tokenize","toUnescaped","end","next","escaped","haxeTokenBase","word","ch","cont","test","eat","eatWhile","match","reAllowed","haxeTokenComment","skipToEnd","current","tp","known","propertyIsEnumerable","kwAllowed","maybeEnd","atomicTypes","HaxeLexical","indented","column","align","prev","info","registerimport","importname","cx","t","importedtypes","name","marked","cc","pass","i","arguments","length","push","apply","inList","list","v","register","varname","context","localVars","globalVars","defaultVars","pushcontext","vars","popcontext","pushlex","result","lexical","lex","poplex","expect","wanted","statement","metadef","vardef1","expression","block","maybeattribute","functiondef","forspec1","maybelabel","funarg","importdef","typedef","hasOwnProperty","maybeoperator","maybeexpression","commasep","objprop","value","property","metaargs","charAt","what","proceed","typeuse","vardef2","forin","_type","typestring","typeprop","haxe","startState","indentUnit","token","sol","indentation","eatSpace","parseHaxe","combinator","pop","inScope","imported","typename","len","indent","textAfter","firstChar","closing","unit","languageData","indentOnInput","commentTokens","line","open","close","hxml","define","inString","peek","skipTo"],"sourceRoot":""}