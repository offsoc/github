# typed: true

# DO NOT EDIT MANUALLY
# This is an autogenerated file for types exported from the `iopromise` gem.
# Please instead update this file by running `bin/tapioca gem iopromise`.

# source://iopromise//lib/iopromise/rack/context_middleware.rb#5
module IOPromise; end

class IOPromise::Base < ::Promise
  # source://iopromise//lib/iopromise.rb#30
  def beginning; end

  # makes this promise inert, ensuring that promise chains do not continue
  # propegation once this promise has been cancelled.
  #
  # source://iopromise//lib/iopromise.rb#70
  def cancel; end

  # @return [Boolean]
  #
  # source://iopromise//lib/iopromise.rb#79
  def cancelled?; end

  # Subclasses are expected to implement 'execute_pool' to return an IOPromise::ExecutorPool
  # that is responsible for completing the given promise.
  #
  # @raise [NotImplementedError]
  #
  # source://iopromise//lib/iopromise.rb#64
  def execute_pool; end

  # source://iopromise//lib/iopromise.rb#45
  def fulfill(value); end

  # @raise [::IOPromise::Error]
  #
  # source://iopromise//lib/iopromise.rb#18
  def instrument(begin_cb = T.unsafe(nil), end_cb = T.unsafe(nil)); end

  # source://iopromise//lib/iopromise.rb#40
  def notify_completion(value: T.unsafe(nil), reason: T.unsafe(nil)); end

  # source://iopromise//lib/iopromise.rb#51
  def reject(reason); end

  # @return [Boolean]
  #
  # source://iopromise//lib/iopromise.rb#36
  def started_executing?; end

  # @raise [IOPromise::CancelledError]
  #
  # source://iopromise//lib/iopromise.rb#57
  def wait; end
end

class IOPromise::CancelContext
  # @return [CancelContext] a new instance of CancelContext
  #
  # source://iopromise//lib/iopromise/cancel_context.rb#34
  def initialize(parent); end

  # source://iopromise//lib/iopromise/cancel_context.rb#43
  def cancel; end

  # source://iopromise//lib/iopromise/cancel_context.rb#38
  def subscribe(observer); end

  class << self
    # source://iopromise//lib/iopromise/cancel_context.rb#6
    def context_stack; end

    # source://iopromise//lib/iopromise/cancel_context.rb#10
    def current; end

    # source://iopromise//lib/iopromise/cancel_context.rb#20
    def pop; end

    # source://iopromise//lib/iopromise/cancel_context.rb#14
    def push; end

    # source://iopromise//lib/iopromise/cancel_context.rb#26
    def with_new_context; end
  end
end

class IOPromise::CancelledError < ::IOPromise::Error; end

# source://iopromise//lib/iopromise/data_loader.rb#4
module IOPromise::DataLoader
  mixes_in_class_methods ::IOPromise::DataLoader::ClassMethods

  # source://iopromise//lib/iopromise/data_loader.rb#30
  def async_attributes; end

  # source://iopromise//lib/iopromise/data_loader.rb#34
  def sync; end

  protected

  # source://iopromise//lib/iopromise/data_loader.rb#40
  def attr_async_promises; end

  class << self
    # @private
    #
    # source://iopromise//lib/iopromise/data_loader.rb#26
    def included(base); end
  end
end

# source://iopromise//lib/iopromise/data_loader.rb#5
module IOPromise::DataLoader::ClassMethods
  # source://iopromise//lib/iopromise/data_loader.rb#6
  def attr_async(attr_name, build_func = T.unsafe(nil)); end

  # source://iopromise//lib/iopromise/data_loader.rb#21
  def attr_async_names; end
end

module IOPromise::Deferred
  class << self
    # source://iopromise//lib/iopromise/deferred.rb#8
    def new(*args, **kwargs, &block); end
  end
end

class IOPromise::Deferred::DeferredExecutorPool < ::IOPromise::ExecutorPool::Batch
  # @return [DeferredExecutorPool] a new instance of DeferredExecutorPool
  #
  # source://iopromise//lib/iopromise/deferred/executor_pool.rb#6
  def initialize(*_arg0); end

  # source://iopromise//lib/iopromise/deferred/executor_pool.rb#15
  def execute_continue; end
end

class IOPromise::Deferred::DeferredPromise < ::IOPromise::Base
  # @return [DeferredPromise] a new instance of DeferredPromise
  #
  # source://iopromise//lib/iopromise/deferred/promise.rb#8
  def initialize(delay: T.unsafe(nil), &block); end

  # source://iopromise//lib/iopromise/deferred/promise.rb#28
  def execute_pool; end

  # source://iopromise//lib/iopromise/deferred/promise.rb#32
  def run_deferred; end

  # source://iopromise//lib/iopromise/deferred/promise.rb#41
  def time_until_execution; end

  # source://iopromise//lib/iopromise/deferred/promise.rb#20
  def wait; end
end

class IOPromise::Error < ::StandardError; end

class IOPromise::ExecutorContext
  # @return [ExecutorContext] a new instance of ExecutorContext
  #
  # source://iopromise//lib/iopromise/executor_context.rb#14
  def initialize; end

  # source://iopromise//lib/iopromise/executor_context.rb#30
  def register(promise); end

  # source://iopromise//lib/iopromise/executor_context.rb#24
  def register_observer_io(observer, io, interest); end

  # source://iopromise//lib/iopromise/executor_context.rb#35
  def wait_for_all_data(end_when_complete: T.unsafe(nil)); end

  private

  # source://iopromise//lib/iopromise/executor_context.rb#87
  def complete_pending_registrations; end

  # source://iopromise//lib/iopromise/executor_context.rb#96
  def register_now(promise); end

  # source://iopromise//lib/iopromise/executor_context.rb#80
  def select(wait_time); end

  class << self
    # source://iopromise//lib/iopromise/executor_context.rb#9
    def current; end
  end
end

module IOPromise::ExecutorPool; end

class IOPromise::ExecutorPool::Base
  include ::Promise::Observer

  # @return [Base] a new instance of Base
  #
  # source://iopromise//lib/iopromise/executor_pool/base.rb#19
  def initialize(connection_pool); end

  # source://iopromise//lib/iopromise/executor_pool/base.rb#43
  def begin_executing(item); end

  # Continue execution of one or more pending IOPromises assigned to this pool.
  # Implementations may choose to pre-register IO handled using:
  #   ExecutorContext.current.register_observer_io(...)
  # Alternatively, they can be registered when this function is called.
  # During this function, implementations should check for timeouts and run
  # any housekeeping operations.
  #
  # Must be implemented by subclasses.
  #
  # @raise [NotImplementedError]
  #
  # source://iopromise//lib/iopromise/executor_pool/base.rb#55
  def execute_continue; end

  # source://iopromise//lib/iopromise/executor_pool/base.rb#39
  def promise_cancelled(item); end

  # source://iopromise//lib/iopromise/executor_pool/base.rb#33
  def promise_fulfilled(_value, item); end

  # source://iopromise//lib/iopromise/executor_pool/base.rb#36
  def promise_rejected(_reason, item); end

  # source://iopromise//lib/iopromise/executor_pool/base.rb#28
  def register(item); end

  # Returns the value of attribute select_timeout.
  #
  # source://iopromise//lib/iopromise/executor_pool/base.rb#17
  def select_timeout; end

  # Sets the attribute select_timeout
  #
  # @param value the value to set the attribute select_timeout to.
  #
  # source://iopromise//lib/iopromise/executor_pool/base.rb#17
  def select_timeout=(_arg0); end

  # source://iopromise//lib/iopromise/executor_pool/base.rb#59
  def sync; end

  class << self
    # source://iopromise//lib/iopromise/executor_pool/base.rb#11
    def for(connection_pool); end
  end
end

class IOPromise::ExecutorPool::Batch < ::IOPromise::ExecutorPool::Base
  # @return [Batch] a new instance of Batch
  #
  # source://iopromise//lib/iopromise/executor_pool/batch.rb#6
  def initialize(*_arg0); end

  # source://iopromise//lib/iopromise/executor_pool/batch.rb#12
  def next_batch; end
end

class IOPromise::ExecutorPool::Sequential < ::IOPromise::ExecutorPool::Base
  # source://iopromise//lib/iopromise/executor_pool/sequential.rb#10
  def execute_continue; end

  # source://iopromise//lib/iopromise/executor_pool/sequential.rb#6
  def execute_continue_item(item); end
end

# source://iopromise//lib/iopromise/rack/context_middleware.rb#6
module IOPromise::Rack; end

# source://iopromise//lib/iopromise/rack/context_middleware.rb#7
class IOPromise::Rack::ContextMiddleware
  # @return [ContextMiddleware] a new instance of ContextMiddleware
  #
  # source://iopromise//lib/iopromise/rack/context_middleware.rb#8
  def initialize(app); end

  # source://iopromise//lib/iopromise/rack/context_middleware.rb#12
  def call(env); end
end

# source://iopromise//lib/iopromise/version.rb#4
IOPromise::VERSION = T.let(T.unsafe(nil), String)
