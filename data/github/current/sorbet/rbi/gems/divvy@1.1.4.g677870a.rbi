# typed: true

# DO NOT EDIT MANUALLY
# This is an autogenerated file for types exported from the `divvy` gem.
# Please instead update this file by running `bin/tapioca gem divvy`.

# source://divvy//lib/divvy/parallelizable.rb#1
module Divvy
  class << self
    # Load a script that defines a Divvy::Parallelizable object. A class that
    # includes the Parallelizable module must be defined in order for this to work.
    #
    # file - Script file to load.
    #
    # Returns an object that implements the Parallelizable interface.
    # Raises a RuntimeError when no parallelizable object was defined.
    #
    # source://divvy//lib/divvy.rb#13
    def load(file); end
  end
end

# The master process used to generate and distribute task items to the
# worker processes.
#
# source://divvy//lib/divvy/master.rb#6
class Divvy::Master
  # Create the master process object.
  #
  # task         - Object that implements the Parallelizable interface.
  # worker_count - Number of worker processes.
  # verbose      - Enable verbose error logging.
  # socket       - The unix domain socket filename.
  #
  # The workers array is initialized with Worker objects for the number of
  # worker processes requested. The processes are not actually started at this
  # time though.
  #
  # @return [Master] a new instance of Master
  #
  # source://divvy//lib/divvy/master.rb#49
  def initialize(task, worker_count, verbose = T.unsafe(nil), socket = T.unsafe(nil)); end

  # Internal: Boot and individual worker process. Don't call this if the
  # worker is thought to be running.
  #
  # worker - The Worker object to boot.
  #
  # Returns the Worker object provided.
  #
  # source://divvy//lib/divvy/master.rb#212
  def boot_worker(worker); end

  # Internal: Boot any workers that are not currently running. This is a no-op
  # if all workers are though to be running. No attempt is made to verify
  # worker processes are running here. Only workers that have not yet been
  # booted and those previously marked as reaped are started.
  #
  # source://divvy//lib/divvy/master.rb#199
  def boot_workers; end

  # Number of worker processes that have exited with a failure status since
  # the master started processing work.
  #
  # source://divvy//lib/divvy/master.rb#24
  def failures; end

  # Internal: Install a trap to dump stack for all processes on SIGINFO. The
  # signal is not supported on all operating systems (namely Linux) so we have
  # to rescue and ignore the exception.
  #
  # source://divvy//lib/divvy/master.rb#297
  def install_siginfo_trap; end

  # Internal: Install traps for shutdown signals. Most signals deal with
  # shutting down the master loop and socket.
  #
  # INFO      - Dump stack for all processes to stderr.
  # TERM      - Initiate immediate forceful shutdown of all worker processes
  #             along with the master process, aborting any existing jobs in
  #             progress.
  # INT, QUIT - Initiate graceful shutdown, allowing existing worker processes
  #             to finish their current task and exit on their own. If this
  #             signal is received again after 10s, instead initiate an
  #             immediate forceful shutdown as with TERM. This is mostly so you
  #             can interrupt sanely with Ctrl+C with the master foregrounded.
  # CHLD      - Set the worker reap flag. An attempt is made to reap workers
  #             immediately after the current dispatch iteration.
  #
  # Returns nothing.
  #
  # source://divvy//lib/divvy/master.rb#276
  def install_signal_traps; end

  # Internal: Send a signal to all running workers.
  #
  # signal - The string signal name.
  #
  # Returns nothing.
  #
  # source://divvy//lib/divvy/master.rb#237
  def kill_workers(signal = T.unsafe(nil)); end

  # Internal: Write a verbose log message to stderr.
  #
  # source://divvy//lib/divvy/master.rb#323
  def log(message); end

  # Public: Check if the current process is the master process.
  #
  # Returns true in the master process, false in the worker process.
  #
  # @return [Boolean]
  #
  # source://divvy//lib/divvy/master.rb#135
  def master_process?; end

  # Internal: Attempt to reap all worker processes via Process::waitpid. This
  # method does not block waiting for processes to exit. Running processes are
  # ignored.
  #
  # Returns an array of Worker objects whose process's were reaped. The
  # Worker#status attribute can be used to access the Process::Status result.
  #
  # source://divvy//lib/divvy/master.rb#250
  def reap_workers; end

  # Internal: Uninstall signal traps set up by the install_signal_traps
  # method. This is called immediately after forking worker processes to reset
  # traps to their default implementations and also when the master process
  # shuts down.
  #
  # source://divvy//lib/divvy/master.rb#310
  def reset_signal_traps; end

  # Public: Start the main run loop. This installs signal handlers into the
  # current process, binds to the unix domain socket, boots workers, and begins
  # dispatching work.
  #
  # The run method does not return until all task items generated have been
  # processed unless a shutdown signal is received or the #shutdown method is
  # called within the loop.
  #
  # Returns nothing.
  # Raises BootFailure when the workers fail to start.
  # Raises Shutdown when a forceful shutdown is triggered (SIGTERM).
  #
  # source://divvy//lib/divvy/master.rb#84
  def run; end

  # Public: Initiate shutdown of the run loop. The loop will not be stopped when
  # this method returns. The original run loop will return after the current
  # iteration of task item.
  #
  # source://divvy//lib/divvy/master.rb#156
  def shutdown; end

  # Internal: Really shutdown the unix socket and reap all worker processes.
  # This doesn't signal the workers. Instead, the socket shutdown is relied
  # upon to trigger the workers to exit normally.
  #
  # TODO Send SIGKILL when workers stay running for configurable period.
  #
  # @raise [Shutdown]
  #
  # source://divvy//lib/divvy/master.rb#165
  def shutdown!; end

  # The string filename of the unix domain socket used to distribute work.
  #
  # source://divvy//lib/divvy/master.rb#14
  def socket; end

  # Number of worker processes that have been spawned since the master
  # started processing work.
  #
  # source://divvy//lib/divvy/master.rb#28
  def spawn_count; end

  # Internal: create and bind to the unix domain socket. Note that the
  # requested backlog matches the number of workers. Otherwise workers will
  # get ECONNREFUSED when attempting to connect to the master and exit.
  #
  # source://divvy//lib/divvy/master.rb#180
  def start_server; end

  # Internal: Close and remove the unix domain socket.
  #
  # source://divvy//lib/divvy/master.rb#188
  def stop_server; end

  # Number of tasks that have been distributed to worker processes.
  #
  # source://divvy//lib/divvy/master.rb#20
  def tasks_distributed; end

  # Enable verbose logging to stderr.
  #
  # source://divvy//lib/divvy/master.rb#17
  def verbose; end

  # Enable verbose logging to stderr.
  #
  # source://divvy//lib/divvy/master.rb#17
  def verbose=(_arg0); end

  # The number of worker processes to boot.
  #
  # source://divvy//lib/divvy/master.rb#8
  def worker_count; end

  # Public: Check if the current process is a worker process.
  # This relies on the @workers array being set to a nil value.
  #
  # Returns true in the worker process, false in master processes.
  #
  # @return [Boolean]
  #
  # source://divvy//lib/divvy/master.rb#143
  def worker_process?; end

  # The array of Worker objects this master is managing.
  #
  # source://divvy//lib/divvy/master.rb#11
  def workers; end

  # Public: Are any worker processes currently running or have yet to be
  # reaped by the master process?
  #
  # @return [Boolean]
  #
  # source://divvy//lib/divvy/master.rb#149
  def workers_running?; end
end

# Raised from the run loop when worker processes never fully booted and
# started making connections to the master.
#
# source://divvy//lib/divvy/master.rb#36
class Divvy::Master::BootFailure < ::StandardError; end

# Raised from a signal handler when a forceful shutdown is requested.
#
# source://divvy//lib/divvy/master.rb#31
class Divvy::Master::Shutdown < ::Exception; end

# Module defining the main task interface. Parallelizable classes must respond
# to #dispatch and #process and may override hook methods to tap into the
# worker process lifecycle.
#
# source://divvy//lib/divvy/parallelizable.rb#5
module Divvy::Parallelizable
  # Hook called after a worker process is forked off from the master process.
  # This runs in the worker process only. Typically used to re-establish
  # connections to external services or open files (logs and such).
  #
  # worker - A Divvy::Worker object describing the process that was just
  #          created. Always the current process ($$).
  #
  # Return value is ignored.
  #
  # source://divvy//lib/divvy/parallelizable.rb#39
  def after_fork(worker); end

  # Hook called before a worker process is forked off from the master process.
  # This runs in the master process only.
  #
  # worker - Divvy::Worker object descibing the process that's about to fork.
  #          Worker#pid will be nil but Worker#number (1..worker_count) is
  #          always available.
  #
  # Return value is ignored.
  #
  # source://divvy//lib/divvy/parallelizable.rb#50
  def before_fork(worker); end

  # The main loop responsible for generating task items to process in workers.
  # Runs in the master process only. Each item this method yields is distributed
  # to one of a pool of worker processes where #process (see below) is invoked
  # to process the task item.
  #
  # The arguments yielded to the block are passed with same arity to
  # the #process method. Only marshallable types may be included.
  #
  # The dispatch method takes no arguments. It's expected that the receiving
  # object is setup with all necessary state to generate task items or can
  # retrieve the information it needs from elsewhere.
  #
  # When the dispatch method returns the master process exits.
  # If an exception is raised, the program exits non-zero.
  #
  # @raise [NotImplementedError]
  #
  # source://divvy//lib/divvy/parallelizable.rb#20
  def dispatch; end

  # Process an individual task item. Each item produced by #dispatch is sent here
  # in one of a pool of the worker processes. The arguments to this method must
  # match the arity of the task item yielded from #dispatch.
  #
  # @raise [NotImplementedError]
  #
  # source://divvy//lib/divvy/parallelizable.rb#27
  def process(*args); end

  class << self
    # @private
    #
    # source://divvy//lib/divvy/parallelizable.rb#55
    def included(mod); end

    # source://divvy//lib/divvy/parallelizable.rb#59
    def parallelizable; end
  end
end

# Models an individual divvy worker process. These objects are used in both
# the master and the forked off workers to perform common tasks and for basic
# tracking.
#
# source://divvy//lib/divvy/worker.rb#5
class Divvy::Worker
  # Create a Worker object. The Master object typically handles this.
  #
  # @return [Worker] a new instance of Worker
  #
  # source://divvy//lib/divvy/worker.rb#23
  def initialize(task, number, socket, verbose = T.unsafe(nil)); end

  # Internal: Retrieve an individual task item from the master process. Opens
  # a new socket, reads and unmarshals a single task item.
  #
  # Returns an Array containing the arguments yielded by the dispatcher.
  #
  # source://divvy//lib/divvy/worker.rb#127
  def dequeue; end

  # source://divvy//lib/divvy/worker.rb#144
  def install_signal_traps; end

  # Public: Send a signal to a running worker process.
  #
  # signal - String signal name.
  #
  # Returns true when the process was signaled, false if the process is no
  # longer running.
  # Raises when the worker process is not thought to be running.
  #
  # source://divvy//lib/divvy/worker.rb#45
  def kill(signal); end

  # source://divvy//lib/divvy/worker.rb#156
  def log(message); end

  # Internal: The main worker loop. This is called after a new worker process
  # has been setup with signal traps and whatnot and connects to the master in
  # a loop to retrieve task items. The worker process exits if this method
  # returns or raises an exception.
  #
  # source://divvy//lib/divvy/worker.rb#101
  def main; end

  # The worker number. These are sequential starting from 1 and ending in the
  # configured worker concurrency count.
  #
  # source://divvy//lib/divvy/worker.rb#8
  def number; end

  # The worker processes's pid. This is $$ when inside the worker process.
  #
  # source://divvy//lib/divvy/worker.rb#20
  def pid; end

  # The worker processes's pid. This is $$ when inside the worker process.
  #
  # source://divvy//lib/divvy/worker.rb#20
  def pid=(_arg0); end

  # Public: Attempt to reap this worker's process using waitpid. This is a
  # no-op if the process is not thought to be running or is marked as already
  # being reaped. This should only be called in the master process.
  #
  # Returns the Process::Status object if the process was reaped, nil if the
  # process was not reaped because it's still running or is already reaped.
  #
  # source://divvy//lib/divvy/worker.rb#89
  def reap; end

  # Public: Check whether the worker process is thought to be running. This
  # does not attempt to verify the real state of the process with the system.
  #
  # @return [Boolean]
  #
  # source://divvy//lib/divvy/worker.rb#34
  def running?; end

  # The Unix domain socket file used to communicate with the master process.
  #
  # source://divvy//lib/divvy/worker.rb#11
  def socket; end

  # Public: Fork off a new process for this worker and yield to the block
  # immediately in the new child process.
  #
  # Returns the pid of the new process in the master process. Never returns in
  # the child process.
  # Raises when the worker process is already thought to be running or has not
  # yet been reaped.
  #
  # source://divvy//lib/divvy/worker.rb#68
  def spawn; end

  # Process::Status object result of reaping the worker.
  #
  # source://divvy//lib/divvy/worker.rb#17
  def status; end

  # Whether verbose log info should be written to stderr.
  #
  # source://divvy//lib/divvy/worker.rb#14
  def verbose; end

  # Whether verbose log info should be written to stderr.
  #
  # source://divvy//lib/divvy/worker.rb#14
  def verbose=(_arg0); end

  # Public: Check whether the current process is this worker process.
  #
  # Returns true when we're in this worker, false in the master.
  #
  # @return [Boolean]
  #
  # source://divvy//lib/divvy/worker.rb#57
  def worker_process?; end
end
