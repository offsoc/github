{"version":3,"file":"chunk-node_modules_codemirror_legacy-modes_mode_dtd_js-xxxxxxxxxxxx.js","mappings":"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","sources":["node_modules/@codemirror/legacy-modes/mode/dtd.js"],"sourcesContent":["var type;\nfunction ret(style, tp) {type = tp; return style;}\n\nfunction tokenBase(stream, state) {\n  var ch = stream.next();\n\n  if (ch == \"<\" && stream.eat(\"!\") ) {\n    if (stream.eatWhile(/[\\-]/)) {\n      state.tokenize = tokenSGMLComment;\n      return tokenSGMLComment(stream, state);\n    } else if (stream.eatWhile(/[\\w]/)) return ret(\"keyword\", \"doindent\");\n  } else if (ch == \"<\" && stream.eat(\"?\")) { //xml declaration\n    state.tokenize = inBlock(\"meta\", \"?>\");\n    return ret(\"meta\", ch);\n  } else if (ch == \"#\" && stream.eatWhile(/[\\w]/)) return ret(\"atom\", \"tag\");\n  else if (ch == \"|\") return ret(\"keyword\", \"separator\");\n  else if (ch.match(/[\\(\\)\\[\\]\\-\\.,\\+\\?>]/)) return ret(null, ch);//if(ch === \">\") return ret(null, \"endtag\"); else\n  else if (ch.match(/[\\[\\]]/)) return ret(\"rule\", ch);\n  else if (ch == \"\\\"\" || ch == \"'\") {\n    state.tokenize = tokenString(ch);\n    return state.tokenize(stream, state);\n  } else if (stream.eatWhile(/[a-zA-Z\\?\\+\\d]/)) {\n    var sc = stream.current();\n    if( sc.substr(sc.length-1,sc.length).match(/\\?|\\+/) !== null )stream.backUp(1);\n    return ret(\"tag\", \"tag\");\n  } else if (ch == \"%\" || ch == \"*\" ) return ret(\"number\", \"number\");\n  else {\n    stream.eatWhile(/[\\w\\\\\\-_%.{,]/);\n    return ret(null, null);\n  }\n}\n\nfunction tokenSGMLComment(stream, state) {\n  var dashes = 0, ch;\n  while ((ch = stream.next()) != null) {\n    if (dashes >= 2 && ch == \">\") {\n      state.tokenize = tokenBase;\n      break;\n    }\n    dashes = (ch == \"-\") ? dashes + 1 : 0;\n  }\n  return ret(\"comment\", \"comment\");\n}\n\nfunction tokenString(quote) {\n  return function(stream, state) {\n    var escaped = false, ch;\n    while ((ch = stream.next()) != null) {\n      if (ch == quote && !escaped) {\n        state.tokenize = tokenBase;\n        break;\n      }\n      escaped = !escaped && ch == \"\\\\\";\n    }\n    return ret(\"string\", \"tag\");\n  };\n}\n\nfunction inBlock(style, terminator) {\n  return function(stream, state) {\n    while (!stream.eol()) {\n      if (stream.match(terminator)) {\n        state.tokenize = tokenBase;\n        break;\n      }\n      stream.next();\n    }\n    return style;\n  };\n}\n\nexport const dtd = {\n  name: \"dtd\",\n  startState: function() {\n    return {tokenize: tokenBase,\n            baseIndent: 0,\n            stack: []};\n  },\n\n  token: function(stream, state) {\n    if (stream.eatSpace()) return null;\n    var style = state.tokenize(stream, state);\n\n    var context = state.stack[state.stack.length-1];\n    if (stream.current() == \"[\" || type === \"doindent\" || type == \"[\") state.stack.push(\"rule\");\n    else if (type === \"endtag\") state.stack[state.stack.length-1] = \"endtag\";\n    else if (stream.current() == \"]\" || type == \"]\" || (type == \">\" && context == \"rule\")) state.stack.pop();\n    else if (type == \"[\") state.stack.push(\"[\");\n    return style;\n  },\n\n  indent: function(state, textAfter, cx) {\n    var n = state.stack.length;\n\n    if( textAfter.charAt(0) === ']' )n--;\n    else if(textAfter.substr(textAfter.length-1, textAfter.length) === \">\"){\n      if(textAfter.substr(0,1) === \"<\") {}\n      else if( type == \"doindent\" && textAfter.length > 1 ) {}\n      else if( type == \"doindent\")n--;\n      else if( type == \">\" && textAfter.length > 1) {}\n      else if( type == \"tag\" && textAfter !== \">\") {}\n      else if( type == \"tag\" && state.stack[state.stack.length-1] == \"rule\")n--;\n      else if( type == \"tag\")n++;\n      else if( textAfter === \">\" && state.stack[state.stack.length-1] == \"rule\" && type === \">\")n--;\n      else if( textAfter === \">\" && state.stack[state.stack.length-1] == \"rule\") {}\n      else if( textAfter.substr(0,1) !== \"<\" && textAfter.substr(0,1) === \">\" )n=n-1;\n      else if( textAfter === \">\") {}\n      else n=n-1;\n      //over rule them all\n      if(type == null || type == \"]\")n--;\n    }\n\n    return state.baseIndent + n * cx.unit;\n  },\n\n  languageData: {\n    indentOnInput: /^\\s*[\\]>]$/\n  }\n};\n\n"],"names":["type","tokenBase","stream","state","ch","next","eat","eatWhile","tokenize","tokenSGMLComment","eol","match","escaped","sc","current","substr","length","backUp","dashes","dtd","name","startState","baseIndent","stack","token","eatSpace","style","context","push","pop","indent","textAfter","cx","n","charAt","unit","languageData","indentOnInput"],"sourceRoot":""}