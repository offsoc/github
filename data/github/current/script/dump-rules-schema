#!/usr/bin/env ruby
# typed: true
# frozen_string_literal: true


require "optparse"
require "version_sorter"
require_relative "../config/environment"

extend T::Sig

@graphql_changed = T.let(false, T::Boolean)
@openapi_changed = T.let(false, T::Boolean)
@openapi_rules = T.let(Hash.new, T::Hash[Symbol, T.untyped])

# The following classes currently don't support graphql enums for their fields.
# Enum field support was added after these classes were added and if we were to change the types to enums,
# we may break existing rules
UNSUPPORTED_ENUM_CLASSES = %w(
  BranchNamePattern
  CodeScanningTool
  CommitAuthorEmailPattern
  CommitMessagePattern
  CommitterEmailPattern
  PropertyTargetDefinition
  TagNamePattern
).freeze

@dry_run = T.let({
  errors: Hash.new { |h, k| h[k] = [] }, # { rule_type => [error, ...]}
  changes: {
    added: [], # [file_path, ...]
    modified: [],
    deleted: []
  }
}, T::Hash[Symbol, T::Hash[Symbol, T::Array[String]]])

FILE_HEADER = <<~HEADER
  # typed: true
  # frozen_string_literal: true

  # DO NOT EDIT MANUALLY
  # This is an autogenerated file of the supported rule parameter schemas
  # Please instead update this file by running `bin/dump-rules-schema`.
HEADER

def write_file(path, contents, file_type: :graphql)
  exists = false
  if File.exist?(path)
    exists = true
    existing = File.read(path)
    return if existing == contents
  end
  if @options[:dry]
    change_type = exists ? :modified : :added
    @dry_run[:changes][change_type] << path
  else
    File.write(path, contents)
  end
  case file_type
  when :graphql
    @graphql_changed = true
  when :openapi
    @openapi_changed = true
  end
end

def write_graphql_schema_file(class_name, class_string, folder:)
  write_file("app/platform/#{folder}/repository_rules/#{class_name.underscore}.rb", class_string)
end

def write_enum_file(class_name, description, rule_types)
  value_string = ""
  rule_types.each do |rule_type_key, rule_type_value|
    rule_description = rule_type_value.description || rule_type_key.humanize
    rule_description += " NOTE: This rule is in beta and subject to change" if rule_type_value.beta_api
    value_string += "      value #{rule_type_key.upcase.dump}, #{rule_description.dump}, value: #{rule_type_key.dump}"
    # If we are publishing the API early, we can ignore the feature flag
    if rule_type_value.feature_flag.present? && !rule_type_value.publish_api
      value_string += ", feature_flag: :#{rule_type_value.feature_flag}"
    end
    value_string += "\n"
  end
  input_data = <<~INPUT
    #{FILE_HEADER.chomp}

    module Platform
      module Enums
        class #{class_name} < Platform::Enums::Base
          description "#{description}"

    #{value_string.chomp}
        end
      end
    end
  INPUT

  write_file("app/platform/enums/#{class_name.underscore}.rb", input_data)
end

def write_input_union_file(class_name, description, rule_parameters_by_type, generated_classes_with_feature_flags)
  argument_string = ""
  rule_parameters_by_type.each do |rule_type, param_class|
    feature_flag = !!generated_classes_with_feature_flags[rule_type] ? ", feature_flag: :#{generated_classes_with_feature_flags[rule_type]}" : ""

    argument_string += "      argument :#{rule_type}, Inputs::RepositoryRules::#{param_class}Input, \"Parameters used for the `#{rule_type}` rule type\"#{feature_flag}, required: false\n"
  end
  input_data = <<~INPUT
    #{FILE_HEADER.chomp}

    module Platform
      module Inputs
        class #{class_name} < Platform::Inputs::Base
          # Once `oneOf` is supported in GraphQL, this class can make use of it
          description "#{description} Only one of the fields should be specified."

    #{argument_string.chomp}
        end
      end
    end
  INPUT

  write_file("app/platform/inputs/#{class_name.underscore}.rb", input_data)
end

def write_model_union_file(class_name, rule_parameters_by_type)
  when_string = ""
  rule_parameters_by_type.each do |rule_type, param_class|
    when_string += <<-WHEN
    when "#{rule_type}"
      "#{param_class}"
    WHEN
  end

  model_data = <<~MODEL
    #{FILE_HEADER.chomp}

    class Platform::Models::#{class_name}
      attr_reader :ruleset, :parameters, :rule_type

      def initialize(ruleset, parameters, platform_type: nil, rule_type: nil)
        @ruleset = ruleset
        @parameters = parameters
        @platform_type = platform_type
        @rule_type = rule_type
      end

      def platform_type_name
        return @platform_type if @platform_type

        case rule_type
    #{when_string.chomp}
        end
      end
    end
  MODEL

  write_file("app/platform/models/#{class_name.underscore}.rb", model_data)
end

def write_graphql_input_class(class_name, schema, description, feature_flag: nil, publish_api: nil)
  argument_string = ""
  schema.fields.sort_by(&:name).each do |field|
    unless field.internal
      argument_string += "        #{graphql_argument_for_field(field, class_name:)}\n"
    end
  end
  input_data = <<~INPUT
    #{FILE_HEADER.chomp}

    module Platform
      module Inputs
        module RepositoryRules
          class #{class_name}Input < Platform::Inputs::Base
            description #{description.dump}
    #{"        feature_flag :#{feature_flag}\n" if feature_flag && !publish_api}
    #{argument_string.chomp}
          end
        end
      end
    end
  INPUT

  write_graphql_schema_file(class_name + "Input", input_data, folder: "inputs")
end

def write_union_file(class_name, description, rule_parameters)
  type_string = ""
  rule_parameters.each do |param_type|
    type_string += "        Objects::RepositoryRules::#{param_type},\n"
  end
  union_data = <<~UNION
    #{FILE_HEADER.chomp}

    module Platform
      module Unions
        class #{class_name} < Platform::Unions::Base
          description "#{description}"

          possible_types(
    #{type_string.chomp}
          )
        end
      end
    end
  UNION

  write_file("app/platform/unions/#{class_name.underscore}.rb", union_data)
end

def is_graphql_enum?(field, class_name)
  !UNSUPPORTED_ENUM_CLASSES.include?(class_name&.delete_suffix("Parameters")) && field.respond_to?(:allowed_options) && (field.allowed_options.present? || field.allowed_values.present?)
end

sig { params(field: RuleEngine::ParameterSchema::Field, class_name: T.nilable(String)).void }
def write_graphql_enum_field_file(field, class_name: nil)
  class_name = class_name&.delete_suffix("Parameters")
  enum_name = class_name ? "#{class_name}#{field.name.camelcase}" : "#{field.name.camelcase}"
  enum_values = ""

  if field.allowed_options.present?
    field.allowed_options&.each do |option|
      enum_values += "        value \"#{option[:value]}\", \"#{option[:description] || option[:display_name]}\", value: \"#{option[:value]}\"\n"
    end
  else
    field.allowed_values&.each do |value|
      enum_values += "        value \"#{value}\", \"#{value}\", value: \"#{value}\"\n"
    end
  end

  text = <<~ENUM
    # typed: true
    # frozen_string_literal: true

    # DO NOT EDIT MANUALLY
  ENUM

  comment = "# This is an autogenerated file of the enums for"
  comment += if class_name.present?
    " the '#{class_name}' field '#{field.name}'\n"
  else
    " the '#{field.name}' field\n"
  end

  text += comment
  text += <<~ENUM
    # Please instead update this file by running `bin/dump-rules-schema`.

    module Platform
      module Enums
        module RepositoryRules
          class #{enum_name} < Platform::Enums::Base
            description "#{field.description_api}"

    #{enum_values.chomp}
          end
        end
      end
    end
  ENUM

  write_file("app/platform/enums/repository_rules/#{enum_name.underscore}.rb", text, file_type: :graphql)
end

def fix_graphql_name(field_name)
  # "context" is a special platform method name that cannot be overriden
  if field_name == "context"
    "status_context"
  end
end

sig do
  params(
    name: String,
    type: String,
    description: String,
    required: T::Boolean,
    feature_flag: T.nilable(Symbol),
    beta: T::Boolean,
    publish_api: T.nilable(T::Boolean),
    object: T::Boolean,
    array: T::Boolean,
    enum: T::Boolean,
    class_name: T.nilable(String)
  ).returns(String)
end
def create_graphql_argument(name:, type:, description:, required:, feature_flag: nil, beta: false, publish_api: nil, object: false, array: false, enum: false, class_name: nil)
  if enum
    type_string = "Enums::RepositoryRules::#{class_name ? "#{class_name.delete_suffix("Parameters")}#{name.camelcase}" : "#{name.camelcase}"}"
  else
    type_string = object ? "Inputs::RepositoryRules::#{type}" : type
    type_string = "[#{type_string}]" if array
  end
  if feature_flag.present? && beta.present?
    description += " This argument is in beta and subject to change. #{description.dump}"
  end
  text_string = "argument :#{name}, #{type_string}, #{description.dump}, required: #{required}"
  text_string << ", feature_flag: :#{feature_flag}" unless feature_flag.nil? || publish_api
  text_string
end

def create_graphql_field(field:, type:, object: false, array: false, enum: false, class_name: nil)
  swap_method_name = fix_graphql_name(field.name)

  field_text = []
  if enum
    # enum fields are written when creating the graphql field
    write_graphql_enum_field_file(field, class_name:)
    type_string = "Enums::RepositoryRules::#{class_name ? "#{class_name.delete_suffix("Parameters")}#{field.name.camelcase}" : "#{field.name.camelcase}"}"
  else
    type_string = (object ? "Objects::RepositoryRules::" : "") + type
    type_string = "[#{type_string}]" if array
  end
  field_text << "        field :#{field.name}, #{type_string},"
  description = if field.feature_flag.present? && field.beta_api
    "This field is in beta and subject to change. #{field.description_api.dump}"
  else
    field.description_api.dump
  end
  field_text << "          description: #{description},"
  # add a feature flag if a feature flag is present unless explictly published
  field_text << "          feature_flag: :#{field.feature_flag}," unless field.feature_flag.nil? || field.publish_api
  # Boolean values should never be nil for GQL
  field_text << "          null: #{type != "Boolean" && field.required == false}"
  if swap_method_name
    field_text[field_text.length - 1] = field_text[field_text.length - 1] + ","
    field_text << "          resolver_method: :#{swap_method_name}"
  end
  field_text << ""
  field_text << "        def #{swap_method_name || field.name}"
  field_text << if array
    if object
      <<-ARRAY_METHOD
          ArrayWrapper.new(@object.parameters[\"#{field.name}\"].map do |param|
            Platform::Models::RepositoryRuleParameters.new(@object.ruleset, param, platform_type: "#{type}")
          end)
      ARRAY_METHOD
    else
      "          ArrayWrapper.new(@object.parameters[\"#{field.name}\"])"
    end.chomp
  else
    value = object ? "Platform::Models::RepositoryRuleParameters.new(@object.ruleset, @object.parameters[\"#{field.name}\"], platform_type: \"#{type}\")" : "@object.parameters[\"#{field.name}\"]"
    # Ensure Boolean values are not nil
    if type == "Boolean" && !field.required
      value += " || #{field.default_value.present? ? field.default_value : "false"}"
    end
    "          #{value}"
  end
  field_text << "        end"
  field_text.join("\n") + "\n"
end

def graphql_argument_for_field(field, class_name:)
  if field.is_a?(RuleEngine::ParameterSchema::Field)
    create_graphql_argument(
      name: field.name,
      type: field.graphql_type,
      description: field.description_api,
      required: field.required,
      feature_flag: field.feature_flag,
      beta: field.beta_api,
      publish_api: field.publish_api,
      enum: is_graphql_enum?(field, class_name),
      class_name:
    )
  elsif field.is_a?(RuleEngine::ParameterSchema::Object)
    class_name = field.name.camelize + "Input"
    create_graphql_argument(
      name: field.name,
      type: class_name,
      description: field.description_api,
      required: field.required,
      feature_flag: field.feature_flag,
      beta: field.beta_api,
      publish_api: field.publish_api,
      object: true,
      class_name:
    )
  elsif field.is_a?(RuleEngine::ParameterSchema::Array)
    if field.content_type == :object
      class_name = field.content_object.name.camelize + "Input"
      create_graphql_argument(
        name: field.name,
        type: class_name,
        description: field.description_api,
        required: field.required,
        feature_flag: field.feature_flag,
        beta: field.beta_api,
        publish_api: field.publish_api,
        object: true,
        array: true,
        class_name:
      )
    else
      create_graphql_argument(
        name: field.name,
        type: field.graphql_content_type,
        description: field.description_api,
        required: field.required,
        feature_flag: field.feature_flag,
        beta: field.beta_api,
        publish_api: field.publish_api,
        array: true,
        class_name:
      )
    end
  end
end

def graphql_field_for_field(field, feature_flag: nil, class_name: nil)
  if field.is_a?(RuleEngine::ParameterSchema::Field)
    create_graphql_field(field: field, type: field.graphql_type, enum: is_graphql_enum?(field, class_name), class_name:)
  elsif field.is_a?(RuleEngine::ParameterSchema::Object)
    class_name = field.name.camelize
    subparameter_class = write_rule_class(class_name, field, field.description_api, feature_flag:)

    create_graphql_field(field: field, type: class_name, object: true, class_name:)
  elsif field.is_a?(RuleEngine::ParameterSchema::Array)
    if field.content_type == :object
      object = field.content_object
      class_name = object.name.camelize
      subparameter_class = write_rule_class(class_name, object, object.description, feature_flag:)

      create_graphql_field(field: field, type: class_name, object: true, array: true, class_name:)
    else
      create_graphql_field(field: field, type: field.graphql_content_type, array: true, class_name:)
    end
  end
end

def write_condition_union_class(generated_condition_classes_by_type)
  field_string = ""
  generated_condition_classes_by_type.each do |type, class_name|
    field_string += <<-FIELD
        field :#{type}, Objects::RepositoryRules::#{class_name},
          description: "Configuration for the #{type} condition",
          null: true

        def #{type}
          condition = @object.conditions.find_by(target: "#{type}")
          return nil unless condition
          Platform::Models::RepositoryRuleParameters.new(@object.ruleset, condition.parameters, platform_type: "#{class_name}")
        end
      FIELD
    field_string += "\n"
  end
  class_string = <<~CLASS
    # typed: true
    # frozen_string_literal: true

    # DO NOT EDIT MANUALLY
    # This is an autogenerated file of the set of rule condition targets
    # Please instead update this file by running `bin/dump-rules-schema`.

    module Platform
      module Objects
        module RepositoryRules
          class RepositoryRuleConditions < Platform::Objects::Base
            description "Set of conditions that determine if a ruleset will evaluate"
            minimum_accepted_scopes ["public_repo"]

            # Determine whether the viewer can access this object via the API (called internally).
            # This is where Egress checks for OAuth scopes and GitHub Apps go.
            # Returns `true`, `false`, or `Promise` resolving to `true` or `false`
            def self.async_api_can_access?(permission, object)
              permission.typed_can_access?("RepositoryRuleset", object.ruleset)
            end

            # Determine whether the viewer can see this object (called internally).
            # Returns `true`, `false`, or `Promise` resolving to `true` or `false`
            def self.async_viewer_can_see?(permission, object)
              permission.typed_can_see?("RepositoryRuleset", object.ruleset)
            end

    #{field_string.rstrip}
          end
        end
      end
    end
  CLASS

  write_graphql_schema_file("RepositoryRuleConditions", class_string, folder: "objects")
end

def write_conditions_union_input_class(generated_condition_classes_by_type)
  argument_string = ""
  generated_condition_classes_by_type.each do |type, class_name|
    argument_string += "        #{create_graphql_argument(name: type, type: "Inputs::RepositoryRules::#{class_name}Input", description: "Configuration for the #{type} condition", required: false)}\n"
  end
  input_data = <<~INPUT
    #{FILE_HEADER.chomp}

    module Platform
      module Inputs
        module RepositoryRules
          class RepositoryRuleConditionsInput < Platform::Inputs::Base
            description "Specifies the conditions required for a ruleset to evaluate"

    #{argument_string.chomp}
          end
        end
      end
    end
  INPUT

  write_graphql_schema_file("RepositoryRuleConditionsInput", input_data, folder: "inputs")
end

def write_rule_class(class_name, schema, description, feature_flag: nil, publish_api: nil)
  field_string = ""
  schema.fields.sort_by(&:name).each do |field|
    unless field.internal
      field_string += "#{graphql_field_for_field(field, feature_flag:, class_name:)}\n"
    end
  end
  parameter_class_string = <<~CLASS
    # typed: true
    # frozen_string_literal: true

    # DO NOT EDIT MANUALLY
    #{
      if schema.root
        "# This is an autogenerated file of the rule parameter schema for the `#{class_name.delete_suffix("Parameters")}` rule."
      else
        "# This is an autogenerated file of the rule parameter schema type `#{class_name}`."
      end
    }
    # Please instead update this file by running `bin/dump-rules-schema`.

    module Platform
      module Objects
        module RepositoryRules
          class #{class_name} < Platform::Objects::Base
            description #{description.dump}
            minimum_accepted_scopes ["public_repo"]
    #{"        feature_flag :#{feature_flag}\n" if feature_flag && !publish_api }
            # Determine whether the viewer can access this object via the API (called internally).
            # This is where Egress checks for OAuth scopes and GitHub Apps go.
            # Returns `true`, `false`, or `Promise` resolving to `true` or `false`
            def self.async_api_can_access?(permission, object)
              permission.typed_can_access?("RepositoryRuleset", object.ruleset)
            end

            # Determine whether the viewer can see this object (called internally).
            # Returns `true`, `false`, or `Promise` resolving to `true` or `false`
            def self.async_viewer_can_see?(permission, object)
              permission.typed_can_see?("RepositoryRuleset", object.ruleset)
            end

    #{field_string.rstrip}
          end
        end
      end
    end
  CLASS

  write_graphql_input_class(class_name, schema, description, feature_flag:, publish_api:)
  write_graphql_schema_file(class_name, parameter_class_string, folder: "objects")
end

def add_spaces(text, spaces)
  space = " " * spaces
  text.split("\n").map { |line| space + line }.join("\n")
end

def write_condition_class(class_name, schema, description, block_non_org_access: false)
  field_string = ""
  schema.fields.sort_by(&:name).each do |field|
    unless field.internal
      field_string += "#{graphql_field_for_field(field)}\n"
    end
  end

  can_access_string = if block_non_org_access
    <<~CAN_ACCESS
      object.ruleset.async_source.then do |source|
        if source.is_a?(::Organization)
          permission.access_allowed?(:manage_organization_ref_rules, resource: source, current_repo: nil, current_org: source, allow_integrations: true, allow_user_via_granular_actor: true)
        else
          permission.typed_can_access?("RepositoryRuleset", object.ruleset)
        end
      end
    CAN_ACCESS
  else
    <<~CAN_ACCESS
      permission.typed_can_access?("RepositoryRuleset", object.ruleset)
    CAN_ACCESS
  end
  can_access_string = add_spaces(can_access_string, 10)

  condition_class_string = <<~CLASS
    # typed: true
    # frozen_string_literal: true

    # DO NOT EDIT MANUALLY
    # This is an autogenerated file of the condition schema type `#{class_name}`."
    # Please instead update this file by running `bin/dump-rules-schema`.

    module Platform
      module Objects
        module RepositoryRules
          class #{class_name} < Platform::Objects::Base
            description #{description.dump}
            minimum_accepted_scopes ["public_repo"]

            # Determine whether the viewer can access this object via the API (called internally).
            # This is where Egress checks for OAuth scopes and GitHub Apps go.
            # Returns `true`, `false`, or `Promise` resolving to `true` or `false`
            def self.async_api_can_access?(permission, object)
    #{can_access_string}
            end

            # Determine whether the viewer can see this object (called internally).
            # Returns `true`, `false`, or `Promise` resolving to `true` or `false`
            def self.async_viewer_can_see?(permission, object)
              permission.typed_can_see?("RepositoryRuleset", object.ruleset)
            end

    #{field_string.rstrip}
          end
        end
      end
    end
  CLASS

  write_graphql_input_class(class_name, schema, description)
  write_graphql_schema_file(class_name, condition_class_string, folder: "objects")
end

def validate_base(base)
  errors = []
  unless base.root
    errors << "Name empty" if base.name.empty?
    errors << "Description empty for #{base.name}" if base.description.empty?
  end
  errors
end

def validate_field(field)
  errors = validate_base(field)

  errors << "Unknwon type #{field.type} for #{field.name}" unless RuleEngine::ParameterSchema::Field::CLASS_TYPES.has_key?(field.type)
  errors
end

def validate_object(object)
  errors = validate_base(object)

  object.fields.group_by(&:name).each do |name, fields|
    errors << "Duplicate field #{name}" if fields.size > 1
  end

  object.fields.each do |field|
    field_errors = validate_generic(field)
    if field_errors.any?
      errors << "Invalid field #{field.name}: "
      field_errors.each do |error|
        errors << "  #{error}"
      end
    end
  end

  errors
end

def validate_array(array)
  errors = validate_base(array)

  if array.content_type == :object
    content_errors = validate_object(array.content_object)
    if content_errors.any?
      errors << "Invalid contents for #{array.name}: "
      content_errors.each do |error|
        errors << "  #{error}"
      end
    end
  else
    errors << "Unknown type #{array.content_type} for array #{array.name}" unless RuleEngine::ParameterSchema::Field::CLASS_TYPES.has_key?(array.content_type)
  end

  errors
end

def validate_generic(schema_obj)
  if schema_obj.is_a?(RuleEngine::ParameterSchema::Array)
    validate_array(schema_obj)
  elsif schema_obj.is_a?(RuleEngine::ParameterSchema::Object)
    validate_object(schema_obj)
  elsif schema_obj.is_a?(RuleEngine::ParameterSchema::Field)
    validate_field(schema_obj)
  end
end

def validate_schema
  puts "Validating parameter schemas" unless @options[:dry]
  success = T.let(true, T::Boolean)
  RuleEngine::Evaluator::REGISTERED_RULES.each do |rule_type, impl|
    schema = impl.try(:parameter_schema)
    if schema && !schema.empty?
      validation_errors = validate_object(schema)
      if validation_errors.any?
        if @options[:dry]
          validation_errors.each { |error| @dry_run[:errors][rule_type.to_sym] << error }
          puts @dry_run.to_json
        else
          puts "Validation error for #{rule_type} parameter schema"
          validation_errors.each { |error| puts error }
        end
        success = false
      end
    end
  end
  success
end

def generate_graphql_schema
  puts "Generating GraphQL objects" unless @options[:dry]
  generated_classes_by_type = {}
  generated_classes_with_feature_flags = {}

  configurable_types.each do |rule_type, impl|
    schema = impl.try(:parameter_schema)
    if schema && schema.has_visible_fields?
      name = rule_type.camelize + "Parameters"

      description = impl.description || "Parameters to be used for the #{rule_type} rule"
      description += " NOTE: This rule is in beta and subject to change" if impl.beta_api
      class_string = write_rule_class(name, schema, description, feature_flag: impl.feature_flag, publish_api: impl.publish_api)
      generated_classes_by_type[rule_type] = name
      # If we are publishing the API early, we can ignore the feature flag
      generated_classes_with_feature_flags[rule_type] = impl.feature_flag if impl.feature_flag && !impl.publish_api
    end
  end

  generated_condition_classes_by_type = {}
  RepositoryRuleCondition::TARGET_TYPES.each do |target_type, impl|
    schema = impl.try(:parameter_schema)
    if !impl.internal? && schema && !schema.empty?
      name = target_type.camelize + "ConditionTarget"

      class_string = write_condition_class(name, schema, "Parameters to be used for the #{target_type} condition",
        block_non_org_access: !impl.supported_sources.include?(:repository))
      generated_condition_classes_by_type[target_type] = name
    end
  end

  # Rules
  write_union_file("RuleParameters", "Types which can be parameters for `RepositoryRule` objects.", generated_classes_by_type.values)
  write_input_union_file("RuleParametersInput", "Specifies the parameters for a `RepositoryRule` object.", generated_classes_by_type, generated_classes_with_feature_flags)
  write_enum_file("RepositoryRuleType", "The rule types supported in rulesets", RuleEngine::Evaluator::REGISTERED_RULES)

  write_model_union_file("RepositoryRuleParameters", generated_classes_by_type)

  # Conditions
  write_condition_union_class(generated_condition_classes_by_type)
  write_conditions_union_input_class(generated_condition_classes_by_type)
end

def write_openapi_schema_file(class_name, class_string, prefix: nil, suffix: nil)
  file_name = "#{prefix}#{class_name.underscore.dasherize}#{suffix}.yaml"
  file_path = "app/api/description/components/schemas/#{file_name}"
  write_file(file_path, class_string, file_type: :openapi)
  file_name
end

# Filter the given rules to only include those that are supported by the given GHES version.
sig { params(rules: T::Hash[Symbol, T.untyped], version: String).returns(T::Hash[Symbol, T.untyped]) }
def filter_for_ghes(rules, version)
  rules.select do |_, rule_hash|
    VersionSorter.compare(version, rule_hash[:impl]&.minimum_ghes_version) >= 0
  end
end

# Build a version requirement string given the lower and upper bounds.
# This only handles bounds with the same major version.
sig { params(lower_version: String, excluded_upper_version: String).returns(String) }
def versions_requirements_string(lower_version, excluded_upper_version)
  lower = T.must(Gem::Version.create(lower_version))
  upper = T.must(Gem::Version.create(excluded_upper_version))
  raise "Script cannot handle versions that are not of the form major.minor" if lower.segments.size != 2 || upper.segments.size != 2
  raise "Script cannot handle major version increase" if lower.segments[0] != upper.segments[0]

  # This cast is necessary because Sorbet currently falsely thinks lower.segments is an array of strings.
  segments = T.cast(lower.segments, T::Array[Integer])

  s = lower_version
  segments[1] = segments.fetch(1) + 1
  v = segments.join(".")

  while VersionSorter.compare(v, excluded_upper_version) < 0 do
    s += " || #{v}"
    segments[1] = segments.fetch(1) + 1
    v = segments.join(".")
  end
  s
end

# Extracts the minimum GHES versions from all the rules and returns them sorted in descending order.
sig { params(rules: T::Hash[Symbol, T.untyped]).returns(T::Array[String]) }
def sorted_ghes_versions(rules)
  versions = rules.map { |_, rule_hash| rule_hash[:impl]&.minimum_ghes_version }.uniq
  VersionSorter.rsort!(versions)
end

# Generates the YAML string for the given rules and generator.
# The generator will be called once with all rules and then for each ghes version range
# that needs its own overlay with just the rules present in that version range.
sig { params(rules: T::Hash[Symbol, T.untyped], generator: T.proc.params(rules: T::Hash[Symbol, T.untyped]).returns(String)).returns(String) }
def generate_with_ghes_overlays(rules, &generator)
  # Generate general version first
  s = generator.call(rules)

  # Rules that are published require a minimum ghes version
  ghes_rules = rules.select { |_, rule_hash| rule_hash[:impl]&.publish_api }

  # Raise if any of the ghes rules do no provide version information
  ghes_rules.each do |rule, rule_hash|
    raise "Non-feature-flagged rule '#{rule}' does not provide ghes version information. Override minimum_ghes_version in the rule implementation to do so." if rule_hash[:impl]&.minimum_ghes_version.nil?
  end

  # Now generate GHES overlays
  ghes_versions = sorted_ghes_versions(ghes_rules)

  # Return early if there is only a single version, meaning we do not need overlays.
  return s if ghes_versions.size <= 1

  s += "x-githubEnterpriseOverlays:\n"

  # Note: We do not need to add an overlay for the greatest version that had a change
  # (i.e. " >= #{ghes_versions[0]}") since it is no different to the dotcom one.

  # Add overlays for all the versions that need both upper and lower bounds
  ghes_versions.drop(1).zip(T.must(ghes_versions[0..-1])) do |lower, upper|
    s += "  \"#{versions_requirements_string(lower, T.must(upper))}\":\n"
    s += add_spaces(generator.call(filter_for_ghes(ghes_rules, lower)), 4)
    s += "\n"
  end

  s
end

sig { params(all_rules: T::Hash[Symbol, T.untyped]).void }
def write_repository_rule_file(all_rules)
  initial_string = <<-REPO_RULE
---
# DO NOT EDIT MANUALLY
# This is an autogenerated file of the supported rule parameter schemas
# Please instead update this file by running `bin/dump-rules-schema`.

title: Repository Rule
type: object
REPO_RULE

  repository_rule_string = "#{initial_string}description: A repository rule.\n"
  repository_rule_string += generate_with_ghes_overlays(all_rules) do |rules|
    list_string = "oneOf:\n"
    list_string += rules.map { |_, rule_hash|
      rule_hash[:impl]&.feature_flag ? "  - #{rule_hash[:rule].chop.gsub("\n", "\n    ")}" : "  - $ref: './#{rule_hash[:rule]}'"
    }.join("\n") + "\n"

    list_string
  end

  # Write changes to file
  write_file("app/api/description/components/schemas/repository-rule.yaml", repository_rule_string, file_type: :openapi)

  repository_rule_response_string = "#{initial_string}description: A repository rule with ruleset details.\n"

  # We're skipping feature flagged rules since this schema is only used on get-branch-rules, which is a GET request, and wouldn't be published anyway
  published_rules = all_rules.filter { |_, rule_hash| rule_hash[:impl]&.feature_flag.nil? }
  repository_rule_response_string += generate_with_ghes_overlays(published_rules) do |rules|
    s = "oneOf:\n"
    rules.each do |_, rule_hash|
      s += <<-SPEC
  - allOf:
    - $ref: './#{rule_hash[:rule]}'
    - $ref: './repository-rule-ruleset-info.yaml'
SPEC
    end
    s
  end

  File.write("app/api/description/components/schemas/repository-rule-detailed.yaml", repository_rule_response_string)
end

sig do
  params(
    name: String,
    schema: RuleEngine::ParameterSchema::Object,
    description: String,
    impl: RuleEngine::BaseRule
  ).returns(String)
end
def generate_openapi_component(name, schema, description, impl)
  required = []
  fields = schema.fields.reject { |field| field.internal }

  # When a rule is feature flagged
  # instead we will directly insert the schema
  # Otherwise, we could be referencing an unpublished schema, which violates openapi rules
  # See https://github.com/github/github/pull/306923#issuecomment-1900461179
  spec = if impl.feature_flag.present?
    ""
  else
    <<-SPEC
---
# DO NOT EDIT MANUALLY
# This is an autogenerated file of the supported rule parameter schemas
# Please instead update this file by running `bin/dump-rules-schema`.

SPEC
  end

  spec += "title: #{name}\n"

  # If feature flagged and in beta, mention that rule may change
  spec += if impl.feature_flag.present? || impl.beta_api
    <<-DESC
description: |-
  > [!NOTE]
  > `#{name}` is in beta and subject to change.

  #{description}
    DESC
  else
    "description: #{description}\n"
  end

  spec += "type: object\n"

  spec += "x-unpublished: Unpublished until the rule is in public beta or GA\n" unless impl.publish_api
  spec += <<-SPEC
required:
  - type
properties:
  type:
    type: string
    enum:
      - #{name}
SPEC
  if fields.present?
    spec += <<-SPEC
  parameters:
    type: object
    properties:\n
SPEC
  else
    spec += "\n"
  end
  spec.chomp!
  fields.sort_by(&:name).each do |field|
    # We can't require a feature flagged rule since we don't publish it
    # Once the feature flag is removed, we can require it
    required << field.name if field.required && field.feature_flag.nil?
    spec += "#{openapi_property_for_field(field)}"
  end

  spec += "    required:\n" if required.size > 0
  required.each do |property|
    spec += "      - #{property}\n"
  end
  spec
end

def generate_openapi_subtype_component(name, schema, description)
  required = []
  fields = schema.fields.reject { |field| field.internal }
  spec = <<-SPEC
---
# DO NOT EDIT MANUALLY
# This is an autogenerated file of the supported rule parameter schemas
# Please instead update this file by running `bin/dump-rules-schema`.

title: #{name}
description: #{description}
type: object
properties:

SPEC
  spec.chomp!
  fields.sort_by(&:name).each do |field|
    # We can't require a feature flagged rule since we don't publish it
    # Once the feature flag is removed, we can require it
    required << field.name if field.required && field.feature_flag.nil?
    spec += "#{openapi_property_for_field(field, leading_space: 2)}"
  end

  spec += "required:\n" if required.size > 0
  required.each do |property|
    spec += "- #{property}\n"
  end
  spec
end

def generate_openapi_rule_response(name, file_name, description)
  <<-SPEC
---
# DO NOT EDIT MANUALLY
# This is an autogenerated file of the supported rule parameter schemas
# Please instead update this file by running `bin/dump-rules-schema`.

title: #{name}
description: #{description}
type: object
properties:
  allOf:
    - $ref: './#{file_name}'
    - $ref: './repository-rule-ruleset-info.yaml
SPEC
end

def openapi_property_for_field(field, leading_space: 6)
  prefix = "repository-rule-params-"
  case field
  when RuleEngine::ParameterSchema::Field
    create_openapi_property(field, field.type, leading_space:)
  when RuleEngine::ParameterSchema::Array
    if field.content_type == :object
      object = field.content_object
      class_name = object.name.camelize
      subparameter_string = generate_openapi_subtype_component(class_name, object, object.description)
      write_openapi_schema_file(class_name, subparameter_string, prefix: prefix) if subparameter_string
    end
    create_openapi_property(field, "array", is_array: true, is_object: field.content_type == :object, prefix: prefix, leading_space:)
  when RuleEngine::ParameterSchema::Object
    class_name = field.name.camelize
    subparameter_string = generate_openapi_subtype_component(class_name, field, field.description_api)
    write_openapi_schema_file(class_name, subparameter_string, prefix: prefix) if subparameter_string
    create_openapi_property(field, "object", is_object: true, prefix: prefix, leading_space:)
  end
end

def create_openapi_property(field, type, is_array: false, is_object: false, prefix: nil, leading_space: 6)
  spacing = " " * leading_space
  property = "#{spacing}#{field.name}:\n"

  property += "#{spacing}  x-unpublished: Unpublished until `#{field.name}` is in public beta or GA\n" unless field.publish_api
  if is_object && !is_array
    property += "#{spacing}  $ref: './#{prefix}#{field.name.underscore.dasherize}.yaml'\n"
    return property
  end
  property += "#{spacing}  type: #{type}\n"
  # If field is in beta, then make note
  description = if field.feature_flag.present? && field.beta_api
    <<-DESC
#{spacing}  description: |-
#{spacing}    > [!NOTE]
#{spacing}    > `#{field.name}` is in beta and subject to change.
#{spacing}
#{spacing}    #{field.description_api}
    DESC
  else
    "#{spacing}  description: #{field.description_api}\n"
  end


  property += "#{description}"
  if field.try(:allowed_range)
    property += "#{spacing}  minimum: #{field.allowed_range.begin ? field.allowed_range.min : field.default_value}\n"
    property += "#{spacing}  maximum: #{field.allowed_range.end ? field.allowed_range.max : field.default_value + 1}\n"
  end

  if is_array
    property += "#{spacing}  items:\n"
    property += "#{spacing}    #{is_object ? "$ref: './#{prefix}#{field.content_object.name.underscore.dasherize}.yaml'" : "type: #{field.content_type}"}\n"
  elsif field.try(:allowed_values)
    property += "#{spacing}  enum:\n"
    field.allowed_values.each { |value| property += "#{spacing}    - #{value}\n" }
  end

  property
end

def generate_openapi_spec
  puts "Generating openapi component" unless @options[:dry]
  rules = Hash.new { |h, k| h[k] = { rule: nil, impl: nil } }
  configurable_types.each do |rule_type, impl|
    # Some rules don't have any configurations, so their schemas are empty
    schema = impl.try(:parameter_schema) || RuleEngine::ParameterSchema::Object.empty_schema
    name = rule_type.underscore
    # currently, write out each policy/rule as a component to be used for input/output
    description = impl.description || "Parameters to be used for the #{name} rule"
    schema_string = generate_openapi_component(name, schema, description, impl)
    if schema_string
      # Directly use schema string if rule is feature flagged, otherwise, write to file
      rules[name][:rule] = impl.feature_flag ? schema_string : write_openapi_schema_file(name, schema_string, prefix: "repository-rule-")
      rules[name][:impl] = impl
    end
  end
  write_repository_rule_file(rules)
end

sig { returns(T::Hash[String, RuleEngine::BaseRule]) }
def configurable_types
  @configurable_types ||= RuleEngine::Evaluator::REGISTERED_RULES.select { |_rule_type, impl| impl.is_user_configurable? || impl.publish_api }
end

## === Run ===

@options = T.let({}, T::Hash[Symbol, T.any(String, T::Boolean)])
OptionParser.new do |opts|
  opts.banner = "Usage: dump-rules-schema [options]"

  opts.on("-d", "--dry-run", FalseClass, "Run without changing files. Output what would have happened") do
    @options[:dry] = true
  end

  opts.on("-h", "--help", "Prints this help") do
    puts opts
    exit
  end

end.parse!

exit 1 unless validate_schema

generate_openapi_spec
unless @options[:dry]
  if @openapi_changed
    puts "REST OpenAPI spec changed! Be sure to version and unpublish the docs as needed."\
    " See https://thehub.github.com/epd/engineering/products-and-services/public-apis/rest/openapi/versioning/"\
    " and https://thehub.github.com/epd/engineering/products-and-services/public-apis/rest/openapi/publishing/"\
    " for more info"
  else
    puts "No REST OpenAPI changes"
  end
end

generate_graphql_schema
unless @options[:dry]
  if @graphql_changed
    puts "GraphQL objects changed! Run `bin/dump-graphql-schema` to regenerate GraphQL schema files"
  else
    puts "No GRAPHQL changes"
  end
end

puts @dry_run.to_json if @options[:dry]
