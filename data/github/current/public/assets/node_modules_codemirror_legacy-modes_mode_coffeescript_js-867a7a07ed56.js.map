{"version":3,"file":"chunk-node_modules_codemirror_legacy-modes_mode_coffeescript_js-xxxxxxxxxxxx.js","mappings":"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","sources":["node_modules/@codemirror/legacy-modes/mode/coffeescript.js"],"sourcesContent":["var ERRORCLASS = \"error\";\n\nfunction wordRegexp(words) {\n  return new RegExp(\"^((\" + words.join(\")|(\") + \"))\\\\b\");\n}\n\nvar operators = /^(?:->|=>|\\+[+=]?|-[\\-=]?|\\*[\\*=]?|\\/[\\/=]?|[=!]=|<[><]?=?|>>?=?|%=?|&=?|\\|=?|\\^=?|\\~|!|\\?|(or|and|\\|\\||&&|\\?)=)/;\nvar delimiters = /^(?:[()\\[\\]{},:`=;]|\\.\\.?\\.?)/;\nvar identifiers = /^[_A-Za-z$][_A-Za-z$0-9]*/;\nvar atProp = /^@[_A-Za-z$][_A-Za-z$0-9]*/;\n\nvar wordOperators = wordRegexp([\"and\", \"or\", \"not\",\n                                \"is\", \"isnt\", \"in\",\n                                \"instanceof\", \"typeof\"]);\nvar indentKeywords = [\"for\", \"while\", \"loop\", \"if\", \"unless\", \"else\",\n                      \"switch\", \"try\", \"catch\", \"finally\", \"class\"];\nvar commonKeywords = [\"break\", \"by\", \"continue\", \"debugger\", \"delete\",\n                      \"do\", \"in\", \"of\", \"new\", \"return\", \"then\",\n                      \"this\", \"@\", \"throw\", \"when\", \"until\", \"extends\"];\n\nvar keywords = wordRegexp(indentKeywords.concat(commonKeywords));\n\nindentKeywords = wordRegexp(indentKeywords);\n\n\nvar stringPrefixes = /^('{3}|\\\"{3}|['\\\"])/;\nvar regexPrefixes = /^(\\/{3}|\\/)/;\nvar commonConstants = [\"Infinity\", \"NaN\", \"undefined\", \"null\", \"true\", \"false\", \"on\", \"off\", \"yes\", \"no\"];\nvar constants = wordRegexp(commonConstants);\n\n// Tokenizers\nfunction tokenBase(stream, state) {\n  // Handle scope changes\n  if (stream.sol()) {\n    if (state.scope.align === null) state.scope.align = false;\n    var scopeOffset = state.scope.offset;\n    if (stream.eatSpace()) {\n      var lineOffset = stream.indentation();\n      if (lineOffset > scopeOffset && state.scope.type == \"coffee\") {\n        return \"indent\";\n      } else if (lineOffset < scopeOffset) {\n        return \"dedent\";\n      }\n      return null;\n    } else {\n      if (scopeOffset > 0) {\n        dedent(stream, state);\n      }\n    }\n  }\n  if (stream.eatSpace()) {\n    return null;\n  }\n\n  var ch = stream.peek();\n\n  // Handle docco title comment (single line)\n  if (stream.match(\"####\")) {\n    stream.skipToEnd();\n    return \"comment\";\n  }\n\n  // Handle multi line comments\n  if (stream.match(\"###\")) {\n    state.tokenize = longComment;\n    return state.tokenize(stream, state);\n  }\n\n  // Single line comment\n  if (ch === \"#\") {\n    stream.skipToEnd();\n    return \"comment\";\n  }\n\n  // Handle number literals\n  if (stream.match(/^-?[0-9\\.]/, false)) {\n    var floatLiteral = false;\n    // Floats\n    if (stream.match(/^-?\\d*\\.\\d+(e[\\+\\-]?\\d+)?/i)) {\n      floatLiteral = true;\n    }\n    if (stream.match(/^-?\\d+\\.\\d*/)) {\n      floatLiteral = true;\n    }\n    if (stream.match(/^-?\\.\\d+/)) {\n      floatLiteral = true;\n    }\n\n    if (floatLiteral) {\n      // prevent from getting extra . on 1..\n      if (stream.peek() == \".\"){\n        stream.backUp(1);\n      }\n      return \"number\";\n    }\n    // Integers\n    var intLiteral = false;\n    // Hex\n    if (stream.match(/^-?0x[0-9a-f]+/i)) {\n      intLiteral = true;\n    }\n    // Decimal\n    if (stream.match(/^-?[1-9]\\d*(e[\\+\\-]?\\d+)?/)) {\n      intLiteral = true;\n    }\n    // Zero by itself with no other piece of number.\n    if (stream.match(/^-?0(?![\\dx])/i)) {\n      intLiteral = true;\n    }\n    if (intLiteral) {\n      return \"number\";\n    }\n  }\n\n  // Handle strings\n  if (stream.match(stringPrefixes)) {\n    state.tokenize = tokenFactory(stream.current(), false, \"string\");\n    return state.tokenize(stream, state);\n  }\n  // Handle regex literals\n  if (stream.match(regexPrefixes)) {\n    if (stream.current() != \"/\" || stream.match(/^.*\\//, false)) { // prevent highlight of division\n      state.tokenize = tokenFactory(stream.current(), true, \"string.special\");\n      return state.tokenize(stream, state);\n    } else {\n      stream.backUp(1);\n    }\n  }\n\n\n\n  // Handle operators and delimiters\n  if (stream.match(operators) || stream.match(wordOperators)) {\n    return \"operator\";\n  }\n  if (stream.match(delimiters)) {\n    return \"punctuation\";\n  }\n\n  if (stream.match(constants)) {\n    return \"atom\";\n  }\n\n  if (stream.match(atProp) || state.prop && stream.match(identifiers)) {\n    return \"property\";\n  }\n\n  if (stream.match(keywords)) {\n    return \"keyword\";\n  }\n\n  if (stream.match(identifiers)) {\n    return \"variable\";\n  }\n\n  // Handle non-detected items\n  stream.next();\n  return ERRORCLASS;\n}\n\nfunction tokenFactory(delimiter, singleline, outclass) {\n  return function(stream, state) {\n    while (!stream.eol()) {\n      stream.eatWhile(/[^'\"\\/\\\\]/);\n      if (stream.eat(\"\\\\\")) {\n        stream.next();\n        if (singleline && stream.eol()) {\n          return outclass;\n        }\n      } else if (stream.match(delimiter)) {\n        state.tokenize = tokenBase;\n        return outclass;\n      } else {\n        stream.eat(/['\"\\/]/);\n      }\n    }\n    if (singleline) {\n      state.tokenize = tokenBase;\n    }\n    return outclass;\n  };\n}\n\nfunction longComment(stream, state) {\n  while (!stream.eol()) {\n    stream.eatWhile(/[^#]/);\n    if (stream.match(\"###\")) {\n      state.tokenize = tokenBase;\n      break;\n    }\n    stream.eatWhile(\"#\");\n  }\n  return \"comment\";\n}\n\nfunction indent(stream, state, type = \"coffee\") {\n  var offset = 0, align = false, alignOffset = null;\n  for (var scope = state.scope; scope; scope = scope.prev) {\n    if (scope.type === \"coffee\" || scope.type == \"}\") {\n      offset = scope.offset + stream.indentUnit;\n      break;\n    }\n  }\n  if (type !== \"coffee\") {\n    align = null;\n    alignOffset = stream.column() + stream.current().length;\n  } else if (state.scope.align) {\n    state.scope.align = false;\n  }\n  state.scope = {\n    offset: offset,\n    type: type,\n    prev: state.scope,\n    align: align,\n    alignOffset: alignOffset\n  };\n}\n\nfunction dedent(stream, state) {\n  if (!state.scope.prev) return;\n  if (state.scope.type === \"coffee\") {\n    var _indent = stream.indentation();\n    var matched = false;\n    for (var scope = state.scope; scope; scope = scope.prev) {\n      if (_indent === scope.offset) {\n        matched = true;\n        break;\n      }\n    }\n    if (!matched) {\n      return true;\n    }\n    while (state.scope.prev && state.scope.offset !== _indent) {\n      state.scope = state.scope.prev;\n    }\n    return false;\n  } else {\n    state.scope = state.scope.prev;\n    return false;\n  }\n}\n\nfunction tokenLexer(stream, state) {\n  var style = state.tokenize(stream, state);\n  var current = stream.current();\n\n  // Handle scope changes.\n  if (current === \"return\") {\n    state.dedent = true;\n  }\n  if (((current === \"->\" || current === \"=>\") && stream.eol())\n      || style === \"indent\") {\n    indent(stream, state);\n  }\n  var delimiter_index = \"[({\".indexOf(current);\n  if (delimiter_index !== -1) {\n    indent(stream, state, \"])}\".slice(delimiter_index, delimiter_index+1));\n  }\n  if (indentKeywords.exec(current)){\n    indent(stream, state);\n  }\n  if (current == \"then\"){\n    dedent(stream, state);\n  }\n\n\n  if (style === \"dedent\") {\n    if (dedent(stream, state)) {\n      return ERRORCLASS;\n    }\n  }\n  delimiter_index = \"])}\".indexOf(current);\n  if (delimiter_index !== -1) {\n    while (state.scope.type == \"coffee\" && state.scope.prev)\n      state.scope = state.scope.prev;\n    if (state.scope.type == current)\n      state.scope = state.scope.prev;\n  }\n  if (state.dedent && stream.eol()) {\n    if (state.scope.type == \"coffee\" && state.scope.prev)\n      state.scope = state.scope.prev;\n    state.dedent = false;\n  }\n\n  return style == \"indent\" || style == \"dedent\" ? null : style;\n}\n\nexport const coffeeScript = {\n  name: \"coffeescript\",\n  startState: function() {\n    return {\n      tokenize: tokenBase,\n      scope: {offset: 0, type:\"coffee\", prev: null, align: false},\n      prop: false,\n      dedent: 0\n    };\n  },\n\n  token: function(stream, state) {\n    var fillAlign = state.scope.align === null && state.scope;\n    if (fillAlign && stream.sol()) fillAlign.align = false;\n\n    var style = tokenLexer(stream, state);\n    if (style && style != \"comment\") {\n      if (fillAlign) fillAlign.align = true;\n      state.prop = style == \"punctuation\" && stream.current() == \".\"\n    }\n\n    return style;\n  },\n\n  indent: function(state, text) {\n    if (state.tokenize != tokenBase) return 0;\n    var scope = state.scope;\n    var closer = text && \"])}\".indexOf(text.charAt(0)) > -1;\n    if (closer) while (scope.type == \"coffee\" && scope.prev) scope = scope.prev;\n    var closes = closer && scope.type === text.charAt(0);\n    if (scope.align)\n      return scope.alignOffset - (closes ? 1 : 0);\n    else\n      return (closes ? scope.prev : scope).offset;\n  },\n\n  languageData: {\n    commentTokens: {line: \"#\"}\n  }\n};\n"],"names":["ERRORCLASS","wordRegexp","words","join","operators","delimiters","identifiers","atProp","wordOperators","indentKeywords","keywords","concat","stringPrefixes","regexPrefixes","constants","tokenBase","stream","state","sol","scope","align","scopeOffset","offset","eatSpace","lineOffset","indentation","type","dedent","ch","peek","match","skipToEnd","tokenize","longComment","floatLiteral","backUp","intLiteral","tokenFactory","current","prop","next","delimiter","singleline","outclass","eol","eatWhile","eat","indent","alignOffset","prev","indentUnit","column","length","_indent","matched","coffeeScript","name","startState","token","fillAlign","style","tokenLexer","delimiter_index","indexOf","slice","exec","text","closer","charAt","closes","languageData","commentTokens","line"],"sourceRoot":""}