# typed: true

# DO NOT EDIT MANUALLY
# This is an autogenerated file for types exported from the `prose_diff` gem.
# Please instead update this file by running `bin/tapioca gem prose_diff`.

# first, helpers neeced by the transformers
#
# source://prose_diff//lib/prose_diff/options.rb#1
module ProseDiff
  private

  # source://prose_diff//lib/prose_diff/version.rb#3
  def gem_name; end

  # source://prose_diff//lib/prose_diff/html.rb#3
  def html(before_html, after_html, options = T.unsafe(nil)); end

  # source://prose_diff//lib/prose_diff/version.rb#11
  def output_version(cache = T.unsafe(nil)); end

  # source://prose_diff//lib/prose_diff/version.rb#7
  def semantic_version; end

  class << self
    # source://prose_diff//lib/prose_diff/version.rb#3
    def gem_name; end

    # source://prose_diff//lib/prose_diff/html.rb#3
    def html(before_html, after_html, options = T.unsafe(nil)); end

    # source://prose_diff//lib/prose_diff/version.rb#11
    def output_version(cache = T.unsafe(nil)); end

    # source://prose_diff//lib/prose_diff/version.rb#7
    def semantic_version; end
  end
end

# source://prose_diff//lib/prose_diff/diff.rb#3
class ProseDiff::Diff
  # @return [Diff] a new instance of Diff
  #
  # source://prose_diff//lib/prose_diff/diff.rb#7
  def initialize(before, after, options = T.unsafe(nil)); end

  # source://prose_diff//lib/prose_diff/diff.rb#83
  def document; end

  # source://prose_diff//lib/prose_diff/diff.rb#89
  def flattened(nodeset); end

  # source://prose_diff//lib/prose_diff/diff.rb#75
  def node_set; end

  # source://prose_diff//lib/prose_diff/diff.rb#198
  def strip_wrapped_text(nodeset); end

  # source://prose_diff//lib/prose_diff/diff.rb#187
  def wrap_text(node); end

  class << self
    # source://prose_diff//lib/prose_diff/diff.rb#163
    def diff_node(after, before, options); end

    # source://prose_diff//lib/prose_diff/diff.rb#110
    def diff_node_set(after_node_sets, before_node_sets, options); end
  end
end

# source://prose_diff//lib/prose_diff/diff.rb#5
ProseDiff::Diff::NAMES = T.let(T.unsafe(nil), Array)

# source://prose_diff//lib/prose_diff/lcs.rb#6
class ProseDiff::LCS
  # @return [LCS] a new instance of LCS
  #
  # source://prose_diff//lib/prose_diff/lcs.rb#10
  def initialize(a, b, options = T.unsafe(nil), &comparator); end

  # source://prose_diff//lib/prose_diff/lcs.rb#46
  def backstep; end

  # source://prose_diff//lib/prose_diff/lcs.rb#41
  def backtrack; end

  # source://prose_diff//lib/prose_diff/lcs.rb#52
  def compute_backstep; end

  # source://prose_diff//lib/prose_diff/lcs.rb#37
  def compute_entry(c, d); end

  # source://prose_diff//lib/prose_diff/lcs.rb#29
  def lookup(x, y); end

  # source://prose_diff//lib/prose_diff/lcs.rb#27
  def match(c, d); end

  # source://prose_diff//lib/prose_diff/lcs.rb#32
  def peek(x, y); end

  # source://prose_diff//lib/prose_diff/lcs.rb#28
  def pos(i, j); end

  # source://prose_diff//lib/prose_diff/lcs.rb#30
  def pos_lower_right; end

  # @return [Boolean]
  #
  # source://prose_diff//lib/prose_diff/lcs.rb#26
  def valid?(i = T.unsafe(nil), j = T.unsafe(nil)); end

  class << self
    # &block
    #
    # source://prose_diff//lib/prose_diff/lcs.rb#86
    def fold_diff(comparator, a, b, acc); end

    # source://prose_diff//lib/prose_diff/lcs.rb#81
    def length(a, b, options = T.unsafe(nil), &comparator); end

    # source://prose_diff//lib/prose_diff/lcs.rb#129
    def pair(a, b, comparator = T.unsafe(nil)); end

    # source://prose_diff//lib/prose_diff/lcs.rb#60
    def smallest_contiguous_change(a, b); end
  end
end

# source://prose_diff//lib/prose_diff/lcs.rb#8
ProseDiff::LCS::DIAG = T.let(T.unsafe(nil), Array)

# source://prose_diff//lib/prose_diff/lcs.rb#8
ProseDiff::LCS::LEFT = T.let(T.unsafe(nil), Array)

# source://prose_diff//lib/prose_diff/lcs.rb#8
ProseDiff::LCS::SELF = T.let(T.unsafe(nil), Array)

# source://prose_diff//lib/prose_diff/lcs.rb#8
ProseDiff::LCS::UP = T.let(T.unsafe(nil), Array)

# source://prose_diff//lib/prose_diff/node/proxy/base_behaviour.rb#4
class ProseDiff::Node
  class << self
    # source://prose_diff//lib/prose_diff/node/node.rb#69
    def Document(value = T.unsafe(nil)); end

    # source://prose_diff//lib/prose_diff/node/node.rb#122
    def HTML(text, query = T.unsafe(nil)); end

    # source://prose_diff//lib/prose_diff/node/node.rb#115
    def LINE(html, doc = T.unsafe(nil)); end

    # source://prose_diff//lib/prose_diff/node/node.rb#51
    def NodeSet(value); end

    # source://prose_diff//lib/prose_diff/node/node.rb#84
    def PARENT(node_or_text_or_string, doc = T.unsafe(nil)); end

    # an undistinguished span
    #
    # source://prose_diff//lib/prose_diff/node/node.rb#77
    def SPAN(text, doc = T.unsafe(nil)); end

    # source://prose_diff//lib/prose_diff/node/node.rb#101
    def TEXT(something, doc = T.unsafe(nil)); end

    # source://prose_diff//lib/prose_diff/node/node.rb#108
    def WHITESPACE(text, doc = T.unsafe(nil)); end

    # source://prose_diff//lib/prose_diff/node/node.rb#94
    def WORD(text, doc = T.unsafe(nil)); end

    # source://prose_diff//lib/prose_diff/node/node.rb#186
    def add_class(*args, &block); end

    # source://prose_diff//lib/prose_diff/node/node.rb#186
    def analysis(*args, &block); end

    # source://prose_diff//lib/prose_diff/node/node.rb#186
    def appear_to_correspond(*args, &block); end

    # source://prose_diff//lib/prose_diff/node/node.rb#186
    def appear_to_correspond?(*args, &block); end

    # source://prose_diff//lib/prose_diff/node/node.rb#186
    def are_comparable_lists?(*args, &block); end

    # source://prose_diff//lib/prose_diff/node/node.rb#186
    def are_comparable_lists_of_nodes?(*args, &block); end

    # @return [Boolean]
    #
    # source://prose_diff//lib/prose_diff/node/node.rb#126
    def are_identical?(node, other_node); end

    # source://prose_diff//lib/prose_diff/node/node.rb#186
    def at(*args, &block); end

    # source://prose_diff//lib/prose_diff/node/node.rb#186
    def becomes_added(*args, &block); end

    # source://prose_diff//lib/prose_diff/node/node.rb#186
    def becomes_changed(*args, &block); end

    # source://prose_diff//lib/prose_diff/node/node.rb#186
    def becomes_moved(*args, &block); end

    # source://prose_diff//lib/prose_diff/node/node.rb#186
    def becomes_removed(*args, &block); end

    # source://prose_diff//lib/prose_diff/node/node.rb#186
    def becomes_unchanged(*args, &block); end

    # source://prose_diff//lib/prose_diff/node/node.rb#186
    def before(*args, &block); end

    # source://prose_diff//lib/prose_diff/node/node.rb#186
    def before_natural_attr_keys(*args, &block); end

    # source://prose_diff//lib/prose_diff/node/node.rb#186
    def before_text(*args, &block); end

    # source://prose_diff//lib/prose_diff/node/node.rb#186
    def children_of(*args, &block); end

    # source://prose_diff//lib/prose_diff/node/node.rb#186
    def classify_before(*args, &block); end

    # source://prose_diff//lib/prose_diff/node/node.rb#185
    def define_method_that_delegates(method_name); end

    # source://prose_diff//lib/prose_diff/node/node.rb#186
    def diff_attributes(*args, &block); end

    # source://prose_diff//lib/prose_diff/node/node.rb#186
    def diff_children(*args, &block); end

    # source://prose_diff//lib/prose_diff/node/node.rb#186
    def diff_with_before(*args, &block); end

    # source://prose_diff//lib/prose_diff/node/node.rb#186
    def digest(*args, &block); end

    # source://prose_diff//lib/prose_diff/node/node.rb#222
    def digested(node); end

    # source://prose_diff//lib/prose_diff/node/node.rb#186
    def digests(*args, &block); end

    # source://prose_diff//lib/prose_diff/node/node.rb#186
    def doesnt_have_natural_keys?(*args, &block); end

    # source://prose_diff//lib/prose_diff/node/node.rb#186
    def doppelganger(*args, &block); end

    # source://prose_diff//lib/prose_diff/node/node.rb#186
    def has_natural_keys?(*args, &block); end

    # source://prose_diff//lib/prose_diff/node/node.rb#186
    def has_same_content_as?(*args, &block); end

    # source://prose_diff//lib/prose_diff/node/node.rb#186
    def have_comparable_children?(*args, &block); end

    # source://prose_diff//lib/prose_diff/node/node.rb#186
    def have_comparable_text?(*args, &block); end

    # source://prose_diff//lib/prose_diff/node/node.rb#186
    def have_same_identification?(*args, &block); end

    # source://prose_diff//lib/prose_diff/node/node.rb#210
    def instance_methods_for_all_proxies; end

    # source://prose_diff//lib/prose_diff/node/node.rb#186
    def is_a_simple_text_container?(*args, &block); end

    # source://prose_diff//lib/prose_diff/node/node.rb#186
    def is_comparable_text?(*args, &block); end

    # source://prose_diff//lib/prose_diff/node/node.rb#186
    def is_compatible_with?(*args, &block); end

    # source://prose_diff//lib/prose_diff/node/node.rb#186
    def is_dominated_by_text?(*args, &block); end

    # source://prose_diff//lib/prose_diff/node/node.rb#186
    def is_textlike?(*args, &block); end

    # source://prose_diff//lib/prose_diff/node/node.rb#186
    def is_uncomplicated?(*args, &block); end

    # source://prose_diff//lib/prose_diff/node/node.rb#186
    def natural_attrs(*args, &block); end

    # source://prose_diff//lib/prose_diff/node/node.rb#186
    def natural_keys(*args, &block); end

    # source://prose_diff//lib/prose_diff/node/node.rb#186
    def number_that_correspond(*args, &block); end

    # source://prose_diff//lib/prose_diff/node/node.rb#186
    def number_that_match_exactly(*args, &block); end

    # source://prose_diff//lib/prose_diff/node/node.rb#186
    def other_changed?(*args, &block); end

    # @return [Boolean]
    #
    # source://prose_diff//lib/prose_diff/node/node.rb#181
    def plural?(node_like_thing); end

    # source://prose_diff//lib/prose_diff/node/node.rb#186
    def preanalyze_moves(*args, &block); end

    # source://prose_diff//lib/prose_diff/node/node.rb#186
    def private_attrs(*args, &block); end

    # source://prose_diff//lib/prose_diff/node/node.rb#130
    def proxies_by_tag; end

    # source://prose_diff//lib/prose_diff/node/node.rb#186
    def replace_children(*args, &block); end

    # source://prose_diff//lib/prose_diff/node/node.rb#186
    def set_analysis(*args, &block); end

    # source://prose_diff//lib/prose_diff/node/node.rb#186
    def set_before(*args, &block); end

    # source://prose_diff//lib/prose_diff/node/node.rb#186
    def significant(*args, &block); end

    # source://prose_diff//lib/prose_diff/node/node.rb#226
    def significant_html(node); end

    # source://prose_diff//lib/prose_diff/node/node.rb#186
    def significants(*args, &block); end

    # source://prose_diff//lib/prose_diff/node/node.rb#186
    def split(*args, &block); end

    # source://prose_diff//lib/prose_diff/node/node.rb#186
    def split_children(*args, &block); end

    # source://prose_diff//lib/prose_diff/node/node.rb#177
    def tags_seen; end

    # source://prose_diff//lib/prose_diff/node/node.rb#186
    def text(*args, &block); end

    # source://prose_diff//lib/prose_diff/node/node.rb#186
    def text_differences_metric(*args, &block); end

    # source://prose_diff//lib/prose_diff/node/node.rb#186
    def text_hash(*args, &block); end

    # source://prose_diff//lib/prose_diff/node/node.rb#214
    def to_text_string(node); end

    # source://prose_diff//lib/prose_diff/node/node.rb#186
    def transform_children(*args, &block); end

    # source://prose_diff//lib/prose_diff/node/node.rb#186
    def unsplit(*args, &block); end

    # source://prose_diff//lib/prose_diff/node/node.rb#186
    def unsplit_all(*args, &block); end

    # source://prose_diff//lib/prose_diff/node/node.rb#186
    def valid?(*args, &block); end

    # source://prose_diff//lib/prose_diff/node/node.rb#186
    def valid_and_compatible?(*args, &block); end

    # source://prose_diff//lib/prose_diff/node/node.rb#186
    def was_added?(*args, &block); end

    # source://prose_diff//lib/prose_diff/node/node.rb#186
    def was_changed?(*args, &block); end

    # source://prose_diff//lib/prose_diff/node/node.rb#186
    def was_moved?(*args, &block); end

    # source://prose_diff//lib/prose_diff/node/node.rb#186
    def was_removed?(*args, &block); end

    # source://prose_diff//lib/prose_diff/node/node.rb#186
    def was_unchanged?(*args, &block); end

    # source://prose_diff//lib/prose_diff/node/node.rb#186
    def wordz(*args, &block); end

    private

    # source://prose_diff//lib/prose_diff/node/node.rb#237
    def dispatch_through_proxy(receiver, method_name, argv, &block); end
  end
end

# source://prose_diff//lib/prose_diff/node/node.rb#14
ProseDiff::Node::ANALYSIS = T.let(T.unsafe(nil), String)

# source://prose_diff//lib/prose_diff/node/node.rb#28
ProseDiff::Node::ATOMS = T.let(T.unsafe(nil), Array)

# source://prose_diff//lib/prose_diff/node/node.rb#18
ProseDiff::Node::BEFORE_ID = T.let(T.unsafe(nil), String)

# source://prose_diff//lib/prose_diff/node/node.rb#22
ProseDiff::Node::BEFORE_NATURAL_ATTR_KEYS = T.let(T.unsafe(nil), String)

# source://prose_diff//lib/prose_diff/node/node.rb#20
ProseDiff::Node::BEFORE_TEXT = T.let(T.unsafe(nil), String)

# source://prose_diff//lib/prose_diff/node/node.rb#45
ProseDiff::Node::CALL_COUNTS = T.let(T.unsafe(nil), Hash)

# source://prose_diff//lib/prose_diff/node/node.rb#10
ProseDiff::Node::CLAZZ = T.let(T.unsafe(nil), String)

# Types of nodes
#
# source://prose_diff//lib/prose_diff/node/node.rb#26
ProseDiff::Node::CONTAINERS = T.let(T.unsafe(nil), Array)

# source://prose_diff//lib/prose_diff/node/node.rb#40
ProseDiff::Node::DEFAULT_XPATH_QUERY = T.let(T.unsafe(nil), String)

# source://prose_diff//lib/prose_diff/node/node.rb#6
ProseDiff::Node::DIGEST = T.let(T.unsafe(nil), String)

# source://prose_diff//lib/prose_diff/node/node.rb#16
ProseDiff::Node::ID = T.let(T.unsafe(nil), String)

# source://prose_diff//lib/prose_diff/node/node.rb#36
ProseDiff::Node::INLINES = T.let(T.unsafe(nil), Array)

# source://prose_diff//lib/prose_diff/node/node.rb#12
ProseDiff::Node::MOVED = T.let(T.unsafe(nil), String)

# source://prose_diff//lib/prose_diff/node/node.rb#47
ProseDiff::Node::OPAQUE = T.let(T.unsafe(nil), ProseDiff::Node::Proxy::Opaque)

# source://prose_diff//lib/prose_diff/node/proxy/base_behaviour.rb#6
module ProseDiff::Node::Proxy; end

# source://prose_diff//lib/prose_diff/node/proxy/a.rb#4
class ProseDiff::Node::Proxy::A
  include ::ProseDiff::Node::Proxy::BaseBehaviour
  include ::ProseDiff::Node::Proxy::SplitsChildrenAndSelfBehaviour
end

# source://prose_diff//lib/prose_diff/node/proxy/article.rb#4
class ProseDiff::Node::Proxy::Article
  include ::ProseDiff::Node::Proxy::BaseBehaviour
  include ::ProseDiff::Node::Proxy::SuperBlockBehaviour
end

# source://prose_diff//lib/prose_diff/node/node.rb#154
class ProseDiff::Node::Proxy::B < ::ProseDiff::Node::Proxy::Inline; end

# source://prose_diff//lib/prose_diff/node/proxy/base_behaviour.rb#8
module ProseDiff::Node::Proxy::BaseBehaviour
  # source://prose_diff//lib/prose_diff/node/proxy/base_behaviour.rb#25
  def add_class(node, new_class); end

  # source://prose_diff//lib/prose_diff/node/proxy/base_behaviour.rb#284
  def analysis(node); end

  # @return [Boolean]
  #
  # source://prose_diff//lib/prose_diff/node/proxy/base_behaviour.rb#123
  def appear_to_correspond?(node, other_node); end

  # tri:state: true, false, nil
  #
  # @return [Boolean]
  #
  # source://prose_diff//lib/prose_diff/node/proxy/base_behaviour.rb#184
  def are_comparable_lists?(a_list, b_list); end

  # tri:state: true, false, nil
  #
  # @return [Boolean]
  #
  # source://prose_diff//lib/prose_diff/node/proxy/base_behaviour.rb#193
  def are_comparable_lists_of_nodes?(a_list, b_list); end

  # source://prose_diff//lib/prose_diff/node/proxy/base_behaviour.rb#20
  def at(options, category, key); end

  # source://prose_diff//lib/prose_diff/node/proxy/base_behaviour.rb#345
  def becomes_added(node); end

  # source://prose_diff//lib/prose_diff/node/proxy/base_behaviour.rb#307
  def becomes_changed(node); end

  # source://prose_diff//lib/prose_diff/node/proxy/base_behaviour.rb#279
  def becomes_moved(node); end

  # source://prose_diff//lib/prose_diff/node/proxy/base_behaviour.rb#354
  def becomes_removed(node); end

  # now recursive
  #
  # source://prose_diff//lib/prose_diff/node/proxy/base_behaviour.rb#335
  def becomes_unchanged(node); end

  # source://prose_diff//lib/prose_diff/node/proxy/base_behaviour.rb#326
  def before_natural_attr_keys(after_node); end

  # source://prose_diff//lib/prose_diff/node/proxy/base_behaviour.rb#322
  def before_text(after_node); end

  # source://prose_diff//lib/prose_diff/node/proxy/base_behaviour.rb#363
  def classify_before(node, attr, value); end

  # source://prose_diff//lib/prose_diff/node/proxy/base_behaviour.rb#367
  def diff_attributes(node, before, options); end

  # source://prose_diff//lib/prose_diff/node/proxy/base_behaviour.rb#424
  def diff_children(node, before, options); end

  # source://prose_diff//lib/prose_diff/node/proxy/base_behaviour.rb#418
  def diff_with_before(node, before, options); end

  # @return [Boolean]
  #
  # source://prose_diff//lib/prose_diff/node/proxy/base_behaviour.rb#101
  def doesnt_have_natural_keys?(node); end

  # @return [Boolean]
  #
  # source://prose_diff//lib/prose_diff/node/proxy/base_behaviour.rb#97
  def has_natural_keys?(node); end

  # @return [Boolean]
  #
  # source://prose_diff//lib/prose_diff/node/proxy/base_behaviour.rb#42
  def has_same_content_as?(node, other_node); end

  # tri:state: true, false, nil
  #
  # @return [Boolean]
  #
  # source://prose_diff//lib/prose_diff/node/proxy/base_behaviour.rb#179
  def have_comparable_children?(node, other_node); end

  # tri:state: true, false, nil
  #
  # @return [Boolean]
  #
  # source://prose_diff//lib/prose_diff/node/proxy/base_behaviour.rb#145
  def have_comparable_text?(node, other_node); end

  # tri:state: true, false, nil
  #
  # @return [Boolean]
  #
  # source://prose_diff//lib/prose_diff/node/proxy/base_behaviour.rb#136
  def have_same_identification?(node, other_node); end

  # @return [Boolean]
  #
  # source://prose_diff//lib/prose_diff/node/proxy/base_behaviour.rb#79
  def is_a_simple_text_container?(node); end

  # @return [Boolean]
  #
  # source://prose_diff//lib/prose_diff/node/proxy/base_behaviour.rb#153
  def is_comparable_text?(text, other_text); end

  # @return [Boolean]
  #
  # source://prose_diff//lib/prose_diff/node/proxy/base_behaviour.rb#112
  def is_compatible_with?(node, other_node); end

  # not meant to be polymorphic through proxies, but maybe that should change?
  #
  # @return [Boolean]
  #
  # source://prose_diff//lib/prose_diff/node/proxy/base_behaviour.rb#206
  def is_dominated_by_text?(node); end

  # @return [Boolean]
  #
  # source://prose_diff//lib/prose_diff/node/proxy/base_behaviour.rb#46
  def is_textlike?(node); end

  # @return [Boolean]
  #
  # source://prose_diff//lib/prose_diff/node/proxy/base_behaviour.rb#299
  def is_uncomplicated?(node); end

  # source://prose_diff//lib/prose_diff/node/proxy/base_behaviour.rb#105
  def natural_attrs(node); end

  # source://prose_diff//lib/prose_diff/node/proxy/base_behaviour.rb#93
  def natural_keys(node); end

  # @return [Boolean]
  #
  # source://prose_diff//lib/prose_diff/node/proxy/base_behaviour.rb#312
  def other_changed?(node); end

  # source://prose_diff//lib/prose_diff/node/proxy/base_behaviour.rb#359
  def private_attrs(node); end

  # source://prose_diff//lib/prose_diff/node/proxy/base_behaviour.rb#83
  def replace_children(node, nkotb); end

  # source://prose_diff//lib/prose_diff/node/proxy/base_behaviour.rb#295
  def set_analysis(node, something); end

  # source://prose_diff//lib/prose_diff/node/proxy/base_behaviour.rb#316
  def set_before(after_node, before_node); end

  # source://prose_diff//lib/prose_diff/node/proxy/base_behaviour.rb#16
  def significant(options, array_of_attrs); end

  # source://prose_diff//lib/prose_diff/node/proxy/base_behaviour.rb#443
  def split(node); end

  # returns the split children as a list
  #
  # source://prose_diff//lib/prose_diff/node/proxy/base_behaviour.rb#75
  def split_children(node); end

  # source://prose_diff//lib/prose_diff/node/proxy/base_behaviour.rb#220
  def text_differences_metric(list_a, list_b); end

  # source://prose_diff//lib/prose_diff/node/proxy/base_behaviour.rb#31
  def text_hash(node); end

  # source://prose_diff//lib/prose_diff/node/proxy/base_behaviour.rb#50
  def unsplit(node, other_node); end

  # source://prose_diff//lib/prose_diff/node/proxy/base_behaviour.rb#54
  def unsplit_all(args_or_set, additional = T.unsafe(nil)); end

  # @return [Boolean]
  #
  # source://prose_diff//lib/prose_diff/node/proxy/base_behaviour.rb#10
  def valid?(node); end

  # @return [Boolean]
  #
  # source://prose_diff//lib/prose_diff/node/proxy/base_behaviour.rb#116
  def valid_and_compatible?(node, other_node); end

  # @return [Boolean]
  #
  # source://prose_diff//lib/prose_diff/node/proxy/base_behaviour.rb#341
  def was_added?(node); end

  # @return [Boolean]
  #
  # source://prose_diff//lib/prose_diff/node/proxy/base_behaviour.rb#303
  def was_changed?(node); end

  # @return [Boolean]
  #
  # source://prose_diff//lib/prose_diff/node/proxy/base_behaviour.rb#275
  def was_moved?(node); end

  # @return [Boolean]
  #
  # source://prose_diff//lib/prose_diff/node/proxy/base_behaviour.rb#350
  def was_removed?(node); end

  # @return [Boolean]
  #
  # source://prose_diff//lib/prose_diff/node/proxy/base_behaviour.rb#330
  def was_unchanged?(node); end

  # source://prose_diff//lib/prose_diff/node/proxy/base_behaviour.rb#216
  def wordz(node); end

  private

  # source://prose_diff//lib/prose_diff/node/proxy/base_behaviour.rb#449
  def unsplit_nodeset(nodeset); end
end

# source://prose_diff//lib/prose_diff/node/proxy/base_behaviour.rb#203
ProseDiff::Node::Proxy::BaseBehaviour::DOMINATION_THRESHOLD = T.let(T.unsafe(nil), Float)

# source://prose_diff//lib/prose_diff/node/proxy/base_behaviour.rb#14
ProseDiff::Node::Proxy::BaseBehaviour::EMPTY_TEXT_HASH = T.let(T.unsafe(nil), String)

# source://prose_diff//lib/prose_diff/node/proxy/base_behaviour.rb#110
ProseDiff::Node::Proxy::BaseBehaviour::NODE_CLOSENESS_THRESHOLD = T.let(T.unsafe(nil), Float)

# code smell: couldn't figure out setting a namespaced attribute
#
# source://prose_diff//lib/prose_diff/node/proxy/base_behaviour.rb#238
class ProseDiff::Node::Proxy::BaseBehaviour::NamespacedAttributeProxy
  # @return [NamespacedAttributeProxy] a new instance of NamespacedAttributeProxy
  #
  # source://prose_diff//lib/prose_diff/node/proxy/base_behaviour.rb#240
  def initialize(node); end

  # source://prose_diff//lib/prose_diff/node/proxy/base_behaviour.rb#244
  def [](attr); end

  # source://prose_diff//lib/prose_diff/node/proxy/base_behaviour.rb#248
  def []=(attr, value); end

  # source://prose_diff//lib/prose_diff/node/proxy/base_behaviour.rb#253
  def to_hash; end

  # source://prose_diff//lib/prose_diff/node/proxy/base_behaviour.rb#262
  def values; end
end

# source://prose_diff//lib/prose_diff/node/proxy/base_behaviour.rb#109
ProseDiff::Node::Proxy::BaseBehaviour::TEXT_DIFFERENCE_THRESHOLD = T.let(T.unsafe(nil), Float)

# source://prose_diff//lib/prose_diff/node/proxy/block.rb#4
class ProseDiff::Node::Proxy::Block
  include ::ProseDiff::Node::Proxy::BaseBehaviour
end

# source://prose_diff//lib/prose_diff/node/proxy/blockquote.rb#4
class ProseDiff::Node::Proxy::Blockquote
  include ::ProseDiff::Node::Proxy::BaseBehaviour
  include ::ProseDiff::Node::Proxy::SimpleTextContainerBehaviour
  include ::ProseDiff::Node::Proxy::LevenshteinDistanceBehaviour

  # @return [Boolean]
  #
  # source://prose_diff//lib/prose_diff/node/proxy/blockquote.rb#12
  def have_comparable_text?(node, other_node); end

  # @return [Boolean]
  #
  # source://prose_diff//lib/prose_diff/node/proxy/blockquote.rb#8
  def is_compatible_with?(node, other_node); end
end

# source://prose_diff//lib/prose_diff/node/proxy/body.rb#4
class ProseDiff::Node::Proxy::Body
  include ::ProseDiff::Node::Proxy::BaseBehaviour
  include ::ProseDiff::Node::Proxy::SuperBlockBehaviour
end

# source://prose_diff//lib/prose_diff/node/node.rb#145
class ProseDiff::Node::Proxy::Br < ::ProseDiff::Node::Proxy::Block; end

# source://prose_diff//lib/prose_diff/node/proxy/can_only_correspond_to_the_same_tag_baheaviour.rb#4
module ProseDiff::Node::Proxy::CanOnlyCorrespondToTheSameTagBehaviour
  # @return [Boolean]
  #
  # source://prose_diff//lib/prose_diff/node/proxy/can_only_correspond_to_the_same_tag_baheaviour.rb#6
  def is_compatible_with?(node, other_node); end
end

# source://prose_diff//lib/prose_diff/node/proxy/caption.rb#4
class ProseDiff::Node::Proxy::Caption
  include ::ProseDiff::Node::Proxy::BaseBehaviour
  include ::ProseDiff::Node::Proxy::CanOnlyCorrespondToTheSameTagBehaviour

  # @return [Boolean]
  #
  # source://prose_diff//lib/prose_diff/node/proxy/caption.rb#8
  def appear_to_correspond?(node, other_node); end
end

# source://prose_diff//lib/prose_diff/node/proxy/code.rb#4
class ProseDiff::Node::Proxy::Code
  include ::ProseDiff::Node::Proxy::BaseBehaviour
  include ::ProseDiff::Node::Proxy::UnsplittableBehaviour

  # @return [Boolean]
  #
  # source://prose_diff//lib/prose_diff/node/proxy/code.rb#8
  def appear_to_correspond?(node, other_node); end
end

# source://prose_diff//lib/prose_diff/node/proxy/dd.rb#4
class ProseDiff::Node::Proxy::Dd
  include ::ProseDiff::Node::Proxy::BaseBehaviour
  include ::ProseDiff::Node::Proxy::CanOnlyCorrespondToTheSameTagBehaviour
  include ::ProseDiff::Node::Proxy::LevenshteinDistanceBehaviour
end

# source://prose_diff//lib/prose_diff/node/proxy/del.rb#4
class ProseDiff::Node::Proxy::Del
  include ::ProseDiff::Node::Proxy::BaseBehaviour
  include ::ProseDiff::Node::Proxy::SplitsChildrenAndSelfBehaviour

  # source://prose_diff//lib/prose_diff/node/proxy/del.rb#8
  def analysis(node); end
end

# source://prose_diff//lib/prose_diff/node/proxy/div.rb#4
class ProseDiff::Node::Proxy::Div
  include ::ProseDiff::Node::Proxy::BaseBehaviour
  include ::ProseDiff::Node::Proxy::CanOnlyCorrespondToTheSameTagBehaviour
  include ::ProseDiff::Node::Proxy::LevenshteinDistanceBehaviour

  # @return [Boolean]
  #
  # source://prose_diff//lib/prose_diff/node/proxy/div.rb#8
  def have_comparable_text?(node, other_node); end
end

# source://prose_diff//lib/prose_diff/node/proxy/dl.rb#4
class ProseDiff::Node::Proxy::Dl
  include ::ProseDiff::Node::Proxy::BaseBehaviour
  include ::ProseDiff::Node::Proxy::CanOnlyCorrespondToTheSameTagBehaviour

  # TODO: valid should check whether all elements are
  #
  # source://prose_diff//lib/prose_diff/node/proxy/dl.rb#10
  def diff_children(node, before, options); end

  # Two DLs are comparable if the text of their dts are comparable. dds don't count
  #
  # @return [Boolean]
  #
  # source://prose_diff//lib/prose_diff/node/proxy/dl.rb#44
  def have_comparable_text?(node, other_node); end

  private

  # source://prose_diff//lib/prose_diff/node/proxy/dl.rb#56
  def chunk(node); end
end

# source://prose_diff//lib/prose_diff/node/proxy/dt.rb#4
class ProseDiff::Node::Proxy::Dt
  include ::ProseDiff::Node::Proxy::BaseBehaviour
  include ::ProseDiff::Node::Proxy::CanOnlyCorrespondToTheSameTagBehaviour
  include ::ProseDiff::Node::Proxy::SimpleTextContainerBehaviour
  include ::ProseDiff::Node::Proxy::LevenshteinDistanceBehaviour
end

# source://prose_diff//lib/prose_diff/node/proxy/em.rb#4
class ProseDiff::Node::Proxy::Em
  include ::ProseDiff::Node::Proxy::BaseBehaviour
  include ::ProseDiff::Node::Proxy::SimpleTextContainerBehaviour
  include ::ProseDiff::Node::Proxy::LevenshteinDistanceBehaviour

  # @return [Boolean]
  #
  # source://prose_diff//lib/prose_diff/node/proxy/em.rb#8
  def have_comparable_text?(node, other_node); end
end

# source://prose_diff//lib/prose_diff/node/node.rb#154
class ProseDiff::Node::Proxy::Fixed < ::ProseDiff::Node::Proxy::Inline; end

# source://prose_diff//lib/prose_diff/node/proxy/h.rb#6
class ProseDiff::Node::Proxy::H
  include ::ProseDiff::Node::Proxy::BaseBehaviour
  include ::ProseDiff::Node::Proxy::LevenshteinDistanceBehaviour

  # @return [Boolean]
  #
  # source://prose_diff//lib/prose_diff/node/proxy/h.rb#14
  def have_comparable_text?(node, other_node); end

  # @return [Boolean]
  #
  # source://prose_diff//lib/prose_diff/node/proxy/h.rb#10
  def is_compatible_with?(node, other_node); end
end

# source://prose_diff//lib/prose_diff/node/node.rb#136
class ProseDiff::Node::Proxy::H1 < ::ProseDiff::Node::Proxy::H; end

# source://prose_diff//lib/prose_diff/node/node.rb#136
class ProseDiff::Node::Proxy::H2 < ::ProseDiff::Node::Proxy::H; end

# source://prose_diff//lib/prose_diff/node/node.rb#136
class ProseDiff::Node::Proxy::H3 < ::ProseDiff::Node::Proxy::H; end

# source://prose_diff//lib/prose_diff/node/node.rb#136
class ProseDiff::Node::Proxy::H4 < ::ProseDiff::Node::Proxy::H; end

# source://prose_diff//lib/prose_diff/node/node.rb#136
class ProseDiff::Node::Proxy::H5 < ::ProseDiff::Node::Proxy::H; end

# source://prose_diff//lib/prose_diff/node/node.rb#136
class ProseDiff::Node::Proxy::H6 < ::ProseDiff::Node::Proxy::H; end

# source://prose_diff//lib/prose_diff/node/node.rb#145
class ProseDiff::Node::Proxy::Hr < ::ProseDiff::Node::Proxy::Block; end

# source://prose_diff//lib/prose_diff/node/node.rb#154
class ProseDiff::Node::Proxy::I < ::ProseDiff::Node::Proxy::Inline; end

# source://prose_diff//lib/prose_diff/node/proxy/img.rb#4
class ProseDiff::Node::Proxy::Img
  include ::ProseDiff::Node::Proxy::BaseBehaviour
  include ::ProseDiff::Node::Proxy::CanOnlyCorrespondToTheSameTagBehaviour
  include ::ProseDiff::Node::Proxy::UnsplittableBehaviour

  # @return [Boolean]
  #
  # source://prose_diff//lib/prose_diff/node/proxy/img.rb#12
  def appear_to_correspond?(node, other_node); end

  # @return [Boolean]
  #
  # source://prose_diff//lib/prose_diff/node/proxy/img.rb#8
  def has_same_content_as?(node, other_node); end
end

# source://prose_diff//lib/prose_diff/node/proxy/inline.rb#4
class ProseDiff::Node::Proxy::Inline
  include ::ProseDiff::Node::Proxy::BaseBehaviour
  include ::ProseDiff::Node::Proxy::SplitsChildrenAndSelfBehaviour
end

# source://prose_diff//lib/prose_diff/node/proxy/input.rb#4
class ProseDiff::Node::Proxy::Input
  include ::ProseDiff::Node::Proxy::BaseBehaviour

  # source://prose_diff//lib/prose_diff/node/proxy/input.rb#12
  def appear_to_correspond(input, other_node); end

  # source://prose_diff//lib/prose_diff/node/proxy/input.rb#16
  def significant(options, array_of_attrs); end

  # @return [Boolean]
  #
  # source://prose_diff//lib/prose_diff/node/proxy/input.rb#8
  def valid?(input); end
end

# source://prose_diff//lib/prose_diff/node/proxy/ins.rb#4
class ProseDiff::Node::Proxy::Ins
  include ::ProseDiff::Node::Proxy::BaseBehaviour
  include ::ProseDiff::Node::Proxy::SplitsChildrenAndSelfBehaviour

  # source://prose_diff//lib/prose_diff/node/proxy/ins.rb#8
  def analysis(node); end
end

# source://prose_diff//lib/prose_diff/node/proxy/levenshtein_distance_behaviour.rb#7
module ProseDiff::Node::Proxy::LevenshteinDistanceBehaviour
  private

  # @return [Boolean]
  #
  # source://prose_diff//lib/prose_diff/node/proxy/levenshtein_distance_behaviour.rb#11
  def is_comparable_text?(node, other_node, threshold = T.unsafe(nil)); end

  class << self
    # @return [Boolean]
    #
    # source://prose_diff//lib/prose_diff/node/proxy/levenshtein_distance_behaviour.rb#11
    def is_comparable_text?(node, other_node, threshold = T.unsafe(nil)); end
  end
end

# source://prose_diff//lib/prose_diff/node/proxy/levenshtein_distance_behaviour.rb#9
ProseDiff::Node::Proxy::LevenshteinDistanceBehaviour::TEXT_DIFFERENCE_THRESHOLD = T.let(T.unsafe(nil), Float)

# source://prose_diff//lib/prose_diff/node/proxy/li.rb#4
class ProseDiff::Node::Proxy::Li
  include ::ProseDiff::Node::Proxy::BaseBehaviour
  include ::ProseDiff::Node::Proxy::CanOnlyCorrespondToTheSameTagBehaviour
  include ::ProseDiff::Node::Proxy::LevenshteinDistanceBehaviour

  # @return [Boolean]
  #
  # source://prose_diff//lib/prose_diff/node/proxy/li.rb#10
  def is_comparable_text?(node, other_node); end

  class << self
    # source://prose_diff//lib/prose_diff/node/proxy/li.rb#25
    def significant_text(li); end
  end
end

# source://prose_diff//lib/prose_diff/node/proxy/li.rb#8
ProseDiff::Node::Proxy::Li::LIST_ITEM_DIFFERENCE_THRESHOLD = T.let(T.unsafe(nil), Float)

# source://prose_diff//lib/prose_diff/node/proxy/line.rb#4
class ProseDiff::Node::Proxy::Line
  include ::ProseDiff::Node::Proxy::BaseBehaviour
  include ::ProseDiff::Node::Proxy::UnsplittableBehaviour

  # @return [Boolean]
  #
  # source://prose_diff//lib/prose_diff/node/proxy/line.rb#8
  def appear_to_correspond?(opaque, other_node); end
end

# source://prose_diff//lib/prose_diff/node/proxy/list_behaviour.rb#9
module ProseDiff::Node::Proxy::ListBehaviour
  # @return [Boolean]
  #
  # source://prose_diff//lib/prose_diff/node/proxy/list_behaviour.rb#13
  def appear_to_correspond?(node, other_node); end

  # source://prose_diff//lib/prose_diff/node/proxy/list_behaviour.rb#41
  def diff_children(node, before, options); end

  # source://prose_diff//lib/prose_diff/node/proxy/list_behaviour.rb#146
  def digest(li); end

  # source://prose_diff//lib/prose_diff/node/proxy/list_behaviour.rb#134
  def digests(node); end

  # source://prose_diff//lib/prose_diff/node/proxy/list_behaviour.rb#106
  def doppelganger(node); end

  # @return [Boolean]
  #
  # source://prose_diff//lib/prose_diff/node/proxy/list_behaviour.rb#27
  def have_comparable_children?(node, other_node); end

  # @return [Boolean]
  #
  # source://prose_diff//lib/prose_diff/node/proxy/list_behaviour.rb#23
  def have_comparable_text?(node, other_node); end

  # source://prose_diff//lib/prose_diff/node/proxy/list_behaviour.rb#121
  def number_that_correspond(a_significants, b_significants); end

  # source://prose_diff//lib/prose_diff/node/proxy/list_behaviour.rb#110
  def number_that_match_exactly(a_digests, b_digests); end

  # source://prose_diff//lib/prose_diff/node/proxy/list_behaviour.rb#57
  def preanalyze_moves(node_children, before_children); end

  # source://prose_diff//lib/prose_diff/node/proxy/list_behaviour.rb#140
  def significants(node); end

  # source://prose_diff//lib/prose_diff/node/proxy/list_behaviour.rb#74
  def transform_children(children, options); end
end

# source://prose_diff//lib/prose_diff/node/proxy/list_behaviour.rb#11
ProseDiff::Node::Proxy::ListBehaviour::HAS_DOPPEL = T.let(T.unsafe(nil), String)

# source://prose_diff//lib/prose_diff/node/proxy/ol.rb#4
class ProseDiff::Node::Proxy::Ol
  include ::ProseDiff::Node::Proxy::BaseBehaviour
  include ::ProseDiff::Node::Proxy::ListBehaviour
  include ::ProseDiff::Node::Proxy::CanOnlyCorrespondToTheSameTagBehaviour
  include ::ProseDiff::Node::Proxy::LevenshteinDistanceBehaviour

  # source://prose_diff//lib/prose_diff/node/proxy/ol.rb#20
  def children_of(node); end

  # source://prose_diff//lib/prose_diff/node/proxy/ol.rb#8
  def diff_children(node, before, options); end

  private

  # source://prose_diff//lib/prose_diff/node/proxy/ol.rb#26
  def numbered_children_of(ol); end
end

# source://prose_diff//lib/prose_diff/node/proxy/opaque.rb#4
class ProseDiff::Node::Proxy::Opaque
  include ::ProseDiff::Node::Proxy::BaseBehaviour
  include ::ProseDiff::Node::Proxy::UnsplittableBehaviour

  # @return [Boolean]
  #
  # source://prose_diff//lib/prose_diff/node/proxy/opaque.rb#8
  def appear_to_correspond?(opaque, other_node); end

  # @return [Boolean]
  #
  # source://prose_diff//lib/prose_diff/node/proxy/opaque.rb#12
  def valid?(opaque); end
end

# source://prose_diff//lib/prose_diff/node/proxy/p.rb#4
class ProseDiff::Node::Proxy::P
  include ::ProseDiff::Node::Proxy::BaseBehaviour
  include ::ProseDiff::Node::Proxy::SimpleTextContainerBehaviour
  include ::ProseDiff::Node::Proxy::LevenshteinDistanceBehaviour

  # @return [Boolean]
  #
  # source://prose_diff//lib/prose_diff/node/proxy/p.rb#12
  def have_comparable_text?(node, other_node); end

  # @return [Boolean]
  #
  # source://prose_diff//lib/prose_diff/node/proxy/p.rb#8
  def is_compatible_with?(node, other_node); end
end

# source://prose_diff//lib/prose_diff/node/proxy/pre.rb#6
class ProseDiff::Node::Proxy::Pre
  include ::ProseDiff::Node::Proxy::BaseBehaviour
  include ::ProseDiff::Node::Proxy::UnsplittableBehaviour
  include ::ProseDiff::Node::Proxy::CanOnlyCorrespondToTheSameTagBehaviour
  include ::ProseDiff::Node::Proxy::LevenshteinDistanceBehaviour

  # @return [Boolean]
  #
  # source://prose_diff//lib/prose_diff/node/proxy/pre.rb#10
  def appear_to_correspond?(node, other_node); end

  # source://prose_diff//lib/prose_diff/node/proxy/pre.rb#23
  def diff_children(node, before, options); end

  private

  # source://prose_diff//lib/prose_diff/node/proxy/pre.rb#68
  def split_children_helper(node); end

  # source://prose_diff//lib/prose_diff/node/proxy/pre.rb#60
  def to_be_split(node); end
end

# source://prose_diff//lib/prose_diff/node/proxy/pre.rb#21
ProseDiff::Node::Proxy::Pre::HTML_TO_USE_REGEX = T.let(T.unsafe(nil), Regexp)

# source://prose_diff//lib/prose_diff/node/proxy/pre.rb#19
ProseDiff::Node::Proxy::Pre::SAME_TEXT = T.let(T.unsafe(nil), Proc)

# source://prose_diff//lib/prose_diff/node/node.rb#145
class ProseDiff::Node::Proxy::Section < ::ProseDiff::Node::Proxy::Block; end

# source://prose_diff//lib/prose_diff/node/proxy/simple_text_container_behaviour.rb#6
module ProseDiff::Node::Proxy::SimpleTextContainerBehaviour
  # source://prose_diff//lib/prose_diff/node/proxy/simple_text_container_behaviour.rb#12
  def diff_children(node, before, options); end

  private

  # slow :-()
  #
  # source://prose_diff//lib/prose_diff/node/proxy/simple_text_container_behaviour.rb#109
  def children_diff(node, common_prefix, node_children, before_children, common_suffix, options); end

  # fastest
  #
  # source://prose_diff//lib/prose_diff/node/proxy/simple_text_container_behaviour.rb#43
  def chunk_diff(node, common_prefix, node_children, before_children, common_suffix, options); end

  # source://prose_diff//lib/prose_diff/node/proxy/simple_text_container_behaviour.rb#157
  def fast_split_children(children); end

  # @return [Boolean]
  #
  # source://prose_diff//lib/prose_diff/node/proxy/simple_text_container_behaviour.rb#262
  def is_a_simple_text_container?(node); end

  # source://prose_diff//lib/prose_diff/node/proxy/simple_text_container_behaviour.rb#168
  def strip_prefixes(outer_prefix, node_children, before_children, outer_suffix); end

  # fast
  #
  # source://prose_diff//lib/prose_diff/node/proxy/simple_text_container_behaviour.rb#63
  def text_diff(node, common_prefix, node_child, before_child, common_suffix, options); end

  class << self
    # @return [Boolean]
    #
    # source://prose_diff//lib/prose_diff/node/proxy/simple_text_container_behaviour.rb#262
    def is_a_simple_text_container?(node); end
  end
end

# source://prose_diff//lib/prose_diff/node/proxy/simple_text_container_behaviour.rb#8
ProseDiff::Node::Proxy::SimpleTextContainerBehaviour::CHUNKING_THRESHOLD = T.let(T.unsafe(nil), Float)

# source://prose_diff//lib/prose_diff/node/proxy/simple_text_container_behaviour.rb#10
ProseDiff::Node::Proxy::SimpleTextContainerBehaviour::WORD_DIFFER = T.let(T.unsafe(nil), Proc)

# source://prose_diff//lib/prose_diff/node/proxy/span.rb#6
class ProseDiff::Node::Proxy::Span
  include ::ProseDiff::Node::Proxy::BaseBehaviour
  include ::ProseDiff::Node::Proxy::SplitsChildrenAndSelfBehaviour
  include ::ProseDiff::Node::Proxy::SpanBehaviour

  # @return [Boolean]
  #
  # source://prose_diff//lib/prose_diff/node/proxy/span.rb#10
  def is_textlike?(node); end

  # source://prose_diff//lib/prose_diff/node/proxy/span.rb#14
  def unsplit(node, other_node); end
end

# source://prose_diff//lib/prose_diff/node/proxy/span_behaviour.rb#8
module ProseDiff::Node::Proxy::SpanBehaviour
  # @return [Boolean]
  #
  # source://prose_diff//lib/prose_diff/node/proxy/span_behaviour.rb#10
  def appear_to_correspond?(node, other_node); end

  # @return [Boolean]
  #
  # source://prose_diff//lib/prose_diff/node/proxy/span_behaviour.rb#20
  def is_textlike?(node); end

  # source://prose_diff//lib/prose_diff/node/proxy/span_behaviour.rb#24
  def unsplit(node, other_node); end
end

# source://prose_diff//lib/prose_diff/node/proxy/splits_children_and_self_behaviour.rb#6
module ProseDiff::Node::Proxy::SplitsChildrenAndSelfBehaviour
  # source://prose_diff//lib/prose_diff/node/proxy/splits_children_and_self_behaviour.rb#8
  def split(node); end

  private

  # source://prose_diff//lib/prose_diff/node/proxy/splits_children_and_self_behaviour.rb#27
  def unsplit(node, other_node); end

  class << self
    # source://prose_diff//lib/prose_diff/node/proxy/splits_children_and_self_behaviour.rb#27
    def unsplit(node, other_node); end
  end
end

# source://prose_diff//lib/prose_diff/node/node.rb#154
class ProseDiff::Node::Proxy::Strike < ::ProseDiff::Node::Proxy::Inline; end

# source://prose_diff//lib/prose_diff/node/proxy/strong.rb#4
class ProseDiff::Node::Proxy::Strong
  include ::ProseDiff::Node::Proxy::BaseBehaviour
  include ::ProseDiff::Node::Proxy::SimpleTextContainerBehaviour
  include ::ProseDiff::Node::Proxy::LevenshteinDistanceBehaviour

  # @return [Boolean]
  #
  # source://prose_diff//lib/prose_diff/node/proxy/strong.rb#8
  def have_comparable_text?(node, other_node); end
end

# source://prose_diff//lib/prose_diff/node/proxy/super_block_behaviour.rb#6
module ProseDiff::Node::Proxy::SuperBlockBehaviour
  # @return [Boolean]
  #
  # source://prose_diff//lib/prose_diff/node/proxy/super_block_behaviour.rb#8
  def appear_to_correspond?(node, other_node); end

  # source://prose_diff//lib/prose_diff/node/proxy/super_block_behaviour.rb#12
  def split_children(node); end
end

# source://prose_diff//lib/prose_diff/node/proxy/table.rb#6
class ProseDiff::Node::Proxy::Table
  include ::ProseDiff::Node::Proxy::BaseBehaviour
  include ::ProseDiff::Node::Proxy::CanOnlyCorrespondToTheSameTagBehaviour

  # source://prose_diff//lib/prose_diff/node/proxy/table.rb#23
  def diff_children(node, before, options); end

  # @return [Boolean]
  #
  # source://prose_diff//lib/prose_diff/node/proxy/table.rb#46
  def have_comparable_children?(node, other_node); end

  # @return [Boolean]
  #
  # source://prose_diff//lib/prose_diff/node/proxy/table.rb#37
  def have_comparable_text?(node, other_node); end

  # FIXME: Document the GFM assumptions, including
  #        * Every column has a TH
  #        * No colspans or colgroups
  #        * at least one row
  #
  # @return [Boolean]
  #
  # source://prose_diff//lib/prose_diff/node/proxy/table.rb#15
  def valid?(node); end

  private

  # source://prose_diff//lib/prose_diff/node/proxy/table.rb#94
  def assign_rows_and_columns(node, before, options); end

  # source://prose_diff//lib/prose_diff/node/proxy/table.rb#236
  def clean_up(node, options); end

  # FIXME: Test adding and removing captions
  #
  # source://prose_diff//lib/prose_diff/node/proxy/table.rb#76
  def diff_captions(node, before, options); end

  # source://prose_diff//lib/prose_diff/node/proxy/table.rb#54
  def inner_valid(node); end

  # source://prose_diff//lib/prose_diff/node/proxy/table.rb#81
  def own_rows(node); end

  # source://prose_diff//lib/prose_diff/node/proxy/table.rb#87
  def own_ths(node); end

  # source://prose_diff//lib/prose_diff/node/proxy/table.rb#66
  def sanitize_rows(node, before); end
end

# source://prose_diff//lib/prose_diff/node/proxy/td.rb#4
class ProseDiff::Node::Proxy::Td
  include ::ProseDiff::Node::Proxy::BaseBehaviour
  include ::ProseDiff::Node::Proxy::CanOnlyCorrespondToTheSameTagBehaviour

  # @return [Boolean]
  #
  # source://prose_diff//lib/prose_diff/node/proxy/td.rb#8
  def appear_to_correspond?(node, other_node); end
end

# source://prose_diff//lib/prose_diff/node/proxy/text.rb#6
class ProseDiff::Node::Proxy::Text
  include ::ProseDiff::Node::Proxy::BaseBehaviour

  # source://prose_diff//lib/prose_diff/node/proxy/text.rb#22
  def analysis(node); end

  # text never compares children
  #
  # @return [Boolean]
  #
  # source://prose_diff//lib/prose_diff/node/proxy/text.rb#13
  def appear_to_correspond?(node, other_node); end

  # source://prose_diff//lib/prose_diff/node/proxy/text.rb#38
  def before(node); end

  # @return [Boolean]
  #
  # source://prose_diff//lib/prose_diff/node/proxy/text.rb#95
  def has_same_content_as?(node, other_node); end

  # @return [Boolean]
  #
  # source://prose_diff//lib/prose_diff/node/proxy/text.rb#26
  def is_uncomplicated?(node); end

  # @return [Boolean]
  #
  # source://prose_diff//lib/prose_diff/node/proxy/text.rb#34
  def other_changed?(node); end

  # source://prose_diff//lib/prose_diff/node/proxy/text.rb#54
  def private_attrs(node); end

  # see http://stackoverflow.com/questions/7724135/ruby-string-split-on-more-than-one-character
  #
  # source://prose_diff//lib/prose_diff/node/proxy/text.rb#63
  def split(node); end

  # source://prose_diff//lib/prose_diff/node/proxy/text.rb#58
  def text(node); end

  # source://prose_diff//lib/prose_diff/node/proxy/text.rb#79
  def unsplit(node, other_node); end

  # @return [Boolean]
  #
  # source://prose_diff//lib/prose_diff/node/proxy/text.rb#46
  def was_added?(node); end

  # @return [Boolean]
  #
  # source://prose_diff//lib/prose_diff/node/proxy/text.rb#30
  def was_changed?(node); end

  # @return [Boolean]
  #
  # source://prose_diff//lib/prose_diff/node/proxy/text.rb#18
  def was_moved?(node); end

  # @return [Boolean]
  #
  # source://prose_diff//lib/prose_diff/node/proxy/text.rb#50
  def was_removed?(node); end

  # @return [Boolean]
  #
  # source://prose_diff//lib/prose_diff/node/proxy/text.rb#42
  def was_unchanged?(node); end
end

# source://prose_diff//lib/prose_diff/node/proxy/text.rb#10
ProseDiff::Node::Proxy::Text::WHITESPACE = T.let(T.unsafe(nil), Regexp)

# source://prose_diff//lib/prose_diff/node/proxy/tr.rb#4
class ProseDiff::Node::Proxy::Tr
  include ::ProseDiff::Node::Proxy::BaseBehaviour
  include ::ProseDiff::Node::Proxy::CanOnlyCorrespondToTheSameTagBehaviour

  # @return [Boolean]
  #
  # source://prose_diff//lib/prose_diff/node/proxy/tr.rb#8
  def appear_to_correspond?(node, other_node); end
end

# source://prose_diff//lib/prose_diff/node/node.rb#154
class ProseDiff::Node::Proxy::Tt < ::ProseDiff::Node::Proxy::Inline; end

# source://prose_diff//lib/prose_diff/node/node.rb#154
class ProseDiff::Node::Proxy::U < ::ProseDiff::Node::Proxy::Inline; end

# source://prose_diff//lib/prose_diff/node/proxy/ul.rb#4
class ProseDiff::Node::Proxy::Ul
  include ::ProseDiff::Node::Proxy::BaseBehaviour
  include ::ProseDiff::Node::Proxy::ListBehaviour
  include ::ProseDiff::Node::Proxy::CanOnlyCorrespondToTheSameTagBehaviour
  include ::ProseDiff::Node::Proxy::LevenshteinDistanceBehaviour

  # source://prose_diff//lib/prose_diff/node/proxy/ul.rb#8
  def children_of(node); end
end

# source://prose_diff//lib/prose_diff/node/proxy/unsplittable_behaviour.rb#8
module ProseDiff::Node::Proxy::UnsplittableBehaviour
  # source://prose_diff//lib/prose_diff/node/proxy/unsplittable_behaviour.rb#14
  def diff_children(node, before, options); end

  # source://prose_diff//lib/prose_diff/node/proxy/unsplittable_behaviour.rb#10
  def split(the_atom); end
end

# source://prose_diff//lib/prose_diff/node/proxy/unword.rb#6
class ProseDiff::Node::Proxy::Unword
  include ::ProseDiff::Node::Proxy::BaseBehaviour
  include ::ProseDiff::Node::Proxy::SpanBehaviour
  include ::ProseDiff::Node::Proxy::UnsplittableBehaviour

  # @return [Boolean]
  #
  # source://prose_diff//lib/prose_diff/node/proxy/unword.rb#15
  def appear_to_correspond?(node, other_node); end

  # source://prose_diff//lib/prose_diff/node/proxy/unword.rb#26
  def diff_with_before(node, before, options); end

  # @return [Boolean]
  #
  # source://prose_diff//lib/prose_diff/node/proxy/unword.rb#20
  def has_same_content_as?(node, other_node); end

  # @return [Boolean]
  #
  # source://prose_diff//lib/prose_diff/node/proxy/unword.rb#10
  def is_compatible_with?(node, other_node); end
end

# source://prose_diff//lib/prose_diff/node/proxy/word.rb#4
class ProseDiff::Node::Proxy::Word
  include ::ProseDiff::Node::Proxy::BaseBehaviour
  include ::ProseDiff::Node::Proxy::SpanBehaviour
  include ::ProseDiff::Node::Proxy::UnsplittableBehaviour

  # @return [Boolean]
  #
  # source://prose_diff//lib/prose_diff/node/proxy/word.rb#12
  def appear_to_correspond?(node, other_node); end

  # @return [Boolean]
  #
  # source://prose_diff//lib/prose_diff/node/proxy/word.rb#8
  def is_compatible_with?(node, other_node); end
end

# source://prose_diff//lib/prose_diff/node/node.rb#8
ProseDiff::Node::RE = T.let(T.unsafe(nil), Regexp)

# source://prose_diff//lib/prose_diff/node/node.rb#32
ProseDiff::Node::SPANLIKE = T.let(T.unsafe(nil), Array)

# source://prose_diff//lib/prose_diff/node/node.rb#34
ProseDiff::Node::SPANS = T.let(T.unsafe(nil), Array)

# source://prose_diff//lib/prose_diff/node/node.rb#30
ProseDiff::Node::TOPLEVEL = T.let(T.unsafe(nil), Array)

# source://prose_diff//lib/prose_diff/node/node.rb#38
ProseDiff::Node::WHITELISTED = T.let(T.unsafe(nil), Array)

# source://prose_diff//lib/prose_diff/node/word_splitting.rb#5
module ProseDiff::Node::WordSplitting
  private

  # see http://stackoverflow.com/questions/7724135/ruby-string-split-on-more-than-one-character
  #
  # source://prose_diff//lib/prose_diff/node/word_splitting.rb#15
  def split_by_word(full_text); end

  # @return [Boolean]
  #
  # source://prose_diff//lib/prose_diff/node/word_splitting.rb#40
  def word?(fragment); end

  class << self
    # see http://stackoverflow.com/questions/7724135/ruby-string-split-on-more-than-one-character
    #
    # source://prose_diff//lib/prose_diff/node/word_splitting.rb#15
    def split_by_word(full_text); end

    # @return [Boolean]
    #
    # source://prose_diff//lib/prose_diff/node/word_splitting.rb#40
    def word?(fragment); end
  end
end

# source://prose_diff//lib/prose_diff/node/word_splitting.rb#8
ProseDiff::Node::WordSplitting::LEADING_NONWORD_CHARACTERS = T.let(T.unsafe(nil), Regexp)

# source://prose_diff//lib/prose_diff/node/word_splitting.rb#7
ProseDiff::Node::WordSplitting::LEADING_OPTIONAL_NONWORD_CHARACTERS = T.let(T.unsafe(nil), Regexp)

# source://prose_diff//lib/prose_diff/node/word_splitting.rb#9
ProseDiff::Node::WordSplitting::LEADING_OPTIONAL_WORD_CHARACTERS = T.let(T.unsafe(nil), Regexp)

# source://prose_diff//lib/prose_diff/node/word_splitting.rb#10
ProseDiff::Node::WordSplitting::LEADING_WORD_AND_FOLLOWING_NONWORD_CHARACTERS = T.let(T.unsafe(nil), Regexp)

# source://prose_diff//lib/prose_diff/node/word_splitting.rb#11
ProseDiff::Node::WordSplitting::LEADING_WORD_CHARACTERS = T.let(T.unsafe(nil), Regexp)

# source://prose_diff//lib/prose_diff/node/word_splitting.rb#12
ProseDiff::Node::WordSplitting::WORD = T.let(T.unsafe(nil), Regexp)

# source://prose_diff//lib/prose_diff/options.rb#3
ProseDiff::OPTIONS = T.let(T.unsafe(nil), Hash)

# source://prose_diff//lib/prose_diff/transformer/transformer.rb#4
module ProseDiff::Transformer
  private

  # source://prose_diff//lib/prose_diff/transformer/transformer.rb#114
  def transform_document(selector, value, options = T.unsafe(nil)); end

  # source://prose_diff//lib/prose_diff/transformer/transformer.rb#93
  def transform_nodes(selector, nodes, options = T.unsafe(nil)); end

  class << self
    # @return [Boolean]
    #
    # source://prose_diff//lib/prose_diff/transformer/transformer.rb#6
    def analysis_is?(node, value, *names); end

    # source://prose_diff//lib/prose_diff/transformer/transformer.rb#23
    def computed_list(options); end

    # source://prose_diff//lib/prose_diff/transformer/transformer.rb#19
    def symbol(clazz); end

    # source://prose_diff//lib/prose_diff/transformer/transformer.rb#114
    def transform_document(selector, value, options = T.unsafe(nil)); end

    # source://prose_diff//lib/prose_diff/transformer/transformer.rb#93
    def transform_nodes(selector, nodes, options = T.unsafe(nil)); end

    # source://prose_diff//lib/prose_diff/transformer/transformer.rb#34
    def underscore(string); end

    # source://prose_diff//lib/prose_diff/transformer/transformer.rb#10
    def where_analysis_is(value, *names); end

    # source://prose_diff//lib/prose_diff/transformer/transformer.rb#15
    def where_name_is(*names); end
  end
end

# source://prose_diff//lib/prose_diff/transformer/all_redundant_divs.rb#5
class ProseDiff::Transformer::AllRedundantDivs < ::ProseDiff::Transformer::Base
  # source://prose_diff//lib/prose_diff/transformer/all_redundant_divs.rb#7
  def transform_document(document); end
end

# source://prose_diff//lib/prose_diff/transformer/base.rb#5
class ProseDiff::Transformer::Base
  # @return [Base] a new instance of Base
  #
  # source://prose_diff//lib/prose_diff/transformer/base.rb#10
  def initialize(options = T.unsafe(nil)); end

  # source://prose_diff//lib/prose_diff/transformer/base.rb#32
  def add_class(node, *new_clazzes); end

  # source://prose_diff//lib/prose_diff/transformer/base.rb#45
  def default_options; end

  # evaluate an option as a predicate
  #
  # @return [Boolean]
  #
  # source://prose_diff//lib/prose_diff/transformer/base.rb#50
  def option?(key); end

  # Returns the value of attribute options.
  #
  # source://prose_diff//lib/prose_diff/transformer/base.rb#8
  def options; end

  # source://prose_diff//lib/prose_diff/transformer/base.rb#22
  def split_keys(options); end

  # source://prose_diff//lib/prose_diff/transformer/base.rb#40
  def transform_nodes(node_enumerable); end
end

# source://prose_diff//lib/prose_diff/transformer/base.rb#6
ProseDiff::Transformer::Base::ANALYSES = T.let(T.unsafe(nil), Array)

# source://prose_diff//lib/prose_diff/transformer/changed_classes.rb#5
class ProseDiff::Transformer::ChangedClasses < ::ProseDiff::Transformer::Base
  # source://prose_diff//lib/prose_diff/transformer/changed_classes.rb#10
  def default_options; end

  # source://prose_diff//lib/prose_diff/transformer/changed_classes.rb#44
  def query(*names); end

  # source://prose_diff//lib/prose_diff/transformer/changed_classes.rb#16
  def transform_document(document); end
end

# source://prose_diff//lib/prose_diff/transformer/changed_classes.rb#7
ProseDiff::Transformer::ChangedClasses::DONT_WRAP = T.let(T.unsafe(nil), Array)

# source://prose_diff//lib/prose_diff/transformer/changed_node.rb#5
class ProseDiff::Transformer::ChangedNode < ::ProseDiff::Transformer::Base
  # source://prose_diff//lib/prose_diff/transformer/changed_node.rb#7
  def transform_node(after); end
end

# run after wrap!
#
# source://prose_diff//lib/prose_diff/transformer/check_boxes.rb#5
class ProseDiff::Transformer::CheckBoxes < ::ProseDiff::Transformer::Base
  # source://prose_diff//lib/prose_diff/transformer/check_boxes.rb#7
  def transform_document(document); end
end

# source://prose_diff//lib/prose_diff/transformer/chunk_edits.rb#7
class ProseDiff::Transformer::ChunkEdits < ::ProseDiff::Transformer::Base
  # FIXME: These should be configurable
  #
  # source://prose_diff//lib/prose_diff/transformer/chunk_edits.rb#12
  def transform_nodes(nodes); end
end

# source://prose_diff//lib/prose_diff/transformer/chunk_edits.rb#9
ProseDiff::Transformer::ChunkEdits::CHUNKABLES = T.let(T.unsafe(nil), Array)

# source://prose_diff//lib/prose_diff/transformer/chunk_edits.rb#16
class ProseDiff::Transformer::ChunkEdits::ChunkParser
  # @return [ChunkParser] a new instance of ChunkParser
  #
  # source://prose_diff//lib/prose_diff/transformer/chunk_edits.rb#18
  def initialize(nodes, separatable_node_names); end

  # source://prose_diff//lib/prose_diff/transformer/chunk_edits.rb#88
  def amalgamate_separators; end

  # source://prose_diff//lib/prose_diff/transformer/chunk_edits.rb#62
  def extract_trailing_separators; end

  # source://prose_diff//lib/prose_diff/transformer/chunk_edits.rb#154
  def last_added_to_accepted; end

  # source://prose_diff//lib/prose_diff/transformer/chunk_edits.rb#139
  def last_added_to_last_added; end

  # source://prose_diff//lib/prose_diff/transformer/chunk_edits.rb#144
  def last_added_to_last_removed; end

  # last_added_to_*
  #
  # source://prose_diff//lib/prose_diff/transformer/chunk_edits.rb#134
  def last_added_to_ready; end

  # source://prose_diff//lib/prose_diff/transformer/chunk_edits.rb#149
  def last_added_to_separator; end

  # source://prose_diff//lib/prose_diff/transformer/chunk_edits.rb#181
  def last_removed_to_accepted; end

  # source://prose_diff//lib/prose_diff/transformer/chunk_edits.rb#166
  def last_removed_to_last_added; end

  # source://prose_diff//lib/prose_diff/transformer/chunk_edits.rb#171
  def last_removed_to_last_removed; end

  # last_removed_to_*
  #
  # source://prose_diff//lib/prose_diff/transformer/chunk_edits.rb#161
  def last_removed_to_ready; end

  # source://prose_diff//lib/prose_diff/transformer/chunk_edits.rb#176
  def last_removed_to_separator; end

  # source://prose_diff//lib/prose_diff/transformer/chunk_edits.rb#128
  def ready_to_accepted; end

  # source://prose_diff//lib/prose_diff/transformer/chunk_edits.rb#118
  def ready_to_last_added; end

  # source://prose_diff//lib/prose_diff/transformer/chunk_edits.rb#112
  def ready_to_last_removed; end

  # ready_to_*
  #
  # source://prose_diff//lib/prose_diff/transformer/chunk_edits.rb#108
  def ready_to_ready; end

  # source://prose_diff//lib/prose_diff/transformer/chunk_edits.rb#124
  def ready_to_separator; end

  # source://prose_diff//lib/prose_diff/transformer/chunk_edits.rb#210
  def separator_to_accepted; end

  # source://prose_diff//lib/prose_diff/transformer/chunk_edits.rb#193
  def separator_to_last_added; end

  # source://prose_diff//lib/prose_diff/transformer/chunk_edits.rb#199
  def separator_to_last_removed; end

  # separator_to_*
  #
  # source://prose_diff//lib/prose_diff/transformer/chunk_edits.rb#188
  def separator_to_ready; end

  # source://prose_diff//lib/prose_diff/transformer/chunk_edits.rb#205
  def separator_to_separator; end

  # source://prose_diff//lib/prose_diff/transformer/chunk_edits.rb#34
  def set_next_state; end

  # source://prose_diff//lib/prose_diff/transformer/chunk_edits.rb#26
  def transform; end

  # source://prose_diff//lib/prose_diff/transformer/chunk_edits.rb#55
  def update_nodes; end
end

# source://prose_diff//lib/prose_diff/transformer/css.rb#5
class ProseDiff::Transformer::Css < ::ProseDiff::Transformer::Base
  # source://prose_diff//lib/prose_diff/transformer/css.rb#7
  def default_options; end

  # source://prose_diff//lib/prose_diff/transformer/css.rb#16
  def transform_document(document); end
end

# source://prose_diff//lib/prose_diff/transformer/expandables.rb#5
class ProseDiff::Transformer::Expandables < ::ProseDiff::Transformer::Base
  # source://prose_diff//lib/prose_diff/transformer/expandables.rb#7
  def default_options; end

  # MUST follow vicinity
  #
  # source://prose_diff//lib/prose_diff/transformer/expandables.rb#17
  def transform_document(document); end
end

# source://prose_diff//lib/prose_diff/transformer/moved.rb#5
class ProseDiff::Transformer::Moved < ::ProseDiff::Transformer::Base
  # source://prose_diff//lib/prose_diff/transformer/moved.rb#12
  def digest(node); end

  # source://prose_diff//lib/prose_diff/transformer/moved.rb#16
  def transform_children(*elements); end

  # Only wired to top-level at this time.
  #
  # source://prose_diff//lib/prose_diff/transformer/moved.rb#8
  def transform_document(document); end
end

# source://prose_diff//lib/prose_diff/transformer/propagate_changed.rb#5
class ProseDiff::Transformer::PropagateChanged < ::ProseDiff::Transformer::Base
  # source://prose_diff//lib/prose_diff/transformer/propagate_changed.rb#16
  def transform_document(document); end
end

# source://prose_diff//lib/prose_diff/transformer/propagate_changed.rb#7
ProseDiff::Transformer::PropagateChanged::FIXED = T.let(T.unsafe(nil), Proc)

# source://prose_diff//lib/prose_diff/transformer/redundant_span.rb#5
class ProseDiff::Transformer::RedundantSpan < ::ProseDiff::Transformer::Base
  # source://prose_diff//lib/prose_diff/transformer/redundant_span.rb#7
  def transform_node(node); end
end

# source://prose_diff//lib/prose_diff/transformer/replace.rb#5
class ProseDiff::Transformer::Replace < ::ProseDiff::Transformer::Base
  # source://prose_diff//lib/prose_diff/transformer/replace.rb#7
  def default_options; end

  # source://prose_diff//lib/prose_diff/transformer/replace.rb#14
  def transform_document(document); end
end

# source://prose_diff//lib/prose_diff/transformer/simple_text_diff.rb#5
class ProseDiff::Transformer::SimpleTextDiff < ::ProseDiff::Transformer::Base
  # source://prose_diff//lib/prose_diff/transformer/simple_text_diff.rb#7
  def transform_nodes(nodes); end
end

# source://prose_diff//lib/prose_diff/transformer/sort_classes.rb#5
class ProseDiff::Transformer::SortClasses < ::ProseDiff::Transformer::Base
  # source://prose_diff//lib/prose_diff/transformer/sort_classes.rb#7
  def default_options; end

  # source://prose_diff//lib/prose_diff/transformer/sort_classes.rb#13
  def transform_document(document); end
end

# source://prose_diff//lib/prose_diff/transformer/strip_private_data_attributes.rb#5
class ProseDiff::Transformer::StripPrivateDataAttributes < ::ProseDiff::Transformer::Base
  # source://prose_diff//lib/prose_diff/transformer/strip_private_data_attributes.rb#7
  def default_options; end

  # source://prose_diff//lib/prose_diff/transformer/strip_private_data_attributes.rb#13
  def transform_document(document); end
end

# source://prose_diff//lib/prose_diff/transformer/transformer.rb#65
ProseDiff::Transformer::TRANSFORMERS = T.let(T.unsafe(nil), Hash)

# source://prose_diff//lib/prose_diff/transformer/vicinity.rb#5
class ProseDiff::Transformer::Vicinity < ::ProseDiff::Transformer::Base
  # source://prose_diff//lib/prose_diff/transformer/vicinity.rb#7
  def default_options; end

  # source://prose_diff//lib/prose_diff/transformer/vicinity.rb#17
  def isHeading(node); end

  # source://prose_diff//lib/prose_diff/transformer/vicinity.rb#21
  def transform_document(document); end

  private

  # source://prose_diff//lib/prose_diff/transformer/vicinity.rb#76
  def arrayize(str_or_arr); end

  # source://prose_diff//lib/prose_diff/transformer/vicinity.rb#64
  def where_parented_by_and_analyses_are(parented_by, analyses, *names); end
end

# source://prose_diff//lib/prose_diff/transformer/whitespace_agnostic.rb#7
class ProseDiff::Transformer::WhitespaceAgnostic < ::ProseDiff::Transformer::Base
  # source://prose_diff//lib/prose_diff/transformer/whitespace_agnostic.rb#9
  def default_options; end

  # source://prose_diff//lib/prose_diff/transformer/whitespace_agnostic.rb#17
  def transform_document(document); end

  class << self
    # source://prose_diff//lib/prose_diff/transformer/whitespace_agnostic.rb#52
    def clean(str); end
  end
end

# source://prose_diff//lib/prose_diff/transformer/wrap.rb#5
class ProseDiff::Transformer::Wrap < ::ProseDiff::Transformer::Base
  # source://prose_diff//lib/prose_diff/transformer/wrap.rb#10
  def default_options; end

  # source://prose_diff//lib/prose_diff/transformer/wrap.rb#18
  def transform_document(document); end
end

# source://prose_diff//lib/prose_diff/transformer/wrap.rb#7
ProseDiff::Transformer::Wrap::DONT_WRAP = T.let(T.unsafe(nil), Array)
