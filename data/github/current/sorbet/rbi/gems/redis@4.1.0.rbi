# typed: true

# DO NOT EDIT MANUALLY
# This is an autogenerated file for types exported from the `redis` gem.
# Please instead update this file by running `bin/tapioca gem redis`.

class Redis
  include ::MonitorMixin

  # Create a new client instance
  #
  # @option options
  # @option options
  # @option options
  # @option options
  # @option options
  # @option options
  # @option options
  # @option options
  # @option options
  # @option options
  # @option options
  # @option options
  # @option options
  # @option options
  # @option options
  # @option options
  # @option options
  # @option options
  # @param options [Hash]
  # @return [Redis] a new client instance
  #
  # source://redis//lib/redis.rb#39
  def initialize(options = T.unsafe(nil)); end

  # source://redis//lib/redis.rb#1159
  def _bpop(cmd, args, &blk); end

  # source://redis//lib/redis.rb#114
  def _client; end

  # source://redis//lib/redis.rb#2540
  def _eval(cmd, args); end

  # source://redis//lib/redis.rb#2603
  def _scan(command, cursor, args, options = T.unsafe(nil), &block); end

  # Append a value to a key.
  #
  # @param key [String]
  # @param value [String] value to append
  # @return [Fixnum] length of the string after appending
  #
  # source://redis//lib/redis.rb#1000
  def append(key, value); end

  # Sends `ASKING` command to random node and returns its reply.
  #
  # @return [String] `'OK'`
  # @see https://redis.io/topics/cluster-spec#ask-redirection ASK redirection
  #
  # source://redis//lib/redis.rb#3291
  def asking; end

  # Authenticate to the server.
  #
  # @param password [String] must match the password specified in the
  #   `requirepass` directive in the configuration file
  # @return [String] `OK`
  #
  # source://redis//lib/redis.rb#123
  def auth(password); end

  # Asynchronously rewrite the append-only file.
  #
  # @return [String] `OK`
  #
  # source://redis//lib/redis.rb#177
  def bgrewriteaof; end

  # Asynchronously save the dataset to disk.
  #
  # @return [String] `OK`
  #
  # source://redis//lib/redis.rb#186
  def bgsave; end

  # Count the number of set bits in a range of the string value stored at key.
  #
  # @param key [String]
  # @param start [Fixnum] start index
  # @param stop [Fixnum] stop index
  # @return [Fixnum] the number of bits set to 1
  #
  # source://redis//lib/redis.rb#1012
  def bitcount(key, start = T.unsafe(nil), stop = T.unsafe(nil)); end

  # Perform a bitwise operation between strings and store the resulting string in a key.
  #
  # @param operation [String] e.g. `and`, `or`, `xor`, `not`
  # @param destkey [String] destination key
  # @param keys [String, Array<String>] one or more source keys to perform `operation`
  # @return [Fixnum] the length of the string stored in `destkey`
  #
  # source://redis//lib/redis.rb#1024
  def bitop(operation, destkey, *keys); end

  # Return the position of the first bit set to 1 or 0 in a string.
  #
  # @param key [String]
  # @param bit [Fixnum] whether to look for the first 1 or 0 bit
  # @param start [Fixnum] start index
  # @param stop [Fixnum] stop index
  # @return [Fixnum] the position of the first 1/0 bit.
  #   -1 if looking for 1 and it is not found or start and stop are given.
  #
  # source://redis//lib/redis.rb#1038
  def bitpos(key, bit, start = T.unsafe(nil), stop = T.unsafe(nil)); end

  # Remove and get the first element in a list, or block until one is available.
  #
  # @example With timeout
  #   list, element = redis.blpop("list", :timeout => 5)
  #   # => nil on timeout
  #   # => ["list", "element"] on success
  # @example Without timeout
  #   list, element = redis.blpop("list")
  #   # => ["list", "element"]
  # @example Blocking pop on multiple lists
  #   list, element = redis.blpop(["list", "another_list"])
  #   # => ["list", "element"]
  # @param keys [String, Array<String>] one or more keys to perform the
  #   blocking pop on
  # @param options [Hash] - `:timeout => Fixnum`: timeout in seconds, defaults to no timeout
  # @return [nil, [String, String]] - `nil` when the operation timed out
  #   - tuple of the list that was popped from and element was popped otherwise
  #
  # source://redis//lib/redis.rb#1204
  def blpop(*args); end

  # Remove and get the last element in a list, or block until one is available.
  #
  # @param keys [String, Array<String>] one or more keys to perform the
  #   blocking pop on
  # @param options [Hash] - `:timeout => Fixnum`: timeout in seconds, defaults to no timeout
  # @return [nil, [String, String]] - `nil` when the operation timed out
  #   - tuple of the list that was popped from and element was popped otherwise
  # @see #blpop
  #
  # source://redis//lib/redis.rb#1220
  def brpop(*args); end

  # Pop a value from a list, push it to another list and return it; or block
  # until one is available.
  #
  # @param source [String] source key
  # @param destination [String] destination key
  # @param options [Hash] - `:timeout => Fixnum`: timeout in seconds, defaults to no timeout
  # @return [nil, String] - `nil` when the operation timed out
  #   - the element was popped and pushed otherwise
  #
  # source://redis//lib/redis.rb#1235
  def brpoplpush(source, destination, options = T.unsafe(nil)); end

  # Removes and returns up to count members with the highest scores in the sorted set stored at keys,
  #   or block until one is available.
  #
  # @example Popping a member from a sorted set
  #   redis.bzpopmax('zset', 1)
  #   #=> ['zset', 'b', 2.0]
  # @example Popping a member from multiple sorted sets
  #   redis.bzpopmax('zset1', 'zset2', 1)
  #   #=> ['zset1', 'b', 2.0]
  # @return [Array<String, String, Float>] a touple of key, member and score
  # @return [nil] when no element could be popped and the timeout expired
  #
  # source://redis//lib/redis.rb#1687
  def bzpopmax(*args); end

  # Removes and returns up to count members with the lowest scores in the sorted set stored at keys,
  #   or block until one is available.
  #
  # @example Popping a member from a sorted set
  #   redis.bzpopmin('zset', 1)
  #   #=> ['zset', 'a', 1.0]
  # @example Popping a member from multiple sorted sets
  #   redis.bzpopmin('zset1', 'zset2', 1)
  #   #=> ['zset1', 'a', 1.0]
  # @return [Array<String, String, Float>] a touple of key, member and score
  # @return [nil] when no element could be popped and the timeout expired
  #
  # source://redis//lib/redis.rb#1708
  def bzpopmin(*args); end

  # Sends a command to Redis and returns its reply.
  #
  # Replies are converted to Ruby objects according to the RESP protocol, so
  # you can expect a Ruby array, integer or nil when Redis sends one. Higher
  # level transformations, such as converting an array of pairs into a Ruby
  # hash, are up to consumers.
  #
  # Redis error replies are raised as Ruby exceptions.
  #
  # source://redis//lib/redis.rb#84
  def call(*command); end

  # Manage client connections.
  #
  # @param subcommand [String, Symbol] e.g. `kill`, `list`, `getname`, `setname`
  # @return [String, Hash] depends on subcommand
  #
  # source://redis//lib/redis.rb#213
  def client(subcommand = T.unsafe(nil), *args); end

  # Disconnect the client as quickly and silently as possible.
  #
  # source://redis//lib/redis.rb#71
  def close; end

  # Sends `CLUSTER *` command to random node and returns its reply.
  #
  # @param subcommand [String, Symbol] the subcommand of cluster command
  #   e.g. `:slots`, `:nodes`, `:slaves`, `:info`
  # @return [Object] depends on the subcommand
  # @see https://redis.io/commands#cluster Reference of cluster command
  #
  # source://redis//lib/redis.rb#3268
  def cluster(subcommand, *args); end

  # Sends all commands in the queue.
  #
  # See http://redis.io/topics/pipelining for more details.
  #
  # source://redis//lib/redis.rb#104
  def commit; end

  # Get or set server configuration parameters.
  #
  # @param action [Symbol] e.g. `:get`, `:set`, `:resetstat`
  # @return [String, Hash] string reply, or hash when retrieving more than one
  #   property with `CONFIG GET`
  #
  # source://redis//lib/redis.rb#197
  def config(action, *args); end

  # Test whether or not the client is connected
  #
  # @return [Boolean]
  #
  # source://redis//lib/redis.rb#66
  def connected?; end

  # source://redis//lib/redis.rb#3307
  def connection; end

  # Return the number of keys in the selected database.
  #
  # @return [Fixnum]
  #
  # source://redis//lib/redis.rb#231
  def dbsize; end

  # source://redis//lib/redis.rb#237
  def debug(*args); end

  # Decrement the integer value of a key by one.
  #
  # @example
  #   redis.decr("value")
  #   # => 4
  # @param key [String]
  # @return [Fixnum] value after decrementing it
  #
  # source://redis//lib/redis.rb#707
  def decr(key); end

  # Decrement the integer value of a key by the given number.
  #
  # @example
  #   redis.decrby("value", 5)
  #   # => 0
  # @param key [String]
  # @param decrement [Fixnum]
  # @return [Fixnum] value after decrementing it
  #
  # source://redis//lib/redis.rb#722
  def decrby(key, decrement); end

  # Delete one or more keys.
  #
  # @param keys [String, Array<String>]
  # @return [Fixnum] number of keys that were deleted
  #
  # source://redis//lib/redis.rb#529
  def del(*keys); end

  # Discard all commands issued after MULTI.
  #
  # Only call this method when `#multi` was called **without** a block.
  #
  # @return [String] `"OK"`
  # @see #multi
  # @see #exec
  #
  # source://redis//lib/redis.rb#2486
  def discard; end

  # Disconnect the client as quickly and silently as possible.
  #
  # source://redis//lib/redis.rb#71
  def disconnect!; end

  # Return a serialized version of the value stored at a key.
  #
  # @param key [String]
  # @return [String] serialized_value
  #
  # source://redis//lib/redis.rb#476
  def dump(key); end

  # source://redis//lib/redis.rb#3303
  def dup; end

  # Echo the given string.
  #
  # @param value [String]
  # @return [String]
  #
  # source://redis//lib/redis.rb#154
  def echo(value); end

  # Evaluate Lua script.
  #
  # @example EVAL without KEYS nor ARGV
  #   redis.eval("return 1")
  #   # => 1
  # @example EVAL with KEYS and ARGV as array arguments
  #   redis.eval("return { KEYS, ARGV }", ["k1", "k2"], ["a1", "a2"])
  #   # => [["k1", "k2"], ["a1", "a2"]]
  # @example EVAL with KEYS and ARGV in a hash argument
  #   redis.eval("return { KEYS, ARGV }", :keys => ["k1", "k2"], :argv => ["a1", "a2"])
  #   # => [["k1", "k2"], ["a1", "a2"]]
  # @param keys [Array<String>] optional array with keys to pass to the script
  # @param argv [Array<String>] optional array with arguments to pass to the script
  # @param options [Hash] - `:keys => Array<String>`: optional array with keys to pass to the script
  #   - `:argv => Array<String>`: optional array with arguments to pass to the script
  # @return depends on the script
  # @see #script
  # @see #evalsha
  #
  # source://redis//lib/redis.rb#2574
  def eval(*args); end

  # Evaluate Lua script by its SHA.
  #
  # @example EVALSHA without KEYS nor ARGV
  #   redis.evalsha(sha)
  #   # => <depends on script>
  # @example EVALSHA with KEYS and ARGV as array arguments
  #   redis.evalsha(sha, ["k1", "k2"], ["a1", "a2"])
  #   # => <depends on script>
  # @example EVALSHA with KEYS and ARGV in a hash argument
  #   redis.evalsha(sha, :keys => ["k1", "k2"], :argv => ["a1", "a2"])
  #   # => <depends on script>
  # @param keys [Array<String>] optional array with keys to pass to the script
  # @param argv [Array<String>] optional array with arguments to pass to the script
  # @param options [Hash] - `:keys => Array<String>`: optional array with keys to pass to the script
  #   - `:argv => Array<String>`: optional array with arguments to pass to the script
  # @return depends on the script
  # @see #script
  # @see #eval
  #
  # source://redis//lib/redis.rb#2599
  def evalsha(*args); end

  # Execute all commands issued after MULTI.
  #
  # Only call this method when `#multi` was called **without** a block.
  #
  # @return [nil, Array<...>] - when commands were not executed, `nil`
  #   - when commands were executed, an array with their replies
  # @see #multi
  # @see #discard
  #
  # source://redis//lib/redis.rb#2472
  def exec; end

  # Determine if a key exists.
  #
  # @param key [String]
  # @return [Boolean]
  #
  # source://redis//lib/redis.rb#549
  def exists(key); end

  # Set a key's time to live in seconds.
  #
  # @param key [String]
  # @param seconds [Fixnum] time to live
  # @return [Boolean] whether the timeout was set or not
  #
  # source://redis//lib/redis.rb#398
  def expire(key, seconds); end

  # Set the expiration for a key as a UNIX timestamp.
  #
  # @param key [String]
  # @param unix_time [Fixnum] expiry time specified as a UNIX timestamp
  # @return [Boolean] whether the timeout was set or not
  #
  # source://redis//lib/redis.rb#409
  def expireat(key, unix_time); end

  # Remove all keys from all databases.
  #
  # @param options [Hash] - `:async => Boolean`: async flush (default: false)
  # @return [String] `OK`
  #
  # source://redis//lib/redis.rb#248
  def flushall(options = T.unsafe(nil)); end

  # Remove all keys from the current database.
  #
  # @param options [Hash] - `:async => Boolean`: async flush (default: false)
  # @return [String] `OK`
  #
  # source://redis//lib/redis.rb#263
  def flushdb(options = T.unsafe(nil)); end

  # Adds the specified geospatial items (latitude, longitude, name) to the specified key
  #
  # @param key [String]
  # @param member [Array] arguemnts for member or members: longitude, latitude, name
  # @return [Intger] number of elements added to the sorted set
  #
  # source://redis//lib/redis.rb#2819
  def geoadd(key, *member); end

  # Returns the distance between two members of a geospatial index
  #
  # @param key [String]
  # @param members [Array<String>]
  # @param unit ['m', 'km', 'mi', 'ft']
  # @return [String, nil] returns distance in spefied unit if both members present, nil otherwise.
  #
  # source://redis//lib/redis.rb#2888
  def geodist(key, member1, member2, unit = T.unsafe(nil)); end

  # Returns geohash string representing position for specified members of the specified key.
  #
  # @param key [String]
  # @param member [String, Array<String>] one member or array of members
  # @return [Array<String, nil>] returns array containg geohash string if member is present, nil otherwise
  #
  # source://redis//lib/redis.rb#2830
  def geohash(key, member); end

  # Returns longitude and latitude of members of a geospatial index
  #
  # @param key [String]
  # @param member [String, Array<String>] one member or array of members
  # @return [Array<Array<String>, nil>] returns array of elements, where each element is either array of longitude and latitude or nil
  #
  # source://redis//lib/redis.rb#2876
  def geopos(key, member); end

  # Query a sorted set representing a geospatial index to fetch members matching a
  # given maximum distance from a point
  #
  # @param args [Array] key, longitude, latitude, radius, unit(m|km|ft|mi)
  # @param sort ['asc', 'desc'] sort returned items from the nearest to the farthest or the farthest to the nearest relative to the center
  # @param count [Integer] limit the results to the first N matching items
  # @param options ['WITHDIST', 'WITHCOORD', 'WITHHASH'] to return additional information
  # @return [Array<String>] may be changed with `options`
  #
  # source://redis//lib/redis.rb#2846
  def georadius(*args, **geoptions); end

  # Query a sorted set representing a geospatial index to fetch members matching a
  # given maximum distance from an already existing member
  #
  # @param args [Array] key, member, radius, unit(m|km|ft|mi)
  # @param sort ['asc', 'desc'] sort returned items from the nearest to the farthest or the farthest to the nearest relative to the center
  # @param count [Integer] limit the results to the first N matching items
  # @param options ['WITHDIST', 'WITHCOORD', 'WITHHASH'] to return additional information
  # @return [Array<String>] may be changed with `options`
  #
  # source://redis//lib/redis.rb#2863
  def georadiusbymember(*args, **geoptions); end

  # Get the value of a key.
  #
  # @param key [String]
  # @return [String]
  #
  # source://redis//lib/redis.rb#905
  def get(key); end

  # Returns the bit value at offset in the string value stored at key.
  #
  # @param key [String]
  # @param offset [Fixnum] bit offset
  # @return [Fixnum] `0` or `1`
  #
  # source://redis//lib/redis.rb#989
  def getbit(key, offset); end

  # Get a substring of the string stored at a key.
  #
  # @param key [String]
  # @param start [Fixnum] zero-based start offset
  # @param stop [Fixnum] zero-based end offset. Use -1 for representing
  #   the end of the string
  # @return [Fixnum] `0` or `1`
  #
  # source://redis//lib/redis.rb#966
  def getrange(key, start, stop); end

  # Set the string value of a key and return its old value.
  #
  # @param key [String]
  # @param value [String] value to replace the current value with
  # @return [String] the old value stored in the key, or `nil` if the key
  #   did not exist
  #
  # source://redis//lib/redis.rb#1057
  def getset(key, value); end

  # Delete one or more hash fields.
  #
  # @param key [String]
  # @param field [String, Array<String>]
  # @return [Fixnum] the number of fields that were removed from the hash
  #
  # source://redis//lib/redis.rb#2206
  def hdel(key, *fields); end

  # Determine if a hash field exists.
  #
  # @param key [String]
  # @param field [String]
  # @return [Boolean] whether or not the field exists in the hash
  #
  # source://redis//lib/redis.rb#2217
  def hexists(key, field); end

  # Get the value of a hash field.
  #
  # @param key [String]
  # @param field [String]
  # @return [String]
  #
  # source://redis//lib/redis.rb#2157
  def hget(key, field); end

  # Get all the fields and values in a hash.
  #
  # @param key [String]
  # @return [Hash<String, String>]
  #
  # source://redis//lib/redis.rb#2271
  def hgetall(key); end

  # Increment the integer value of a hash field by the given integer number.
  #
  # @param key [String]
  # @param field [String]
  # @param increment [Fixnum]
  # @return [Fixnum] value of the field after incrementing it
  #
  # source://redis//lib/redis.rb#2229
  def hincrby(key, field, increment); end

  # Increment the numeric value of a hash field by the given float number.
  #
  # @param key [String]
  # @param field [String]
  # @param increment [Float]
  # @return [Float] value of the field after incrementing it
  #
  # source://redis//lib/redis.rb#2241
  def hincrbyfloat(key, field, increment); end

  # Get all the fields in a hash.
  #
  # @param key [String]
  # @return [Array<String>]
  #
  # source://redis//lib/redis.rb#2251
  def hkeys(key); end

  # Get the number of fields in a hash.
  #
  # @param key [String]
  # @return [Fixnum] number of fields in the hash
  #
  # source://redis//lib/redis.rb#2090
  def hlen(key); end

  # Get the values of all the given hash fields.
  #
  # @example
  #   redis.hmget("hash", "f1", "f2")
  #   # => ["v1", "v2"]
  # @param key [String]
  # @param fields [Array<String>] array of fields
  # @return [Array<String>] an array of values for the specified fields
  # @see #mapped_hmget
  #
  # source://redis//lib/redis.rb#2174
  def hmget(key, *fields, &blk); end

  # Set one or more hash values.
  #
  # @example
  #   redis.hmset("hash", "f1", "v1", "f2", "v2")
  #   # => "OK"
  # @param key [String]
  # @param attrs [Array<String>] array of fields and values
  # @return [String] `"OK"`
  # @see #mapped_hmset
  #
  # source://redis//lib/redis.rb#2131
  def hmset(key, *attrs); end

  # Scan a hash
  #
  # @example Retrieve the first batch of key/value pairs in a hash
  #   redis.hscan("hash", 0)
  # @param cursor [String, Integer] the cursor of the iteration
  # @param options [Hash] - `:match => String`: only return keys matching the pattern
  #   - `:count => Integer`: return count keys at most per iteration
  # @return [String, Array<[String, String]>] the next cursor and all found keys
  #
  # source://redis//lib/redis.rb#2676
  def hscan(key, cursor, options = T.unsafe(nil)); end

  # Scan a hash
  #
  # @example Retrieve all of the key/value pairs in a hash
  #   redis.hscan_each("hash").to_a
  #   # => [["key70", "70"], ["key80", "80"]]
  # @param options [Hash] - `:match => String`: only return keys matching the pattern
  #   - `:count => Integer`: return count keys at most per iteration
  # @return [Enumerator] an enumerator for all found keys
  #
  # source://redis//lib/redis.rb#2693
  def hscan_each(key, options = T.unsafe(nil), &block); end

  # Set the string value of a hash field.
  #
  # @param key [String]
  # @param field [String]
  # @param value [String]
  # @return [Boolean] whether or not the field was **added** to the hash
  #
  # source://redis//lib/redis.rb#2102
  def hset(key, field, value); end

  # Set the value of a hash field, only if the field does not exist.
  #
  # @param key [String]
  # @param field [String]
  # @param value [String]
  # @return [Boolean] whether or not the field was **added** to the hash
  #
  # source://redis//lib/redis.rb#2114
  def hsetnx(key, field, value); end

  # Get all the values in a hash.
  #
  # @param key [String]
  # @return [Array<String>]
  #
  # source://redis//lib/redis.rb#2261
  def hvals(key); end

  # source://redis//lib/redis.rb#3295
  def id; end

  # Increment the integer value of a key by one.
  #
  # @example
  #   redis.incr("value")
  #   # => 6
  # @param key [String]
  # @return [Fixnum] value after incrementing it
  #
  # source://redis//lib/redis.rb#736
  def incr(key); end

  # Increment the integer value of a key by the given integer number.
  #
  # @example
  #   redis.incrby("value", 5)
  #   # => 10
  # @param key [String]
  # @param increment [Fixnum]
  # @return [Fixnum] value after incrementing it
  #
  # source://redis//lib/redis.rb#751
  def incrby(key, increment); end

  # Increment the numeric value of a key by the given float number.
  #
  # @example
  #   redis.incrbyfloat("value", 1.23)
  #   # => 1.23
  # @param key [String]
  # @param increment [Float]
  # @return [Float] value after incrementing it
  #
  # source://redis//lib/redis.rb#766
  def incrbyfloat(key, increment); end

  # Get information and statistics about the server.
  #
  # @param cmd [String, Symbol] e.g. "commandstats"
  # @return [Hash<String, String>]
  #
  # source://redis//lib/redis.rb#277
  def info(cmd = T.unsafe(nil)); end

  # source://redis//lib/redis.rb#3299
  def inspect; end

  # Find all keys matching the given pattern.
  #
  # @param pattern [String]
  # @return [Array<String>]
  #
  # source://redis//lib/redis.rb#559
  def keys(pattern = T.unsafe(nil)); end

  # Get the UNIX time stamp of the last successful save to disk.
  #
  # @return [Fixnum]
  #
  # source://redis//lib/redis.rb#300
  def lastsave; end

  # Get an element from a list by its index.
  #
  # @param key [String]
  # @param index [Fixnum]
  # @return [String]
  #
  # source://redis//lib/redis.rb#1256
  def lindex(key, index); end

  # Insert an element before or after another element in a list.
  #
  # @param key [String]
  # @param where [String, Symbol] `BEFORE` or `AFTER`
  # @param pivot [String] reference element
  # @param value [String]
  # @return [Fixnum] length of the list after the insert operation, or `-1`
  #   when the element `pivot` was not found
  #
  # source://redis//lib/redis.rb#1270
  def linsert(key, where, pivot, value); end

  # Get the length of a list.
  #
  # @param key [String]
  # @return [Fixnum]
  #
  # source://redis//lib/redis.rb#1078
  def llen(key); end

  # Remove and get the first element in a list.
  #
  # @param key [String]
  # @return [String]
  #
  # source://redis//lib/redis.rb#1132
  def lpop(key); end

  # Prepend one or more values to a list, creating the list if it doesn't exist
  #
  # @param key [String]
  # @param value [String, Array<String>] string value, or array of string values to push
  # @return [Fixnum] the length of the list after the push operation
  #
  # source://redis//lib/redis.rb#1089
  def lpush(key, value); end

  # Prepend a value to a list, only if the list exists.
  #
  # @param key [String]
  # @param value [String]
  # @return [Fixnum] the length of the list after the push operation
  #
  # source://redis//lib/redis.rb#1100
  def lpushx(key, value); end

  # Get a range of elements from a list.
  #
  # @param key [String]
  # @param start [Fixnum] start index
  # @param stop [Fixnum] stop index
  # @return [Array<String>]
  #
  # source://redis//lib/redis.rb#1282
  def lrange(key, start, stop); end

  # Remove elements from a list.
  #
  # @param key [String]
  # @param count [Fixnum] number of elements to remove. Use a positive
  #   value to remove the first `count` occurrences of `value`. A negative
  #   value to remove the last `count` occurrences of `value`. Or zero, to
  #   remove all occurrences of `value` from the list.
  # @param value [String]
  # @return [Fixnum] the number of removed elements
  #
  # source://redis//lib/redis.rb#1297
  def lrem(key, count, value); end

  # Set the value of an element in a list by its index.
  #
  # @param key [String]
  # @param index [Fixnum]
  # @param value [String]
  # @return [String] `OK`
  #
  # source://redis//lib/redis.rb#1309
  def lset(key, index, value); end

  # Trim a list to the specified range.
  #
  # @param key [String]
  # @param start [Fixnum] start index
  # @param stop [Fixnum] stop index
  # @return [String] `OK`
  #
  # source://redis//lib/redis.rb#1321
  def ltrim(key, start, stop); end

  # Get the values of all the given hash fields.
  #
  # @example
  #   redis.mapped_hmget("hash", "f1", "f2")
  #   # => { "f1" => "v1", "f2" => "v2" }
  # @param key [String]
  # @param fields [Array<String>] array of fields
  # @return [Hash] a hash mapping the specified fields to their values
  # @see #hmget
  #
  # source://redis//lib/redis.rb#2191
  def mapped_hmget(key, *fields); end

  # Set one or more hash values.
  #
  # @example
  #   redis.mapped_hmset("hash", { "f1" => "v1", "f2" => "v2" })
  #   # => "OK"
  # @param key [String]
  # @param hash [Hash] a non-empty hash with fields mapping to values
  # @return [String] `"OK"`
  # @see #hmset
  #
  # source://redis//lib/redis.rb#2148
  def mapped_hmset(key, hash); end

  # Get the values of all the given keys.
  #
  # @example
  #   redis.mapped_mget("key1", "key2")
  #   # => { "key1" => "v1", "key2" => "v2" }
  # @param keys [Array<String>] array of keys
  # @return [Hash] a hash mapping the specified keys to their values
  # @see #mget
  #
  # source://redis//lib/redis.rb#937
  def mapped_mget(*keys); end

  # Set one or more values.
  #
  # @example
  #   redis.mapped_mset({ "f1" => "v1", "f2" => "v2" })
  #   # => "OK"
  # @param hash [Hash] keys mapping to values
  # @return [String] `"OK"`
  # @see #mset
  #
  # source://redis//lib/redis.rb#867
  def mapped_mset(hash); end

  # Set one or more values, only if none of the keys exist.
  #
  # @example
  #   redis.mapped_msetnx({ "key1" => "v1", "key2" => "v2" })
  #   # => true
  # @param hash [Hash] keys mapping to values
  # @return [Boolean] whether or not all values were set
  # @see #msetnx
  #
  # source://redis//lib/redis.rb#897
  def mapped_msetnx(hash); end

  # source://redis//lib/redis.rb#3319
  def method_missing(command, *args); end

  # Get the values of all the given keys.
  #
  # @example
  #   redis.mget("key1", "key1")
  #   # => ["v1", "v2"]
  # @param keys [Array<String>]
  # @return [Array<String>] an array of values for the specified keys
  # @see #mapped_mget
  #
  # source://redis//lib/redis.rb#921
  def mget(*keys, &blk); end

  # Transfer a key from the connected instance to another instance.
  #
  # @param key [String, Array<String>]
  # @param options [Hash] - `:host => String`: host of instance to migrate to
  #   - `:port => Integer`: port of instance to migrate to
  #   - `:db => Integer`: database to migrate to (default: same as source)
  #   - `:timeout => Integer`: timeout (default: same as connection timeout)
  #   - `:copy => Boolean`: Do not remove the key from the local instance.
  #   - `:replace => Boolean`: Replace existing key on the remote instance.
  # @return [String] `"OK"`
  #
  # source://redis//lib/redis.rb#511
  def migrate(key, options); end

  # Listen for all requests received by the server in real time.
  #
  # There is no way to interrupt this command.
  #
  # @yield a block to be called for every line of output
  # @yieldparam line [String] timestamp and command that was executed
  #
  # source://redis//lib/redis.rb#312
  def monitor(&block); end

  # Move a key to another database.
  #
  # @example Move a key to another database
  #   redis.set "foo", "bar"
  #   # => "OK"
  #   redis.move "foo", 2
  #   # => true
  #   redis.exists "foo"
  #   # => false
  #   redis.select 2
  #   # => "OK"
  #   redis.exists "foo"
  #   # => true
  #   redis.get "foo"
  #   # => "bar"
  # @param key [String]
  # @param db [Fixnum]
  # @return [Boolean] whether the key was moved or not
  #
  # source://redis//lib/redis.rb#590
  def move(key, db); end

  # Set one or more values.
  #
  # @example
  #   redis.mset("key1", "v1", "key2", "v2")
  #   # => "OK"
  # @param args [Array<String>] array of keys and values
  # @return [String] `"OK"`
  # @see #mapped_mset
  #
  # source://redis//lib/redis.rb#851
  def mset(*args); end

  # Set one or more values, only if none of the keys exist.
  #
  # @example
  #   redis.msetnx("key1", "v1", "key2", "v2")
  #   # => true
  # @param args [Array<String>] array of keys and values
  # @return [Boolean] whether or not all values were set
  # @see #mapped_msetnx
  #
  # source://redis//lib/redis.rb#881
  def msetnx(*args); end

  # Mark the start of a transaction block.
  #
  # Passing a block is optional.
  #
  # @example With a block
  #   redis.multi do |multi|
  #   multi.set("key", "value")
  #   multi.incr("counter")
  #   end # => ["OK", 6]
  # @example Without a block
  #   redis.multi
  #   # => "OK"
  #   redis.set("key", "value")
  #   # => "QUEUED"
  #   redis.incr("counter")
  #   # => "QUEUED"
  #   redis.exec
  #   # => ["OK", 6]
  # @return [String, Array<...>] - when a block is not given, `OK`
  #   - when a block is given, an array with replies
  # @see #watch
  # @see #unwatch
  # @yield [multi] the commands that are called inside this block are cached
  #   and written to the server upon returning from it
  # @yieldparam multi [Redis] `self`
  #
  # source://redis//lib/redis.rb#2445
  def multi; end

  # source://redis//lib/redis.rb#596
  def object(*args); end

  # Remove the expiration from a key.
  #
  # @param key [String]
  # @return [Boolean] whether the timeout was removed or not
  #
  # source://redis//lib/redis.rb#387
  def persist(key); end

  # Set a key's time to live in milliseconds.
  #
  # @param key [String]
  # @param milliseconds [Fixnum] time to live
  # @return [Boolean] whether the timeout was set or not
  #
  # source://redis//lib/redis.rb#438
  def pexpire(key, milliseconds); end

  # Set the expiration for a key as number of milliseconds from UNIX Epoch.
  #
  # @param key [String]
  # @param ms_unix_time [Fixnum] expiry time specified as number of milliseconds from UNIX Epoch.
  # @return [Boolean] whether the timeout was set or not
  #
  # source://redis//lib/redis.rb#449
  def pexpireat(key, ms_unix_time); end

  # Add one or more members to a HyperLogLog structure.
  #
  # @param key [String]
  # @param member [String, Array<String>] one member, or array of members
  # @return [Boolean] true if at least 1 HyperLogLog internal register was altered. false otherwise.
  #
  # source://redis//lib/redis.rb#2783
  def pfadd(key, member); end

  # Get the approximate cardinality of members added to HyperLogLog structure.
  #
  # If called with multiple keys, returns the approximate cardinality of the
  # union of the HyperLogLogs contained in the keys.
  #
  # @param keys [String, Array<String>]
  # @return [Fixnum]
  #
  # source://redis//lib/redis.rb#2796
  def pfcount(*keys); end

  # Merge multiple HyperLogLog values into an unique value that will approximate the cardinality of the union of
  # the observed Sets of the source HyperLogLog structures.
  #
  # @param dest_key [String] destination key
  # @param source_key [String, Array<String>] source key, or array of keys
  # @return [Boolean]
  #
  # source://redis//lib/redis.rb#2808
  def pfmerge(dest_key, *source_key); end

  # Ping the server.
  #
  # @param message [optional, String]
  # @return [String] `PONG`
  #
  # source://redis//lib/redis.rb#144
  def ping(message = T.unsafe(nil)); end

  # source://redis//lib/redis.rb#2403
  def pipelined; end

  # Set the time to live in milliseconds of a key.
  #
  # @param key [String]
  # @param ttl [Fixnum]
  # @param value [String]
  # @return [String] `"OK"`
  #
  # source://redis//lib/redis.rb#824
  def psetex(key, ttl, value); end

  # Listen for messages published to channels matching the given patterns.
  #
  # source://redis//lib/redis.rb#2313
  def psubscribe(*channels, &block); end

  # Listen for messages published to channels matching the given patterns. Throw a timeout error if there is no messages for a timeout period.
  #
  # source://redis//lib/redis.rb#2320
  def psubscribe_with_timeout(timeout, *channels, &block); end

  # Get the time to live (in milliseconds) for a key.
  #
  # In Redis 2.6 or older the command returns -1 if the key does not exist or if
  # the key exist but has no associated expire.
  #
  # Starting with Redis 2.8 the return value in case of error changed:
  #
  #     - The command returns -2 if the key does not exist.
  #     - The command returns -1 if the key exists but has no associated expire.
  #
  # @param key [String]
  # @return [Fixnum] remaining time to live in milliseconds
  #
  # source://redis//lib/redis.rb#466
  def pttl(key); end

  # Post a message to a channel.
  #
  # source://redis//lib/redis.rb#2278
  def publish(channel, message); end

  # Inspect the state of the Pub/Sub subsystem.
  # Possible subcommands: channels, numsub, numpat.
  #
  # source://redis//lib/redis.rb#2336
  def pubsub(subcommand, *args); end

  # Stop listening for messages posted to channels matching the given patterns.
  #
  # source://redis//lib/redis.rb#2327
  def punsubscribe(*channels); end

  # Queues a command for pipelining.
  #
  # Commands in the queue are executed with the Redis#commit method.
  #
  # See http://redis.io/topics/pipelining for more details.
  #
  # source://redis//lib/redis.rb#96
  def queue(*command); end

  # Close the connection.
  #
  # @return [String] `OK`
  #
  # source://redis//lib/redis.rb#163
  def quit; end

  # Return a random key from the keyspace.
  #
  # @return [String]
  #
  # source://redis//lib/redis.rb#605
  def randomkey; end

  # Rename a key. If the new key already exists it is overwritten.
  #
  # @param old_name [String]
  # @param new_name [String]
  # @return [String] `OK`
  #
  # source://redis//lib/redis.rb#616
  def rename(old_name, new_name); end

  # Rename a key, only if the new key does not exist.
  #
  # @param old_name [String]
  # @param new_name [String]
  # @return [Boolean] whether the key was renamed or not
  #
  # source://redis//lib/redis.rb#627
  def renamenx(old_name, new_name); end

  # Create a key using the serialized value, previously obtained using DUMP.
  #
  # @param key [String]
  # @param ttl [String]
  # @param serialized_value [String]
  # @param options [Hash] - `:replace => Boolean`: if false, raises an error if key already exists
  # @raise [Redis::CommandError]
  # @return [String] `"OK"`
  #
  # source://redis//lib/redis.rb#491
  def restore(key, ttl, serialized_value, options = T.unsafe(nil)); end

  # Remove and get the last element in a list.
  #
  # @param key [String]
  # @return [String]
  #
  # source://redis//lib/redis.rb#1142
  def rpop(key); end

  # Remove the last element in a list, append it to another list and return it.
  #
  # @param source [String] source key
  # @param destination [String] destination key
  # @return [nil, String] the element, or nil when the source key does not exist
  #
  # source://redis//lib/redis.rb#1153
  def rpoplpush(source, destination); end

  # Append one or more values to a list, creating the list if it doesn't exist
  #
  # @param key [String]
  # @param value [String, Array<String>] string value, or array of string values to push
  # @return [Fixnum] the length of the list after the push operation
  #
  # source://redis//lib/redis.rb#1111
  def rpush(key, value); end

  # Append a value to a list, only if the list exists.
  #
  # @param key [String]
  # @param value [String]
  # @return [Fixnum] the length of the list after the push operation
  #
  # source://redis//lib/redis.rb#1122
  def rpushx(key, value); end

  # Add one or more members to a set.
  #
  # @param key [String]
  # @param member [String, Array<String>] one member, or array of members
  # @return [Boolean, Fixnum] `Boolean` when a single member is specified,
  #   holding whether or not adding the member succeeded, or `Fixnum` when an
  #   array of members is specified, holding the number of members that were
  #   successfully added
  #
  # source://redis//lib/redis.rb#1345
  def sadd(key, member); end

  # Synchronously save the dataset to disk.
  #
  # @return [String]
  #
  # source://redis//lib/redis.rb#321
  def save; end

  # Scan the keyspace
  #
  # @example Retrieve the first batch of keys
  #   redis.scan(0)
  #   # => ["4", ["key:21", "key:47", "key:42"]]
  # @example Retrieve a batch of keys matching a pattern
  #   redis.scan(4, :match => "key:1?")
  #   # => ["92", ["key:13", "key:18"]]
  # @param cursor [String, Integer] the cursor of the iteration
  # @param options [Hash] - `:match => String`: only return keys matching the pattern
  #   - `:count => Integer`: return count keys at most per iteration
  # @return [String, Array<String>] the next cursor and all found keys
  #
  # source://redis//lib/redis.rb#2636
  def scan(cursor, options = T.unsafe(nil)); end

  # Scan the keyspace
  #
  # @example Retrieve all of the keys (with possible duplicates)
  #   redis.scan_each.to_a
  #   # => ["key:21", "key:47", "key:42"]
  # @example Execute block for each key matching a pattern
  #   redis.scan_each(:match => "key:1?") {|key| puts key}
  #   # => key:13
  #   # => key:18
  # @param options [Hash] - `:match => String`: only return keys matching the pattern
  #   - `:count => Integer`: return count keys at most per iteration
  # @return [Enumerator] an enumerator for all found keys
  #
  # source://redis//lib/redis.rb#2655
  def scan_each(options = T.unsafe(nil), &block); end

  # Get the number of members in a set.
  #
  # @param key [String]
  # @return [Fixnum]
  #
  # source://redis//lib/redis.rb#1331
  def scard(key); end

  # Control remote script registry.
  #
  # @example Load a script
  #   sha = redis.script(:load, "return 1")
  #   # => <sha of this script>
  # @example Check if a script exists
  #   redis.script(:exists, sha)
  #   # => true
  # @example Check if multiple scripts exist
  #   redis.script(:exists, [sha, other_sha])
  #   # => [true, false]
  # @example Flush the script registry
  #   redis.script(:flush)
  #   # => "OK"
  # @example Kill a running script
  #   redis.script(:kill)
  #   # => "OK"
  # @param subcommand [String] e.g. `exists`, `flush`, `load`, `kill`
  # @param args [Array<String>] depends on subcommand
  # @return [String, Boolean, Array<Boolean>, ...] depends on subcommand
  # @see #eval
  # @see #evalsha
  #
  # source://redis//lib/redis.rb#2516
  def script(subcommand, *args); end

  # Subtract multiple sets.
  #
  # @param keys [String, Array<String>] keys pointing to sets to subtract
  # @return [Array<String>] members in the difference
  #
  # source://redis//lib/redis.rb#1448
  def sdiff(*keys); end

  # Subtract multiple sets and store the resulting set in a key.
  #
  # @param destination [String] destination key
  # @param keys [String, Array<String>] keys pointing to sets to subtract
  # @return [Fixnum] number of elements in the resulting set
  #
  # source://redis//lib/redis.rb#1459
  def sdiffstore(destination, *keys); end

  # Change the selected database for the current connection.
  #
  # @param db [Fixnum] zero-based index of the DB to use (0 to 15)
  # @return [String] `OK`
  #
  # source://redis//lib/redis.rb#133
  def select(db); end

  # Interact with the sentinel command (masters, master, slaves, failover)
  #
  # @param subcommand [String] e.g. `masters`, `master`, `slaves`
  # @param args [Array<String>] depends on subcommand
  # @return [Array<String>, Hash<String, String>, String] depends on subcommand
  #
  # source://redis//lib/redis.rb#3238
  def sentinel(subcommand, *args); end

  # Set the string value of a key.
  #
  # @param key [String]
  # @param value [String]
  # @param options [Hash] - `:ex => Fixnum`: Set the specified expire time, in seconds.
  #   - `:px => Fixnum`: Set the specified expire time, in milliseconds.
  #   - `:nx => true`: Only set the key if it does not already exist.
  #   - `:xx => true`: Only set the key if it already exist.
  # @return [String, Boolean] `"OK"` or true, false if `:nx => true` or `:xx => true`
  #
  # source://redis//lib/redis.rb#782
  def set(key, value, options = T.unsafe(nil)); end

  # Sets or clears the bit at offset in the string value stored at key.
  #
  # @param key [String]
  # @param offset [Fixnum] bit offset
  # @param value [Fixnum] bit value `0` or `1`
  # @return [Fixnum] the original bit value stored at `offset`
  #
  # source://redis//lib/redis.rb#978
  def setbit(key, offset, value); end

  # Set the time to live in seconds of a key.
  #
  # @param key [String]
  # @param ttl [Fixnum]
  # @param value [String]
  # @return [String] `"OK"`
  #
  # source://redis//lib/redis.rb#812
  def setex(key, ttl, value); end

  # Set the value of a key, only if the key does not exist.
  #
  # @param key [String]
  # @param value [String]
  # @return [Boolean] whether the key was set or not
  #
  # source://redis//lib/redis.rb#835
  def setnx(key, value); end

  # Overwrite part of a string at key starting at the specified offset.
  #
  # @param key [String]
  # @param offset [Fixnum] byte offset
  # @param value [String]
  # @return [Fixnum] length of the string after it was modified
  #
  # source://redis//lib/redis.rb#953
  def setrange(key, offset, value); end

  # Synchronously save the dataset to disk and then shut down the server.
  #
  # source://redis//lib/redis.rb#328
  def shutdown; end

  # Intersect multiple sets.
  #
  # @param keys [String, Array<String>] keys pointing to sets to intersect
  # @return [Array<String>] members in the intersection
  #
  # source://redis//lib/redis.rb#1469
  def sinter(*keys); end

  # Intersect multiple sets and store the resulting set in a key.
  #
  # @param destination [String] destination key
  # @param keys [String, Array<String>] keys pointing to sets to intersect
  # @return [Fixnum] number of elements in the resulting set
  #
  # source://redis//lib/redis.rb#1480
  def sinterstore(destination, *keys); end

  # Determine if a given value is a member of a set.
  #
  # @param key [String]
  # @param member [String]
  # @return [Boolean]
  #
  # source://redis//lib/redis.rb#1428
  def sismember(key, member); end

  # Make the server a slave of another instance, or promote it as master.
  #
  # source://redis//lib/redis.rb#342
  def slaveof(host, port); end

  # Interact with the slowlog (get, len, reset)
  #
  # @param subcommand [String] e.g. `get`, `len`, `reset`
  # @param length [Fixnum] maximum number of entries to return
  # @return [Array<String>, Fixnum, String] depends on subcommand
  #
  # source://redis//lib/redis.rb#353
  def slowlog(subcommand, length = T.unsafe(nil)); end

  # Get all the members in a set.
  #
  # @param key [String]
  # @return [Array<String>]
  #
  # source://redis//lib/redis.rb#1438
  def smembers(key); end

  # Move a member from one set to another.
  #
  # @param source [String] source key
  # @param destination [String] destination key
  # @param member [String] member to move from `source` to `destination`
  # @return [Boolean]
  #
  # source://redis//lib/redis.rb#1417
  def smove(source, destination, member); end

  # Sort the elements in a list, set or sorted set.
  #
  # @example Retrieve the first 2 elements from an alphabetically sorted "list"
  #   redis.sort("list", :order => "alpha", :limit => [0, 2])
  #   # => ["a", "b"]
  # @example Store an alphabetically descending list in "target"
  #   redis.sort("list", :order => "desc alpha", :store => "target")
  #   # => 26
  # @param key [String]
  # @param options [Hash] - `:by => String`: use external key to sort elements by
  #   - `:limit => [offset, count]`: skip `offset` elements, return a maximum
  #   of `count` elements
  #   - `:get => [String, Array<String>]`: single key or array of keys to
  #   retrieve per element in the result
  #   - `:order => String`: combination of `ASC`, `DESC` and optionally `ALPHA`
  #   - `:store => String`: key to store the result at
  # @return [Array<String>, Array<Array<String>>, Fixnum] - when `:get` is not specified, or holds a single element, an array of elements
  #   - when `:get` is specified, and holds more than one element, an array of
  #   elements where every element is an array with the result for every
  #   element specified in `:get`
  #   - when `:store` is specified, the number of elements in the stored result
  #
  # source://redis//lib/redis.rb#658
  def sort(key, options = T.unsafe(nil)); end

  # Remove and return one or more random member from a set.
  #
  # @param key [String]
  # @param count [Fixnum]
  # @return [String]
  #
  # source://redis//lib/redis.rb#1386
  def spop(key, count = T.unsafe(nil)); end

  # Get one or more random members from a set.
  #
  # @param key [String]
  # @param count [Fixnum]
  # @return [String]
  #
  # source://redis//lib/redis.rb#1401
  def srandmember(key, count = T.unsafe(nil)); end

  # Remove one or more members from a set.
  #
  # @param key [String]
  # @param member [String, Array<String>] one member, or array of members
  # @return [Boolean, Fixnum] `Boolean` when a single member is specified,
  #   holding whether or not removing the member succeeded, or `Fixnum` when an
  #   array of members is specified, holding the number of members that were
  #   successfully removed
  #
  # source://redis//lib/redis.rb#1367
  def srem(key, member); end

  # Scan a set
  #
  # @example Retrieve the first batch of keys in a set
  #   redis.sscan("set", 0)
  # @param cursor [String, Integer] the cursor of the iteration
  # @param options [Hash] - `:match => String`: only return keys matching the pattern
  #   - `:count => Integer`: return count keys at most per iteration
  # @return [String, Array<String>] the next cursor and all found members
  #
  # source://redis//lib/redis.rb#2753
  def sscan(key, cursor, options = T.unsafe(nil)); end

  # Scan a set
  #
  # @example Retrieve all of the keys in a set
  #   redis.sscan_each("set").to_a
  #   # => ["key1", "key2", "key3"]
  # @param options [Hash] - `:match => String`: only return keys matching the pattern
  #   - `:count => Integer`: return count keys at most per iteration
  # @return [Enumerator] an enumerator for all keys in the set
  #
  # source://redis//lib/redis.rb#2768
  def sscan_each(key, options = T.unsafe(nil), &block); end

  # Get the length of the value stored in a key.
  #
  # @param key [String]
  # @return [Fixnum] the length of the value stored in the key, or 0
  #   if the key does not exist
  #
  # source://redis//lib/redis.rb#1068
  def strlen(key); end

  # Listen for messages published to the given channels.
  #
  # source://redis//lib/redis.rb#2291
  def subscribe(*channels, &block); end

  # Listen for messages published to the given channels. Throw a timeout error if there is no messages for a timeout period.
  #
  # source://redis//lib/redis.rb#2298
  def subscribe_with_timeout(timeout, *channels, &block); end

  # @return [Boolean]
  #
  # source://redis//lib/redis.rb#2284
  def subscribed?; end

  # Add multiple sets.
  #
  # @param keys [String, Array<String>] keys pointing to sets to unify
  # @return [Array<String>] members in the union
  #
  # source://redis//lib/redis.rb#1490
  def sunion(*keys); end

  # Add multiple sets and store the resulting set in a key.
  #
  # @param destination [String] destination key
  # @param keys [String, Array<String>] keys pointing to sets to unify
  # @return [Fixnum] number of elements in the resulting set
  #
  # source://redis//lib/redis.rb#1501
  def sunionstore(destination, *keys); end

  # Internal command used for replication.
  #
  # source://redis//lib/redis.rb#362
  def sync; end

  # source://redis//lib/redis.rb#49
  def synchronize; end

  # Return the server time.
  #
  # @example
  #   r.time # => [ 1333093196, 606806 ]
  # @return [Array<Fixnum>] tuple of seconds since UNIX epoch and
  #   microseconds in the current second
  #
  # source://redis//lib/redis.rb#375
  def time; end

  # Get the time to live (in seconds) for a key.
  #
  # In Redis 2.6 or older the command returns -1 if the key does not exist or if
  # the key exist but has no associated expire.
  #
  # Starting with Redis 2.8 the return value in case of error changed:
  #
  #     - The command returns -2 if the key does not exist.
  #     - The command returns -1 if the key exists but has no associated expire.
  #
  # @param key [String]
  # @return [Fixnum] remaining time to live in seconds.
  #
  # source://redis//lib/redis.rb#427
  def ttl(key); end

  # Determine the type stored at key.
  #
  # @param key [String]
  # @return [String] `string`, `list`, `set`, `zset`, `hash` or `none`
  #
  # source://redis//lib/redis.rb#693
  def type(key); end

  # Unlink one or more keys.
  #
  # @param keys [String, Array<String>]
  # @return [Fixnum] number of keys that were unlinked
  #
  # source://redis//lib/redis.rb#539
  def unlink(*keys); end

  # Stop listening for messages posted to the given channels.
  #
  # source://redis//lib/redis.rb#2305
  def unsubscribe(*channels); end

  # Forget about all watched keys.
  #
  # @return [String] `OK`
  # @see #watch
  # @see #multi
  #
  # source://redis//lib/redis.rb#2397
  def unwatch; end

  # Watch the given keys to determine execution of the MULTI/EXEC block.
  #
  # Using a block is optional, but is necessary for thread-safety.
  #
  # An `#unwatch` is automatically issued if an exception is raised within the
  # block that is a subclass of StandardError and is not a ConnectionError.
  #
  # @example With a block
  #   redis.watch("key") do
  #   if redis.get("key") == "some value"
  #   redis.multi do |multi|
  #   multi.set("key", "other value")
  #   multi.incr("counter")
  #   end
  #   else
  #   redis.unwatch
  #   end
  #   end
  #   # => ["OK", 6]
  # @example Without a block
  #   redis.watch("key")
  #   # => "OK"
  # @param keys [String, Array<String>] one or more keys to watch
  # @return [Object] if using a block, returns the return value of the block
  # @return [String] if not using a block, returns `OK`
  # @see #unwatch
  # @see #multi
  #
  # source://redis//lib/redis.rb#2372
  def watch(*keys); end

  # Run code with the client reconnecting
  #
  # source://redis//lib/redis.rb#54
  def with_reconnect(val = T.unsafe(nil), &blk); end

  # Run code without the client reconnecting
  #
  # source://redis//lib/redis.rb#61
  def without_reconnect(&blk); end

  # Removes one or multiple entries from the pending entries list of a stream consumer group.
  #
  # @example With a entry id
  #   redis.xack('mystream', 'mygroup', '1526569495631-0')
  # @example With splatted entry ids
  #   redis.xack('mystream', 'mygroup', '0-1', '0-2')
  # @example With arrayed entry ids
  #   redis.xack('mystream', 'mygroup', %w[0-1 0-2])
  # @param key [String] the stream key
  # @param group [String] the consumer group name
  # @param ids [Array<String>] one or multiple entry ids
  # @return [Integer] the number of entries successfully acknowledged
  #
  # source://redis//lib/redis.rb#3153
  def xack(key, group, *ids); end

  # Add new entry to the stream.
  #
  # @example Without options
  #   redis.xadd('mystream', f1: 'v1', f2: 'v2')
  # @example With options
  #   redis.xadd('mystream', { f1: 'v1', f2: 'v2' }, id: '0-0', maxlen: 1000, approximate: true)
  # @option opts
  # @option opts
  # @option opts
  # @param key [String] the stream key
  # @param entry [Hash] one or multiple field-value pairs
  # @param opts [Hash] several options for `XADD` command
  # @return [String] the entry id
  #
  # source://redis//lib/redis.rb#2939
  def xadd(key, entry, opts = T.unsafe(nil)); end

  # Changes the ownership of a pending entry
  #
  # @example With splatted entry ids
  #   redis.xclaim('mystream', 'mygroup', 'consumer1', 3600000, '0-1', '0-2')
  # @example With arrayed entry ids
  #   redis.xclaim('mystream', 'mygroup', 'consumer1', 3600000, %w[0-1 0-2])
  # @example With idle option
  #   redis.xclaim('mystream', 'mygroup', 'consumer1', 3600000, %w[0-1 0-2], idle: 1000)
  # @example With time option
  #   redis.xclaim('mystream', 'mygroup', 'consumer1', 3600000, %w[0-1 0-2], time: 1542866959000)
  # @example With retrycount option
  #   redis.xclaim('mystream', 'mygroup', 'consumer1', 3600000, %w[0-1 0-2], retrycount: 10)
  # @example With force option
  #   redis.xclaim('mystream', 'mygroup', 'consumer1', 3600000, %w[0-1 0-2], force: true)
  # @example With justid option
  #   redis.xclaim('mystream', 'mygroup', 'consumer1', 3600000, %w[0-1 0-2], justid: true)
  # @option opts
  # @option opts
  # @option opts
  # @option opts
  # @option opts
  # @param key [String] the stream key
  # @param group [String] the consumer group name
  # @param consumer [String] the consumer name
  # @param min_idle_time [Integer] the number of milliseconds
  # @param ids [Array<String>] one or multiple entry ids
  # @param opts [Hash] several options for `XCLAIM` command
  # @return [Hash{String => Hash}] the entries successfully claimed
  # @return [Array<String>] the entry ids successfully claimed if justid option is `true`
  #
  # source://redis//lib/redis.rb#3190
  def xclaim(key, group, consumer, min_idle_time, *ids, **opts); end

  # Delete entries by entry ids.
  #
  # @example With splatted entry ids
  #   redis.xdel('mystream', '0-1', '0-2')
  # @example With arrayed entry ids
  #   redis.xdel('mystream', ['0-1', '0-2'])
  # @param key [String] the stream key
  # @param ids [Array<String>] one or multiple entry ids
  # @return [Integer] the number of entries actually deleted
  #
  # source://redis//lib/redis.rb#2975
  def xdel(key, *ids); end

  # Manages the consumer group of the stream.
  #
  # @example With `create` subcommand
  #   redis.xgroup(:create, 'mystream', 'mygroup', '$')
  # @example With `setid` subcommand
  #   redis.xgroup(:setid, 'mystream', 'mygroup', '$')
  # @example With `destroy` subcommand
  #   redis.xgroup(:destroy, 'mystream', 'mygroup')
  # @example With `delconsumer` subcommand
  #   redis.xgroup(:delconsumer, 'mystream', 'mygroup', 'consumer1')
  # @param subcommand [String] `create` `setid` `destroy` `delconsumer`
  # @param key [String] the stream key
  # @param group [String] the consumer group name
  # @param id_or_consumer [String] * the entry id or `$`, required if subcommand is `create` or `setid`
  #   * the consumer name, required if subcommand is `delconsumer`
  # @param mkstream [Boolean] whether to create an empty stream automatically or not
  # @return [String] `OK` if subcommand is `create` or `setid`
  # @return [Integer] effected count if subcommand is `destroy` or `delconsumer`
  #
  # source://redis//lib/redis.rb#3101
  def xgroup(subcommand, key, group, id_or_consumer = T.unsafe(nil), mkstream: T.unsafe(nil)); end

  # Returns the stream information each subcommand.
  #
  # @example stream
  #   redis.xinfo(:stream, 'mystream')
  # @example groups
  #   redis.xinfo(:groups, 'mystream')
  # @example consumers
  #   redis.xinfo(:consumers, 'mystream', 'mygroup')
  # @param subcommand [String] e.g. `stream` `groups` `consumers`
  # @param key [String] the stream key
  # @param group [String] the consumer group name, required if subcommand is `consumers`
  # @return [Hash] information of the stream if subcommand is `stream`
  # @return [Array<Hash>] information of the consumer groups if subcommand is `groups`
  # @return [Array<Hash>] information of the consumers if subcommand is `consumers`
  #
  # source://redis//lib/redis.rb#2910
  def xinfo(subcommand, key, group = T.unsafe(nil)); end

  # Returns the number of entries inside a stream.
  #
  # @example With key
  #   redis.xlen('mystream')
  # @param key [String] the stream key
  # @return [Integer] the number of entries
  #
  # source://redis//lib/redis.rb#3052
  def xlen(key); end

  # Fetches not acknowledging pending entries
  #
  # @example With key and group
  #   redis.xpending('mystream', 'mygroup')
  # @example With range options
  #   redis.xpending('mystream', 'mygroup', '-', '+', 10)
  # @example With range and consumer options
  #   redis.xpending('mystream', 'mygroup', '-', '+', 10, 'consumer1')
  # @param key [String] the stream key
  # @param group [String] the consumer group name
  # @param start [String] start first entry id of range
  # @param end [String] end   last entry id of range
  # @param count [Integer] count the number of entries as limit
  # @param consumer [String] the consumer name
  # @return [Hash] the summary of pending entries
  # @return [Array<Hash>] the pending entries details if options were specified
  #
  # source://redis//lib/redis.rb#3219
  def xpending(key, group, *args); end

  # Fetches entries of the stream in ascending order.
  #
  # @example Without options
  #   redis.xrange('mystream')
  # @example With a specific start
  #   redis.xrange('mystream', '0-1')
  # @example With a specific start and end
  #   redis.xrange('mystream', '0-1', '0-3')
  # @example With count options
  #   redis.xrange('mystream', count: 10)
  # @param key [String] the stream key
  # @param start [String] first entry id of range, default value is `-`
  # @param end [String] last entry id of range, default value is `+`
  # @param count [Integer] the number of entries as limit
  # @return [Array<Array<String, Hash>>] the ids and entries pairs
  #
  # source://redis//lib/redis.rb#3015
  def xrange(key, start = T.unsafe(nil), _end = T.unsafe(nil), count: T.unsafe(nil)); end

  # Fetches entries from one or multiple streams. Optionally blocking.
  #
  # @example With a key
  #   redis.xread('mystream', '0-0')
  # @example With multiple keys
  #   redis.xread(%w[mystream1 mystream2], %w[0-0 0-0])
  # @example With count option
  #   redis.xread('mystream', '0-0', count: 2)
  # @example With block option
  #   redis.xread('mystream', '$', block: 1000)
  # @param keys [Array<String>] one or multiple stream keys
  # @param ids [Array<String>] one or multiple entry ids
  # @param count [Integer] the number of entries as limit per stream
  # @param block [Integer] the number of milliseconds as blocking timeout
  # @return [Hash{String => Hash{String => Hash}}] the entries
  #
  # source://redis//lib/redis.rb#3073
  def xread(keys, ids, count: T.unsafe(nil), block: T.unsafe(nil)); end

  # Fetches a subset of the entries from one or multiple streams related with the consumer group.
  # Optionally blocking.
  #
  # @example With a key
  #   redis.xreadgroup('mygroup', 'consumer1', 'mystream', '>')
  # @example With multiple keys
  #   redis.xreadgroup('mygroup', 'consumer1', %w[mystream1 mystream2], %w[> >])
  # @example With count option
  #   redis.xreadgroup('mygroup', 'consumer1', 'mystream', '>', count: 2)
  # @example With block option
  #   redis.xreadgroup('mygroup', 'consumer1', 'mystream', '>', block: 1000)
  # @example With noack option
  #   redis.xreadgroup('mygroup', 'consumer1', 'mystream', '>', noack: true)
  # @option opts
  # @option opts
  # @option opts
  # @param group [String] the consumer group name
  # @param consumer [String] the consumer name
  # @param keys [Array<String>] one or multiple stream keys
  # @param ids [Array<String>] one or multiple entry ids
  # @param opts [Hash] several options for `XREADGROUP` command
  # @return [Hash{String => Hash{String => Hash}}] the entries
  #
  # source://redis//lib/redis.rb#3131
  def xreadgroup(group, consumer, keys, ids, opts = T.unsafe(nil)); end

  # Fetches entries of the stream in descending order.
  #
  # @example Without options
  #   redis.xrevrange('mystream')
  # @example With a specific end
  #   redis.xrevrange('mystream', '0-3')
  # @example With a specific end and start
  #   redis.xrevrange('mystream', '0-3', '0-1')
  # @example With count options
  #   redis.xrevrange('mystream', count: 10)
  # @param key [String] the stream key
  # @param end [String] first entry id of range, default value is `+`
  # @param start [String] last entry id of range, default value is `-`
  # @return [Array<Array<String, Hash>>] the ids and entries pairs
  #
  # source://redis//lib/redis.rb#3038
  def xrevrange(key, _end = T.unsafe(nil), start = T.unsafe(nil), count: T.unsafe(nil)); end

  # Trims older entries of the stream if needed.
  #
  # @example Without options
  #   redis.xtrim('mystream', 1000)
  # @example With options
  #   redis.xtrim('mystream', 1000, approximate: true)
  # @param key [String] the stream key
  # @param mexlen [Integer] max length of entries
  # @param approximate [Boolean] whether to add `~` modifier of maxlen or not
  # @return [Integer] the number of entries actually deleted
  #
  # source://redis//lib/redis.rb#2959
  def xtrim(key, maxlen, approximate: T.unsafe(nil)); end

  # Add one or more members to a sorted set, or update the score for members
  # that already exist.
  #
  # @example Add a single `[score, member]` pair to a sorted set
  #   redis.zadd("zset", 32.0, "member")
  # @example Add an array of `[score, member]` pairs to a sorted set
  #   redis.zadd("zset", [[32.0, "a"], [64.0, "b"]])
  # @param key [String]
  # @param args [[Float, String], Array<[Float, String]>] - a single `[score, member]` pair
  #   - an array of `[score, member]` pairs
  # @param options [Hash] - `:xx => true`: Only update elements that already exist (never
  #   add elements)
  #   - `:nx => true`: Don't update already existing elements (always
  #   add new elements)
  #   - `:ch => true`: Modify the return value from the number of new
  #   elements added, to the total number of elements changed (CH is an
  #   abbreviation of changed); changed elements are new elements added
  #   and elements already existing for which the score was updated
  #   - `:incr => true`: When this option is specified ZADD acts like
  #   ZINCRBY; only one score-element pair can be specified in this mode
  # @return [Boolean, Fixnum, Float] - `Boolean` when a single pair is specified, holding whether or not it was
  #   **added** to the sorted set.
  #   - `Fixnum` when an array of pairs is specified, holding the number of
  #   pairs that were **added** to the sorted set.
  #   - `Float` when option :incr is specified, holding the score of the member
  #   after incrementing it.
  #
  # source://redis//lib/redis.rb#1552
  def zadd(key, *args); end

  # Get the number of members in a sorted set.
  #
  # @example
  #   redis.zcard("zset")
  #   # => 4
  # @param key [String]
  # @return [Fixnum]
  #
  # source://redis//lib/redis.rb#1515
  def zcard(key); end

  # Count the members in a sorted set with scores within the given values.
  #
  # @example Count members with score `>= 5` and `< 100`
  #   redis.zcount("zset", "5", "(100")
  #   # => 2
  # @example Count members with scores `> 5`
  #   redis.zcount("zset", "(5", "+inf")
  #   # => 2
  # @param key [String]
  # @param min [String] - inclusive minimum score is specified verbatim
  #   - exclusive minimum score is specified by prefixing `(`
  # @param max [String] - inclusive maximum score is specified verbatim
  #   - exclusive maximum score is specified by prefixing `(`
  # @return [Fixnum] number of members in within the specified range
  #
  # source://redis//lib/redis.rb#2025
  def zcount(key, min, max); end

  # Increment the score of a member in a sorted set.
  #
  # @example
  #   redis.zincrby("zset", 32.0, "a")
  #   # => 64.0
  # @param key [String]
  # @param increment [Float]
  # @param member [String]
  # @return [Float] score of the member after incrementing it
  #
  # source://redis//lib/redis.rb#1593
  def zincrby(key, increment, member); end

  # Intersect multiple sorted sets and store the resulting sorted set in a new
  # key.
  #
  # @example Compute the intersection of `2*zsetA` with `1*zsetB`, summing their scores
  #   redis.zinterstore("zsetC", ["zsetA", "zsetB"], :weights => [2.0, 1.0], :aggregate => "sum")
  #   # => 4
  # @param destination [String] destination key
  # @param keys [Array<String>] source keys
  # @param options [Hash] - `:weights => [Float, Float, ...]`: weights to associate with source
  #   sorted sets
  #   - `:aggregate => String`: aggregate function to use (sum, min, max, ...)
  # @return [Fixnum] number of elements in the resulting sorted set
  #
  # source://redis//lib/redis.rb#2045
  def zinterstore(destination, keys, options = T.unsafe(nil)); end

  # Count the members, with the same score in a sorted set, within the given lexicographical range.
  #
  # @example Count members matching a
  #   redis.zlexcount("zset", "[a", "[a\xff")
  #   # => 1
  # @example Count members matching a-z
  #   redis.zlexcount("zset", "[a", "[z\xff")
  #   # => 26
  # @param key [String]
  # @param min [String] - inclusive minimum is specified by prefixing `(`
  #   - exclusive minimum is specified by prefixing `[`
  # @param max [String] - inclusive maximum is specified by prefixing `(`
  #   - exclusive maximum is specified by prefixing `[`
  # @return [Fixnum] number of members within the specified lexicographical range
  #
  # source://redis//lib/redis.rb#1848
  def zlexcount(key, min, max); end

  # Removes and returns up to count members with the highest scores in the sorted set stored at key.
  #
  # @example Popping a member
  #   redis.zpopmax('zset')
  #   #=> ['b', 2.0]
  # @example With count option
  #   redis.zpopmax('zset', 2)
  #   #=> [['b', 2.0], ['a', 1.0]]
  # @return [Array<String, Float>] element and score pair if count is not specified
  # @return [Array<Array<String, Float>>] list of popped elements and scores
  #
  # source://redis//lib/redis.rb#1644
  def zpopmax(key, count = T.unsafe(nil)); end

  # Removes and returns up to count members with the lowest scores in the sorted set stored at key.
  #
  # @example Popping a member
  #   redis.zpopmin('zset')
  #   #=> ['a', 1.0]
  # @example With count option
  #   redis.zpopmin('zset', 2)
  #   #=> [['a', 1.0], ['b', 2.0]]
  # @return [Array<String, Float>] element and score pair if count is not specified
  # @return [Array<Array<String, Float>>] list of popped elements and scores
  #
  # source://redis//lib/redis.rb#1665
  def zpopmin(key, count = T.unsafe(nil)); end

  # Return a range of members in a sorted set, by index.
  #
  # @example Retrieve all members from a sorted set
  #   redis.zrange("zset", 0, -1)
  #   # => ["a", "b"]
  # @example Retrieve all members and their scores from a sorted set
  #   redis.zrange("zset", 0, -1, :with_scores => true)
  #   # => [["a", 32.0], ["b", 64.0]]
  # @param key [String]
  # @param start [Fixnum] start index
  # @param stop [Fixnum] stop index
  # @param options [Hash] - `:with_scores => true`: include scores in output
  # @return [Array<String>, Array<[String, Float]>] - when `:with_scores` is not specified, an array of members
  #   - when `:with_scores` is specified, an array with `[member, score]` pairs
  #
  # source://redis//lib/redis.rb#1747
  def zrange(key, start, stop, options = T.unsafe(nil)); end

  # Return a range of members with the same score in a sorted set, by lexicographical ordering
  #
  # @example Retrieve members matching a
  #   redis.zrangebylex("zset", "[a", "[a\xff")
  #   # => ["aaren", "aarika", "abagael", "abby"]
  # @example Retrieve the first 2 members matching a
  #   redis.zrangebylex("zset", "[a", "[a\xff", :limit => [0, 2])
  #   # => ["aaren", "aarika"]
  # @param key [String]
  # @param min [String] - inclusive minimum is specified by prefixing `(`
  #   - exclusive minimum is specified by prefixing `[`
  # @param max [String] - inclusive maximum is specified by prefixing `(`
  #   - exclusive maximum is specified by prefixing `[`
  # @param options [Hash] - `:limit => [offset, count]`: skip `offset` members, return a maximum of
  #   `count` members
  # @return [Array<String>, Array<[String, Float]>]
  #
  # source://redis//lib/redis.rb#1875
  def zrangebylex(key, min, max, options = T.unsafe(nil)); end

  # Return a range of members in a sorted set, by score.
  #
  # @example Retrieve members with score `>= 5` and `< 100`
  #   redis.zrangebyscore("zset", "5", "(100")
  #   # => ["a", "b"]
  # @example Retrieve the first 2 members with score `>= 0`
  #   redis.zrangebyscore("zset", "0", "+inf", :limit => [0, 2])
  #   # => ["a", "b"]
  # @example Retrieve members and their scores with scores `> 5`
  #   redis.zrangebyscore("zset", "(5", "+inf", :with_scores => true)
  #   # => [["a", 32.0], ["b", 64.0]]
  # @param key [String]
  # @param min [String] - inclusive minimum score is specified verbatim
  #   - exclusive minimum score is specified by prefixing `(`
  # @param max [String] - inclusive maximum score is specified verbatim
  #   - exclusive maximum score is specified by prefixing `(`
  # @param options [Hash] - `:with_scores => true`: include scores in output
  #   - `:limit => [offset, count]`: skip `offset` members, return a maximum of
  #   `count` members
  # @return [Array<String>, Array<[String, Float]>] - when `:with_scores` is not specified, an array of members
  #   - when `:with_scores` is specified, an array with `[member, score]` pairs
  #
  # source://redis//lib/redis.rb#1935
  def zrangebyscore(key, min, max, options = T.unsafe(nil)); end

  # Determine the index of a member in a sorted set.
  #
  # @param key [String]
  # @param member [String]
  # @return [Fixnum]
  #
  # source://redis//lib/redis.rb#1793
  def zrank(key, member); end

  # Remove one or more members from a sorted set.
  #
  # @example Remove a single member from a sorted set
  #   redis.zrem("zset", "a")
  # @example Remove an array of members from a sorted set
  #   redis.zrem("zset", ["a", "b"])
  # @param key [String]
  # @param member [String, Array<String>] - a single member
  #   - an array of members
  # @return [Boolean, Fixnum] - `Boolean` when a single member is specified, holding whether or not it
  #   was removed from the sorted set
  #   - `Fixnum` when an array of pairs is specified, holding the number of
  #   members that were removed to the sorted set
  #
  # source://redis//lib/redis.rb#1616
  def zrem(key, member); end

  # Remove all members in a sorted set within the given indexes.
  #
  # @example Remove first 5 members
  #   redis.zremrangebyrank("zset", 0, 4)
  #   # => 5
  # @example Remove last 5 members
  #   redis.zremrangebyrank("zset", -5, -1)
  #   # => 5
  # @param key [String]
  # @param start [Fixnum] start index
  # @param stop [Fixnum] stop index
  # @return [Fixnum] number of members that were removed
  #
  # source://redis//lib/redis.rb#1824
  def zremrangebyrank(key, start, stop); end

  # Remove all members in a sorted set within the given scores.
  #
  # @example Remove members with score `>= 5` and `< 100`
  #   redis.zremrangebyscore("zset", "5", "(100")
  #   # => 2
  # @example Remove members with scores `> 5`
  #   redis.zremrangebyscore("zset", "(5", "+inf")
  #   # => 2
  # @param key [String]
  # @param min [String] - inclusive minimum score is specified verbatim
  #   - exclusive minimum score is specified by prefixing `(`
  # @param max [String] - inclusive maximum score is specified verbatim
  #   - exclusive maximum score is specified by prefixing `(`
  # @return [Fixnum] number of members that were removed
  #
  # source://redis//lib/redis.rb#2002
  def zremrangebyscore(key, min, max); end

  # Return a range of members in a sorted set, by index, with scores ordered
  # from high to low.
  #
  # @example Retrieve all members from a sorted set
  #   redis.zrevrange("zset", 0, -1)
  #   # => ["b", "a"]
  # @example Retrieve all members and their scores from a sorted set
  #   redis.zrevrange("zset", 0, -1, :with_scores => true)
  #   # => [["b", 64.0], ["a", 32.0]]
  # @see #zrange
  #
  # source://redis//lib/redis.rb#1773
  def zrevrange(key, start, stop, options = T.unsafe(nil)); end

  # Return a range of members with the same score in a sorted set, by reversed lexicographical ordering.
  # Apart from the reversed ordering, #zrevrangebylex is similar to #zrangebylex.
  #
  # @example Retrieve members matching a
  #   redis.zrevrangebylex("zset", "[a", "[a\xff")
  #   # => ["abbygail", "abby", "abagael", "aaren"]
  # @example Retrieve the last 2 members matching a
  #   redis.zrevrangebylex("zset", "[a", "[a\xff", :limit => [0, 2])
  #   # => ["abbygail", "abby"]
  # @see #zrangebylex
  #
  # source://redis//lib/redis.rb#1897
  def zrevrangebylex(key, max, min, options = T.unsafe(nil)); end

  # Return a range of members in a sorted set, by score, with scores ordered
  # from high to low.
  #
  # @example Retrieve members with score `< 100` and `>= 5`
  #   redis.zrevrangebyscore("zset", "(100", "5")
  #   # => ["b", "a"]
  # @example Retrieve the first 2 members with score `<= 0`
  #   redis.zrevrangebyscore("zset", "0", "-inf", :limit => [0, 2])
  #   # => ["b", "a"]
  # @example Retrieve members and their scores with scores `> 5`
  #   redis.zrevrangebyscore("zset", "+inf", "(5", :with_scores => true)
  #   # => [["b", 64.0], ["a", 32.0]]
  # @see #zrangebyscore
  #
  # source://redis//lib/redis.rb#1967
  def zrevrangebyscore(key, max, min, options = T.unsafe(nil)); end

  # Determine the index of a member in a sorted set, with scores ordered from
  # high to low.
  #
  # @param key [String]
  # @param member [String]
  # @return [Fixnum]
  #
  # source://redis//lib/redis.rb#1805
  def zrevrank(key, member); end

  # Scan a sorted set
  #
  # @example Retrieve the first batch of key/value pairs in a hash
  #   redis.zscan("zset", 0)
  # @param cursor [String, Integer] the cursor of the iteration
  # @param options [Hash] - `:match => String`: only return keys matching the pattern
  #   - `:count => Integer`: return count keys at most per iteration
  # @return [String, Array<[String, Float]>] the next cursor and all found
  #   members and scores
  #
  # source://redis//lib/redis.rb#2715
  def zscan(key, cursor, options = T.unsafe(nil)); end

  # Scan a sorted set
  #
  # @example Retrieve all of the members/scores in a sorted set
  #   redis.zscan_each("zset").to_a
  #   # => [["key70", "70"], ["key80", "80"]]
  # @param options [Hash] - `:match => String`: only return keys matching the pattern
  #   - `:count => Integer`: return count keys at most per iteration
  # @return [Enumerator] an enumerator for all found scores and members
  #
  # source://redis//lib/redis.rb#2732
  def zscan_each(key, options = T.unsafe(nil), &block); end

  # Get the score associated with the given member in a sorted set.
  #
  # @example Get the score for member "a"
  #   redis.zscore("zset", "a")
  #   # => 32.0
  # @param key [String]
  # @param member [String]
  # @return [Float] score of the member
  #
  # source://redis//lib/redis.rb#1723
  def zscore(key, member); end

  # Add multiple sorted sets and store the resulting sorted set in a new key.
  #
  # @example Compute the union of `2*zsetA` with `1*zsetB`, summing their scores
  #   redis.zunionstore("zsetC", ["zsetA", "zsetB"], :weights => [2.0, 1.0], :aggregate => "sum")
  #   # => 8
  # @param destination [String] destination key
  # @param keys [Array<String>] source keys
  # @param options [Hash] - `:weights => [Float, Float, ...]`: weights to associate with source
  #   sorted sets
  #   - `:aggregate => String`: aggregate function to use (sum, min, max, ...)
  # @return [Fixnum] number of elements in the resulting sorted set
  #
  # source://redis//lib/redis.rb#2072
  def zunionstore(destination, keys, options = T.unsafe(nil)); end

  private

  # source://redis//lib/redis.rb#3458
  def _geoarguments(*args, options: T.unsafe(nil), sort: T.unsafe(nil), count: T.unsafe(nil)); end

  # source://redis//lib/redis.rb#3466
  def _subscription(method, timeout, channels, block); end

  # source://redis//lib/redis.rb#3481
  def _xread(args, keys, ids, blocking_timeout_msec); end

  class << self
    # source://redis//lib/redis.rb#6
    def current; end

    # source://redis//lib/redis.rb#10
    def current=(redis); end
  end
end

# Base error for connection related errors.
class Redis::BaseConnectionError < ::Redis::BaseError; end

# Base error for all redis-rb errors.
class Redis::BaseError < ::RuntimeError; end

# Commands returning 1 for true and 0 for false may be executed in a pipeline
# where the method call will return nil. Propagate the nil instead of falsely
# returning false.
#
# source://redis//lib/redis.rb#3330
Redis::Boolify = T.let(T.unsafe(nil), Proc)

# source://redis//lib/redis.rb#3335
Redis::BoolifySet = T.let(T.unsafe(nil), Proc)

# Raised when connection to a Redis server cannot be made.
class Redis::CannotConnectError < ::Redis::BaseConnectionError; end

class Redis::Client
  # @return [Client] a new instance of Client
  #
  # source://redis//lib/redis/client.rb#80
  def initialize(options = T.unsafe(nil)); end

  def call(cmd, *args, &block); end

  # source://redis//lib/redis/client.rb#133
  def call_loop(command, timeout = T.unsafe(nil)); end

  # source://redis//lib/redis/client.rb#157
  def call_pipeline(pipeline); end

  def call_pipelined(cmd, *args, &block); end

  # source://redis//lib/redis/client.rb#210
  def call_with_timeout(command, timeout, &blk); end

  # source://redis//lib/redis/client.rb#218
  def call_without_timeout(command, &blk); end

  # Returns the value of attribute command_map.
  #
  # source://redis//lib/redis/client.rb#78
  def command_map; end

  # source://redis//lib/redis/client.rb#99
  def connect; end

  # source://redis//lib/redis/client.rb#48
  def connect_timeout; end

  # @return [Boolean]
  #
  # source://redis//lib/redis/client.rb#239
  def connected?; end

  # Returns the value of attribute connection.
  #
  # source://redis//lib/redis/client.rb#77
  def connection; end

  # source://redis//lib/redis/client.rb#60
  def db; end

  # source://redis//lib/redis/client.rb#64
  def db=(db); end

  # source://redis//lib/redis/client.rb#243
  def disconnect; end

  # source://redis//lib/redis/client.rb#68
  def driver; end

  # source://redis//lib/redis/client.rb#32
  def host; end

  # source://redis//lib/redis/client.rb#114
  def id; end

  # @return [Boolean]
  #
  # source://redis//lib/redis/client.rb#72
  def inherit_socket?; end

  # source://redis//lib/redis/client.rb#252
  def io; end

  # source://redis//lib/redis/client.rb#118
  def location; end

  # Returns the value of attribute logger.
  #
  # source://redis//lib/redis/client.rb#76
  def logger; end

  # Sets the attribute logger
  #
  # @param value the value to set the attribute logger to.
  #
  # source://redis//lib/redis/client.rb#76
  def logger=(_arg0); end

  # Returns the value of attribute options.
  #
  # source://redis//lib/redis/client.rb#26
  def options; end

  # source://redis//lib/redis/client.rb#56
  def password; end

  # source://redis//lib/redis/client.rb#40
  def path; end

  # source://redis//lib/redis/client.rb#36
  def port; end

  # source://redis//lib/redis/client.rb#222
  def process(commands); end

  # source://redis//lib/redis/client.rb#263
  def read; end

  # source://redis//lib/redis/client.rb#44
  def read_timeout; end

  # source://redis//lib/redis/client.rb#247
  def reconnect; end

  # source://redis//lib/redis/client.rb#28
  def scheme; end

  # source://redis//lib/redis/client.rb#52
  def timeout; end

  # source://redis//lib/redis/client.rb#296
  def with_reconnect(val = T.unsafe(nil)); end

  # source://redis//lib/redis/client.rb#278
  def with_socket_timeout(timeout); end

  # source://redis//lib/redis/client.rb#305
  def without_reconnect(&blk); end

  # source://redis//lib/redis/client.rb#292
  def without_socket_timeout(&blk); end

  # source://redis//lib/redis/client.rb#271
  def write(command); end

  protected

  # source://redis//lib/redis/client.rb#492
  def _parse_driver(driver); end

  # source://redis//lib/redis/client.rb#394
  def _parse_options(options); end

  # source://redis//lib/redis/client.rb#356
  def ensure_connected; end

  # source://redis//lib/redis/client.rb#336
  def establish_connection; end

  # source://redis//lib/redis/client.rb#311
  def logging(commands); end

  class << self
    def collector; end
    def queries; end
    def queries=(value); end
    def query_count; end
    def query_count=(value); end
    def query_time; end
    def query_time=(value); end
    def track; end
    def track=(value); end
  end
end

class Redis::Client::Connector
  # @return [Connector] a new instance of Connector
  #
  # source://redis//lib/redis/client.rb#513
  def initialize(options); end

  # source://redis//lib/redis/client.rb#521
  def check(client); end

  # source://redis//lib/redis/client.rb#517
  def resolve; end
end

class Redis::Client::Connector::Sentinel < ::Redis::Client::Connector
  # @return [Sentinel] a new instance of Sentinel
  #
  # source://redis//lib/redis/client.rb#525
  def initialize(options); end

  # source://redis//lib/redis/client.rb#536
  def check(client); end

  # source://redis//lib/redis/client.rb#553
  def resolve; end

  # source://redis//lib/redis/client.rb#591
  def resolve_master; end

  # source://redis//lib/redis/client.rb#599
  def resolve_slave; end

  # @raise [CannotConnectError]
  #
  # source://redis//lib/redis/client.rb#566
  def sentinel_detect; end
end

# source://redis//lib/redis/client.rb#8
Redis::Client::DEFAULTS = T.let(T.unsafe(nil), Hash)

class Redis::Cluster
  # @return [Cluster] a new instance of Cluster
  #
  # source://redis//lib/redis/cluster.rb#24
  def initialize(options = T.unsafe(nil)); end

  # source://redis//lib/redis/cluster.rb#71
  def call(command, &block); end

  # source://redis//lib/redis/cluster.rb#75
  def call_loop(command, timeout = T.unsafe(nil), &block); end

  # @raise [CrossSlotPipeliningError]
  #
  # source://redis//lib/redis/cluster.rb#80
  def call_pipeline(pipeline); end

  # source://redis//lib/redis/cluster.rb#87
  def call_with_timeout(command, timeout, &block); end

  # source://redis//lib/redis/cluster.rb#92
  def call_without_timeout(command, &block); end

  # @return [Boolean]
  #
  # source://redis//lib/redis/cluster.rb#46
  def connected?; end

  # source://redis//lib/redis/cluster.rb#55
  def connection_info; end

  # db feature is disabled in cluster mode
  #
  # source://redis//lib/redis/cluster.rb#35
  def db; end

  # db feature is disabled in cluster mode
  #
  # source://redis//lib/redis/cluster.rb#40
  def db=(_db); end

  # source://redis//lib/redis/cluster.rb#50
  def disconnect; end

  # source://redis//lib/redis/cluster.rb#30
  def id; end

  # source://redis//lib/redis/cluster.rb#96
  def process(commands, &block); end

  # source://redis//lib/redis/cluster.rb#42
  def timeout; end

  # source://redis//lib/redis/cluster.rb#67
  def with_reconnect(val = T.unsafe(nil), &block); end

  private

  # source://redis//lib/redis/cluster.rb#238
  def assign_asking_node(err_msg); end

  # source://redis//lib/redis/cluster.rb#243
  def assign_node(command); end

  # source://redis//lib/redis/cluster.rb#231
  def assign_redirection_node(err_msg); end

  # source://redis//lib/redis/cluster.rb#280
  def extract_keys_in_pipeline(pipeline); end

  # source://redis//lib/redis/cluster.rb#111
  def fetch_cluster_info!(option); end

  # source://redis//lib/redis/cluster.rb#123
  def fetch_command_details(nodes); end

  # source://redis//lib/redis/cluster.rb#262
  def find_node(node_key); end

  # source://redis//lib/redis/cluster.rb#248
  def find_node_key(command); end

  # source://redis//lib/redis/cluster.rb#172
  def send_client_command(command, &block); end

  # source://redis//lib/redis/cluster.rb#181
  def send_cluster_command(command, &block); end

  # source://redis//lib/redis/cluster.rb#128
  def send_command(command, &block); end

  # source://redis//lib/redis/cluster.rb#156
  def send_config_command(command, &block); end

  # source://redis//lib/redis/cluster.rb#164
  def send_memory_command(command, &block); end

  # source://redis//lib/redis/cluster.rb#202
  def send_pubsub_command(command, &block); end

  # source://redis//lib/redis/cluster.rb#192
  def send_script_command(command, &block); end

  # @see https://redis.io/topics/cluster-spec#redirection-and-resharding Redirection and resharding
  #
  # source://redis//lib/redis/cluster.rb#215
  def try_send(node, method_name, *args, retry_count: T.unsafe(nil), &block); end

  # source://redis//lib/redis/cluster.rb#270
  def update_cluster_info!(node_key = T.unsafe(nil)); end
end

# Raised when cluster client can't select node.
class Redis::Cluster::AmbiguousNodeError < ::Redis::BaseError
  # @return [AmbiguousNodeError] a new instance of AmbiguousNodeError
  #
  # source://redis//lib/redis/errors.rb#73
  def initialize(command); end
end

# Keep details about Redis commands for Redis Cluster Client.
#
# @see https://redis.io/commands/command
class Redis::Cluster::Command
  # @return [Command] a new instance of Command
  #
  # source://redis//lib/redis/cluster/command.rb#10
  def initialize(details); end

  # source://redis//lib/redis/cluster/command.rb#14
  def extract_first_key(command); end

  # @return [Boolean]
  #
  # source://redis//lib/redis/cluster/command.rb#23
  def should_send_to_master?(command); end

  # @return [Boolean]
  #
  # source://redis//lib/redis/cluster/command.rb#27
  def should_send_to_slave?(command); end

  private

  # source://redis//lib/redis/cluster/command.rb#50
  def determine_first_key_position(command); end

  # source://redis//lib/redis/cluster/command.rb#65
  def determine_optional_key_position(command, option_name); end

  # source://redis//lib/redis/cluster/command.rb#43
  def dig_details(command, key); end

  # @see https://redis.io/topics/cluster-spec#keys-hash-tags Keys hash tags
  #
  # source://redis//lib/redis/cluster/command.rb#71
  def extract_hash_tag(key); end

  # source://redis//lib/redis/cluster/command.rb#33
  def pick_details(details); end
end

# Raised when error occurs on any node of cluster.
class Redis::Cluster::CommandErrorCollection < ::Redis::BaseError
  # @param errors [Hash{String => Redis::CommandError}]
  # @param error_message [String]
  # @return [CommandErrorCollection] a new instance of CommandErrorCollection
  #
  # source://redis//lib/redis/errors.rb#65
  def initialize(errors, error_message = T.unsafe(nil)); end

  # Returns the value of attribute errors.
  #
  # source://redis//lib/redis/errors.rb#61
  def errors; end
end

# Load details about Redis commands for Redis Cluster Client
#
# @see https://redis.io/commands/command
module Redis::Cluster::CommandLoader
  private

  # source://redis//lib/redis/cluster/command_loader.rb#23
  def fetch_command_details(node); end

  # source://redis//lib/redis/cluster/command_loader.rb#12
  def load(nodes); end

  class << self
    # source://redis//lib/redis/cluster/command_loader.rb#12
    def load(nodes); end

    private

    # source://redis//lib/redis/cluster/command_loader.rb#23
    def fetch_command_details(node); end
  end
end

# Raised when commands in pipelining include cross slot keys.
class Redis::Cluster::CrossSlotPipeliningError < ::Redis::BaseError
  # @return [CrossSlotPipeliningError] a new instance of CrossSlotPipeliningError
  #
  # source://redis//lib/redis/errors.rb#80
  def initialize(keys); end
end

module Redis::Cluster::KeySlotConverter
  private

  # Convert key into slot.
  #
  # @param key [String] the key of the redis command
  # @return [Integer] slot number
  #
  # source://redis//lib/redis/cluster/key_slot_converter.rb#62
  def convert(key); end

  class << self
    # Convert key into slot.
    #
    # @param key [String] the key of the redis command
    # @return [Integer] slot number
    #
    # source://redis//lib/redis/cluster/key_slot_converter.rb#62
    def convert(key); end
  end
end

# source://redis//lib/redis/cluster/key_slot_converter.rb#53
Redis::Cluster::KeySlotConverter::HASH_SLOTS = T.let(T.unsafe(nil), Integer)

# source://redis//lib/redis/cluster/key_slot_converter.rb#18
Redis::Cluster::KeySlotConverter::XMODEM_CRC16_LOOKUP = T.let(T.unsafe(nil), Array)

# Keep client list of node for Redis Cluster Client
class Redis::Cluster::Node
  include ::Prelude::Enumerator
  include ::Enumerable

  # @return [Node] a new instance of Node
  #
  # source://redis//lib/redis/cluster/node.rb#15
  def initialize(options, node_flags = T.unsafe(nil), with_replica = T.unsafe(nil)); end

  # source://redis//lib/redis/cluster/node.rb#35
  def call_all(command, &block); end

  # source://redis//lib/redis/cluster/node.rb#39
  def call_master(command, &block); end

  # source://redis//lib/redis/cluster/node.rb#46
  def call_slave(command, &block); end

  # source://redis//lib/redis/cluster/node.rb#21
  def each(&block); end

  # source://redis//lib/redis/cluster/node.rb#29
  def find_by(node_key); end

  # source://redis//lib/redis/cluster/node.rb#55
  def process_all(commands, &block); end

  # source://redis//lib/redis/cluster/node.rb#25
  def sample; end

  private

  # source://redis//lib/redis/cluster/node.rb#73
  def build_clients(options); end

  # @return [Boolean]
  #
  # source://redis//lib/redis/cluster/node.rb#65
  def master?(node_key); end

  # @return [Boolean]
  #
  # source://redis//lib/redis/cluster/node.rb#61
  def replica_disabled?; end

  # @return [Boolean]
  #
  # source://redis//lib/redis/cluster/node.rb#69
  def slave?(node_key); end

  # @raise [CommandErrorCollection]
  #
  # source://redis//lib/redis/cluster/node.rb#85
  def try_map; end
end

# source://redis//lib/redis/cluster/node.rb#13
Redis::Cluster::Node::ROLE_SLAVE = T.let(T.unsafe(nil), String)

class Redis::Cluster::Node::ReloadNeeded < ::StandardError; end

# Node key's format is `<ip>:<port>`.
# It is different from node id.
# Node id is internal identifying code in Redis Cluster.
module Redis::Cluster::NodeKey
  private

  # source://redis//lib/redis/cluster/node_key.rb#30
  def build_from_host_port(host, port); end

  # source://redis//lib/redis/cluster/node_key.rb#26
  def build_from_uri(uri); end

  # source://redis//lib/redis/cluster/node_key.rb#22
  def split(node_key); end

  # source://redis//lib/redis/cluster/node_key.rb#15
  def to_node_urls(node_keys, secure:); end

  class << self
    # source://redis//lib/redis/cluster/node_key.rb#30
    def build_from_host_port(host, port); end

    # source://redis//lib/redis/cluster/node_key.rb#26
    def build_from_uri(uri); end

    # source://redis//lib/redis/cluster/node_key.rb#22
    def split(node_key); end

    # source://redis//lib/redis/cluster/node_key.rb#15
    def to_node_urls(node_keys, secure:); end
  end
end

# source://redis//lib/redis/cluster/node_key.rb#9
Redis::Cluster::NodeKey::DEFAULT_SCHEME = T.let(T.unsafe(nil), String)

# source://redis//lib/redis/cluster/node_key.rb#11
Redis::Cluster::NodeKey::DELIMITER = T.let(T.unsafe(nil), String)

# source://redis//lib/redis/cluster/node_key.rb#10
Redis::Cluster::NodeKey::SECURE_SCHEME = T.let(T.unsafe(nil), String)

# Load and hashify node info for Redis Cluster Client
module Redis::Cluster::NodeLoader
  private

  # source://redis//lib/redis/cluster/node_loader.rb#24
  def fetch_node_info(node); end

  # source://redis//lib/redis/cluster/node_loader.rb#11
  def load_flags(nodes); end

  class << self
    # @raise [CannotConnectError]
    #
    # source://redis//lib/redis/cluster/node_loader.rb#11
    def load_flags(nodes); end

    private

    # source://redis//lib/redis/cluster/node_loader.rb#24
    def fetch_node_info(node); end
  end
end

# Keep options for Redis Cluster Client
class Redis::Cluster::Option
  # @return [Option] a new instance of Option
  #
  # source://redis//lib/redis/cluster/option.rb#15
  def initialize(options); end

  # source://redis//lib/redis/cluster/option.rb#40
  def add_node(host, port); end

  # source://redis//lib/redis/cluster/option.rb#23
  def per_node_key; end

  # @return [Boolean]
  #
  # source://redis//lib/redis/cluster/option.rb#28
  def secure?; end

  # source://redis//lib/redis/cluster/option.rb#36
  def update_node(addrs); end

  # @return [Boolean]
  #
  # source://redis//lib/redis/cluster/option.rb#32
  def use_replica?; end

  private

  # @raise [InvalidClientOptionError]
  #
  # source://redis//lib/redis/cluster/option.rb#46
  def build_node_uris(addrs); end

  # source://redis//lib/redis/cluster/option.rb#51
  def parse_node_addr(addr); end

  # @raise [InvalidClientOptionError]
  #
  # source://redis//lib/redis/cluster/option.rb#70
  def parse_node_hash(addr); end

  # source://redis//lib/redis/cluster/option.rb#62
  def parse_node_url(addr); end
end

# source://redis//lib/redis/cluster/option.rb#11
Redis::Cluster::Option::DEFAULT_SCHEME = T.let(T.unsafe(nil), String)

# source://redis//lib/redis/cluster/option.rb#12
Redis::Cluster::Option::SECURE_SCHEME = T.let(T.unsafe(nil), String)

# source://redis//lib/redis/cluster/option.rb#13
Redis::Cluster::Option::VALID_SCHEMES = T.let(T.unsafe(nil), Array)

# Raised when client connected to redis as cluster mode
# and some cluster subcommands were called.
class Redis::Cluster::OrchestrationCommandNotSupported < ::Redis::BaseError
  # @return [OrchestrationCommandNotSupported] a new instance of OrchestrationCommandNotSupported
  #
  # source://redis//lib/redis/errors.rb#49
  def initialize(command, subcommand = T.unsafe(nil)); end
end

# Keep slot and node key map for Redis Cluster Client
class Redis::Cluster::Slot
  # @return [Slot] a new instance of Slot
  #
  # source://redis//lib/redis/cluster/slot.rb#11
  def initialize(available_slots, node_flags = T.unsafe(nil), with_replica = T.unsafe(nil)); end

  # @return [Boolean]
  #
  # source://redis//lib/redis/cluster/slot.rb#17
  def exists?(slot); end

  # source://redis//lib/redis/cluster/slot.rb#21
  def find_node_key_of_master(slot); end

  # source://redis//lib/redis/cluster/slot.rb#27
  def find_node_key_of_slave(slot); end

  # source://redis//lib/redis/cluster/slot.rb#34
  def put(slot, node_key); end

  private

  # source://redis//lib/redis/cluster/slot.rb#59
  def assign_node_key(mappings, slot, node_key); end

  # source://redis//lib/redis/cluster/slot.rb#53
  def build_slot_node_key_map(available_slots); end

  # @return [Boolean]
  #
  # source://redis//lib/redis/cluster/slot.rb#45
  def master?(node_key); end

  # @return [Boolean]
  #
  # source://redis//lib/redis/cluster/slot.rb#41
  def replica_disabled?; end

  # @return [Boolean]
  #
  # source://redis//lib/redis/cluster/slot.rb#49
  def slave?(node_key); end
end

# source://redis//lib/redis/cluster/slot.rb#9
Redis::Cluster::Slot::ROLE_SLAVE = T.let(T.unsafe(nil), String)

# Load and hashify slot info for Redis Cluster Client
module Redis::Cluster::SlotLoader
  private

  # source://redis//lib/redis/cluster/slot_loader.rb#25
  def fetch_slot_info(node); end

  # source://redis//lib/redis/cluster/slot_loader.rb#12
  def load(nodes); end

  # source://redis//lib/redis/cluster/slot_loader.rb#33
  def parse_slot_info(arr, default_ip:); end

  # source://redis//lib/redis/cluster/slot_loader.rb#40
  def stringify_node_key(arr, default_ip); end

  class << self
    # @raise [CannotConnectError]
    #
    # source://redis//lib/redis/cluster/slot_loader.rb#12
    def load(nodes); end

    private

    # source://redis//lib/redis/cluster/slot_loader.rb#25
    def fetch_slot_info(node); end

    # source://redis//lib/redis/cluster/slot_loader.rb#33
    def parse_slot_info(arr, default_ip:); end

    # source://redis//lib/redis/cluster/slot_loader.rb#40
    def stringify_node_key(arr, default_ip); end
  end
end

# Raised by the client when command execution returns an error reply.
class Redis::CommandError < ::Redis::BaseError; end

module Redis::Connection
  class << self
    # Store a list of loaded connection drivers in the Connection module.
    # Redis::Client uses the last required driver by default, and will be aware
    # of the loaded connection drivers if the user chooses to override the
    # default connection driver.
    #
    # source://redis//lib/redis/connection/registry.rb#8
    def drivers; end
  end
end

module Redis::Connection::CommandHelper
  # source://redis//lib/redis/connection/command_helper.rb#7
  def build_command(args); end

  protected

  # source://redis//lib/redis/connection/command_helper.rb#33
  def encode(string); end
end

# source://redis//lib/redis/connection/command_helper.rb#5
Redis::Connection::CommandHelper::COMMAND_DELIMITER = T.let(T.unsafe(nil), String)

class Redis::Connection::Ruby
  include ::Redis::Connection::CommandHelper

  # @return [Ruby] a new instance of Ruby
  #
  # source://redis//lib/redis/connection/ruby.rb#333
  def initialize(sock); end

  # @return [Boolean]
  #
  # source://redis//lib/redis/connection/ruby.rb#337
  def connected?; end

  # source://redis//lib/redis/connection/ruby.rb#341
  def disconnect; end

  # source://redis//lib/redis/connection/ruby.rb#394
  def format_bulk_reply(line); end

  # source://redis//lib/redis/connection/ruby.rb#382
  def format_error_reply(line); end

  # source://redis//lib/redis/connection/ruby.rb#390
  def format_integer_reply(line); end

  # source://redis//lib/redis/connection/ruby.rb#402
  def format_multi_bulk_reply(line); end

  # source://redis//lib/redis/connection/ruby.rb#371
  def format_reply(reply_type, line); end

  # source://redis//lib/redis/connection/ruby.rb#386
  def format_status_reply(line); end

  # source://redis//lib/redis/connection/ruby.rb#316
  def get_tcp_keepalive; end

  # source://redis//lib/redis/connection/ruby.rb#362
  def read; end

  # source://redis//lib/redis/connection/ruby.rb#307
  def set_tcp_keepalive(keepalive); end

  # source://redis//lib/redis/connection/ruby.rb#348
  def timeout=(timeout); end

  # source://redis//lib/redis/connection/ruby.rb#358
  def write(command); end

  # source://redis//lib/redis/connection/ruby.rb#354
  def write_timeout=(timeout); end

  class << self
    # source://redis//lib/redis/connection/ruby.rb#289
    def connect(config); end
  end
end

# source://redis//lib/redis/connection/ruby.rb#287
Redis::Connection::Ruby::ASTERISK = T.let(T.unsafe(nil), String)

# source://redis//lib/redis/connection/ruby.rb#285
Redis::Connection::Ruby::COLON = T.let(T.unsafe(nil), String)

# source://redis//lib/redis/connection/ruby.rb#286
Redis::Connection::Ruby::DOLLAR = T.let(T.unsafe(nil), String)

# source://redis//lib/redis/connection/ruby.rb#283
Redis::Connection::Ruby::MINUS = T.let(T.unsafe(nil), String)

# source://redis//lib/redis/connection/ruby.rb#284
Redis::Connection::Ruby::PLUS = T.let(T.unsafe(nil), String)

class Redis::Connection::SSLSocket < ::OpenSSL::SSL::SSLSocket
  include ::Redis::Connection::SocketMixin

  class << self
    # source://redis//lib/redis/connection/ruby.rb#260
    def connect(host, port, timeout, ssl_params); end
  end
end

module Redis::Connection::SocketMixin
  # source://redis//lib/redis/connection/ruby.rb#19
  def initialize(*args); end

  # source://redis//lib/redis/connection/ruby.rb#62
  def _read_from_socket(nbytes); end

  # source://redis//lib/redis/connection/ruby.rb#85
  def _write_to_socket(data); end

  # source://redis//lib/redis/connection/ruby.rb#52
  def gets; end

  # source://redis//lib/redis/connection/ruby.rb#42
  def read(nbytes); end

  # source://redis//lib/redis/connection/ruby.rb#26
  def timeout=(timeout); end

  # source://redis//lib/redis/connection/ruby.rb#107
  def write(data); end

  # source://redis//lib/redis/connection/ruby.rb#34
  def write_timeout=(timeout); end
end

# source://redis//lib/redis/connection/ruby.rb#17
Redis::Connection::SocketMixin::CRLF = T.let(T.unsafe(nil), String)

class Redis::Connection::TCPSocket < ::Socket
  include ::Redis::Connection::SocketMixin

  class << self
    # source://redis//lib/redis/connection/ruby.rb#195
    def connect(host, port, timeout); end

    # source://redis//lib/redis/connection/ruby.rb#175
    def connect_addrinfo(ai, port, timeout); end
  end
end

class Redis::Connection::UNIXSocket < ::Socket
  include ::Redis::Connection::SocketMixin

  class << self
    # source://redis//lib/redis/connection/ruby.rb#233
    def connect(path, timeout); end
  end
end

# Raised when connection to a Redis server is lost.
class Redis::ConnectionError < ::Redis::BaseConnectionError; end

class Redis::Distributed
  # @return [Distributed] a new instance of Distributed
  #
  # source://redis//lib/redis/distributed.rb#18
  def initialize(node_configs, options = T.unsafe(nil)); end

  # source://redis//lib/redis/distributed.rb#352
  def [](key); end

  # source://redis//lib/redis/distributed.rb#356
  def []=(key, value); end

  # source://redis//lib/redis/distributed.rb#403
  def _bpop(cmd, args); end

  # source://redis//lib/redis/distributed.rb#829
  def _eval(cmd, args); end

  # source://redis//lib/redis/distributed.rb#35
  def add_node(options); end

  # Append a value to a key.
  #
  # source://redis//lib/redis/distributed.rb#321
  def append(key, value); end

  # Asynchronously save the dataset to disk.
  #
  # source://redis//lib/redis/distributed.rb#62
  def bgsave; end

  # Count the number of set bits in a range of the string value stored at key.
  #
  # source://redis//lib/redis/distributed.rb#326
  def bitcount(key, start = T.unsafe(nil), stop = T.unsafe(nil)); end

  # Perform a bitwise operation between strings and store the resulting string in a key.
  #
  # source://redis//lib/redis/distributed.rb#331
  def bitop(operation, destkey, *keys); end

  # Return the position of the first bit set to 1 or 0 in a string.
  #
  # source://redis//lib/redis/distributed.rb#338
  def bitpos(key, bit, start = T.unsafe(nil), stop = T.unsafe(nil)); end

  # Remove and get the first element in a list, or block until one is
  # available.
  #
  # source://redis//lib/redis/distributed.rb#426
  def blpop(*args); end

  # Remove and get the last element in a list, or block until one is
  # available.
  #
  # source://redis//lib/redis/distributed.rb#432
  def brpop(*args); end

  # Pop a value from a list, push it to another list and return it; or block
  # until one is available.
  #
  # source://redis//lib/redis/distributed.rb#438
  def brpoplpush(source, destination, options = T.unsafe(nil)); end

  # Return the number of keys in the selected database.
  #
  # source://redis//lib/redis/distributed.rb#67
  def dbsize; end

  # Decrement the integer value of a key by one.
  #
  # source://redis//lib/redis/distributed.rb#221
  def decr(key); end

  # Decrement the integer value of a key by the given number.
  #
  # source://redis//lib/redis/distributed.rb#226
  def decrby(key, decrement); end

  # Delete a key.
  #
  # source://redis//lib/redis/distributed.rb#157
  def del(*args); end

  # Discard all commands issued after MULTI.
  #
  # @raise [CannotDistribute]
  #
  # source://redis//lib/redis/distributed.rb#800
  def discard; end

  # Return a serialized version of the value stored at a key.
  #
  # source://redis//lib/redis/distributed.rb#142
  def dump(key); end

  # source://redis//lib/redis/distributed.rb#856
  def dup; end

  # Echo the given string.
  #
  # source://redis//lib/redis/distributed.rb#52
  def echo(value); end

  # Evaluate Lua script.
  #
  # source://redis//lib/redis/distributed.rb#843
  def eval(*args); end

  # Evaluate Lua script by its SHA.
  #
  # source://redis//lib/redis/distributed.rb#848
  def evalsha(*args); end

  # Execute all commands issued after MULTI.
  #
  # @raise [CannotDistribute]
  #
  # source://redis//lib/redis/distributed.rb#795
  def exec; end

  # Determine if a key exists.
  #
  # source://redis//lib/redis/distributed.rb#173
  def exists(key); end

  # Set a key's time to live in seconds.
  #
  # source://redis//lib/redis/distributed.rb#112
  def expire(key, seconds); end

  # Set the expiration for a key as a UNIX timestamp.
  #
  # source://redis//lib/redis/distributed.rb#117
  def expireat(key, unix_time); end

  # Remove all keys from all databases.
  #
  # source://redis//lib/redis/distributed.rb#72
  def flushall; end

  # Remove all keys from the current database.
  #
  # source://redis//lib/redis/distributed.rb#77
  def flushdb; end

  # Get the value of a key.
  #
  # source://redis//lib/redis/distributed.rb#284
  def get(key); end

  # Returns the bit value at offset in the string value stored at key.
  #
  # source://redis//lib/redis/distributed.rb#316
  def getbit(key, offset); end

  # Get a substring of the string stored at a key.
  #
  # source://redis//lib/redis/distributed.rb#306
  def getrange(key, start, stop); end

  # Set the string value of a key and return its old value.
  #
  # source://redis//lib/redis/distributed.rb#343
  def getset(key, value); end

  # Delete one or more hash fields.
  #
  # source://redis//lib/redis/distributed.rb#702
  def hdel(key, *fields); end

  # Determine if a hash field exists.
  #
  # source://redis//lib/redis/distributed.rb#707
  def hexists(key, field); end

  # Get the value of a hash field.
  #
  # source://redis//lib/redis/distributed.rb#688
  def hget(key, field); end

  # Get all the fields and values in a hash.
  #
  # source://redis//lib/redis/distributed.rb#732
  def hgetall(key); end

  # Increment the integer value of a hash field by the given integer number.
  #
  # source://redis//lib/redis/distributed.rb#712
  def hincrby(key, field, increment); end

  # Increment the numeric value of a hash field by the given float number.
  #
  # source://redis//lib/redis/distributed.rb#717
  def hincrbyfloat(key, field, increment); end

  # Get all the fields in a hash.
  #
  # source://redis//lib/redis/distributed.rb#722
  def hkeys(key); end

  # Get the number of fields in a hash.
  #
  # source://redis//lib/redis/distributed.rb#664
  def hlen(key); end

  # Get the values of all the given hash fields.
  #
  # source://redis//lib/redis/distributed.rb#693
  def hmget(key, *fields); end

  # Set multiple hash fields to multiple values.
  #
  # source://redis//lib/redis/distributed.rb#679
  def hmset(key, *attrs); end

  # Set the string value of a hash field.
  #
  # source://redis//lib/redis/distributed.rb#669
  def hset(key, field, value); end

  # Set the value of a hash field, only if the field does not exist.
  #
  # source://redis//lib/redis/distributed.rb#674
  def hsetnx(key, field, value); end

  # Get all the values in a hash.
  #
  # source://redis//lib/redis/distributed.rb#727
  def hvals(key); end

  # Increment the integer value of a key by one.
  #
  # source://redis//lib/redis/distributed.rb#231
  def incr(key); end

  # Increment the integer value of a key by the given integer number.
  #
  # source://redis//lib/redis/distributed.rb#236
  def incrby(key, increment); end

  # Increment the numeric value of a key by the given float number.
  #
  # source://redis//lib/redis/distributed.rb#241
  def incrbyfloat(key, increment); end

  # Get information and statistics about the server.
  #
  # source://redis//lib/redis/distributed.rb#82
  def info(cmd = T.unsafe(nil)); end

  # source://redis//lib/redis/distributed.rb#852
  def inspect; end

  # Find all keys matching the given pattern.
  #
  # source://redis//lib/redis/distributed.rb#178
  def keys(glob = T.unsafe(nil)); end

  # Get the UNIX time stamp of the last successful save to disk.
  #
  # source://redis//lib/redis/distributed.rb#87
  def lastsave; end

  # Get an element from a list by its index.
  #
  # source://redis//lib/redis/distributed.rb#451
  def lindex(key, index); end

  # Insert an element before or after another element in a list.
  #
  # source://redis//lib/redis/distributed.rb#456
  def linsert(key, where, pivot, value); end

  # Get the length of a list.
  #
  # source://redis//lib/redis/distributed.rb#361
  def llen(key); end

  # Remove and get the first element in a list.
  #
  # source://redis//lib/redis/distributed.rb#386
  def lpop(key); end

  # Prepend one or more values to a list.
  #
  # source://redis//lib/redis/distributed.rb#366
  def lpush(key, value); end

  # Prepend a value to a list, only if the list exists.
  #
  # source://redis//lib/redis/distributed.rb#371
  def lpushx(key, value); end

  # Get a range of elements from a list.
  #
  # source://redis//lib/redis/distributed.rb#461
  def lrange(key, start, stop); end

  # Remove elements from a list.
  #
  # source://redis//lib/redis/distributed.rb#466
  def lrem(key, count, value); end

  # Set the value of an element in a list by its index.
  #
  # source://redis//lib/redis/distributed.rb#471
  def lset(key, index, value); end

  # Trim a list to the specified range.
  #
  # source://redis//lib/redis/distributed.rb#476
  def ltrim(key, start, stop); end

  # source://redis//lib/redis/distributed.rb#697
  def mapped_hmget(key, *fields); end

  # source://redis//lib/redis/distributed.rb#683
  def mapped_hmset(key, hash); end

  # Get the values of all the given keys as a Hash.
  #
  # source://redis//lib/redis/distributed.rb#294
  def mapped_mget(*keys); end

  # @raise [CannotDistribute]
  #
  # source://redis//lib/redis/distributed.rb#270
  def mapped_mset(hash); end

  # @raise [CannotDistribute]
  #
  # source://redis//lib/redis/distributed.rb#279
  def mapped_msetnx(hash); end

  # Get the values of all the given keys as an Array.
  #
  # source://redis//lib/redis/distributed.rb#289
  def mget(*keys); end

  # Transfer a key from the connected instance to another instance.
  #
  # @raise [CannotDistribute]
  #
  # source://redis//lib/redis/distributed.rb#152
  def migrate(key, options); end

  # Listen for all requests received by the server in real time.
  #
  # @raise [NotImplementedError]
  #
  # source://redis//lib/redis/distributed.rb#92
  def monitor; end

  # Move a key to another database.
  #
  # source://redis//lib/redis/distributed.rb#183
  def move(key, db); end

  # Set multiple keys to multiple values.
  #
  # @raise [CannotDistribute]
  #
  # source://redis//lib/redis/distributed.rb#266
  def mset(*args); end

  # Set multiple keys to multiple values, only if none of the keys exist.
  #
  # @raise [CannotDistribute]
  #
  # source://redis//lib/redis/distributed.rb#275
  def msetnx(*args); end

  # Mark the start of a transaction block.
  #
  # @raise [CannotDistribute]
  #
  # source://redis//lib/redis/distributed.rb#790
  def multi; end

  # source://redis//lib/redis/distributed.rb#27
  def node_for(key); end

  # source://redis//lib/redis/distributed.rb#31
  def nodes; end

  # Remove the expiration from a key.
  #
  # source://redis//lib/redis/distributed.rb#107
  def persist(key); end

  # Set a key's time to live in milliseconds.
  #
  # source://redis//lib/redis/distributed.rb#127
  def pexpire(key, milliseconds); end

  # Set the expiration for a key as number of milliseconds from UNIX Epoch.
  #
  # source://redis//lib/redis/distributed.rb#132
  def pexpireat(key, ms_unix_time); end

  # Add one or more members to a HyperLogLog structure.
  #
  # source://redis//lib/redis/distributed.rb#810
  def pfadd(key, member); end

  # Get the approximate cardinality of members added to HyperLogLog structure.
  #
  # source://redis//lib/redis/distributed.rb#815
  def pfcount(*keys); end

  # Merge multiple HyperLogLog values into an unique value that will approximate the cardinality of the union of
  # the observed Sets of the source HyperLogLog structures.
  #
  # source://redis//lib/redis/distributed.rb#823
  def pfmerge(dest_key, *source_key); end

  # Ping the server.
  #
  # source://redis//lib/redis/distributed.rb#47
  def ping; end

  # @raise [CannotDistribute]
  #
  # source://redis//lib/redis/distributed.rb#785
  def pipelined; end

  # Set the time to live in milliseconds of a key.
  #
  # source://redis//lib/redis/distributed.rb#256
  def psetex(key, ttl, value); end

  # Listen for messages published to channels matching the given patterns.
  #
  # @raise [NotImplementedError]
  #
  # source://redis//lib/redis/distributed.rb#765
  def psubscribe(*channels, &block); end

  # Get the time to live (in milliseconds) for a key.
  #
  # source://redis//lib/redis/distributed.rb#137
  def pttl(key); end

  # Post a message to a channel.
  #
  # source://redis//lib/redis/distributed.rb#737
  def publish(channel, message); end

  # Stop listening for messages posted to channels matching the given
  # patterns.
  #
  # @raise [NotImplementedError]
  #
  # source://redis//lib/redis/distributed.rb#771
  def punsubscribe(*channels); end

  # Close the connection.
  #
  # source://redis//lib/redis/distributed.rb#57
  def quit; end

  # Return a random key from the keyspace.
  #
  # @raise [CannotDistribute]
  #
  # source://redis//lib/redis/distributed.rb#188
  def randomkey; end

  # Rename a key.
  #
  # source://redis//lib/redis/distributed.rb#193
  def rename(old_name, new_name); end

  # Rename a key, only if the new key does not exist.
  #
  # source://redis//lib/redis/distributed.rb#200
  def renamenx(old_name, new_name); end

  # Create a key using the serialized value, previously obtained using DUMP.
  #
  # source://redis//lib/redis/distributed.rb#147
  def restore(key, ttl, serialized_value, options = T.unsafe(nil)); end

  # Returns the value of attribute ring.
  #
  # source://redis//lib/redis/distributed.rb#16
  def ring; end

  # Remove and get the last element in a list.
  #
  # source://redis//lib/redis/distributed.rb#391
  def rpop(key); end

  # Remove the last element in a list, append it to another list and return
  # it.
  #
  # source://redis//lib/redis/distributed.rb#397
  def rpoplpush(source, destination); end

  # Append one or more values to a list.
  #
  # source://redis//lib/redis/distributed.rb#376
  def rpush(key, value); end

  # Append a value to a list, only if the list exists.
  #
  # source://redis//lib/redis/distributed.rb#381
  def rpushx(key, value); end

  # Add one or more members to a set.
  #
  # source://redis//lib/redis/distributed.rb#486
  def sadd(key, member); end

  # Synchronously save the dataset to disk.
  #
  # source://redis//lib/redis/distributed.rb#97
  def save; end

  # Get the number of members in a set.
  #
  # source://redis//lib/redis/distributed.rb#481
  def scard(key); end

  # Control remote script registry.
  #
  # source://redis//lib/redis/distributed.rb#805
  def script(subcommand, *args); end

  # Subtract multiple sets.
  #
  # source://redis//lib/redis/distributed.rb#533
  def sdiff(*keys); end

  # Subtract multiple sets and store the resulting set in a key.
  #
  # source://redis//lib/redis/distributed.rb#540
  def sdiffstore(destination, *keys); end

  # Change the selected database for the current connection.
  #
  # source://redis//lib/redis/distributed.rb#42
  def select(db); end

  # Set the string value of a key.
  #
  # source://redis//lib/redis/distributed.rb#246
  def set(key, value, options = T.unsafe(nil)); end

  # Sets or clears the bit at offset in the string value stored at key.
  #
  # source://redis//lib/redis/distributed.rb#311
  def setbit(key, offset, value); end

  # Set the time to live in seconds of a key.
  #
  # source://redis//lib/redis/distributed.rb#251
  def setex(key, ttl, value); end

  # Set the value of a key, only if the key does not exist.
  #
  # source://redis//lib/redis/distributed.rb#261
  def setnx(key, value); end

  # Overwrite part of a string at key starting at the specified offset.
  #
  # source://redis//lib/redis/distributed.rb#301
  def setrange(key, offset, value); end

  # Intersect multiple sets.
  #
  # source://redis//lib/redis/distributed.rb#547
  def sinter(*keys); end

  # Intersect multiple sets and store the resulting set in a key.
  #
  # source://redis//lib/redis/distributed.rb#554
  def sinterstore(destination, *keys); end

  # Determine if a given value is a member of a set.
  #
  # source://redis//lib/redis/distributed.rb#513
  def sismember(key, member); end

  # Get all the members in a set.
  #
  # source://redis//lib/redis/distributed.rb#518
  def smembers(key); end

  # Move a member from one set to another.
  #
  # source://redis//lib/redis/distributed.rb#506
  def smove(source, destination, member); end

  # Sort the elements in a list, set or sorted set.
  #
  # source://redis//lib/redis/distributed.rb#207
  def sort(key, options = T.unsafe(nil)); end

  # Remove and return a random member from a set.
  #
  # source://redis//lib/redis/distributed.rb#496
  def spop(key, count = T.unsafe(nil)); end

  # Get a random member from a set.
  #
  # source://redis//lib/redis/distributed.rb#501
  def srandmember(key, count = T.unsafe(nil)); end

  # Remove one or more members from a set.
  #
  # source://redis//lib/redis/distributed.rb#491
  def srem(key, member); end

  # Scan a set
  #
  # source://redis//lib/redis/distributed.rb#523
  def sscan(key, cursor, options = T.unsafe(nil)); end

  # Scan a set and return an enumerator
  #
  # source://redis//lib/redis/distributed.rb#528
  def sscan_each(key, options = T.unsafe(nil), &block); end

  # Get the length of the value stored in a key.
  #
  # source://redis//lib/redis/distributed.rb#348
  def strlen(key); end

  # Listen for messages published to the given channels.
  #
  # source://redis//lib/redis/distributed.rb#746
  def subscribe(channel, *channels, &block); end

  # @return [Boolean]
  #
  # source://redis//lib/redis/distributed.rb#741
  def subscribed?; end

  # Add multiple sets.
  #
  # source://redis//lib/redis/distributed.rb#561
  def sunion(*keys); end

  # Add multiple sets and store the resulting set in a key.
  #
  # source://redis//lib/redis/distributed.rb#568
  def sunionstore(destination, *keys); end

  # Get server time: an UNIX timestamp and the elapsed microseconds in the current second.
  #
  # source://redis//lib/redis/distributed.rb#102
  def time; end

  # Get the time to live (in seconds) for a key.
  #
  # source://redis//lib/redis/distributed.rb#122
  def ttl(key); end

  # Determine the type stored at key.
  #
  # source://redis//lib/redis/distributed.rb#216
  def type(key); end

  # Unlink keys.
  #
  # source://redis//lib/redis/distributed.rb#165
  def unlink(*args); end

  # Stop listening for messages posted to the given channels.
  #
  # @raise [RuntimeError]
  #
  # source://redis//lib/redis/distributed.rb#759
  def unsubscribe(*channels); end

  # Forget about all watched keys.
  #
  # @raise [CannotDistribute]
  #
  # source://redis//lib/redis/distributed.rb#781
  def unwatch; end

  # Watch the given keys to determine execution of the MULTI/EXEC block.
  #
  # @raise [CannotDistribute]
  #
  # source://redis//lib/redis/distributed.rb#776
  def watch(*keys); end

  # Add one or more members to a sorted set, or update the score for members
  # that already exist.
  #
  # source://redis//lib/redis/distributed.rb#581
  def zadd(key, *args); end

  # Get the number of members in a sorted set.
  #
  # source://redis//lib/redis/distributed.rb#575
  def zcard(key); end

  # Get the number of members in a particular score range.
  #
  # source://redis//lib/redis/distributed.rb#644
  def zcount(key, min, max); end

  # Increment the score of a member in a sorted set.
  #
  # source://redis//lib/redis/distributed.rb#586
  def zincrby(key, increment, member); end

  # Intersect multiple sorted sets and store the resulting sorted set in a new
  # key.
  #
  # source://redis//lib/redis/distributed.rb#650
  def zinterstore(destination, keys, options = T.unsafe(nil)); end

  # Return a range of members in a sorted set, by index.
  #
  # source://redis//lib/redis/distributed.rb#601
  def zrange(key, start, stop, options = T.unsafe(nil)); end

  # Return a range of members in a sorted set, by score.
  #
  # source://redis//lib/redis/distributed.rb#628
  def zrangebyscore(key, min, max, options = T.unsafe(nil)); end

  # Determine the index of a member in a sorted set.
  #
  # source://redis//lib/redis/distributed.rb#612
  def zrank(key, member); end

  # Remove one or more members from a sorted set.
  #
  # source://redis//lib/redis/distributed.rb#591
  def zrem(key, member); end

  # Remove all members in a sorted set within the given indexes.
  #
  # source://redis//lib/redis/distributed.rb#623
  def zremrangebyrank(key, start, stop); end

  # Remove all members in a sorted set within the given scores.
  #
  # source://redis//lib/redis/distributed.rb#639
  def zremrangebyscore(key, min, max); end

  # Return a range of members in a sorted set, by index, with scores ordered
  # from high to low.
  #
  # source://redis//lib/redis/distributed.rb#607
  def zrevrange(key, start, stop, options = T.unsafe(nil)); end

  # Return a range of members in a sorted set, by score, with scores ordered
  # from high to low.
  #
  # source://redis//lib/redis/distributed.rb#634
  def zrevrangebyscore(key, max, min, options = T.unsafe(nil)); end

  # Determine the index of a member in a sorted set, with scores ordered from
  # high to low.
  #
  # source://redis//lib/redis/distributed.rb#618
  def zrevrank(key, member); end

  # Get the score associated with the given member in a sorted set.
  #
  # source://redis//lib/redis/distributed.rb#596
  def zscore(key, member); end

  # Add multiple sorted sets and store the resulting sorted set in a new key.
  #
  # source://redis//lib/redis/distributed.rb#657
  def zunionstore(destination, keys, options = T.unsafe(nil)); end

  protected

  # @yield [node_for(keys.first)]
  #
  # source://redis//lib/redis/distributed.rb#876
  def ensure_same_node(command, keys); end

  # source://redis//lib/redis/distributed.rb#872
  def key_tag(key); end

  # source://redis//lib/redis/distributed.rb#868
  def node_index_for(key); end

  # source://redis//lib/redis/distributed.rb#862
  def on_each_node(command, *args); end
end

class Redis::Distributed::CannotDistribute < ::RuntimeError
  # @return [CannotDistribute] a new instance of CannotDistribute
  #
  # source://redis//lib/redis/distributed.rb#7
  def initialize(command); end

  # source://redis//lib/redis/distributed.rb#11
  def message; end
end

# source://redis//lib/redis.rb#3353
Redis::Floatify = T.let(T.unsafe(nil), Proc)

# source://redis//lib/redis.rb#3364
Redis::FloatifyPairs = T.let(T.unsafe(nil), Proc)

class Redis::Future < ::BasicObject
  # @return [Future] a new instance of Future
  #
  # source://redis//lib/redis/pipeline.rb#111
  def initialize(command, transformation); end

  # source://redis//lib/redis/pipeline.rb#126
  def _command; end

  # source://redis//lib/redis/pipeline.rb#121
  def _set(object); end

  # source://redis//lib/redis/pipeline.rb#139
  def class; end

  # source://redis//lib/redis/pipeline.rb#117
  def inspect; end

  # @return [Boolean]
  #
  # source://redis//lib/redis/pipeline.rb#135
  def is_a?(other); end

  # source://redis//lib/redis/pipeline.rb#130
  def value; end
end

# source://redis//lib/redis/pipeline.rb#109
Redis::Future::FutureNotReady = T.let(T.unsafe(nil), Redis::FutureNotReady)

class Redis::FutureNotReady < ::RuntimeError
  # @return [FutureNotReady] a new instance of FutureNotReady
  #
  # source://redis//lib/redis/pipeline.rb#103
  def initialize; end
end

class Redis::HashRing
  # nodes is a list of objects that have a proper to_s representation.
  # replicas indicates how many virtual points should be used pr. node,
  # replicas are required to improve the distribution.
  #
  # @return [HashRing] a new instance of HashRing
  #
  # source://redis//lib/redis/hash_ring.rb#13
  def initialize(nodes = T.unsafe(nil), replicas = T.unsafe(nil)); end

  # Adds a `node` to the hash ring (including a number of replicas).
  #
  # source://redis//lib/redis/hash_ring.rb#24
  def add_node(node); end

  # get the node in the hash ring for this key
  #
  # source://redis//lib/redis/hash_ring.rb#44
  def get_node(key); end

  # source://redis//lib/redis/hash_ring.rb#48
  def get_node_pos(key); end

  # source://redis//lib/redis/hash_ring.rb#55
  def iter_nodes(key); end

  # Returns the value of attribute nodes.
  #
  # source://redis//lib/redis/hash_ring.rb#8
  def nodes; end

  # source://redis//lib/redis/hash_ring.rb#34
  def remove_node(node); end

  # Returns the value of attribute replicas.
  #
  # source://redis//lib/redis/hash_ring.rb#8
  def replicas; end

  # Returns the value of attribute ring.
  #
  # source://redis//lib/redis/hash_ring.rb#8
  def ring; end

  # Returns the value of attribute sorted_keys.
  #
  # source://redis//lib/redis/hash_ring.rb#8
  def sorted_keys; end

  class << self
    # Find the closest index in HashRing with value <= the given value
    #
    # source://redis//lib/redis/hash_ring.rb#64
    def binary_search(ary, value, &block); end
  end
end

# this is the default in libmemcached
#
# source://redis//lib/redis/hash_ring.rb#6
Redis::HashRing::POINTS_PER_SERVER = T.let(T.unsafe(nil), Integer)

# source://redis//lib/redis.rb#3344
Redis::Hashify = T.let(T.unsafe(nil), Proc)

# source://redis//lib/redis.rb#3415
Redis::HashifyClusterNodeInfo = T.let(T.unsafe(nil), Proc)

# source://redis//lib/redis.rb#3446
Redis::HashifyClusterNodes = T.let(T.unsafe(nil), Proc)

# source://redis//lib/redis.rb#3451
Redis::HashifyClusterSlaves = T.let(T.unsafe(nil), Proc)

# source://redis//lib/redis.rb#3431
Redis::HashifyClusterSlots = T.let(T.unsafe(nil), Proc)

# source://redis//lib/redis.rb#3371
Redis::HashifyInfo = T.let(T.unsafe(nil), Proc)

# source://redis//lib/redis.rb#3386
Redis::HashifyStreamEntries = T.let(T.unsafe(nil), Proc)

# source://redis//lib/redis.rb#3403
Redis::HashifyStreamPendingDetails = T.let(T.unsafe(nil), Proc)

# source://redis//lib/redis.rb#3393
Redis::HashifyStreamPendings = T.let(T.unsafe(nil), Proc)

# source://redis//lib/redis.rb#3378
Redis::HashifyStreams = T.let(T.unsafe(nil), Proc)

# Raised when the connection was inherited by a child process.
class Redis::InheritedError < ::Redis::BaseConnectionError; end

# Raised when client options are invalid.
class Redis::InvalidClientOptionError < ::Redis::BaseError; end

# source://redis//lib/redis.rb#3456
Redis::Noop = T.let(T.unsafe(nil), Proc)

class Redis::Pipeline
  # @return [Pipeline] a new instance of Pipeline
  #
  # source://redis//lib/redis/pipeline.rb#7
  def initialize; end

  # source://redis//lib/redis/pipeline.rb#29
  def call(command, &block); end

  # source://redis//lib/redis/pipeline.rb#38
  def call_pipeline(pipeline); end

  # source://redis//lib/redis/pipeline.rb#45
  def commands; end

  # Returns the value of attribute db.
  #
  # source://redis//lib/redis/pipeline.rb#3
  def db; end

  # Sets the attribute db
  #
  # @param value the value to set the attribute db to.
  #
  # source://redis//lib/redis/pipeline.rb#3
  def db=(_arg0); end

  # @return [Boolean]
  #
  # source://redis//lib/redis/pipeline.rb#25
  def empty?; end

  # source://redis//lib/redis/pipeline.rb#58
  def finish(replies, &blk); end

  # Returns the value of attribute futures.
  #
  # source://redis//lib/redis/pipeline.rb#5
  def futures; end

  # @return [Boolean]
  #
  # source://redis//lib/redis/pipeline.rb#21
  def shutdown?; end

  # source://redis//lib/redis/pipeline.rb#49
  def with_reconnect(val = T.unsafe(nil)); end

  # @return [Boolean]
  #
  # source://redis//lib/redis/pipeline.rb#13
  def with_reconnect?; end

  # source://redis//lib/redis/pipeline.rb#54
  def without_reconnect(&blk); end

  # @return [Boolean]
  #
  # source://redis//lib/redis/pipeline.rb#17
  def without_reconnect?; end
end

class Redis::Pipeline::Multi < ::Redis::Pipeline
  # source://redis//lib/redis/pipeline.rb#92
  def commands; end

  # source://redis//lib/redis/pipeline.rb#71
  def finish(replies); end
end

# Raised by the connection when a protocol error occurs.
class Redis::ProtocolError < ::Redis::BaseError
  # @return [ProtocolError] a new instance of ProtocolError
  #
  # source://redis//lib/redis/errors.rb#8
  def initialize(reply_type); end
end

class Redis::SubscribedClient
  # @return [SubscribedClient] a new instance of SubscribedClient
  #
  # source://redis//lib/redis/subscribe.rb#3
  def initialize(client); end

  # source://redis//lib/redis/subscribe.rb#7
  def call(command); end

  # source://redis//lib/redis/subscribe.rb#19
  def psubscribe(*channels, &block); end

  # source://redis//lib/redis/subscribe.rb#23
  def psubscribe_with_timeout(timeout, *channels, &block); end

  # source://redis//lib/redis/subscribe.rb#31
  def punsubscribe(*channels); end

  # source://redis//lib/redis/subscribe.rb#11
  def subscribe(*channels, &block); end

  # source://redis//lib/redis/subscribe.rb#15
  def subscribe_with_timeout(timeout, *channels, &block); end

  # source://redis//lib/redis/subscribe.rb#27
  def unsubscribe(*channels); end

  protected

  # source://redis//lib/redis/subscribe.rb#37
  def subscription(start, stop, channels, block, timeout = T.unsafe(nil)); end
end

class Redis::Subscription
  # @return [Subscription] a new instance of Subscription
  # @yield [_self]
  # @yieldparam _self [Redis::Subscription] the object that the method was called on
  #
  # source://redis//lib/redis/subscribe.rb#59
  def initialize; end

  # Returns the value of attribute callbacks.
  #
  # source://redis//lib/redis/subscribe.rb#57
  def callbacks; end

  # source://redis//lib/redis/subscribe.rb#75
  def message(&block); end

  # source://redis//lib/redis/subscribe.rb#87
  def pmessage(&block); end

  # source://redis//lib/redis/subscribe.rb#79
  def psubscribe(&block); end

  # source://redis//lib/redis/subscribe.rb#83
  def punsubscribe(&block); end

  # source://redis//lib/redis/subscribe.rb#67
  def subscribe(&block); end

  # source://redis//lib/redis/subscribe.rb#71
  def unsubscribe(&block); end
end

# Raised when performing I/O times out.
class Redis::TimeoutError < ::Redis::BaseConnectionError; end

# source://redis//lib/redis/version.rb#2
Redis::VERSION = T.let(T.unsafe(nil), String)
