# typed: true

# DO NOT EDIT MANUALLY
# This is an autogenerated file for types exported from the `kgio` gem.
# Please instead update this file by running `bin/tapioca gem kgio`.

# See the {README}[link:index.html]
#
# source://kgio//lib/kgio.rb#5
module Kgio
  class << self
    def accept_class; end
    def accept_class=(_arg0); end
    def accept_cloexec=(_arg0); end
    def accept_cloexec?; end
    def accept_nonblock=(_arg0); end
    def accept_nonblock?; end
    def autopush=(_arg0); end
    def autopush?; end
    def poll(*_arg0); end
    def trypeek(*_arg0); end
    def tryread(*_arg0); end
    def trywrite(_arg0, _arg1); end
    def trywritev(_arg0, _arg1); end
  end
end

module Kgio::DefaultWaiters
  def kgio_wait_readable(*_arg0); end
  def kgio_wait_writable(*_arg0); end
end

class Kgio::File < ::File
  include ::Kgio::DefaultWaiters
  include ::Kgio::PipeMethods

  class << self
    def tryopen(*_arg0); end
  end
end

# The IPv4 address of UNIX domain sockets, useful for creating
# Rack (and CGI) servers that also serve HTTP traffic over
# UNIX domain sockets.
#
# source://kgio//lib/kgio.rb#10
Kgio::LOCALHOST = T.let(T.unsafe(nil), String)

Kgio::MSG_FASTOPEN = T.let(T.unsafe(nil), Integer)
Kgio::POLLERR = T.let(T.unsafe(nil), Integer)
Kgio::POLLHUP = T.let(T.unsafe(nil), Integer)
Kgio::POLLIN = T.let(T.unsafe(nil), Integer)
Kgio::POLLNVAL = T.let(T.unsafe(nil), Integer)
Kgio::POLLOUT = T.let(T.unsafe(nil), Integer)
Kgio::POLLPRI = T.let(T.unsafe(nil), Integer)
Kgio::POLLRDHUP = T.let(T.unsafe(nil), Integer)

# use Kgio::Pipe.popen and Kgio::Pipe.new instead of IO.popen
# and IO.pipe to get PipeMethods#kgio_read and PipeMethod#kgio_write
# methods.
#
# source://kgio//lib/kgio.rb#26
class Kgio::Pipe < ::IO
  include ::Kgio::DefaultWaiters
  include ::Kgio::PipeMethods

  class << self
    # call-seq:
    #
    #   rd, wr = Kgio::Pipe.new
    #
    # This creates a new pipe(7) with Kgio::Pipe objects that respond
    # to PipeMethods#kgio_read and PipeMethod#kgio_write
    def new(*_arg0); end
  end
end

module Kgio::PipeMethods
  include ::Kgio::DefaultWaiters

  def kgio_read(*_arg0); end
  def kgio_read!(*_arg0); end
  def kgio_tryread(*_arg0); end
  def kgio_trywrite(_arg0); end
  def kgio_trywritev(_arg0); end
  def kgio_write(_arg0); end
  def kgio_writev(_arg0); end
end

Kgio::SOCK_CLOEXEC = T.let(T.unsafe(nil), Integer)
Kgio::SOCK_NONBLOCK = T.let(T.unsafe(nil), Integer)

class Kgio::Socket < ::Socket
  include ::Kgio::DefaultWaiters
  include ::Kgio::SocketMethods

  def kgio_fastopen(_arg0, _arg1); end

  class << self
    def connect(_arg0); end
    def new(*_arg0); end
    def start(_arg0); end
  end
end

module Kgio::SocketMethods
  include ::Kgio::DefaultWaiters

  def kgio_addr; end
  def kgio_addr!; end
  def kgio_addr=(_arg0); end
  def kgio_autopush=(_arg0); end
  def kgio_autopush?; end
  def kgio_peek(*_arg0); end
  def kgio_read(*_arg0); end
  def kgio_read!(*_arg0); end
  def kgio_syssend(_arg0, _arg1); end
  def kgio_trypeek(*_arg0); end
  def kgio_tryread(*_arg0); end
  def kgio_trywrite(_arg0); end
  def kgio_trywritev(_arg0); end
  def kgio_write(_arg0); end
  def kgio_writev(_arg0); end
end

class Kgio::TCPServer < ::TCPServer
  def kgio_accept(*_arg0); end
  def kgio_tryaccept(*_arg0); end
end

class Kgio::TCPSocket < ::TCPSocket
  include ::Kgio::DefaultWaiters
  include ::Kgio::SocketMethods

  class << self
    def new(_arg0, _arg1); end
    def start(_arg0, _arg1); end
  end
end

Kgio::TCP_FASTOPEN = T.let(T.unsafe(nil), Integer)

class Kgio::UNIXServer < ::UNIXServer
  def kgio_accept(*_arg0); end
  def kgio_tryaccept(*_arg0); end
end

class Kgio::UNIXSocket < ::UNIXSocket
  include ::Kgio::DefaultWaiters
  include ::Kgio::SocketMethods

  class << self
    def new(_arg0); end
    def start(_arg0); end
  end
end

# Kgio::PipeMethods#kgio_tryread and Kgio::SocketMethods#kgio_tryread will
# return :wait_readable when waiting for a read is required.
#
# source://kgio//lib/kgio.rb#14
Kgio::WaitReadable = T.let(T.unsafe(nil), Symbol)

# PipeMethods#kgio_trywrite and SocketMethods#kgio_trywrite will return
# :wait_writable when waiting for a read is required.
#
# source://kgio//lib/kgio.rb#18
Kgio::WaitWritable = T.let(T.unsafe(nil), Symbol)
