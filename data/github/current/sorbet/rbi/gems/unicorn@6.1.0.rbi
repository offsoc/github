# typed: true

# DO NOT EDIT MANUALLY
# This is an autogenerated file for types exported from the `unicorn` gem.
# Please instead update this file by running `bin/tapioca gem unicorn`.

module Kgio::DefaultWaiters
  def kgio_wait_readable(*_arg0); end
  def kgio_wait_writable(*_arg0); end
end

class Kgio::Socket < ::Socket
  include ::Kgio::DefaultWaiters
  include ::Kgio::SocketMethods

  def kgio_fastopen(_arg0, _arg1); end

  class << self
    def connect(_arg0); end
    def new(*_arg0); end
    def start(_arg0); end
  end
end

module Kgio::SocketMethods
  include ::Kgio::DefaultWaiters

  def kgio_addr; end
  def kgio_addr!; end
  def kgio_addr=(_arg0); end
  def kgio_autopush=(_arg0); end
  def kgio_autopush?; end
  def kgio_peek(*_arg0); end
  def kgio_read(*_arg0); end
  def kgio_read!(*_arg0); end
  def kgio_syssend(_arg0, _arg1); end
  def kgio_trypeek(*_arg0); end
  def kgio_tryread(*_arg0); end
  def kgio_trywrite(_arg0); end
  def kgio_trywritev(_arg0); end
  def kgio_write(_arg0); end
  def kgio_writev(_arg0); end
end

class Kgio::TCPServer < ::TCPServer
  def kgio_accept(*_arg0); end
  def kgio_tryaccept(*_arg0); end
end

# unicorn exposes very little of an user-visible API and most of its
# internals are subject to change.  unicorn is designed to host Rack
# applications, so applications should be written against the Rack SPEC
# and not unicorn internals.
#
# source://unicorn//lib/unicorn.rb#24
module Unicorn
  class << self
    # This returns a lambda to pass in as the app, this does not "build" the
    # app (which we defer based on the outcome of "preload_app" in the
    # Unicorn config).  The returned lambda will be called when it is
    # time to build the app.
    #
    # source://unicorn//lib/unicorn.rb#41
    def builder(ru, op); end

    # returns an array of strings representing TCP listen socket addresses
    # and Unix domain socket paths.  This is useful for use with
    # Raindrops::Middleware under Linux: https://yhbt.net/raindrops/
    #
    # source://unicorn//lib/unicorn.rb#100
    def listener_names; end

    # source://unicorn//lib/unicorn.rb#106
    def log_error(logger, prefix, exc); end

    # source://unicorn//lib/unicorn.rb#115
    def pipe; end
  end
end

# Raised inside TeeInput when a client closes the socket inside the
# application dispatch.  This is always raised with an empty backtrace
# since there is nothing in the application stack that is responsible
# for client shutdowns/disconnects.  This exception is visible to Rack
# applications unless PrereadInput middleware is loaded.  This
# is a subclass of the standard EOFError class and applications should
# not rescue it explicitly, but rescue EOFError instead.
#
# source://unicorn//lib/unicorn.rb#33
class Unicorn::ClientShutdown < ::EOFError; end

# Implements a simple DSL for configuring a unicorn server.
#
# See https://yhbt.net/unicorn/examples/unicorn.conf.rb and
# https://yhbt.net/unicorn/examples/unicorn.conf.minimal.rb
# example configuration files.  An example config file for use with
# nginx is also available at
# https://yhbt.net/unicorn/examples/nginx.conf
#
# See the link:/TUNING.html document for more information on tuning unicorn.
#
# source://unicorn//lib/unicorn/configurator.rb#13
class Unicorn::Configurator
  include ::Unicorn

  # :startdoc:
  #
  # @return [Configurator] a new instance of Configurator
  #
  # source://unicorn//lib/unicorn/configurator.rb#65
  def initialize(defaults = T.unsafe(nil)); end

  # source://unicorn//lib/unicorn/configurator.rb#128
  def [](key); end

  # sets after_fork hook to a given block.  This block will be called by
  # the worker after forking.  The following is an example hook which adds
  # a per-process listener to every worker:
  #
  #  after_fork do |server,worker|
  #    # per-process listener ports for debugging/admin:
  #    addr = "127.0.0.1:#{9293 + worker.nr}"
  #
  #    # the negative :tries parameter indicates we will retry forever
  #    # waiting on the existing process to exit with a 5 second :delay
  #    # Existing options for Unicorn::Configurator#listen such as
  #    # :backlog, :rcvbuf, :sndbuf are available here as well.
  #    server.listen(addr, :tries => -1, :delay => 5, :backlog => 128)
  #  end
  #
  # source://unicorn//lib/unicorn/configurator.rb#166
  def after_fork(*args, &block); end

  # :stopdoc:
  #
  # source://unicorn//lib/unicorn/configurator.rb#17
  def after_reload; end

  # :stopdoc:
  #
  # source://unicorn//lib/unicorn/configurator.rb#17
  def after_reload=(_arg0); end

  # sets after_worker_exit hook to a given block.  This block will be called
  # by the master process after a worker exits:
  #
  #  after_worker_exit do |server,worker,status|
  #    # status is a Process::Status instance for the exited worker process
  #    unless status.success?
  #      server.logger.error("worker process failure: #{status.inspect}")
  #    end
  #  end
  #
  # after_worker_exit is only available in unicorn 5.3.0+
  #
  # source://unicorn//lib/unicorn/configurator.rb#181
  def after_worker_exit(*args, &block); end

  # sets after_worker_ready hook to a given block.  This block will be called
  # by a worker process after it has been fully loaded, directly before it
  # starts responding to requests:
  #
  #  after_worker_ready do |server,worker|
  #    server.logger.info("worker #{worker.nr} ready, dropping privileges")
  #    worker.user('username', 'groupname')
  #  end
  #
  # Do not use Configurator#user if you rely on changing users in the
  # after_worker_ready hook.
  #
  # after_worker_ready is only available in unicorn 5.3.0+
  #
  # source://unicorn//lib/unicorn/configurator.rb#198
  def after_worker_ready(*args, &block); end

  # sets the before_exec hook to a given Proc object.  This
  # Proc object will be called by the master process right
  # before exec()-ing the new unicorn binary.  This is useful
  # for freeing certain OS resources that you do NOT wish to
  # share with the reexeced child process.
  # There is no corresponding after_exec hook (for obvious reasons).
  #
  # source://unicorn//lib/unicorn/configurator.rb#215
  def before_exec(*args, &block); end

  # sets before_fork got be a given Proc object.  This Proc
  # object will be called by the master process before forking
  # each worker.
  #
  # source://unicorn//lib/unicorn/configurator.rb#205
  def before_fork(*args, &block); end

  # When enabled, unicorn will check the client connection by writing
  # the beginning of the HTTP headers before calling the application.
  #
  # This will prevent calling the application for clients who have
  # disconnected while their connection was queued.
  #
  # This only affects clients connecting over Unix domain sockets
  # and TCP via loopback (127.*.*.*).  It is unlikely to detect
  # disconnects if the client is on a remote host (even on a fast LAN).
  #
  # This option cannot be used in conjunction with :tcp_nopush.
  #
  # source://unicorn//lib/unicorn/configurator.rb#574
  def check_client_connection(bool); end

  # The maximum size (in +bytes+) to buffer in memory before
  # resorting to a temporary file.  Default is 112 kilobytes.
  # This option has no effect if "rewindable_input" is set to
  # +false+.
  #
  # source://unicorn//lib/unicorn/configurator.rb#559
  def client_body_buffer_size(bytes); end

  # source://unicorn//lib/unicorn/configurator.rb#108
  def commit!(server, options = T.unsafe(nil)); end

  # :stopdoc:
  #
  # source://unicorn//lib/unicorn/configurator.rb#17
  def config_file; end

  # :stopdoc:
  #
  # source://unicorn//lib/unicorn/configurator.rb#17
  def config_file=(_arg0); end

  # sets whether to add default middleware in the development and
  # deployment RACK_ENVs.
  #
  # default_middleware is only available in unicorn 5.5.0+
  #
  # source://unicorn//lib/unicorn/configurator.rb#276
  def default_middleware(bool); end

  # sets whether to enable the proposed early hints Rack API.
  # If enabled, Rails 5.2+ will automatically send a 103 Early Hint
  # for all the `javascript_include_tag` and `stylesheet_link_tag`
  # in your response. See: https://api.rubyonrails.org/v5.2/classes/ActionDispatch/Request.html#method-i-send_early_hints
  # See also https://tools.ietf.org/html/rfc8297
  #
  # source://unicorn//lib/unicorn/configurator.rb#285
  def early_hints(bool); end

  # expands "unix:path/to/foo" to a socket relative to the current path
  # expands pathnames of sockets if relative to "~" or "~username"
  # expands "*:port and ":port" to "0.0.0.0:port"
  #
  # source://unicorn//lib/unicorn/configurator.rb#640
  def expand_addr(address); end

  # Adds an +address+ to the existing listener set.  May be specified more
  # than once.  +address+ may be an Integer port number for a TCP port, an
  # "IP_ADDRESS:PORT" for TCP listeners or a pathname for UNIX domain sockets.
  #
  #   listen 3000 # listen to port 3000 on all TCP interfaces
  #   listen "127.0.0.1:3000"  # listen to port 3000 on the loopback interface
  #   listen "/path/to/.unicorn.sock" # listen on the given Unix domain socket
  #   listen "[::1]:3000" # listen to port 3000 on the IPv6 loopback interface
  #
  # When using Unix domain sockets, be sure:
  # 1) the path matches the one used by nginx
  # 2) uses the same filesystem namespace as the nginx process
  # For systemd users using PrivateTmp=true (for either nginx or unicorn),
  # this means Unix domain sockets must not be placed in /tmp
  #
  # The following options may be specified (but are generally not needed):
  #
  # [:backlog => number of clients]
  #
  #   This is the backlog of the listen() syscall.
  #
  #   Some operating systems allow negative values here to specify the
  #   maximum allowable value.  In most cases, this number is only
  #   recommendation and there are other OS-specific tunables and
  #   variables that can affect this number.  See the listen(2)
  #   syscall documentation of your OS for the exact semantics of
  #   this.
  #
  #   If you are running unicorn on multiple machines, lowering this number
  #   can help your load balancer detect when a machine is overloaded
  #   and give requests to a different machine.
  #
  #   Default: 1024
  #
  #   Note: with the Linux kernel, the net.core.somaxconn sysctl defaults
  #   to 128, capping this value to 128.  Raising the sysctl allows a
  #   larger backlog (which may not be desirable with multiple,
  #   load-balanced machines).
  #
  # [:rcvbuf => bytes, :sndbuf => bytes]
  #
  #   Maximum receive and send buffer sizes (in bytes) of sockets.
  #
  #   These correspond to the SO_RCVBUF and SO_SNDBUF settings which
  #   can be set via the setsockopt(2) syscall.  Some kernels
  #   (e.g. Linux 2.4+) have intelligent auto-tuning mechanisms and
  #   there is no need (and it is sometimes detrimental) to specify them.
  #
  #   See the socket API documentation of your operating system
  #   to determine the exact semantics of these settings and
  #   other operating system-specific knobs where they can be
  #   specified.
  #
  #   Defaults: operating system defaults
  #
  # [:tcp_nodelay => true or false]
  #
  #   Disables Nagle's algorithm on TCP sockets if +true+.
  #
  #   Setting this to +true+ can make streaming responses in Rails 3.1
  #   appear more quickly at the cost of slightly higher bandwidth usage.
  #   The effect of this option is most visible if nginx is not used,
  #   but nginx remains highly recommended with unicorn.
  #
  #   This has no effect on UNIX sockets.
  #
  #   Default: +true+ (Nagle's algorithm disabled) in unicorn
  #   This defaulted to +false+ in unicorn 3.x
  #
  # [:tcp_nopush => true or false]
  #
  #   Enables/disables TCP_CORK in Linux or TCP_NOPUSH in FreeBSD
  #
  #   This prevents partial TCP frames from being sent out and reduces
  #   wakeups in nginx if it is on a different machine.  Since unicorn
  #   is only designed for applications that send the response body
  #   quickly without keepalive, sockets will always be flushed on close
  #   to prevent delays.
  #
  #   This has no effect on UNIX sockets.
  #
  #   Default: +false+
  #   This defaulted to +true+ in unicorn 3.4 - 3.7
  #
  # [:ipv6only => true or false]
  #
  #   This option makes IPv6-capable TCP listeners IPv6-only and unable
  #   to receive IPv4 queries on dual-stack systems.  A separate IPv4-only
  #   listener is required if this is true.
  #
  #   Enabling this option for the IPv6-only listener and having a
  #   separate IPv4 listener is recommended if you wish to support IPv6
  #   on the same TCP port.  Otherwise, the value of \env[\"REMOTE_ADDR\"]
  #   will appear as an ugly IPv4-mapped-IPv6 address for IPv4 clients
  #   (e.g ":ffff:10.0.0.1" instead of just "10.0.0.1").
  #
  #   Default: Operating-system dependent
  #
  # [:reuseport => true or false]
  #
  #   This enables multiple, independently-started unicorn instances to
  #   bind to the same port (as long as all the processes enable this).
  #
  #   This option must be used when unicorn first binds the listen socket.
  #   It cannot be enabled when a socket is inherited via SIGUSR2
  #   (but it will remain on if inherited), and it cannot be enabled
  #   directly via SIGHUP.
  #
  #   Note: there is a chance of connections being dropped if
  #   one of the unicorn instances is stopped while using this.
  #
  #   This is supported on *BSD systems and Linux 3.9 or later.
  #
  #   ref: https://lwn.net/Articles/542629/
  #
  #   Default: false (unset)
  #
  # [:tries => Integer]
  #
  #   Times to retry binding a socket if it is already in use
  #
  #   A negative number indicates we will retry indefinitely, this is
  #   useful for migrations and upgrades when individual workers
  #   are binding to different ports.
  #
  #   Default: 5
  #
  # [:delay => seconds]
  #
  #   Seconds to wait between successive +tries+
  #
  #   Default: 0.5 seconds
  #
  # [:umask => mode]
  #
  #   Sets the file mode creation mask for UNIX sockets.  If specified,
  #   this is usually in octal notation.
  #
  #   Typically UNIX domain sockets are created with more liberal
  #   file permissions than the rest of the application.  By default,
  #   we create UNIX domain sockets to be readable and writable by
  #   all local users to give them the same accessibility as
  #   locally-bound TCP listeners.
  #
  #   This has no effect on TCP listeners.
  #
  #   Default: 0000 (world-read/writable)
  #
  # [:tcp_defer_accept => Integer]
  #
  #   Defer accept() until data is ready (Linux-only)
  #
  #   For Linux 2.6.32 and later, this is the number of retransmits to
  #   defer an accept() for if no data arrives, but the client will
  #   eventually be accepted after the specified number of retransmits
  #   regardless of whether data is ready.
  #
  #   For Linux before 2.6.32, this is a boolean option, and
  #   accepts are _always_ deferred indefinitely if no data arrives.
  #   This is similar to <code>:accept_filter => "dataready"</code>
  #   under FreeBSD.
  #
  #   Specifying +true+ is synonymous for the default value(s) below,
  #   and +false+ or +nil+ is synonymous for a value of zero.
  #
  #   A value of +1+ is a good optimization for local networks
  #   and trusted clients.  There is no good reason to ever
  #   disable this with a +zero+ value with unicorn.
  #
  #   Default: 1
  #
  # [:accept_filter => String]
  #
  #   defer accept() until data is ready (FreeBSD-only)
  #
  #   This enables either the "dataready" or (default) "httpready"
  #   accept() filter under FreeBSD.  This is intended as an
  #   optimization to reduce context switches with common GET/HEAD
  #   requests.
  #
  #   There is no good reason to change from the default.
  #
  #   Default: "httpready"
  #
  # source://unicorn//lib/unicorn/configurator.rb#483
  def listen(address, options = T.unsafe(nil)); end

  # sets listeners to the given +addresses+, replacing or augmenting the
  # current set.  This is for the global listener pool shared by all
  # worker processes.  For per-worker listeners, see the after_fork example
  # This is for internal API use only, do not use it in your Unicorn
  # config file.  Use listen instead.
  #
  # source://unicorn//lib/unicorn/configurator.rb#294
  def listeners(addresses); end

  # sets object to the +obj+ Logger-like object.  The new Logger-like
  # object must respond to the following methods:
  # * debug
  # * info
  # * warn
  # * error
  # * fatal
  # The default Logger will log its output to the path specified
  # by +stderr_path+.  If you're running Unicorn daemonized, then
  # you must specify a path to prevent error messages from going
  # to /dev/null.
  #
  # source://unicorn//lib/unicorn/configurator.rb#143
  def logger(obj); end

  # sets the +path+ for the PID file of the unicorn master process
  #
  # source://unicorn//lib/unicorn/configurator.rb#507
  def pid(path); end

  # Enabling this preloads an application before forking worker
  # processes.  This allows memory savings when using a
  # copy-on-write-friendly GC but can cause bad things to happen when
  # resources like sockets are opened at load time by the master
  # process and shared by multiple children.  People enabling this are
  # highly encouraged to look at the before_fork/after_fork hooks to
  # properly close/reopen sockets.  Files opened for logging do not
  # have to be reopened as (unbuffered-in-userspace) files opened with
  # the File::APPEND flag are written to atomically on UNIX.
  #
  # In addition to reloading the unicorn-specific config settings,
  # SIGHUP will reload application code in the working
  # directory/symlink when workers are gracefully restarted when
  # preload_app=false (the default).  As reloading the application
  # sometimes requires RubyGems updates, +Gem.refresh+ is always
  # called before the application is loaded (for RubyGems users).
  #
  # During deployments, care should _always_ be taken to ensure your
  # applications are properly deployed and running.  Using
  # preload_app=false (the default) means you _must_ check if
  # your application is responding properly after a deployment.
  # Improperly deployed applications can go into a spawn loop
  # if the application fails to load.  While your children are
  # in a spawn loop, it is is possible to fix an application
  # by properly deploying all required code and dependencies.
  # Using preload_app=true means any application load error will
  # cause the master process to exit with an error.
  #
  # source://unicorn//lib/unicorn/configurator.rb#537
  def preload_app(bool); end

  # source://unicorn//lib/unicorn/configurator.rb#81
  def reload(merge_defaults = T.unsafe(nil)); end

  # Toggles making \env[\"rack.input\"] rewindable.
  # Disabling rewindability can improve performance by lowering
  # I/O and memory usage for applications that accept uploads.
  # Keep in mind that the Rack 1.x spec requires
  # \env[\"rack.input\"] to be rewindable,
  # but the Rack 2.x spec does not.
  #
  # +rewindable_input+ defaults to +true+ for compatibility.
  # Setting it to +false+ may be safe for applications and
  # frameworks developed for Rack 2.x and later.
  #
  # source://unicorn//lib/unicorn/configurator.rb#551
  def rewindable_input(bool); end

  # :stopdoc:
  #
  # source://unicorn//lib/unicorn/configurator.rb#17
  def set; end

  # :stopdoc:
  #
  # source://unicorn//lib/unicorn/configurator.rb#17
  def set=(_arg0); end

  # Allow redirecting $stderr to a given path.  Unlike doing this from
  # the shell, this allows the unicorn process to know the path its
  # writing to and rotate the file if it is used for logging.  The
  # file will be opened with the File::APPEND flag and writes
  # synchronized to the kernel (but not necessarily to _disk_) so
  # multiple processes can safely append to it.
  #
  # If you are daemonizing and using the default +logger+, it is important
  # to specify this as errors will otherwise be lost to /dev/null.
  # Some applications/libraries may also triggering warnings that go to
  # stderr, and they will end up here.
  #
  # source://unicorn//lib/unicorn/configurator.rb#589
  def stderr_path(path); end

  # Same as stderr_path, except for $stdout.  Not many Rack applications
  # write to $stdout, but any that do will have their output written here.
  # It is safe to point this to the same location a stderr_path.
  # Like stderr_path, this defaults to /dev/null when daemonized.
  #
  # source://unicorn//lib/unicorn/configurator.rb#597
  def stdout_path(path); end

  # sets the timeout of worker processes to +seconds+.  Workers
  # handling the request/app.call/response cycle taking longer than
  # this time period will be forcibly killed (via SIGKILL).  This
  # timeout is enforced by the master process itself and not subject
  # to the scheduling limitations by the worker process.  Due the
  # low-complexity, low-overhead implementation, timeouts of less
  # than 3.0 seconds can be considered inaccurate and unsafe.
  #
  # For running Unicorn behind nginx, it is recommended to set
  # "fail_timeout=0" for in your nginx configuration like this
  # to have nginx always retry backends that may have had workers
  # SIGKILL-ed due to timeouts.
  #
  #    upstream unicorn_backend {
  #      # for UNIX domain socket setups:
  #      server unix:/path/to/.unicorn.sock fail_timeout=0;
  #
  #      # for TCP setups
  #      server 192.168.0.7:8080 fail_timeout=0;
  #      server 192.168.0.8:8080 fail_timeout=0;
  #      server 192.168.0.9:8080 fail_timeout=0;
  #    }
  #
  # See https://nginx.org/en/docs/http/ngx_http_upstream_module.html
  # for more details on nginx upstream configuration.
  #
  # source://unicorn//lib/unicorn/configurator.rb#244
  def timeout(seconds); end

  # Runs worker processes as the specified +user+ and +group+.
  # The master process always stays running as the user who started it.
  # This switch will occur after calling the after_fork hook, and only
  # if the Worker#user method is not called in the after_fork hook
  # +group+ is optional and will not change if unspecified.
  #
  # Do not use Configurator#user if you rely on changing users in the
  # after_worker_ready hook.  Instead, you need to call Worker#user
  # directly in after_worker_ready.
  #
  # source://unicorn//lib/unicorn/configurator.rb#630
  def user(user, group = T.unsafe(nil)); end

  # Whether to exec in each worker process after forking.  This changes the
  # memory layout of each worker process, which is a security feature designed
  # to defeat possible address space discovery attacks.  Note that using
  # worker_exec only makes sense if you are not preloading the application,
  # and will result in higher memory usage.
  #
  # worker_exec is only available in unicorn 5.3.0+
  #
  # source://unicorn//lib/unicorn/configurator.rb#258
  def worker_exec(bool); end

  # sets the current number of worker_processes to +nr+.  Each worker
  # process will serve exactly one client at a time.  You can
  # increment or decrement this value at runtime by sending SIGTTIN
  # or SIGTTOU respectively to the master process without reloading
  # the rest of your Unicorn configuration.  See the SIGNALS document
  # for more information.
  #
  # source://unicorn//lib/unicorn/configurator.rb#268
  def worker_processes(nr); end

  # sets the working directory for Unicorn.  This ensures SIGUSR2 will
  # start a new instance of Unicorn in this directory.  This may be
  # a symlink, a common scenario for Capistrano users.  Unlike
  # all other Unicorn configuration directives, this binds immediately
  # for error checking and cannot be undone by unsetting it in the
  # configuration file and reloading.
  #
  # source://unicorn//lib/unicorn/configurator.rb#607
  def working_directory(path); end

  private

  # source://unicorn//lib/unicorn/configurator.rb#667
  def canonicalize_tcp(addr, port); end

  # @raise [ArgumentError]
  #
  # source://unicorn//lib/unicorn/configurator.rb#682
  def check_bool(var, bool); end

  # this is called _after_ working_directory is bound.  This only
  # parses the embedded switches in .ru files
  # (for "rackup" compatibility)
  #
  # source://unicorn//lib/unicorn/configurator.rb#713
  def parse_rackup_file; end

  # source://unicorn//lib/unicorn/configurator.rb#690
  def set_bool(var, bool); end

  # source://unicorn//lib/unicorn/configurator.rb#694
  def set_hook(var, my_proc, req_arity = T.unsafe(nil)); end

  # source://unicorn//lib/unicorn/configurator.rb#661
  def set_int(var, n, min); end

  # source://unicorn//lib/unicorn/configurator.rb#673
  def set_path(var, path); end
end

# Default settings for Unicorn
#
# source://unicorn//lib/unicorn/configurator.rb#31
Unicorn::Configurator::DEFAULTS = T.let(T.unsafe(nil), Hash)

# used to stash stuff for deferred processing of cli options in
# config.ru after "working_directory" is bound.  Do not rely on
# this being around later on...
#
# source://unicorn//lib/unicorn/configurator.rb#22
Unicorn::Configurator::RACKUP = T.let(T.unsafe(nil), Hash)

# source://unicorn//lib/unicorn/const.rb#3
module Unicorn::Const; end

# The basic request body size we'll try to read at once (16 kilobytes).
#
# source://unicorn//lib/unicorn/const.rb#14
Unicorn::Const::CHUNK_SIZE = T.let(T.unsafe(nil), Integer)

# default TCP listen host address (0.0.0.0, all interfaces)
#
# source://unicorn//lib/unicorn/const.rb#5
Unicorn::Const::DEFAULT_HOST = T.let(T.unsafe(nil), String)

# default TCP listen address and port (0.0.0.0:8080)
#
# source://unicorn//lib/unicorn/const.rb#11
Unicorn::Const::DEFAULT_LISTEN = T.let(T.unsafe(nil), String)

# default TCP listen port (8080)
#
# source://unicorn//lib/unicorn/const.rb#8
Unicorn::Const::DEFAULT_PORT = T.let(T.unsafe(nil), Integer)

# Maximum request body size before it is moved out of memory and into a
# temporary file for reading (112 kilobytes).  This is the default
# value of client_body_buffer_size.
#
# source://unicorn//lib/unicorn/const.rb#19
Unicorn::Const::MAX_BODY = T.let(T.unsafe(nil), Integer)

# source://unicorn//lib/unicorn/version.rb#1
Unicorn::Const::UNICORN_VERSION = T.let(T.unsafe(nil), String)

# source://unicorn//lib/unicorn.rb#113
Unicorn::F_SETPIPE_SZ = T.let(T.unsafe(nil), Integer)

# source://unicorn//lib/unicorn/http_request.rb#8
class Unicorn::HttpParser
  def initialize; end

  def add_parse(_arg0); end
  def body_eof?; end
  def buf; end

  # for rack.hijack, we respond to this method so no extra allocation
  # of a proc object
  #
  # source://unicorn//lib/unicorn/http_request.rb#98
  def call; end

  # Ruby 2.2+ can show struct tcp_info as a string Socket::Option#inspect.
  # Not that efficient, but probably still better than doing unnecessary
  # work after a client gives up.
  #
  # source://unicorn//lib/unicorn/http_request.rb#110
  def check_client_connection(socket); end

  def clear; end

  # raindrops before 0.18 only supported TCP_INFO under Linux
  #
  # @return [Boolean]
  #
  # source://unicorn//lib/unicorn/http_request.rb#139
  def closed_state?(state); end

  def content_length; end
  def env; end
  def filter_body(_arg0, _arg1); end
  def headers(_arg0, _arg1); end
  def headers?; end
  def hijacked!; end

  # @return [Boolean]
  #
  # source://unicorn//lib/unicorn/http_request.rb#103
  def hijacked?; end

  def keepalive?; end
  def next?; end
  def parse; end

  # Does the majority of the IO processing.  It has been written in
  # Ruby using about 8 different IO processing strategies.
  #
  # It is currently carefully constructed to make sure that it gets
  # the best possible performance for the common case: GET requests
  # that are fully complete after a single read(2)
  #
  # Anyone who thinks they can make it faster is more than welcome to
  # take a crack at it.
  #
  # returns an environment hash suitable for Rack if successful
  # This does minimal exception trapping and it is up to the caller
  # to handle any socket errors (e.g. user aborted upload).
  #
  # source://unicorn//lib/unicorn/http_request.rb#64
  def read(socket); end

  def response_start_sent; end
  def response_start_sent=(_arg0); end
  def trailers(_arg0, _arg1); end

  # source://unicorn//lib/unicorn/http_request.rb#184
  def write_http_header(socket); end

  class << self
    # source://unicorn//lib/unicorn/http_request.rb#41
    def check_client_connection; end

    # source://unicorn//lib/unicorn/http_request.rb#45
    def check_client_connection=(bool); end

    # source://unicorn//lib/unicorn/http_request.rb#33
    def input_class; end

    # source://unicorn//lib/unicorn/http_request.rb#37
    def input_class=(klass); end

    # called by ext/unicorn_http/unicorn_http.rl via rb_funcall
    #
    # @raise [Unicorn::HttpParserError]
    # @return [Boolean]
    #
    # source://unicorn//lib/unicorn/http_request.rb#192
    def is_chunked?(v); end

    def max_header_len=(_arg0); end
  end
end

Unicorn::HttpParser::CHUNK_MAX = T.let(T.unsafe(nil), Integer)

# default parameters we merge into the request env for Rack handlers
#
# source://unicorn//lib/unicorn/http_request.rb#11
Unicorn::HttpParser::DEFAULTS = T.let(T.unsafe(nil), Hash)

# source://unicorn//lib/unicorn/http_request.rb#28
Unicorn::HttpParser::EMPTY_ARRAY = T.let(T.unsafe(nil), Array)

# :stopdoc:
#
# source://unicorn//lib/unicorn/http_request.rb#27
Unicorn::HttpParser::HTTP_RESPONSE_START = T.let(T.unsafe(nil), Array)

Unicorn::HttpParser::LENGTH_MAX = T.let(T.unsafe(nil), Integer)

# source://unicorn//lib/unicorn/http_request.rb#24
Unicorn::HttpParser::NULL_IO = T.let(T.unsafe(nil), StringIO)

# source://unicorn//lib/unicorn/http_request.rb#108
Unicorn::HttpParser::TCPI = T.let(T.unsafe(nil), Raindrops::TCP_Info)

class Unicorn::HttpParserError < ::IOError; end

# source://unicorn//lib/unicorn/http_request.rb#7
Unicorn::HttpRequest = Unicorn::HttpParser

# :enddoc:
# Writes a Rack response to your client using the HTTP/1.1 specification.
# You use it by simply doing:
#
#   status, headers, body = rack_app.call(env)
#   http_response_write(socket, status, headers, body)
#
# Most header correctness (including Content-Length and Content-Type)
# is the job of Rack, with the exception of the "Date" and "Status" header.
#
# source://unicorn//lib/unicorn/http_response.rb#11
module Unicorn::HttpResponse
  # internal API, code will always be common-enough-for-even-old-Rack
  #
  # source://unicorn//lib/unicorn/http_response.rb#17
  def err_response(code, response_start_sent); end

  # writes the rack_response to socket as an HTTP response
  #
  # source://unicorn//lib/unicorn/http_response.rb#23
  def http_response_write(socket, status, headers, body, req = T.unsafe(nil)); end

  def httpdate; end
end

# source://unicorn//lib/unicorn/http_response.rb#13
Unicorn::HttpResponse::STATUS_CODES = T.let(T.unsafe(nil), Hash)

# This is the process manager of Unicorn. This manages worker
# processes which in turn handle the I/O and application process.
# Listener sockets are started in the master process and shared with
# forked worker children.
#
# Users do not need to know the internals of this class, but reading the
# {source}[https://yhbt.net/unicorn.git/tree/lib/unicorn/http_server.rb]
# is education for programmers wishing to learn how unicorn works.
# See Unicorn::Configurator for information on how to configure unicorn.
#
# source://unicorn//lib/unicorn/http_server.rb#12
class Unicorn::HttpServer
  include ::Unicorn::SocketHelper
  include ::Unicorn::HttpResponse

  # Creates a working server on host:port (strange things happen if
  # port isn't a Number).  Use HttpServer::run to start the server and
  # HttpServer.run.join to join the thread that's processing
  # incoming requests on the socket.
  #
  # @return [HttpServer] a new instance of HttpServer
  #
  # source://unicorn//lib/unicorn/http_server.rb#70
  def initialize(app, options = T.unsafe(nil)); end

  # :stopdoc:
  #
  # source://unicorn//lib/unicorn/http_server.rb#14
  def after_fork; end

  # :stopdoc:
  #
  # source://unicorn//lib/unicorn/http_server.rb#14
  def after_fork=(_arg0); end

  # Sets the attribute after_worker_exit
  #
  # @param value the value to set the attribute after_worker_exit to.
  #
  # source://unicorn//lib/unicorn/http_server.rb#19
  def after_worker_exit=(_arg0); end

  # Sets the attribute after_worker_ready
  #
  # @param value the value to set the attribute after_worker_ready to.
  #
  # source://unicorn//lib/unicorn/http_server.rb#19
  def after_worker_ready=(_arg0); end

  # :stopdoc:
  #
  # source://unicorn//lib/unicorn/http_server.rb#14
  def app; end

  # :stopdoc:
  #
  # source://unicorn//lib/unicorn/http_server.rb#14
  def app=(_arg0); end

  # :stopdoc:
  #
  # source://unicorn//lib/unicorn/http_server.rb#14
  def before_exec; end

  # :stopdoc:
  #
  # source://unicorn//lib/unicorn/http_server.rb#14
  def before_exec=(_arg0); end

  # :stopdoc:
  #
  # source://unicorn//lib/unicorn/http_server.rb#14
  def before_fork; end

  # :stopdoc:
  #
  # source://unicorn//lib/unicorn/http_server.rb#14
  def before_fork=(_arg0); end

  # source://unicorn//lib/unicorn/http_server.rb#372
  def check_client_connection; end

  # source://unicorn//lib/unicorn/http_server.rb#376
  def check_client_connection=(bool); end

  # source://unicorn//lib/unicorn/http_server.rb#364
  def client_body_buffer_size; end

  # source://unicorn//lib/unicorn/http_server.rb#368
  def client_body_buffer_size=(bytes); end

  # source://unicorn//lib/unicorn/http_server.rb#181
  def clobber_pid(path); end

  # :stopdoc:
  #
  # source://unicorn//lib/unicorn/http_server.rb#14
  def config; end

  # :stopdoc:
  #
  # source://unicorn//lib/unicorn/http_server.rb#14
  def config=(_arg0); end

  # :stopdoc:
  #
  # source://unicorn//lib/unicorn/http_server.rb#14
  def default_middleware; end

  # :stopdoc:
  #
  # source://unicorn//lib/unicorn/http_server.rb#14
  def default_middleware=(_arg0); end

  # :stopdoc:
  #
  # source://unicorn//lib/unicorn/http_server.rb#14
  def early_hints; end

  # :stopdoc:
  #
  # source://unicorn//lib/unicorn/http_server.rb#14
  def early_hints=(_arg0); end

  # monitors children and receives signals forever
  # (or until a termination signal is sent).  This handles signals
  # one-at-a-time time and we'll happily drop signals in case somebody
  # is signalling us too often.
  #
  # source://unicorn//lib/unicorn/http_server.rb#268
  def join; end

  # add a given address to the +listeners+ set, idempotently
  # Allows workers to add a private, per-process listener via the
  # after_fork hook.  Very useful for debugging and testing.
  # +:tries+ may be specified as an option for the number of times
  # to retry, and +:delay+ may be specified as the time in seconds
  # to delay between retries.
  # A negative value for +:tries+ indicates the listen will be
  # retried indefinitely, this is useful when workers belonging to
  # different masters are spawned during a transparent upgrade.
  #
  # source://unicorn//lib/unicorn/http_server.rb#235
  def listen(address, opt = T.unsafe(nil)); end

  # :stopdoc:
  #
  # source://unicorn//lib/unicorn/http_server.rb#14
  def listener_opts; end

  # :stopdoc:
  #
  # source://unicorn//lib/unicorn/http_server.rb#14
  def listener_opts=(_arg0); end

  # replaces current listener set with +listeners+.  This will
  # close the socket if it will not exist in the new listener set
  #
  # source://unicorn//lib/unicorn/http_server.rb#149
  def listeners=(listeners); end

  # Returns the value of attribute logger.
  #
  # source://unicorn//lib/unicorn/http_server.rb#21
  def logger; end

  # source://unicorn//lib/unicorn/http_server.rb#177
  def logger=(obj); end

  # :stopdoc:
  #
  # source://unicorn//lib/unicorn/http_server.rb#14
  def orig_app; end

  # :stopdoc:
  #
  # source://unicorn//lib/unicorn/http_server.rb#14
  def orig_app=(_arg0); end

  # Returns the value of attribute pid.
  #
  # source://unicorn//lib/unicorn/http_server.rb#21
  def pid; end

  # sets the path for the PID file of the master process
  #
  # source://unicorn//lib/unicorn/http_server.rb#197
  def pid=(path); end

  # :stopdoc:
  #
  # source://unicorn//lib/unicorn/http_server.rb#14
  def preload_app; end

  # :stopdoc:
  #
  # source://unicorn//lib/unicorn/http_server.rb#14
  def preload_app=(_arg0); end

  # :stopdoc:
  #
  # source://unicorn//lib/unicorn/http_server.rb#14
  def ready_pipe; end

  # :stopdoc:
  #
  # source://unicorn//lib/unicorn/http_server.rb#14
  def ready_pipe=(_arg0); end

  # source://unicorn//lib/unicorn/http_server.rb#355
  def rewindable_input; end

  # source://unicorn//lib/unicorn/http_server.rb#359
  def rewindable_input=(bool); end

  # Runs the thing.  Returns self so you can run join on it
  #
  # source://unicorn//lib/unicorn/http_server.rb#121
  def start; end

  # source://unicorn//lib/unicorn/http_server.rb#175
  def stderr_path=(path); end

  # source://unicorn//lib/unicorn/http_server.rb#174
  def stdout_path=(path); end

  # Terminates all workers, but does not exit master process
  #
  # source://unicorn//lib/unicorn/http_server.rb#340
  def stop(graceful = T.unsafe(nil)); end

  # :stopdoc:
  #
  # source://unicorn//lib/unicorn/http_server.rb#14
  def timeout; end

  # :stopdoc:
  #
  # source://unicorn//lib/unicorn/http_server.rb#14
  def timeout=(_arg0); end

  # :stopdoc:
  #
  # source://unicorn//lib/unicorn/http_server.rb#14
  def user; end

  # :stopdoc:
  #
  # source://unicorn//lib/unicorn/http_server.rb#14
  def user=(_arg0); end

  # Sets the attribute worker_exec
  #
  # @param value the value to set the attribute worker_exec to.
  #
  # source://unicorn//lib/unicorn/http_server.rb#19
  def worker_exec=(_arg0); end

  # :stopdoc:
  #
  # source://unicorn//lib/unicorn/http_server.rb#14
  def worker_processes; end

  # :stopdoc:
  #
  # source://unicorn//lib/unicorn/http_server.rb#14
  def worker_processes=(_arg0); end

  private

  # source://unicorn//lib/unicorn/http_server.rb#518
  def after_fork_internal; end

  # source://unicorn//lib/unicorn/http_server.rb#392
  def awaken_master; end

  # call only after calling inherit_listeners!
  # This binds any listeners we did NOT inherit from the parent
  #
  # @raise [ArgumentError]
  #
  # source://unicorn//lib/unicorn/http_server.rb#876
  def bind_new_listeners!; end

  # source://unicorn//lib/unicorn/http_server.rb#815
  def build_app!; end

  # source://unicorn//lib/unicorn/http_server.rb#488
  def close_sockets_on_exec(sockets); end

  # source://unicorn//lib/unicorn/http_server.rb#609
  def e100_response_write(client, env); end

  # source://unicorn//lib/unicorn/http_server.rb#590
  def e103_response_write(client, headers); end

  # if we get any error, try to write something back to the client
  # assuming we haven't closed the socket, but don't get hung up
  # if the socket is already closed or broken.  We'll always ensure
  # the socket is closed at the end of this function
  #
  # source://unicorn//lib/unicorn/http_server.rb#569
  def handle_error(client, e); end

  # source://unicorn//lib/unicorn/http_server.rb#835
  def inherit_listeners!; end

  # gets rid of stuff the worker has no business keeping track of
  # to free some resources and drops all sig handlers.
  # traps for USR1, USR2, and HUP may be set in the after_fork Proc
  # by the user.
  #
  # source://unicorn//lib/unicorn/http_server.rb#671
  def init_worker_process(worker); end

  # delivers a signal to each worker
  #
  # source://unicorn//lib/unicorn/http_server.rb#763
  def kill_each_worker(signal); end

  # delivers a signal to a worker and fails gracefully if the worker
  # is no longer running.
  #
  # source://unicorn//lib/unicorn/http_server.rb#756
  def kill_worker(signal, wpid); end

  # returns an array of string names for the given listener array
  #
  # source://unicorn//lib/unicorn/http_server.rb#811
  def listener_names(listeners = T.unsafe(nil)); end

  # source://unicorn//lib/unicorn/http_server.rb#479
  def listener_sockets; end

  # source://unicorn//lib/unicorn/http_server.rb#793
  def load_config!; end

  # source://unicorn//lib/unicorn/http_server.rb#559
  def maintain_worker_count; end

  # wait for a signal hander to wake us up and then consume the pipe
  #
  # source://unicorn//lib/unicorn/http_server.rb#383
  def master_sleep(sec); end

  # forcibly terminate all workers that haven't checked in in timeout seconds.  The timeout is implemented using an unlinked File
  #
  # source://unicorn//lib/unicorn/http_server.rb#498
  def murder_lazy_workers; end

  # source://unicorn//lib/unicorn/http_server.rb#660
  def nuke_listeners!(readers); end

  # source://unicorn//lib/unicorn/http_server.rb#707
  def prep_readers(readers); end

  # source://unicorn//lib/unicorn/http_server.rb#825
  def proc_name(tag); end

  # once a client is accepted, it is processed in its entirety here
  # in 3 easy steps: read request, call app, write app response
  #
  # source://unicorn//lib/unicorn/http_server.rb#622
  def process_client(client); end

  # reaps all unreaped workers
  #
  # source://unicorn//lib/unicorn/http_server.rb#398
  def reap_all_workers; end

  # source://unicorn//lib/unicorn/http_server.rb#830
  def redirect_io(io, path); end

  # reexecutes the START_CTX with a new binary
  #
  # source://unicorn//lib/unicorn/http_server.rb#417
  def reexec; end

  # source://unicorn//lib/unicorn/http_server.rb#697
  def reopen_worker_logs(worker_nr); end

  # source://unicorn//lib/unicorn/http_server.rb#767
  def soft_kill_each_worker(signal); end

  # source://unicorn//lib/unicorn/http_server.rb#529
  def spawn_missing_workers; end

  # source://unicorn//lib/unicorn/http_server.rb#885
  def time_now; end

  # unlinks a PID file at given +path+ if it contains the current PID
  # still potentially racy without locking the directory (which is
  # non-portable and may interact badly with other programs), but the
  # window for hitting the race condition is small
  #
  # source://unicorn//lib/unicorn/http_server.rb#775
  def unlink_pid_safe(path); end

  # returns a PID if a given path contains a non-stale PID file,
  # nil otherwise.
  #
  # @return [Boolean]
  #
  # source://unicorn//lib/unicorn/http_server.rb#781
  def valid_pid?(path); end

  # runs inside each forked worker, this sits around and waits
  # for connections and doesn't die until the parent dies (or is
  # given a INT, QUIT, or TERM signal)
  #
  # source://unicorn//lib/unicorn/http_server.rb#720
  def worker_loop(worker); end

  # source://unicorn//lib/unicorn/http_server.rb#463
  def worker_spawn(worker); end
end

# all bound listener sockets
# note: this is public used by raindrops, but not recommended for use
# in new projects
#
# source://unicorn//lib/unicorn/http_server.rb#28
Unicorn::HttpServer::LISTENERS = T.let(T.unsafe(nil), Array)

# listeners we have yet to bind
#
# source://unicorn//lib/unicorn/http_server.rb#31
Unicorn::HttpServer::NEW_LISTENERS = T.let(T.unsafe(nil), Array)

# :startdoc:
# We populate this at startup so we can figure out how to reexecute
# and upgrade the currently running instance of Unicorn
# This Hash is considered a stable interface and changing its contents
# will allow you to switch between different installations of Unicorn
# or even different installations of the same applications without
# downtime.  Keys of this constant Hash are described as follows:
#
# * 0 - the path to the unicorn executable
# * :argv - a deep copy of the ARGV array the executable originally saw
# * :cwd - the working directory of the application, this is where
# you originally started Unicorn.
#
# To change your unicorn executable to a different path without downtime,
# you can set the following in your Unicorn config file, HUP and then
# continue with the traditional USR2 + QUIT upgrade steps:
#
#   Unicorn::HttpServer::START_CTX[0] = "/home/bofh/2.3.0/bin/unicorn"
#
# source://unicorn//lib/unicorn/http_server.rb#51
Unicorn::HttpServer::START_CTX = T.let(T.unsafe(nil), Hash)

class Unicorn::RequestEntityTooLargeError < ::Unicorn::HttpParserError; end
class Unicorn::RequestURITooLongError < ::Unicorn::HttpParserError; end

# source://unicorn//lib/unicorn/socket_helper.rb#18
module Unicorn::SocketHelper
  # creates a new server, socket. address may be a HOST:PORT or
  # an absolute path to a UNIX socket.  address can even be a Socket
  # object in which case it is immediately returned
  #
  # source://unicorn//lib/unicorn/socket_helper.rb#117
  def bind_listen(address = T.unsafe(nil), opt = T.unsafe(nil)); end

  # source://unicorn//lib/unicorn/socket_helper.rb#108
  def log_buffer_sizes(sock, pfx = T.unsafe(nil)); end

  # source://unicorn//lib/unicorn/socket_helper.rb#153
  def new_tcp_server(addr, port, opt); end

  # casts a given Socket to be a TCPServer or UNIXServer
  #
  # source://unicorn//lib/unicorn/socket_helper.rb#201
  def server_cast(sock); end

  # source://unicorn//lib/unicorn/socket_helper.rb#91
  def set_server_sockopt(sock, opt); end

  # source://unicorn//lib/unicorn/socket_helper.rb#45
  def set_tcp_sockopt(sock, opt); end

  private

  # Returns the configuration name of a socket as a string.  sock may
  # be a string value, in which case it is returned as-is
  # Warning: TCP sockets may not always return the name given to it.
  #
  # source://unicorn//lib/unicorn/socket_helper.rb#180
  def sock_name(sock); end

  # returns rfc2732-style (e.g. "[::1]:666") addresses for IPv6
  #
  # source://unicorn//lib/unicorn/socket_helper.rb#171
  def tcp_name(sock); end

  class << self
    # Returns the configuration name of a socket as a string.  sock may
    # be a string value, in which case it is returned as-is
    # Warning: TCP sockets may not always return the name given to it.
    #
    # source://unicorn//lib/unicorn/socket_helper.rb#180
    def sock_name(sock); end

    # returns rfc2732-style (e.g. "[::1]:666") addresses for IPv6
    #
    # source://unicorn//lib/unicorn/socket_helper.rb#171
    def tcp_name(sock); end
  end
end

# internal interface
#
# source://unicorn//lib/unicorn/socket_helper.rb#21
Unicorn::SocketHelper::DEFAULTS = T.let(T.unsafe(nil), Hash)

# When processing uploads, unicorn may expose a StreamInput object under
# "rack.input" of the Rack environment when
# Unicorn::Configurator#rewindable_input is set to +false+
#
# source://unicorn//lib/unicorn/stream_input.rb#6
class Unicorn::StreamInput
  # Initializes a new StreamInput object.  You normally do not have to call
  # this unless you are writing an HTTP server.
  #
  # @return [StreamInput] a new instance of StreamInput
  #
  # source://unicorn//lib/unicorn/stream_input.rb#14
  def initialize(socket, request); end

  # :call-seq:
  #   ios.each { |line| block }  => ios
  #
  # Executes the block for every ``line'' in *ios*, where lines are
  # separated by the global record separator ($/, typically "\n").
  #
  # source://unicorn//lib/unicorn/stream_input.rb#97
  def each; end

  # :call-seq:
  #   ios.gets   => string or nil
  #
  # Reads the next ``line'' from the I/O stream; lines are separated
  # by the global record separator ($/, typically "\n"). A global
  # record separator of nil reads the entire unread contents of ios.
  # Returns nil if called at the end of file.
  # This takes zero arguments for strict Rack::Lint compatibility,
  # unlike IO#gets.
  #
  # source://unicorn//lib/unicorn/stream_input.rb#75
  def gets; end

  # :call-seq:
  #   ios.read([length [, buffer ]]) => string, buffer, or nil
  #
  # Reads at most length bytes from the I/O stream, or to the end of
  # file if length is omitted or is nil. length must be a non-negative
  # integer or nil. If the optional buffer argument is present, it
  # must reference a String, which will receive the data.
  #
  # At end of file, it returns nil or '' depend on length.
  # ios.read() and ios.read(nil) returns ''.
  # ios.read(length [, buffer]) returns nil.
  #
  # If the Content-Length of the HTTP request is known (as is the common
  # case for POST requests), then ios.read(length [, buffer]) will block
  # until the specified length is read (or it is the last chunk).
  # Otherwise, for uncommon "Transfer-Encoding: chunked" requests,
  # ios.read(length [, buffer]) will return immediately if there is
  # any data and only block when nothing is available (providing
  # IO#readpartial semantics).
  #
  # source://unicorn//lib/unicorn/stream_input.rb#43
  def read(length = T.unsafe(nil), rv = T.unsafe(nil)); end

  private

  # source://unicorn//lib/unicorn/stream_input.rb#138
  def eof!; end

  # @return [Boolean]
  #
  # source://unicorn//lib/unicorn/stream_input.rb#107
  def eof?; end

  # source://unicorn//lib/unicorn/stream_input.rb#120
  def filter_body(dst, src); end

  # source://unicorn//lib/unicorn/stream_input.rb#126
  def read_all(dst); end
end

# Instead of using a generic Kgio::Socket for everything,
# tag TCP sockets so we can use TCP_INFO under Linux without
# incurring extra syscalls for Unix domain sockets.
# TODO: remove these when we remove kgio
#
# source://unicorn//lib/unicorn/socket_helper.rb#11
class Unicorn::TCPClient < ::Kgio::Socket; end

# source://unicorn//lib/unicorn/socket_helper.rb#12
class Unicorn::TCPSrv < ::Kgio::TCPServer
  # source://unicorn//lib/unicorn/socket_helper.rb#13
  def kgio_tryaccept; end
end

# Acts like tee(1) on an input input to provide a input-like stream
# while providing rewindable semantics through a File/StringIO backing
# store.  On the first pass, the input is only read on demand so your
# Rack application can use input notification (upload progress and
# like).  This should fully conform to the Rack::Lint::InputWrapper
# specification on the public API.  This class is intended to be a
# strict interpretation of Rack::Lint::InputWrapper functionality and
# will not support any deviations from it.
#
# When processing uploads, unicorn exposes a TeeInput object under
# "rack.input" of the Rack environment by default.
#
# source://unicorn//lib/unicorn/tee_input.rb#14
class Unicorn::TeeInput < ::Unicorn::StreamInput
  # Initializes a new TeeInput object.  You normally do not have to call
  # this unless you are writing an HTTP server.
  #
  # @return [TeeInput] a new instance of TeeInput
  #
  # source://unicorn//lib/unicorn/tee_input.rb#40
  def initialize(socket, request); end

  # :call-seq:
  #   ios.gets   => string or nil
  #
  # Reads the next ``line'' from the I/O stream; lines are separated
  # by the global record separator ($/, typically "\n"). A global
  # record separator of nil reads the entire unread contents of ios.
  # Returns nil if called at the end of file.
  # This takes zero arguments for strict Rack::Lint compatibility,
  # unlike IO#gets.
  #
  # source://unicorn//lib/unicorn/tee_input.rb#103
  def gets; end

  # for Rack::TempfileReaper in rack 1.6+
  #
  # source://unicorn//lib/unicorn/tee_input.rb#32
  def new_tmpio; end

  # :call-seq:
  #   ios.read([length [, buffer ]]) => string, buffer, or nil
  #
  # Reads at most length bytes from the I/O stream, or to the end of
  # file if length is omitted or is nil. length must be a non-negative
  # integer or nil. If the optional buffer argument is present, it
  # must reference a String, which will receive the data.
  #
  # At end of file, it returns nil or "" depend on length.
  # ios.read() and ios.read(nil) returns "".
  # ios.read(length [, buffer]) returns nil.
  #
  # If the Content-Length of the HTTP request is known (as is the common
  # case for POST requests), then ios.read(length [, buffer]) will block
  # until the specified length is read (or it is the last chunk).
  # Otherwise, for uncommon "Transfer-Encoding: chunked" requests,
  # ios.read(length [, buffer]) will return immediately if there is
  # any data and only block when nothing is available (providing
  # IO#readpartial semantics).
  #
  # source://unicorn//lib/unicorn/tee_input.rb#90
  def read(*args); end

  # :call-seq:
  #   ios.rewind    => 0
  #
  # Positions the *ios* pointer to the beginning of input, returns
  # the offset (zero) of the +ios+ pointer.  Subsequent reads will
  # start from the beginning of the previously-buffered input.
  #
  # source://unicorn//lib/unicorn/tee_input.rb#113
  def rewind; end

  # :call-seq:
  #   ios.size  => Integer
  #
  # Returns the size of the input.  For requests with a Content-Length
  # header value, this will not read data off the socket and just return
  # the value of the Content-Length header as an Integer.
  #
  # For Transfer-Encoding:chunked requests, this requires consuming
  # all of the input stream before returning since there's no other
  # way to determine the size of the request body beforehand.
  #
  # This method is no longer part of the Rack specification as of
  # Rack 1.2, so its use is not recommended.  This method only exists
  # for compatibility with Rack applications designed for Rack 1.1 and
  # earlier.  Most applications should only need to call +read+ with a
  # specified +length+ in a loop until it returns +nil+.
  #
  # source://unicorn//lib/unicorn/tee_input.rb#63
  def size; end

  private

  # consumes the stream of the socket
  #
  # source://unicorn//lib/unicorn/tee_input.rb#122
  def consume!; end

  # source://unicorn//lib/unicorn/tee_input.rb#127
  def tee(buffer); end

  class << self
    # returns the maximum size of request bodies to buffer in memory,
    # amounts larger than this are buffered to the filesystem
    #
    # source://unicorn//lib/unicorn/tee_input.rb#27
    def client_body_buffer_size; end

    # sets the maximum size of request bodies to buffer in memory,
    # amounts larger than this are buffered to the filesystem
    #
    # source://unicorn//lib/unicorn/tee_input.rb#21
    def client_body_buffer_size=(bytes); end
  end
end

# some versions of Ruby had a broken Tempfile which didn't work
# well with unlinked files.  This one is much shorter, easier
# to understand, and slightly faster.
#
# source://unicorn//lib/unicorn/tmpio.rb#8
class Unicorn::TmpIO < ::File
  # pretend we're Tempfile for Rack::TempfileReaper
  def close!; end

  class << self
    # creates and returns a new File object.  The File is unlinked
    # immediately, switched to binary mode, and userspace output
    # buffering is disabled
    #
    # source://unicorn//lib/unicorn/tmpio.rb#13
    def new; end
  end
end

# source://unicorn//lib/unicorn/util.rb#4
module Unicorn::Util
  class << self
    # source://unicorn//lib/unicorn/util.rb#18
    def chown_logs(uid, gid); end

    # :stopdoc:
    #
    # @return [Boolean]
    #
    # source://unicorn//lib/unicorn/util.rb#7
    def is_log?(fp); end

    # This reopens ALL logfiles in the process that have been rotated
    # using logrotate(8) (without copytruncate) or similar tools.
    # A +File+ object is considered for reopening if it is:
    #   1) opened with the O_APPEND and O_WRONLY flags
    #   2) the current open file handle does not match its original open path
    #   3) unbuffered (as far as userspace buffering goes, not O_SYNC)
    # Returns the number of files reopened
    #
    # In Unicorn 3.5.x and earlier, files must be opened with an absolute
    # path to be considered a log file.
    #
    # source://unicorn//lib/unicorn/util.rb#35
    def reopen_logs; end
  end
end

class Unicorn::Waiter < ::IO
  def get_readers(_arg0, _arg1, _arg2); end

  class << self
    def prep_readers(_arg0); end
  end
end

# This class and its members can be considered a stable interface
# and will not change in a backwards-incompatible fashion between
# releases of unicorn.  Knowledge of this class is generally not
# not needed for most users of unicorn.
#
# Some users may want to access it in the before_fork/after_fork hooks.
# See the Unicorn::Configurator RDoc for examples.
#
# source://unicorn//lib/unicorn/worker.rb#11
class Unicorn::Worker
  # @return [Worker] a new instance of Worker
  #
  # source://unicorn//lib/unicorn/worker.rb#20
  def initialize(nr, pipe = T.unsafe(nil)); end

  # worker objects may be compared to just plain Integers
  #
  # source://unicorn//lib/unicorn/worker.rb#90
  def ==(other_nr); end

  # source://unicorn//lib/unicorn/worker.rb#30
  def atfork_child; end

  # parent does not read
  #
  # source://unicorn//lib/unicorn/worker.rb#41
  def atfork_parent; end

  # called in both the master (reaping worker) and worker (SIGQUIT handler)
  #
  # source://unicorn//lib/unicorn/worker.rb#105
  def close; end

  # call a signal handler immediately without triggering EINTR
  # We do not use the more obvious Process.kill(sig, $$) here since
  # that signal delivery may be deferred.  We want to avoid signal delivery
  # while the Rack app.call is running because some database drivers
  # (e.g. ruby-pg) may cancel pending requests.
  #
  # source://unicorn//lib/unicorn/worker.rb#50
  def fake_sig(sig); end

  # this only runs when the Rack app.call is not running
  # act like a listener
  #
  # source://unicorn//lib/unicorn/worker.rb#75
  def kgio_tryaccept; end

  # Returns the value of attribute master.
  #
  # source://unicorn//lib/unicorn/worker.rb#15
  def master; end

  # :stopdoc:
  #
  # source://unicorn//lib/unicorn/worker.rb#13
  def nr; end

  # :stopdoc:
  #
  # source://unicorn//lib/unicorn/worker.rb#13
  def nr=(_arg0); end

  # master fakes SIGQUIT using this
  #
  # source://unicorn//lib/unicorn/worker.rb#36
  def quit; end

  # master sends fake signals to children
  #
  # source://unicorn//lib/unicorn/worker.rb#58
  def soft_kill(sig); end

  # :stopdoc:
  #
  # source://unicorn//lib/unicorn/worker.rb#13
  def switched; end

  # :stopdoc:
  #
  # source://unicorn//lib/unicorn/worker.rb#13
  def switched=(_arg0); end

  # called in the master process
  #
  # source://unicorn//lib/unicorn/worker.rb#100
  def tick; end

  # called in the worker process
  #
  # source://unicorn//lib/unicorn/worker.rb#95
  def tick=(value); end

  # IO.select-compatible
  #
  # source://unicorn//lib/unicorn/worker.rb#14
  def to_io; end

  # In most cases, you should be using the Unicorn::Configurator#user
  # directive instead.  This method should only be used if you need
  # fine-grained control of exactly when you want to change permissions
  # in your after_fork or after_worker_ready hooks, or if you want to
  # use the chroot support.
  #
  # Changes the worker process to the specified +user+ and +group+,
  # and chroots to the current working directory if +chroot+ is set.
  # This is only intended to be called from within the worker
  # process from the +after_fork+ hook.  This should be called in
  # the +after_fork+ hook after any privileged functions need to be
  # run (e.g. to set per-worker CPU affinity, niceness, etc)
  #
  # +group+ can be specified as a string, or as an array of two
  # strings.  If an array of two strings is given, the first string
  # is used as the primary group of the process, and the second is
  # used as the group of the log files.
  #
  # Any and all errors raised within this method will be propagated
  # directly back to the caller (usually the +after_fork+ hook.
  # These errors commonly include ArgumentError for specifying an
  # invalid user/group and Errno::EPERM for insufficient privileges.
  #
  # chroot support is only available in unicorn 5.3.0+
  # user and group switching appeared in unicorn 0.94.0 (2009-11-05)
  #
  # source://unicorn//lib/unicorn/worker.rb#137
  def user(user, group = T.unsafe(nil), chroot = T.unsafe(nil)); end
end

# source://unicorn//lib/unicorn/worker.rb#18
Unicorn::Worker::DROPS = T.let(T.unsafe(nil), Array)

# source://unicorn//lib/unicorn/worker.rb#17
Unicorn::Worker::PER_DROP = T.let(T.unsafe(nil), Integer)
