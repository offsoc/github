module Failbot
  module ExceptionFormat
    # The format recognized by haystack.
    class Haystack

      # Format an exception.
      def self.call(e)
        res = {
          'class'      => e.class.to_s,
          'message'    => e.message,
          'backtrace'  => Array(e.backtrace)[0,500].join("\n"),
          'ruby'       => RUBY_DESCRIPTION,
          'created_at' => Time.now.utc.iso8601(6)
        }

        if cause = pretty_print_cause(e)
          res['cause'] = cause
        end

        res
      end

      # given a hash generated by this class, return the exception message.
      def self.exception_message_from_hash(hash)
        hash["message"]
      end

      # given a hash generated by this class, return the exception class name.
      def self.exception_classname_from_hash(hash)
        hash["class"]
      end

      # Pretty-print Exception#cause (and nested causes) for inclusion in needle
      # context
      #
      # e     - The Exception object whose #cause should be printed
      # depth - Integer number of Exception#cause objects to descend into.
      #
      # Returns a String.
      def self.pretty_print_cause(e, depth = MAXIMUM_CAUSE_DEPTH)
        return unless depth > 0

        causes = []

        current = e
        depth.times do
          pretty_cause = pretty_print_one_cause(current)
          break unless pretty_cause
          causes << pretty_cause
          current = current.cause
        end

        return if causes.empty?

        result = causes.join("\n\nCAUSED BY:\n\n")

        if current.cause
          result << "\n\nFurther #cause backtraces were omitted\n"
        end

        result
      end

      # Pretty-print a single Exception#cause
      #
      # e - The Exception object whose #cause should be printed
      #
      # Returns a String.
      def self.pretty_print_one_cause(e)
        cause = e.cause
        return unless cause

        result = "#{cause.class.name}: #{cause.message}\n"

        # Find where the cause's backtrace differs from the child exception's.
        backtrace = Array(e.backtrace)
        cause_backtrace = Array(cause.backtrace)
        index = -1
        min_index = [backtrace.size, cause_backtrace.size].min * -1
        just_in_case = -5000

        while index > min_index && backtrace[index] == cause_backtrace[index] && index >= just_in_case
          index -= 1
        end

        # Add on a few common frames to make it clear where the backtraces line up.
        index += 3
        index = -1 if index >= 0

        cause_backtrace[0..index].each do |line|
          result << "\t#{line}\n"
        end

        result
      end
    end
  end
end
