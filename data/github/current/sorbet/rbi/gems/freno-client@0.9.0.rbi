# typed: true

# DO NOT EDIT MANUALLY
# This is an autogenerated file for types exported from the `freno-client` gem.
# Please instead update this file by running `bin/tapioca gem freno-client`.

# source://freno-client//lib/freno/client/version.rb#3
module Freno; end

# source://freno-client//lib/freno/client/version.rb#4
class Freno::Client
  # Creates a new instance of the client, that uses faraday to make http calls.
  #
  # If most of the times you are going to ask Freno about the same app and/or storage name,
  # you can tell the client to use some defaults, and override them as necessary.
  #
  # Examples a ruby client that by default asks Freno for throttling information
  # about `:my_app` accessing `:my_cluster` storage.
  #
  #  ```ruby
  #  freno = Freno::Client.new(faraday) do |client|
  #    client.default_store_name = :my_cluster
  #    client.default_app        = :my_app
  #  end
  #  ```
  #
  # Any options set on the Client are passed through to the initialization of
  # each request:
  #
  #  ```ruby
  #  freno = Freno::Client.new(faraday) do |client|
  #    client.options = { raise_on_timeout: false }
  #  end
  #  ```
  #
  #  These default options can be overridden per request. The given options
  #  are merged into the defaults. The request below would be performed with
  #  the options: `{ raise_on_timeout: false, low_priority: true }`
  #
  #  ```ruby
  #  freno = Freno::Client.new(faraday) do |client|
  #    client.options = { raise_on_timeout: false }
  #  end
  #
  #  freno.check?(options: { low_priority: true })
  #  ```
  #
  # @return [Client] a new instance of Client
  # @yield [_self]
  # @yieldparam _self [Freno::Client] the object that the method was called on
  #
  # source://freno-client//lib/freno/client.rb#57
  def initialize(faraday); end

  # Provides an interface to Freno"s check request
  #
  # See https://github.com/github/freno/blob/master/doc/http.md#check-request
  #
  # Returns Result
  #
  # source://freno-client//lib/freno/client.rb#73
  def check(app: T.unsafe(nil), store_type: T.unsafe(nil), store_name: T.unsafe(nil), options: T.unsafe(nil)); end

  # Determines whether Freno considers it"s OK to write to masters
  #
  # Returns true or false.
  #
  # @return [Boolean]
  #
  # source://freno-client//lib/freno/client.rb#126
  def check?(app: T.unsafe(nil), store_type: T.unsafe(nil), store_name: T.unsafe(nil), options: T.unsafe(nil)); end

  # Provides an interface to Freno"s check-read request
  #
  # See https://github.com/github/freno/blob/master/doc/http.md#specialized-requests
  #
  # Returns Result
  #
  # source://freno-client//lib/freno/client.rb#83
  def check_read(threshold:, app: T.unsafe(nil), store_type: T.unsafe(nil), store_name: T.unsafe(nil), options: T.unsafe(nil)); end

  # Determines whether it"s OK to read from replicas as replication delay is below
  # the given threshold.
  #
  # Returns true or false.
  #
  # @return [Boolean]
  #
  # source://freno-client//lib/freno/client.rb#135
  def check_read?(threshold:, app: T.unsafe(nil), store_type: T.unsafe(nil), store_name: T.unsafe(nil), options: T.unsafe(nil)); end

  # Configures the client to extend the functionality of part or all the API
  # by means of decorators.
  #
  # A decorator is any object that has a `:request` accessor and can forward
  # the execution of `perform` to it.
  #
  # Examples:
  #
  # The following is a decorator implementing a read-trough cache.
  #
  # ```ruby
  # class Cache
  #   attr_accessor :request
  #
  #   def initialize(cache, ttl)
  #     @cache = cache
  #     @ttl = ttl
  #   end
  #
  #   def perform(**kwargs)
  #     @cache.fetch("freno:client:v1:#{args.hash}", ttl: @ttl) do
  #       request.perform(kwargs)
  #     end
  #   end
  # end
  # ```
  #
  # You can use it to decorate a single kind of request to freno:
  #
  # ```ruby
  # freno = Freno::Client.new(faraday) do |client|
  #   client.decorate :replication_delay, with: Cache.new(App.cache, App.config.ttl)
  # end
  # ```
  #
  # Or every kind of request:
  #
  # ```ruby
  # freno = Freno::Client.new(faraday) do |client|
  #   client.decorate :all, with: Cache.new(App.cache, App.config.ttl)
  # end
  # ```
  #
  # Additionally, decorators can be composed in multiple ways. The following client
  # applies logging and instrumentation to all the requests, and it also applies caching,
  # **before** the previous concerns, to `replication_delay` requests.
  #
  # ```ruby
  # freno = Freno::Client.new(faraday) do |client|
  #   client.decorate :replication_delay, with: caching
  #   client.decorate :all, with: [logging, instrumentation]
  # end
  # ```
  #
  # source://freno-client//lib/freno/client.rb#205
  def decorate(request_or_all, with:); end

  # Returns the value of attribute decorated_requests.
  #
  # source://freno-client//lib/freno/client.rb#18
  def decorated_requests; end

  # Returns the value of attribute decorators.
  #
  # source://freno-client//lib/freno/client.rb#18
  def decorators; end

  # Returns the value of attribute default_app.
  #
  # source://freno-client//lib/freno/client.rb#19
  def default_app; end

  # Sets the attribute default_app
  #
  # @param value the value to set the attribute default_app to.
  #
  # source://freno-client//lib/freno/client.rb#19
  def default_app=(_arg0); end

  # Returns the value of attribute default_store_name.
  #
  # source://freno-client//lib/freno/client.rb#19
  def default_store_name; end

  # Sets the attribute default_store_name
  #
  # @param value the value to set the attribute default_store_name to.
  #
  # source://freno-client//lib/freno/client.rb#19
  def default_store_name=(_arg0); end

  # Returns the value of attribute default_store_type.
  #
  # source://freno-client//lib/freno/client.rb#19
  def default_store_type; end

  # Sets the attribute default_store_type
  #
  # @param value the value to set the attribute default_store_type to.
  #
  # source://freno-client//lib/freno/client.rb#19
  def default_store_type=(_arg0); end

  # Returns the value of attribute faraday.
  #
  # source://freno-client//lib/freno/client.rb#18
  def faraday; end

  # Returns the value of attribute options.
  #
  # source://freno-client//lib/freno/client.rb#19
  def options; end

  # Sets the attribute options
  #
  # @param value the value to set the attribute options to.
  #
  # source://freno-client//lib/freno/client.rb#19
  def options=(_arg0); end

  # Implements a specific check request to retrieve the consolidated replication
  # delay
  #
  # See https://github.com/github/freno/blob/master/doc/http.md#get-method
  #
  # Returns Float indicating the replication delay in seconds as reported by Freno.
  #
  # source://freno-client//lib/freno/client.rb#107
  def replication_delay(app: T.unsafe(nil), store_type: T.unsafe(nil), store_name: T.unsafe(nil), options: T.unsafe(nil)); end

  private

  # @return [Boolean]
  #
  # source://freno-client//lib/freno/client.rb#253
  def already_registered?(decorator); end

  # source://freno-client//lib/freno/client.rb#229
  def decorated(request); end

  # source://freno-client//lib/freno/client.rb#225
  def perform(request, **kwargs); end

  # source://freno-client//lib/freno/client.rb#257
  def registered_decorators; end

  # source://freno-client//lib/freno/client.rb#245
  def validate!(decorators); end
end

# source://freno-client//lib/freno/client.rb#10
class Freno::Client::DecorationError < ::ArgumentError; end

# source://freno-client//lib/freno/client/preconditions.rb#5
module Freno::Client::Preconditions
  private

  # source://freno-client//lib/freno/client/preconditions.rb#28
  def check(&block); end

  class << self
    # source://freno-client//lib/freno/client/preconditions.rb#28
    def check(&block); end
  end
end

# source://freno-client//lib/freno/client/preconditions.rb#10
class Freno::Client::Preconditions::Checker
  # @return [Checker] a new instance of Checker
  #
  # source://freno-client//lib/freno/client/preconditions.rb#13
  def initialize; end

  # Returns the value of attribute errors.
  #
  # source://freno-client//lib/freno/client/preconditions.rb#11
  def errors; end

  # source://freno-client//lib/freno/client/preconditions.rb#17
  def present(args = T.unsafe(nil)); end

  # @raise [PreconditionNotMet]
  #
  # source://freno-client//lib/freno/client/preconditions.rb#23
  def report; end
end

# source://freno-client//lib/freno/client/preconditions.rb#8
class Freno::Client::Preconditions::PreconditionNotMet < ::ArgumentError; end

# source://freno-client//lib/freno/client.rb#12
Freno::Client::REQUESTS = T.let(T.unsafe(nil), Hash)

# source://freno-client//lib/freno/client/request.rb#9
class Freno::Client::Request
  include ::Freno::Client::Preconditions

  # @return [Request] a new instance of Request
  #
  # source://freno-client//lib/freno/client/request.rb#18
  def initialize(**kwargs); end

  # Returns the value of attribute args.
  #
  # source://freno-client//lib/freno/client/request.rb#12
  def args; end

  # Returns the value of attribute faraday.
  #
  # source://freno-client//lib/freno/client/request.rb#12
  def faraday; end

  # Returns the value of attribute options.
  #
  # source://freno-client//lib/freno/client/request.rb#12
  def options; end

  # source://freno-client//lib/freno/client/request.rb#27
  def perform; end

  # Returns the value of attribute raise_on_timeout.
  #
  # source://freno-client//lib/freno/client/request.rb#12
  def raise_on_timeout; end

  protected

  # source://freno-client//lib/freno/client/request.rb#56
  def params; end

  # source://freno-client//lib/freno/client/request.rb#44
  def path; end

  # source://freno-client//lib/freno/client/request.rb#60
  def process_response(response); end

  # source://freno-client//lib/freno/client/request.rb#40
  def request(verb, path, params); end

  # source://freno-client//lib/freno/client/request.rb#50
  def verb; end

  class << self
    # source://freno-client//lib/freno/client/request.rb#14
    def perform(**kwargs); end
  end
end

# source://freno-client//lib/freno/client/requests/check_read.rb#7
module Freno::Client::Requests; end

# source://freno-client//lib/freno/client/requests/check.rb#8
class Freno::Client::Requests::Check < ::Freno::Client::Request
  # @return [Check] a new instance of Check
  #
  # source://freno-client//lib/freno/client/requests/check.rb#9
  def initialize(**kwargs); end
end

# source://freno-client//lib/freno/client/requests/check_read.rb#8
class Freno::Client::Requests::CheckRead < ::Freno::Client::Request
  # @return [CheckRead] a new instance of CheckRead
  #
  # source://freno-client//lib/freno/client/requests/check_read.rb#9
  def initialize(**kwargs); end
end

# source://freno-client//lib/freno/client/requests/replication_delay.rb#8
class Freno::Client::Requests::ReplicationDelay < ::Freno::Client::Requests::Check
  protected

  # source://freno-client//lib/freno/client/requests/replication_delay.rb#11
  def process_response(*_arg0); end

  # source://freno-client//lib/freno/client/requests/replication_delay.rb#16
  def verb; end
end

# source://freno-client//lib/freno/client/result.rb#7
class Freno::Client::Result
  # @return [Result] a new instance of Result
  #
  # source://freno-client//lib/freno/client/result.rb#35
  def initialize(code, body = T.unsafe(nil)); end

  # source://freno-client//lib/freno/client/result.rb#57
  def ==(other); end

  # source://freno-client//lib/freno/client/result.rb#53
  def body; end

  # Returns the value of attribute code.
  #
  # source://freno-client//lib/freno/client/result.rb#33
  def code; end

  # @return [Boolean]
  #
  # source://freno-client//lib/freno/client/result.rb#45
  def failed?; end

  # Returns the value of attribute meaning.
  #
  # source://freno-client//lib/freno/client/result.rb#33
  def meaning; end

  # @return [Boolean]
  #
  # source://freno-client//lib/freno/client/result.rb#41
  def ok?; end

  # Returns the value of attribute raw_body.
  #
  # source://freno-client//lib/freno/client/result.rb#33
  def raw_body; end

  # @return [Boolean]
  #
  # source://freno-client//lib/freno/client/result.rb#49
  def unkown?; end

  class << self
    # source://freno-client//lib/freno/client/result.rb#25
    def from_faraday_response(response); end

    # source://freno-client//lib/freno/client/result.rb#29
    def from_meaning(meaning); end
  end
end

# these are included to add resiliency to freno-client
#
# source://freno-client//lib/freno/client/result.rb#18
Freno::Client::Result::ADDITIONAL_STATUS_CODE_MEANINGS = T.let(T.unsafe(nil), Hash)

# source://freno-client//lib/freno/client/result.rb#22
Freno::Client::Result::CODE_MEANINGS = T.let(T.unsafe(nil), Hash)

# https://github.com/github/freno/blob/master/doc/http.md#status-codes
#
# source://freno-client//lib/freno/client/result.rb#9
Freno::Client::Result::FRENO_STATUS_CODE_MEANINGS = T.let(T.unsafe(nil), Hash)

# source://freno-client//lib/freno/client/result.rb#23
Freno::Client::Result::MEANING_CODES = T.let(T.unsafe(nil), Hash)

# source://freno-client//lib/freno/client/version.rb#5
Freno::Client::VERSION = T.let(T.unsafe(nil), Gem::Version)

# source://freno-client//lib/freno/client/errors.rb#4
class Freno::Error < ::StandardError; end

# Freno::Throttler is the class responsible for throttling writes to a cluster
# or a set of clusters. Throttling means to slow down the pace at which write
# operations occur by checking with freno whether all the clusters affected by
# the operation are in good health before allowing it. If any of the clusters
# is not in good health, the throttler will wait some time and repeat the
# process.
#
# Examples:
#
# Let's use the following throttler, which uses Mapper::Identity implicitly.
# (see #initialze docs)
#
# ```
# throttler = Throttler.new(client: freno_client, app: :my_app)
# data.find_in_batches do |batch|
#   throttler.throttle([:mysqla, :mysqlb]) do
#     update(batch)
#   end
# end
# ```
#
# Before each call to `update(batch)` the throttler will call freno to
# check the health of the `mysqla` and `mysqlb` stores on behalf of :my_app;
# and sleep if any of the stores is not ok.
#
# source://freno-client//lib/freno/throttler/errors.rb#6
class Freno::Throttler
  # Initializes a new instance of the throttler
  #
  # In order to initialize a Throttler you need the following arguments:
  #
  #  - a `client`: a instance of Freno::Client
  #
  #  - an `app`: a symbol indicating the app-name for which Freno will respond
  #    checks.
  #
  # Also, you can optionally provide the following named arguments:
  #
  #  - `:mapper`: An object that responds to `call(context)` and returns a
  #     `Enumerable` of the store names for which we need to wait for
  #     replication delay. By default this is the `IdentityMapper`, which will
  #     check the stores given as context.
  #
  #     For example, if the `throttler` object used the default mapper:
  #
  #      ```
  #      throttler.throttle(:mysqlc) do
  #         update(batch)
  #      end
  #      ```
  #
  #  - `:instrumenter`: An object that responds to
  #     `instrument(event_name, context = {}, &block)` that can be used to
  #     add cross-cutting concerns like logging or stats to the throttler.
  #
  #     By default, the instrumenter is `Instrumenter::Noop`, which does
  #     nothing but yielding the block it receives.
  #
  #  - `:circuit_breaker`: An object responding to `allow_request?`,
  #     `success`, and `failure?`, compatible with `Resilient::CircuitBreaker`
  #     (see https://github.com/jnunemaker/resilient).
  #
  #     By default, the circuit breaker is `CircuitBreaker::Noop`, which
  #     always allows requests, and does not provide resiliency guarantees.
  #
  #  - `:wait_seconds`: A positive float indicating the number of seconds the
  #     throttler will wait before checking again, in case some of the stores
  #     didn't catch-up the last time they were check.
  #
  #  - `:max_wait_seconds`: A positive float indicating the maxium number of
  #     seconds the throttler will wait in total for replicas to catch-up
  #     before raising a `WaitedTooLong` error.
  #
  # @return [Throttler] a new instance of Throttler
  # @yield [_self]
  # @yieldparam _self [Freno::Throttler] the object that the method was called on
  #
  # source://freno-client//lib/freno/throttler.rb#102
  def initialize(client: T.unsafe(nil), app: T.unsafe(nil), mapper: T.unsafe(nil), instrumenter: T.unsafe(nil), circuit_breaker: T.unsafe(nil), wait_seconds: T.unsafe(nil), max_wait_seconds: T.unsafe(nil)); end

  # Returns the value of attribute app.
  #
  # source://freno-client//lib/freno/throttler.rb#48
  def app; end

  # Sets the attribute app
  #
  # @param value the value to set the attribute app to.
  #
  # source://freno-client//lib/freno/throttler.rb#48
  def app=(_arg0); end

  # Returns the value of attribute circuit_breaker.
  #
  # source://freno-client//lib/freno/throttler.rb#48
  def circuit_breaker; end

  # Sets the attribute circuit_breaker
  #
  # @param value the value to set the attribute circuit_breaker to.
  #
  # source://freno-client//lib/freno/throttler.rb#48
  def circuit_breaker=(_arg0); end

  # Returns the value of attribute client.
  #
  # source://freno-client//lib/freno/throttler.rb#48
  def client; end

  # Sets the attribute client
  #
  # @param value the value to set the attribute client to.
  #
  # source://freno-client//lib/freno/throttler.rb#48
  def client=(_arg0); end

  # Returns the value of attribute instrumenter.
  #
  # source://freno-client//lib/freno/throttler.rb#48
  def instrumenter; end

  # Sets the attribute instrumenter
  #
  # @param value the value to set the attribute instrumenter to.
  #
  # source://freno-client//lib/freno/throttler.rb#48
  def instrumenter=(_arg0); end

  # Returns the value of attribute mapper.
  #
  # source://freno-client//lib/freno/throttler.rb#48
  def mapper; end

  # Sets the attribute mapper
  #
  # @param value the value to set the attribute mapper to.
  #
  # source://freno-client//lib/freno/throttler.rb#48
  def mapper=(_arg0); end

  # Returns the value of attribute max_wait_seconds.
  #
  # source://freno-client//lib/freno/throttler.rb#48
  def max_wait_seconds; end

  # Sets the attribute max_wait_seconds
  #
  # @param value the value to set the attribute max_wait_seconds to.
  #
  # source://freno-client//lib/freno/throttler.rb#48
  def max_wait_seconds=(_arg0); end

  # This method receives a context to infer the set of stores that it needs to
  # throttle writes to. It can also receive additional options which are
  # passed to the underlying Check request object:
  #
  # ```
  # throttler = Throttler.new(client: freno_client, app: :my_app)
  # data.find_in_batches do |batch|
  #   throttler.throttle(:mysqla, low_priority: true) do
  #     update(batch)
  #   end
  # end
  # ```
  #
  # With that information it asks freno whether all the stores are ok.
  # In case they are, it executes the given block.
  # Otherwise, it waits `wait_seconds` before trying again.
  #
  # In case the throttler has waited more than `max_wait_seconds`, it raises
  # a `WaitedTooLong` error.
  #
  # In case there's an underlying Freno error, it raises a `ClientError`
  # error.
  #
  # In case the circuit breaker is open, it raises a `CircuitOpen` error.
  #
  # this method is instrumented, the instrumenter will receive the following
  # events:
  #
  # - "throttler.called" each time this method is called
  # - "throttler.succeeded" when the stores were ok, before yielding the block
  # - "throttler.waited" when the stores were not ok, after waiting
  #   `wait_seconds`
  # - "throttler.waited_too_long" when the stores were not ok, but the
  #   thottler already waited at least `max_wait_seconds`, right before
  #   raising `WaitedTooLong`
  # - "throttler.freno_errored" when there was an error with freno, before
  #   raising `ClientError`.
  # - "throttler.circuit_open" when the circuit breaker does not allow the
  #   next request, before raising `CircuitOpen`
  #
  # source://freno-client//lib/freno/throttler.rb#164
  def throttle(context = T.unsafe(nil), **options); end

  # Returns the value of attribute wait_seconds.
  #
  # source://freno-client//lib/freno/throttler.rb#48
  def wait_seconds; end

  # Sets the attribute wait_seconds
  #
  # @param value the value to set the attribute wait_seconds to.
  #
  # source://freno-client//lib/freno/throttler.rb#48
  def wait_seconds=(_arg0); end

  private

  # @return [Boolean]
  #
  # source://freno-client//lib/freno/throttler.rb#211
  def all_stores_ok?(store_names, **options); end

  # source://freno-client//lib/freno/throttler.rb#225
  def instrument(event_name, payload = T.unsafe(nil), &block); end

  # @raise [ArgumentError]
  #
  # source://freno-client//lib/freno/throttler.rb#197
  def validate_args; end

  # source://freno-client//lib/freno/throttler.rb#221
  def wait; end
end

# A CircuitBreaker is the entry point of the pattern with same name.
# (see https://martinfowler.com/bliki/CircuitBreaker.html)
#
# Clients that use circuit breakers to add resiliency to their processes
# send `failure` or `sucess` messages to the CircuitBreaker depending on the
# results of the last requests made.
#
# With that information, the circuit breaker determines whether or not to
# allow the next request (`allow_request?`). A circuit is said to be open
# when the next request is not allowed; and it's said to be closed when the
# next request is allowed.
#
# source://freno-client//lib/freno/throttler/circuit_breaker.rb#17
module Freno::Throttler::CircuitBreaker; end

# The Noop circuit breaker is the `:circuit_breaker` used by default in
# the Throttler
#
# It always allows requests, and does nothing when given `success` or
# `failure` messages. For that reason it doesn't provide any resiliency
# guarantee.
#
# See https://github.com/jnunemaker/resilient for a real ruby implementation
# of the CircuitBreaker pattern.
#
# source://freno-client//lib/freno/throttler/circuit_breaker.rb#28
class Freno::Throttler::CircuitBreaker::Noop
  class << self
    # @return [Boolean]
    #
    # source://freno-client//lib/freno/throttler/circuit_breaker.rb#29
    def allow_request?; end

    # source://freno-client//lib/freno/throttler/circuit_breaker.rb#35
    def failure; end

    # source://freno-client//lib/freno/throttler/circuit_breaker.rb#33
    def success; end
  end
end

# Raised if the circuit breaker is open and didn't allow latest request
#
# source://freno-client//lib/freno/throttler/errors.rb#19
class Freno::Throttler::CircuitOpen < ::Freno::Throttler::Error; end

# Raised if the freno client errored.
#
# source://freno-client//lib/freno/throttler/errors.rb#22
class Freno::Throttler::ClientError < ::Freno::Throttler::Error; end

# source://freno-client//lib/freno/throttler.rb#37
Freno::Throttler::DEFAULT_MAX_WAIT_SECONDS = T.let(T.unsafe(nil), Integer)

# source://freno-client//lib/freno/throttler.rb#36
Freno::Throttler::DEFAULT_WAIT_SECONDS = T.let(T.unsafe(nil), Float)

# Any throttler-related error.
#
# source://freno-client//lib/freno/throttler/errors.rb#8
class Freno::Throttler::Error < ::Freno::Error; end

# An Instrumenter is an object that responds to
# `instrument(event_name, payload = {})` to receive events from the
# throttler.
#
# As an example, in a rails app one could use ActiveSupport::Notifications
# as an instrumenter and subscribe to the "freno.*" events somewhere else in
# the application.
#
# source://freno-client//lib/freno/throttler/instrumenter.rb#13
module Freno::Throttler::Instrumenter; end

# The Noop instrumenter is the `:instrumenter` used by default in the
# Throttler
#
# It does nothing but yielding the control to the block given if it is
# provided.
#
# source://freno-client//lib/freno/throttler/instrumenter.rb#20
class Freno::Throttler::Instrumenter::Noop
  class << self
    # @yield [payload]
    #
    # source://freno-client//lib/freno/throttler/instrumenter.rb#21
    def instrument(_event_name, payload = T.unsafe(nil)); end
  end
end

# A Mapper is any object that responds to `call`, by receiving a context
# object and returning a list of strings, each of which corresponds to the
# store_name that will be checked in freno.
#
# See https://github.com/github/freno/blob/master/doc/http.md#client-requests
# for more context.
#
# As an example we could use a mapper that will receive as a context a set
# of [table, shard_id] tuples, and could return the list of all the stores
# where that shards exist.
#
# source://freno-client//lib/freno/throttler/mapper.rb#16
module Freno::Throttler::Mapper; end

# The Identity mapper is the one used by default in the Throttler.
#
# It works by informing the throttler to check exact same stores that it
# receives as context, without any translation.
#
# Let's use the following throttler, which uses Mapper::Identity
# implicitly.
#
# ```ruby
# throttler = Throttler.new(client: freno_client, app: :my_app)
# data.find_in_batches do |batch|
#   throttler.throttle([:mysqla, :mysqlb]) do
#     update(batch)
#   end
# end
# ```
#
# Before each call to `update(batch)` the throttler will call freno to
# check the health of `mysqla` and `mysqlb`. And sleep if any of them is
# not ok.
#
# source://freno-client//lib/freno/throttler/mapper.rb#38
class Freno::Throttler::Mapper::Identity
  class << self
    # source://freno-client//lib/freno/throttler/mapper.rb#39
    def call(context); end
  end
end

# source://freno-client//lib/freno/throttler.rb#38
Freno::Throttler::REQUIRED_ARGS = T.let(T.unsafe(nil), Array)

# Raised if the throttler has waited too long for replication delay
# to catch up.
#
# source://freno-client//lib/freno/throttler/errors.rb#12
class Freno::Throttler::WaitedTooLong < ::Freno::Throttler::Error
  # @return [WaitedTooLong] a new instance of WaitedTooLong
  #
  # source://freno-client//lib/freno/throttler/errors.rb#13
  def initialize(waited_seconds: T.unsafe(nil), max_wait_seconds: T.unsafe(nil)); end
end
