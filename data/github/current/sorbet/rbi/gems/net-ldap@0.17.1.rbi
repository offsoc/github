# typed: true

# DO NOT EDIT MANUALLY
# This is an autogenerated file for types exported from the `net-ldap` gem.
# Please instead update this file by running `bin/tapioca gem net-ldap`.

# source://net-ldap//lib/net/ber/core_ext.rb#31
class Array
  include ::Prelude::Enumerator
  include ::Enumerable
  include ::MessagePack::CoreExt
  include ::JSON::Ext::Generator::GeneratorMethods::Array
  include ::Net::BER::Extensions::Array
end

# source://net-ldap//lib/net/ber/core_ext.rb#52
class FalseClass
  include ::MessagePack::CoreExt
  include ::JSON::Ext::Generator::GeneratorMethods::FalseClass
  include ::Net::BER::Extensions::FalseClass
end

# source://net-ldap//lib/net/ber/core_ext.rb#4
class IO
  include ::Prelude::Enumerator
  include ::Enumerable
  include ::File::Constants
  include ::Net::BER::BERParser
end

# source://net-ldap//lib/net/ber/core_ext.rb#38
class Integer < ::Numeric
  include ::ActiveSupport::NumericWithFormat
  include ::MessagePack::CoreExt
  include ::JSON::Ext::Generator::GeneratorMethods::Integer
  include ::Net::BER::Extensions::Integer
end

# :stopdoc:
#
# source://net-ldap//lib/net/ldap.rb#4
module Net
  class << self
    # Handle renamed constants Net::LdapPdu (Net::LDAP::PDU) and
    # Net::LdapPduError (Net::LDAP::PDU::Error).
    #
    # source://net-ldap//lib/net/ldap/pdu.rb#308
    def const_missing(name); end
  end
end

# == Basic Encoding Rules (BER) Support Module
#
# Much of the text below is cribbed from Wikipedia:
# http://en.wikipedia.org/wiki/Basic_Encoding_Rules
#
# The ITU Specification is also worthwhile reading:
# http://www.itu.int/ITU-T/studygroups/com17/languages/X.690-0207.pdf
#
# The Basic Encoding Rules were the original rules laid out by the ASN.1
# standard for encoding abstract information into a concrete data stream.
# The rules, collectively referred to as a transfer syntax in ASN.1
# parlance, specify the exact octet sequences which are used to encode a
# given data item. The syntax defines such elements as: the
# representations for basic data types, the structure of length
# information, and the means for defining complex or compound types based
# on more primitive types. The BER syntax, along with two subsets of BER
# (the Canonical Encoding Rules and the Distinguished Encoding Rules), are
# defined by the ITU-T's X.690 standards document, which is part of the
# ASN.1 document series.
#
# == Encoding
# The BER format specifies a self-describing and self-delimiting format
# for encoding ASN.1 data structures. Each data element is encoded as a
# type identifier, a length description, the actual data elements, and
# where necessary, an end-of-content marker. This format allows a receiver
# to decode the ASN.1 information from an incomplete stream, without
# requiring any pre-knowledge of the size, content, or semantic meaning of
# the data.
#
#   <Type | Length | Value [| End-of-Content]>
#
# == Protocol Data Units (PDU)
# Protocols are defined with schema represented in BER, such that a PDU
# consists of cascaded type-length-value encodings.
#
# === Type Tags
# BER type tags are represented as single octets (bytes). The lower five
# bits of the octet are tag identifier numbers and the upper three bits of
# the octet are used to distinguish the type as native to ASN.1,
# application-specific, context-specific, or private. See
# Net::BER::TAG_CLASS and Net::BER::ENCODING_TYPE for more information.
#
# If Class is set to Universal (0b00______), the value is of a type native
# to ASN.1 (e.g. INTEGER). The Application class (0b01______) is only
# valid for one specific application. Context_specific (0b10______)
# depends on the context and private (0b11_______) can be defined in
# private specifications
#
# If the primitive/constructed bit is zero (0b__0_____), it specifies that
# the value is primitive like an INTEGER. If it is one (0b__1_____), the
# value is a constructed value that contains type-length-value encoded
# types like a SET or a SEQUENCE.
#
# === Defined Universal (ASN.1 Native) Types
# There are a number of pre-defined universal (native) types.
#
# <table>
# <tr><th>Name</th><th>Primitive<br />Constructed</th><th>Number</th></tr>
# <tr><th>EOC (End-of-Content)</th><th>P</th><td>0: 0 (0x0, 0b00000000)</td></tr>
# <tr><th>BOOLEAN</th><th>P</th><td>1: 1 (0x01, 0b00000001)</td></tr>
# <tr><th>INTEGER</th><th>P</th><td>2: 2 (0x02, 0b00000010)</td></tr>
# <tr><th>BIT STRING</th><th>P</th><td>3: 3 (0x03, 0b00000011)</td></tr>
# <tr><th>BIT STRING</th><th>C</th><td>3: 35 (0x23, 0b00100011)</td></tr>
# <tr><th>OCTET STRING</th><th>P</th><td>4: 4 (0x04, 0b00000100)</td></tr>
# <tr><th>OCTET STRING</th><th>C</th><td>4: 36 (0x24, 0b00100100)</td></tr>
# <tr><th>NULL</th><th>P</th><td>5: 5 (0x05, 0b00000101)</td></tr>
# <tr><th>OBJECT IDENTIFIER</th><th>P</th><td>6: 6 (0x06, 0b00000110)</td></tr>
# <tr><th>Object Descriptor</th><th>P</th><td>7: 7 (0x07, 0b00000111)</td></tr>
# <tr><th>EXTERNAL</th><th>C</th><td>8: 40 (0x28, 0b00101000)</td></tr>
# <tr><th>REAL (float)</th><th>P</th><td>9: 9 (0x09, 0b00001001)</td></tr>
# <tr><th>ENUMERATED</th><th>P</th><td>10: 10 (0x0a, 0b00001010)</td></tr>
# <tr><th>EMBEDDED PDV</th><th>C</th><td>11: 43 (0x2b, 0b00101011)</td></tr>
# <tr><th>UTF8String</th><th>P</th><td>12: 12 (0x0c, 0b00001100)</td></tr>
# <tr><th>UTF8String</th><th>C</th><td>12: 44 (0x2c, 0b00101100)</td></tr>
# <tr><th>RELATIVE-OID</th><th>P</th><td>13: 13 (0x0d, 0b00001101)</td></tr>
# <tr><th>SEQUENCE and SEQUENCE OF</th><th>C</th><td>16: 48 (0x30, 0b00110000)</td></tr>
# <tr><th>SET and SET OF</th><th>C</th><td>17: 49 (0x31, 0b00110001)</td></tr>
# <tr><th>NumericString</th><th>P</th><td>18: 18 (0x12, 0b00010010)</td></tr>
# <tr><th>NumericString</th><th>C</th><td>18: 50 (0x32, 0b00110010)</td></tr>
# <tr><th>PrintableString</th><th>P</th><td>19: 19 (0x13, 0b00010011)</td></tr>
# <tr><th>PrintableString</th><th>C</th><td>19: 51 (0x33, 0b00110011)</td></tr>
# <tr><th>T61String</th><th>P</th><td>20: 20 (0x14, 0b00010100)</td></tr>
# <tr><th>T61String</th><th>C</th><td>20: 52 (0x34, 0b00110100)</td></tr>
# <tr><th>VideotexString</th><th>P</th><td>21: 21 (0x15, 0b00010101)</td></tr>
# <tr><th>VideotexString</th><th>C</th><td>21: 53 (0x35, 0b00110101)</td></tr>
# <tr><th>IA5String</th><th>P</th><td>22: 22 (0x16, 0b00010110)</td></tr>
# <tr><th>IA5String</th><th>C</th><td>22: 54 (0x36, 0b00110110)</td></tr>
# <tr><th>UTCTime</th><th>P</th><td>23: 23 (0x17, 0b00010111)</td></tr>
# <tr><th>UTCTime</th><th>C</th><td>23: 55 (0x37, 0b00110111)</td></tr>
# <tr><th>GeneralizedTime</th><th>P</th><td>24: 24 (0x18, 0b00011000)</td></tr>
# <tr><th>GeneralizedTime</th><th>C</th><td>24: 56 (0x38, 0b00111000)</td></tr>
# <tr><th>GraphicString</th><th>P</th><td>25: 25 (0x19, 0b00011001)</td></tr>
# <tr><th>GraphicString</th><th>C</th><td>25: 57 (0x39, 0b00111001)</td></tr>
# <tr><th>VisibleString</th><th>P</th><td>26: 26 (0x1a, 0b00011010)</td></tr>
# <tr><th>VisibleString</th><th>C</th><td>26: 58 (0x3a, 0b00111010)</td></tr>
# <tr><th>GeneralString</th><th>P</th><td>27: 27 (0x1b, 0b00011011)</td></tr>
# <tr><th>GeneralString</th><th>C</th><td>27: 59 (0x3b, 0b00111011)</td></tr>
# <tr><th>UniversalString</th><th>P</th><td>28: 28 (0x1c, 0b00011100)</td></tr>
# <tr><th>UniversalString</th><th>C</th><td>28: 60 (0x3c, 0b00111100)</td></tr>
# <tr><th>CHARACTER STRING</th><th>P</th><td>29: 29 (0x1d, 0b00011101)</td></tr>
# <tr><th>CHARACTER STRING</th><th>C</th><td>29: 61 (0x3d, 0b00111101)</td></tr>
# <tr><th>BMPString</th><th>P</th><td>30: 30 (0x1e, 0b00011110)</td></tr>
# <tr><th>BMPString</th><th>C</th><td>30: 62 (0x3e, 0b00111110)</td></tr>
# <tr><th>ExtendedResponse</th><th>C</th><td>107: 139 (0x8b, 0b010001011)</td></tr>
# </table>
#
# source://net-ldap//lib/net/ber.rb#111
module Net::BER
  class << self
    # Accepts a hash of hashes describing a BER syntax and converts it into
    # a byte-keyed object for fast BER conversion lookup. The resulting
    # "compiled" syntax is used by Net::BER::BERParser.
    #
    # This method should be called only by client classes of Net::BER (e.g.,
    # Net::LDAP and Net::SNMP) and not by clients of those classes.
    #
    # The hash-based syntax uses TAG_CLASS keys that contain hashes of
    # ENCODING_TYPE keys that contain tag numbers with object type markers.
    #
    #   :<TAG_CLASS> => {
    #     :<ENCODING_TYPE> => {
    #       <number> => <object-type>
    #     },
    #   },
    #
    # === Permitted Object Types
    # <tt>:string</tt>::  A string value, represented as BerIdentifiedString.
    # <tt>:integer</tt>:: An integer value, represented with Fixnum.
    # <tt>:oid</tt>::     An Object Identifier value; see X.690 section
    #                     8.19. Currently represented with a standard array,
    #                     but may be better represented as a
    #                     BerIdentifiedOID object.
    # <tt>:array</tt>::   A sequence, represented as BerIdentifiedArray.
    # <tt>:boolean</tt>:: A boolean value, represented as +true+ or +false+.
    # <tt>:null</tt>::    A null value, represented as BerIdentifiedNull.
    #
    # === Example
    # Net::LDAP defines its ASN.1 BER syntax something like this:
    #
    #   class Net::LDAP
    #     AsnSyntax = Net::BER.compile_syntax({
    #       :application => {
    #         :primitive => {
    #           2 => :null,
    #         },
    #         :constructed => {
    #           0 => :array,
    #           # ...
    #         },
    #       },
    #       :context_specific => {
    #         :primitive => {
    #           0 => :string,
    #           # ...
    #         },
    #         :constructed => {
    #           0 => :array,
    #           # ...
    #         },
    #       }
    #       })
    #   end
    #
    # NOTE:: For readability and formatting purposes, Net::LDAP and its
    #        siblings actually construct their syntaxes more deliberately,
    #        as shown below. Since a hash is passed in the end in any case,
    #        the format does not matter.
    #
    #   primitive = { 2 => :null }
    #   constructed = {
    #     0 => :array,
    #     # ...
    #   }
    #   application = {
    #     :primitive => primitive,
    #     :constructed => constructed
    #   }
    #
    #   primitive = {
    #     0 => :string,
    #     # ...
    #   }
    #   constructed = {
    #     0 => :array,
    #     # ...
    #   }
    #   context_specific = {
    #     :primitive => primitive,
    #     :constructed => constructed
    #   }
    #   AsnSyntax = Net::BER.compile_syntax(:application => application,
    #                                       :context_specific => context_specific)
    #
    # source://net-ldap//lib/net/ber.rb#234
    def compile_syntax(syntax); end
  end
end

# Implements Basic Encoding Rules parsing to be mixed into types as needed.
#
# source://net-ldap//lib/net/ber/ber_parser.rb#5
module Net::BER::BERParser
  # Reads a BER object from the including object. Requires that #getbyte is
  # implemented on the including object and that it returns a Fixnum value.
  # Also requires #read(bytes) to work.
  #
  # Yields the object type `id` and the data `content_length` if a block is
  # given. This is namely to support instrumentation.
  #
  # This does not work with non-blocking I/O.
  #
  # @yield [id, content_length]
  #
  # source://net-ldap//lib/net/ber/ber_parser.rb#164
  def read_ber(syntax = T.unsafe(nil)); end

  private

  # This is an extract of our BER object parsing to simplify our
  # understanding of how we parse basic BER object types.
  #
  # source://net-ldap//lib/net/ber/ber_parser.rb#31
  def parse_ber_object(syntax, id, data); end

  # This is an extract of how our BER object length parsing is done to
  # simplify the primary call. This is defined in X.690 section 8.1.3.
  #
  # The BER length will either be a single byte or up to 126 bytes in
  # length. There is a special case of a BER length indicating that the
  # content-length is undefined and will be identified by the presence of
  # two null values (0x00 0x00).
  #
  # <table>
  # <tr>
  # <th>Range</th>
  # <th>Length</th>
  # </tr>
  # <tr>
  # <th>0x00 -- 0x7f<br />0b00000000 -- 0b01111111</th>
  # <td>0 - 127 bytes</td>
  # </tr>
  # <tr>
  # <th>0x80<br />0b10000000</th>
  # <td>Indeterminate (end-of-content marker required)</td>
  # </tr>
  # <tr>
  # <th>0x81 -- 0xfe<br />0b10000001 -- 0b11111110</th>
  # <td>1 - 126 bytes of length as an integer value</td>
  # </tr>
  # <tr>
  # <th>0xff<br />0b11111111</th>
  # <td>Illegal (reserved for future expansion)</td>
  # </tr>
  # </table>
  #
  # --
  # This has been modified from the version that was previously inside
  # #read_ber to handle both the indeterminate terminator case and the
  # invalid BER length case. Because the "lengthlength" value was not used
  # inside of #read_ber, we no longer return it.
  #
  # source://net-ldap//lib/net/ber/ber_parser.rb#135
  def read_ber_length; end
end

# The universal, built-in ASN.1 BER syntax.
#
# source://net-ldap//lib/net/ber/ber_parser.rb#25
Net::BER::BERParser::BuiltinSyntax = T.let(T.unsafe(nil), Array)

# source://net-ldap//lib/net/ber.rb#254
class Net::BER::BerError < ::RuntimeError; end

# An Array object with a BER identifier attached.
#
# source://net-ldap//lib/net/ber.rb#258
class Net::BER::BerIdentifiedArray < ::Array
  # @return [BerIdentifiedArray] a new instance of BerIdentifiedArray
  #
  # source://net-ldap//lib/net/ber.rb#261
  def initialize(*args); end

  # Returns the value of attribute ber_identifier.
  #
  # source://net-ldap//lib/net/ber.rb#259
  def ber_identifier; end

  # Sets the attribute ber_identifier
  #
  # @param value the value to set the attribute ber_identifier to.
  #
  # source://net-ldap//lib/net/ber.rb#259
  def ber_identifier=(_arg0); end
end

# A BER null object.
#
# source://net-ldap//lib/net/ber.rb#340
class Net::BER::BerIdentifiedNull
  # Returns the value of attribute ber_identifier.
  #
  # source://net-ldap//lib/net/ber.rb#341
  def ber_identifier; end

  # Sets the attribute ber_identifier
  #
  # @param value the value to set the attribute ber_identifier to.
  #
  # source://net-ldap//lib/net/ber.rb#341
  def ber_identifier=(_arg0); end

  # source://net-ldap//lib/net/ber.rb#342
  def to_ber; end
end

# A BER object identifier.
#
# source://net-ldap//lib/net/ber.rb#268
class Net::BER::BerIdentifiedOid
  # @return [BerIdentifiedOid] a new instance of BerIdentifiedOid
  #
  # source://net-ldap//lib/net/ber.rb#271
  def initialize(oid); end

  # Returns the value of attribute ber_identifier.
  #
  # source://net-ldap//lib/net/ber.rb#269
  def ber_identifier; end

  # Sets the attribute ber_identifier
  #
  # @param value the value to set the attribute ber_identifier to.
  #
  # source://net-ldap//lib/net/ber.rb#269
  def ber_identifier=(_arg0); end

  # source://net-ldap//lib/net/ber.rb#290
  def to_arr; end

  # source://net-ldap//lib/net/ber.rb#278
  def to_ber; end

  # source://net-ldap//lib/net/ber.rb#282
  def to_ber_oid; end

  # source://net-ldap//lib/net/ber.rb#286
  def to_s; end
end

# A String object with a BER identifier attached.
#
# source://net-ldap//lib/net/ber.rb#298
class Net::BER::BerIdentifiedString < ::String
  # The binary data provided when parsing the result of the LDAP search
  # has the encoding 'ASCII-8BIT' (which is basically 'BINARY', or 'unknown').
  #
  # This is the kind of a backtrace showing how the binary `data` comes to
  # BerIdentifiedString.new(data):
  #
  #  @conn.read_ber(syntax)
  #     -> StringIO.new(self).read_ber(syntax), i.e. included from module
  #     -> Net::BER::BERParser.read_ber(syntax)
  #        -> (private)Net::BER::BERParser.parse_ber_object(syntax, id, data)
  #
  # In the `#parse_ber_object` method `data`, according to its OID, is being
  # 'casted' to one of the Net::BER:BerIdentifiedXXX classes.
  #
  # As we are using LDAP v3 we can safely assume that the data is encoded
  # in UTF-8 and therefore the only thing to be done when instantiating is to
  # switch the encoding from 'ASCII-8BIT' to 'UTF-8'.
  #
  # Unfortunately, there are some ActiveDirectory specific attributes
  # (like `objectguid`) that should remain binary (do they really?).
  # Using the `#valid_encoding?` we can trap this cases. Special cases like
  # Japanese, Korean, etc. encodings might also profit from this. However
  # I have no clue how this encodings function.
  #
  # @return [BerIdentifiedString] a new instance of BerIdentifiedString
  #
  # source://net-ldap//lib/net/ber.rb#324
  def initialize(args); end

  # Returns the value of attribute ber_identifier.
  #
  # source://net-ldap//lib/net/ber.rb#299
  def ber_identifier; end

  # Sets the attribute ber_identifier
  #
  # @param value the value to set the attribute ber_identifier to.
  #
  # source://net-ldap//lib/net/ber.rb#299
  def ber_identifier=(_arg0); end
end

# BER encoding type is kept in bit 6 of the tag type octet.
#
# <table>
# <tr><th>Bitmask</th><th>Definition</th></tr>
# <tr><th><tt>0b__0_____</tt></th><td>Primitive</td></tr>
# <tr><th><tt>0b__1_____</tt></th><td>Constructed</td></tr>
# </table>
#
# source://net-ldap//lib/net/ber.rb#145
Net::BER::ENCODING_TYPE = T.let(T.unsafe(nil), Hash)

# :startdoc:
#
# source://net-ldap//lib/net/ber/core_ext.rb#19
module Net::BER::Extensions; end

# BER extensions to the Array class.
#
# source://net-ldap//lib/net/ber/core_ext/array.rb#4
module Net::BER::Extensions::Array
  # Converts an Array to a BER sequence. All values in the Array are
  # expected to be in BER format prior to calling this method.
  #
  # source://net-ldap//lib/net/ber/core_ext/array.rb#8
  def to_ber(id = T.unsafe(nil)); end

  # Converts an Array to an application-specific sequence, assigned a tag
  # value that is meaningful to the particular protocol being used. All
  # values in the Array are expected to be in BER format pr prior to calling
  # this method.
  # --
  # Implementor's note 20100320(AZ): RFC 4511 (the LDAPv3 protocol) as well
  # as earlier RFCs 1777 and 2559 seem to indicate that LDAP only has
  # application constructed sequences (0x60). However, ldapsearch sends some
  # context-specific constructed sequences (0xA0); other clients may do the
  # same. This behaviour appears to violate the RFCs. In real-world
  # practice, we may need to change calls of #to_ber_appsequence to
  # #to_ber_contextspecific for full LDAP server compatibility.
  #
  # This note probably belongs elsewhere.
  # ++
  #
  # source://net-ldap//lib/net/ber/core_ext/array.rb#40
  def to_ber_appsequence(id = T.unsafe(nil)); end

  # Converts an Array to a context-specific sequence, assigned a tag value
  # that is meaningful to the particular context of the particular protocol
  # being used. All values in the Array are expected to be in BER format
  # prior to calling this method.
  #
  # source://net-ldap//lib/net/ber/core_ext/array.rb#51
  def to_ber_contextspecific(id = T.unsafe(nil)); end

  # Converts an array into a set of ber control codes
  # The expected format is [[control_oid, criticality, control_value(optional)]]
  #   [['1.2.840.113556.1.4.805',true]]
  #
  # source://net-ldap//lib/net/ber/core_ext/array.rb#88
  def to_ber_control; end

  # SNMP Object Identifiers (OID) are special arrays
  # --
  # 20100320 AZ: I do not think that this method should be in BER, since
  # this appears to be SNMP-specific. This should probably be subsumed by a
  # proper SNMP OID object.
  # ++
  #
  # @raise [Net::BER::BerError]
  #
  # source://net-ldap//lib/net/ber/core_ext/array.rb#73
  def to_ber_oid; end

  # Converts an Array to a BER sequence. All values in the Array are
  # expected to be in BER format prior to calling this method.
  #
  # source://net-ldap//lib/net/ber/core_ext/array.rb#8
  def to_ber_sequence(id = T.unsafe(nil)); end

  # Converts an Array to a BER set. All values in the Array are expected to
  # be in BER format prior to calling this method.
  #
  # source://net-ldap//lib/net/ber/core_ext/array.rb#18
  def to_ber_set(id = T.unsafe(nil)); end

  private

  # The internal sequence packing routine. All values in the Array are
  # expected to be in BER format prior to calling this method.
  #
  # source://net-ldap//lib/net/ber/core_ext/array.rb#60
  def to_ber_seq_internal(code); end
end

# BER extensions to +false+.
#
# source://net-ldap//lib/net/ber/core_ext/false_class.rb#4
module Net::BER::Extensions::FalseClass
  # Converts +false+ to the BER wireline representation of +false+.
  #
  # source://net-ldap//lib/net/ber/core_ext/false_class.rb#7
  def to_ber; end
end

# BER extensions to the Integer class, affecting Fixnum and Bignum objects.
#
# source://net-ldap//lib/net/ber/core_ext/integer.rb#4
module Net::BER::Extensions::Integer
  # Converts the Integer to BER format.
  #
  # source://net-ldap//lib/net/ber/core_ext/integer.rb#7
  def to_ber; end

  # Generate a BER-encoding for an application-defined INTEGER. Examples of
  # such integers are SNMP's Counter, Gauge, and TimeTick types.
  #
  # source://net-ldap//lib/net/ber/core_ext/integer.rb#31
  def to_ber_application(tag); end

  # Converts the Integer to BER enumerated format.
  #
  # source://net-ldap//lib/net/ber/core_ext/integer.rb#13
  def to_ber_enumerated; end

  # Converts the Integer to BER length encoding format.
  #
  # source://net-ldap//lib/net/ber/core_ext/integer.rb#19
  def to_ber_length_encoding; end

  private

  # Used to BER-encode the length and content bytes of an Integer. Callers
  # must prepend the tag byte for the contained value.
  #
  # source://net-ldap//lib/net/ber/core_ext/integer.rb#38
  def to_ber_internal; end
end

# BER extensions to the String class.
#
# source://net-ldap//lib/net/ber/core_ext/string.rb#6
module Net::BER::Extensions::String
  # Nondestructively reads a BER object from this string.
  #
  # source://net-ldap//lib/net/ber/core_ext/string.rb#62
  def read_ber(syntax = T.unsafe(nil)); end

  # Destructively reads a BER object from the string.
  #
  # source://net-ldap//lib/net/ber/core_ext/string.rb#68
  def read_ber!(syntax = T.unsafe(nil)); end

  # source://net-ldap//lib/net/ber/core_ext/string.rb#77
  def reject_empty_ber_arrays; end

  # Converts a string to a BER string. Universal octet-strings are tagged
  # with 0x04, but other values are possible depending on the context, so we
  # let the caller give us one.
  #
  # User code should call either #to_ber_application_string or
  # #to_ber_contextspecific.
  #
  # source://net-ldap//lib/net/ber/core_ext/string.rb#14
  def to_ber(code = T.unsafe(nil)); end

  # Creates an application-specific BER string encoded value with the
  # provided syntax code value.
  #
  # source://net-ldap//lib/net/ber/core_ext/string.rb#49
  def to_ber_application_string(code); end

  # Converts a string to a BER string but does *not* encode to UTF-8 first.
  # This is required for proper representation of binary data for Microsoft
  # Active Directory
  #
  # source://net-ldap//lib/net/ber/core_ext/string.rb#23
  def to_ber_bin(code = T.unsafe(nil)); end

  # Creates a context-specific BER string encoded value with the provided
  # syntax code value.
  #
  # source://net-ldap//lib/net/ber/core_ext/string.rb#56
  def to_ber_contextspecific(code); end

  private

  # source://net-ldap//lib/net/ber/core_ext/string.rb#27
  def raw_utf8_encoded; end
end

# BER extensions to +true+.
#
# source://net-ldap//lib/net/ber/core_ext/true_class.rb#4
module Net::BER::Extensions::TrueClass
  # Converts +true+ to the BER wireline representation of +true+.
  #
  # source://net-ldap//lib/net/ber/core_ext/true_class.rb#7
  def to_ber; end
end

# Used for BER-encoding the length and content bytes of a Fixnum integer
# values.
#
# source://net-ldap//lib/net/ber.rb#117
Net::BER::MAX_FIXNUM_SIZE = T.let(T.unsafe(nil), Integer)

# The default BerIdentifiedNull object.
#
# source://net-ldap//lib/net/ber.rb#349
Net::BER::Null = T.let(T.unsafe(nil), Net::BER::BerIdentifiedNull)

# BER tag classes are kept in bits seven and eight of the tag type
# octet.
#
# <table>
# <tr><th>Bitmask</th><th>Definition</th></tr>
# <tr><th><tt>0b00______</tt></th><td>Universal (ASN.1 Native) Types</td></tr>
# <tr><th><tt>0b01______</tt></th><td>Application Types</td></tr>
# <tr><th><tt>0b10______</tt></th><td>Context-Specific Types</td></tr>
# <tr><th><tt>0b11______</tt></th><td>Private Types</td></tr>
# </table>
#
# source://net-ldap//lib/net/ber.rb#130
Net::BER::TAG_CLASS = T.let(T.unsafe(nil), Hash)

# source://net-ldap//lib/net/ber.rb#112
Net::BER::VERSION = T.let(T.unsafe(nil), String)

class Net::HTTPAlreadyReported < ::Net::HTTPSuccess; end

class Net::HTTPClientException < ::Net::ProtoServerError
  include ::Net::HTTPExceptions
end

class Net::HTTPEarlyHints < ::Net::HTTPInformation; end

class Net::HTTPError < ::Net::ProtocolError
  include ::Net::HTTPExceptions
end

class Net::HTTPFatalError < ::Net::ProtoFatalError
  include ::Net::HTTPExceptions
end

class Net::HTTPLoopDetected < ::Net::HTTPServerError; end
class Net::HTTPMisdirectedRequest < ::Net::HTTPClientError; end
class Net::HTTPNotExtended < ::Net::HTTPServerError; end
class Net::HTTPPayloadTooLarge < ::Net::HTTPClientError; end
class Net::HTTPProcessing < ::Net::HTTPInformation; end
class Net::HTTPRangeNotSatisfiable < ::Net::HTTPClientError; end

class Net::HTTPRetriableError < ::Net::ProtoRetriableError
  include ::Net::HTTPExceptions
end

class Net::HTTPURITooLong < ::Net::HTTPClientError; end
class Net::HTTPVariantAlsoNegotiates < ::Net::HTTPServerError; end

# == Quick-start for the Impatient
# === Quick Example of a user-authentication against an LDAP directory:
#
#  require 'rubygems'
#  require 'net/ldap'
#
#  ldap = Net::LDAP.new
#  ldap.host = your_server_ip_address
#  ldap.port = 389
#  ldap.auth "joe_user", "opensesame"
#  if ldap.bind
#    # authentication succeeded
#  else
#    # authentication failed
#  end
#
#
# === Quick Example of a search against an LDAP directory:
#
#  require 'rubygems'
#  require 'net/ldap'
#
#  ldap = Net::LDAP.new :host => server_ip_address,
#       :port => 389,
#       :auth => {
#             :method => :simple,
#             :username => "cn=manager, dc=example, dc=com",
#             :password => "opensesame"
#       }
#
#  filter = Net::LDAP::Filter.eq("cn", "George*")
#  treebase = "dc=example, dc=com"
#
#  ldap.search(:base => treebase, :filter => filter) do |entry|
#    puts "DN: #{entry.dn}"
#    entry.each do |attribute, values|
#      puts "   #{attribute}:"
#      values.each do |value|
#        puts "      --->#{value}"
#      end
#    end
#  end
#
#  p ldap.get_operation_result
#
# === Setting connect timeout
#
# By default, Net::LDAP uses TCP sockets with a connection timeout of 5 seconds.
#
# This value can be tweaked passing the :connect_timeout parameter.
# i.e.
#  ldap = Net::LDAP.new ...,
#                       :connect_timeout => 3
#
# == A Brief Introduction to LDAP
#
# We're going to provide a quick, informal introduction to LDAP terminology
# and typical operations. If you're comfortable with this material, skip
# ahead to "How to use Net::LDAP." If you want a more rigorous treatment of
# this material, we recommend you start with the various IETF and ITU
# standards that relate to LDAP.
#
# === Entities
# LDAP is an Internet-standard protocol used to access directory servers.
# The basic search unit is the <i>entity, </i> which corresponds to a person
# or other domain-specific object. A directory service which supports the
# LDAP protocol typically stores information about a number of entities.
#
# === Principals
# LDAP servers are typically used to access information about people, but
# also very often about such items as printers, computers, and other
# resources. To reflect this, LDAP uses the term <i>entity, </i> or less
# commonly, <i>principal, </i> to denote its basic data-storage unit.
#
# === Distinguished Names
# In LDAP's view of the world, an entity is uniquely identified by a
# globally-unique text string called a <i>Distinguished Name, </i> originally
# defined in the X.400 standards from which LDAP is ultimately derived. Much
# like a DNS hostname, a DN is a "flattened" text representation of a string
# of tree nodes. Also like DNS (and unlike Java package names), a DN
# expresses a chain of tree-nodes written from left to right in order from
# the most-resolved node to the most-general one.
#
# If you know the DN of a person or other entity, then you can query an
# LDAP-enabled directory for information (attributes) about the entity.
# Alternatively, you can query the directory for a list of DNs matching a
# set of criteria that you supply.
#
# === Attributes
#
# In the LDAP view of the world, a DN uniquely identifies an entity.
# Information about the entity is stored as a set of <i>Attributes.</i> An
# attribute is a text string which is associated with zero or more values.
# Most LDAP-enabled directories store a well-standardized range of
# attributes, and constrain their values according to standard rules.
#
# A good example of an attribute is <tt>sn, </tt> which stands for "Surname."
# This attribute is generally used to store a person's surname, or last
# name. Most directories enforce the standard convention that an entity's
# <tt>sn</tt> attribute have <i>exactly one</i> value. In LDAP jargon, that
# means that <tt>sn</tt> must be <i>present</i> and <i>single-valued.</i>
#
# Another attribute is <tt>mail, </tt> which is used to store email
# addresses. (No, there is no attribute called "email, " perhaps because
# X.400 terminology predates the invention of the term <i>email.</i>)
# <tt>mail</tt> differs from <tt>sn</tt> in that most directories permit any
# number of values for the <tt>mail</tt> attribute, including zero.
#
# === Tree-Base
# We said above that X.400 Distinguished Names are <i>globally unique.</i>
# In a manner reminiscent of DNS, LDAP supposes that each directory server
# contains authoritative attribute data for a set of DNs corresponding to a
# specific sub-tree of the (notional) global directory tree. This subtree is
# generally configured into a directory server when it is created. It
# matters for this discussion because most servers will not allow you to
# query them unless you specify a correct tree-base.
#
# Let's say you work for the engineering department of Big Company, Inc.,
# whose internet domain is bigcompany.com. You may find that your
# departmental directory is stored in a server with a defined tree-base of
#    ou=engineering, dc=bigcompany, dc=com
# You will need to supply this string as the <i>tree-base</i> when querying
# this directory. (Ou is a very old X.400 term meaning "organizational
# unit." Dc is a more recent term meaning "domain component.")
#
# === LDAP Versions
# (stub, discuss v2 and v3)
#
# === LDAP Operations
# The essential operations are: #bind, #search, #add, #modify, #delete, and
# #rename.
#
# ==== Bind
# #bind supplies a user's authentication credentials to a server, which in
# turn verifies or rejects them. There is a range of possibilities for
# credentials, but most directories support a simple username and password
# authentication.
#
# Taken by itself, #bind can be used to authenticate a user against
# information stored in a directory, for example to permit or deny access to
# some other resource. In terms of the other LDAP operations, most
# directories require a successful #bind to be performed before the other
# operations will be permitted. Some servers permit certain operations to be
# performed with an "anonymous" binding, meaning that no credentials are
# presented by the user. (We're glossing over a lot of platform-specific
# detail here.)
#
# ==== Search
# Calling #search against the directory involves specifying a treebase, a
# set of <i>search filters, </i> and a list of attribute values. The filters
# specify ranges of possible values for particular attributes. Multiple
# filters can be joined together with AND, OR, and NOT operators. A server
# will respond to a #search by returning a list of matching DNs together
# with a set of attribute values for each entity, depending on what
# attributes the search requested.
#
# ==== Add
# #add specifies a new DN and an initial set of attribute values. If the
# operation succeeds, a new entity with the corresponding DN and attributes
# is added to the directory.
#
# ==== Modify
# #modify specifies an entity DN, and a list of attribute operations.
# #modify is used to change the attribute values stored in the directory for
# a particular entity. #modify may add or delete attributes (which are lists
# of values) or it change attributes by adding to or deleting from their
# values. Net::LDAP provides three easier methods to modify an entry's
# attribute values: #add_attribute, #replace_attribute, and
# #delete_attribute.
#
# ==== Delete
# #delete specifies an entity DN. If it succeeds, the entity and all its
# attributes is removed from the directory.
#
# ==== Rename (or Modify RDN)
# #rename (or #modify_rdn) is an operation added to version 3 of the LDAP
# protocol. It responds to the often-arising need to change the DN of an
# entity without discarding its attribute values. In earlier LDAP versions,
# the only way to do this was to delete the whole entity and add it again
# with a different DN.
#
# #rename works by taking an "old" DN (the one to change) and a "new RDN, "
# which is the left-most part of the DN string. If successful, #rename
# changes the entity DN so that its left-most node corresponds to the new
# RDN given in the request. (RDN, or "relative distinguished name, " denotes
# a single tree-node as expressed in a DN, which is a chain of tree nodes.)
#
# == How to use Net::LDAP
# To access Net::LDAP functionality in your Ruby programs, start by
# requiring the library:
#
#  require 'net/ldap'
#
# If you installed the Gem version of Net::LDAP, and depending on your
# version of Ruby and rubygems, you _may_ also need to require rubygems
# explicitly:
#
#  require 'rubygems'
#  require 'net/ldap'
#
# Most operations with Net::LDAP start by instantiating a Net::LDAP object.
# The constructor for this object takes arguments specifying the network
# location (address and port) of the LDAP server, and also the binding
# (authentication) credentials, typically a username and password. Given an
# object of class Net:LDAP, you can then perform LDAP operations by calling
# instance methods on the object. These are documented with usage examples
# below.
#
# The Net::LDAP library is designed to be very disciplined about how it
# makes network connections to servers. This is different from many of the
# standard native-code libraries that are provided on most platforms, which
# share bloodlines with the original Netscape/Michigan LDAP client
# implementations. These libraries sought to insulate user code from the
# workings of the network. This is a good idea of course, but the practical
# effect has been confusing and many difficult bugs have been caused by the
# opacity of the native libraries, and their variable behavior across
# platforms.
#
# In general, Net::LDAP instance methods which invoke server operations make
# a connection to the server when the method is called. They execute the
# operation (typically binding first) and then disconnect from the server.
# The exception is Net::LDAP#open, which makes a connection to the server
# and then keeps it open while it executes a user-supplied block.
# Net::LDAP#open closes the connection on completion of the block.
#
# source://net-ldap//lib/net/ldap.rb#5
class Net::LDAP
  include ::Net::LDAP::Instrumentation

  # Instantiate an object of type Net::LDAP to perform directory operations.
  # This constructor takes a Hash containing arguments, all of which are
  # either optional or may be specified later with other methods as
  # described below. The following arguments are supported:
  # * :host => the LDAP server's IP-address (default 127.0.0.1)
  # * :port => the LDAP server's TCP port (default 389)
  # * :hosts => an enumerable of pairs of hosts and corresponding ports with
  #   which to attempt opening connections (default [[host, port]])
  # * :auth => a Hash containing authorization parameters. Currently
  #   supported values include: {:method => :anonymous} and {:method =>
  #   :simple, :username => your_user_name, :password => your_password }
  #   The password parameter may be a Proc that returns a String.
  # * :base => a default treebase parameter for searches performed against
  #   the LDAP server. If you don't give this value, then each call to
  #   #search must specify a treebase parameter. If you do give this value,
  #   then it will be used in subsequent calls to #search that do not
  #   specify a treebase. If you give a treebase value in any particular
  #   call to #search, that value will override any treebase value you give
  #   here.
  # * :force_no_page => Set to true to prevent paged results even if your
  #   server says it supports them. This is a fix for MS Active Directory
  # * :instrumentation_service => An object responsible for instrumenting
  #   operations, compatible with ActiveSupport::Notifications' public API.
  # * :encryption => specifies the encryption to be used in communicating
  #   with the LDAP server. The value must be a Hash containing additional
  #   parameters, which consists of two keys:
  #     method: - :simple_tls or :start_tls
  #     tls_options: - Hash of options for that method
  #   The :simple_tls encryption method encrypts <i>all</i> communications
  #   with the LDAP server. It completely establishes SSL/TLS encryption with
  #   the LDAP server before any LDAP-protocol data is exchanged. There is no
  #   plaintext negotiation and no special encryption-request controls are
  #   sent to the server. <i>The :simple_tls option is the simplest, easiest
  #   way to encrypt communications between Net::LDAP and LDAP servers.</i>
  #   If you get communications or protocol errors when using this option,
  #   check with your LDAP server administrator. Pay particular attention
  #   to the TCP port you are connecting to. It's impossible for an LDAP
  #   server to support plaintext LDAP communications and <i>simple TLS</i>
  #   connections on the same port. The standard TCP port for unencrypted
  #   LDAP connections is 389, but the standard port for simple-TLS
  #   encrypted connections is 636. Be sure you are using the correct port.
  #   The :start_tls like the :simple_tls encryption method also encrypts all
  #   communcations with the LDAP server. With the exception that it operates
  #   over the standard TCP port.
  #
  #   To validate the LDAP server's certificate (a security must if you're
  #   talking over the public internet), you need to set :tls_options
  #   something like this...
  #
  #   Net::LDAP.new(
  #     # ... set host, bind dn, etc ...
  #     encryption: {
  #       method: :simple_tls,
  #       tls_options: OpenSSL::SSL::SSLContext::DEFAULT_PARAMS,
  #     }
  #   )
  #
  #   The above will use the operating system-provided store of CA
  #   certificates to validate your LDAP server's cert.
  #   If cert validation fails, it'll happen during the #bind
  #   whenever you first try to open a connection to the server.
  #   Those methods will throw Net::LDAP::ConnectionError with
  #   a message about certificate verify failing. If your
  #   LDAP server's certificate is signed by DigiCert, Comodo, etc.,
  #   you're probably good. If you've got a self-signed cert but it's
  #   been added to the host's OS-maintained CA store (e.g. on Debian
  #   add foobar.crt to /usr/local/share/ca-certificates/ and run
  #   `update-ca-certificates`), then the cert should pass validation.
  #   To ignore the OS's CA store, put your CA in a PEM-encoded file and...
  #
  #   encryption: {
  #     method:      :simple_tls,
  #     tls_options: { ca_file:     '/path/to/my-little-ca.pem',
  #                    ssl_version: 'TLSv1_1' },
  #   }
  #
  #   As you might guess, the above example also fails the connection
  #   if the client can't negotiate TLS v1.1.
  #   tls_options is ultimately passed to OpenSSL::SSL::SSLContext#set_params
  #   For more details, see
  #    http://ruby-doc.org/stdlib-2.0.0/libdoc/openssl/rdoc/OpenSSL/SSL/SSLContext.html
  #
  # Instantiating a Net::LDAP object does <i>not</i> result in network
  # traffic to the LDAP server. It simply stores the connection and binding
  # parameters in the object. That's why Net::LDAP.new doesn't throw
  # cert validation errors itself; #bind does instead.
  #
  # @return [LDAP] a new instance of LDAP
  #
  # source://net-ldap//lib/net/ldap.rb#546
  def initialize(args = T.unsafe(nil)); end

  # Adds a new entry to the remote LDAP server.
  # Supported arguments:
  # :dn :: Full DN of the new entry
  # :attributes :: Attributes of the new entry.
  #
  # The attributes argument is supplied as a Hash keyed by Strings or
  # Symbols giving the attribute name, and mapping to Strings or Arrays of
  # Strings giving the actual attribute values. Observe that most LDAP
  # directories enforce schema constraints on the attributes contained in
  # entries. #add will fail with a server-generated error if your attributes
  # violate the server-specific constraints.
  #
  # Here's an example:
  #
  #  dn = "cn=George Smith, ou=people, dc=example, dc=com"
  #  attr = {
  #    :cn => "George Smith",
  #    :objectclass => ["top", "inetorgperson"],
  #    :sn => "Smith",
  #    :mail => "gsmith@example.com"
  #  }
  #  Net::LDAP.open(:host => host) do |ldap|
  #    ldap.add(:dn => dn, :attributes => attr)
  #  end
  #
  # source://net-ldap//lib/net/ldap.rb#962
  def add(args); end

  # Add a value to an attribute. Takes the full DN of the entry to modify,
  # the name (Symbol or String) of the attribute, and the value (String or
  # Array). If the attribute does not exist (and there are no schema
  # violations), #add_attribute will create it with the caller-specified
  # values. If the attribute already exists (and there are no schema
  # violations), the caller-specified values will be _added_ to the values
  # already present.
  #
  # Returns True or False to indicate whether the operation succeeded or
  # failed, with extended information available by calling
  # #get_operation_result. See also #replace_attribute and
  # #delete_attribute.
  #
  #  dn = "cn=modifyme, dc=example, dc=com"
  #  ldap.add_attribute dn, :mail, "newmailaddress@example.com"
  #
  # source://net-ldap//lib/net/ldap.rb#1114
  def add_attribute(dn, attribute, value); end

  # Convenience method to specify authentication credentials to the LDAP
  # server. Currently supports simple authentication requiring a username
  # and password.
  #
  # Observe that on most LDAP servers, the username is a complete DN.
  # However, with A/D, it's often possible to give only a user-name rather
  # than a complete DN. In the latter case, beware that many A/D servers are
  # configured to permit anonymous (uncredentialled) binding, and will
  # silently accept your binding as anonymous if you give an unrecognized
  # username. This is not usually what you want. (See
  # #get_operation_result.)
  #
  # <b>Important:</b> The password argument may be a Proc that returns a
  # string. This makes it possible for you to write client programs that
  # solicit passwords from users or from other data sources without showing
  # them in your code or on command lines.
  #
  #  require 'net/ldap'
  #
  #  ldap = Net::LDAP.new
  #  ldap.host = server_ip_address
  #  ldap.authenticate "cn=Your Username, cn=Users, dc=example, dc=com", "your_psw"
  #
  # Alternatively (with a password block):
  #
  #  require 'net/ldap'
  #
  #  ldap = Net::LDAP.new
  #  ldap.host = server_ip_address
  #  psw = proc { your_psw_function }
  #  ldap.authenticate "cn=Your Username, cn=Users, dc=example, dc=com", psw
  #
  # source://net-ldap//lib/net/ldap.rb#601
  def auth(username, password); end

  # Convenience method to specify authentication credentials to the LDAP
  # server. Currently supports simple authentication requiring a username
  # and password.
  #
  # Observe that on most LDAP servers, the username is a complete DN.
  # However, with A/D, it's often possible to give only a user-name rather
  # than a complete DN. In the latter case, beware that many A/D servers are
  # configured to permit anonymous (uncredentialled) binding, and will
  # silently accept your binding as anonymous if you give an unrecognized
  # username. This is not usually what you want. (See
  # #get_operation_result.)
  #
  # <b>Important:</b> The password argument may be a Proc that returns a
  # string. This makes it possible for you to write client programs that
  # solicit passwords from users or from other data sources without showing
  # them in your code or on command lines.
  #
  #  require 'net/ldap'
  #
  #  ldap = Net::LDAP.new
  #  ldap.host = server_ip_address
  #  ldap.authenticate "cn=Your Username, cn=Users, dc=example, dc=com", "your_psw"
  #
  # Alternatively (with a password block):
  #
  #  require 'net/ldap'
  #
  #  ldap = Net::LDAP.new
  #  ldap.host = server_ip_address
  #  psw = proc { your_psw_function }
  #  ldap.authenticate "cn=Your Username, cn=Users, dc=example, dc=com", psw
  #
  # source://net-ldap//lib/net/ldap.rb#601
  def authenticate(username, password); end

  # Returns the value of attribute base.
  #
  # source://net-ldap//lib/net/ldap.rb#458
  def base; end

  # Sets the attribute base
  #
  # @param value the value to set the attribute base to.
  #
  # source://net-ldap//lib/net/ldap.rb#458
  def base=(_arg0); end

  # #bind connects to an LDAP server and requests authentication based on
  # the <tt>:auth</tt> parameter passed to #open or #new. It takes no
  # parameters.
  #
  # User code does not need to call #bind directly. It will be called
  # implicitly by the library whenever you invoke an LDAP operation, such as
  # #search or #add.
  #
  # It is useful, however, to call #bind in your own code when the only
  # operation you intend to perform against the directory is to validate a
  # login credential. #bind returns true or false to indicate whether the
  # binding was successful. Reasons for failure include malformed or
  # unrecognized usernames and incorrect passwords. Use
  # #get_operation_result to find out what happened in case of failure.
  #
  # Here's a typical example using #bind to authenticate a credential which
  # was (perhaps) solicited from the user of a web site:
  #
  #  require 'net/ldap'
  #  ldap = Net::LDAP.new
  #  ldap.host = your_server_ip_address
  #  ldap.port = 389
  #  ldap.auth your_user_name, your_user_password
  #  if ldap.bind
  #    # authentication succeeded
  #  else
  #    # authentication failed
  #    p ldap.get_operation_result
  #  end
  #
  # Here's a more succinct example which does exactly the same thing, but
  # collects all the required parameters into arguments:
  #
  #  require 'net/ldap'
  #  ldap = Net::LDAP.new(:host => your_server_ip_address, :port => 389)
  #  if ldap.bind(:method => :simple, :username => your_user_name,
  #               :password => your_user_password)
  #    # authentication succeeded
  #  else
  #    # authentication failed
  #    p ldap.get_operation_result
  #  end
  #
  # You don't need to pass a user-password as a String object to bind. You
  # can also pass a Ruby Proc object which returns a string. This will cause
  # bind to execute the Proc (which might then solicit input from a user
  # with console display suppressed). The String value returned from the
  # Proc is used as the password.
  #
  # You don't have to create a new instance of Net::LDAP every time you
  # perform a binding in this way. If you prefer, you can cache the
  # Net::LDAP object and re-use it to perform subsequent bindings,
  # <i>provided</i> you call #auth to specify a new credential before
  # calling #bind. Otherwise, you'll just re-authenticate the previous user!
  # (You don't need to re-set the values of #host and #port.) As noted in
  # the documentation for #auth, the password parameter can be a Ruby Proc
  # instead of a String.
  #
  # source://net-ldap//lib/net/ldap.rb#859
  def bind(auth = T.unsafe(nil)); end

  # #bind_as is for testing authentication credentials.
  #
  # As described under #bind, most LDAP servers require that you supply a
  # complete DN as a binding-credential, along with an authenticator such as
  # a password. But for many applications (such as authenticating users to a
  # Rails application), you often don't have a full DN to identify the user.
  # You usually get a simple identifier like a username or an email address,
  # along with a password. #bind_as allows you to authenticate these
  # user-identifiers.
  #
  # #bind_as is a combination of a search and an LDAP binding. First, it
  # connects and binds to the directory as normal. Then it searches the
  # directory for an entry corresponding to the email address, username, or
  # other string that you supply. If the entry exists, then #bind_as will
  # <b>re-bind</b> as that user with the password (or other authenticator)
  # that you supply.
  #
  # #bind_as takes the same parameters as #search, <i>with the addition of
  # an authenticator.</i> Currently, this authenticator must be
  # <tt>:password</tt>. Its value may be either a String, or a +proc+ that
  # returns a String. #bind_as returns +false+ on failure. On success, it
  # returns a result set, just as #search does. This result set is an Array
  # of objects of type Net::LDAP::Entry. It contains the directory
  # attributes corresponding to the user. (Just test whether the return
  # value is logically true, if you don't need this additional information.)
  #
  # Here's how you would use #bind_as to authenticate an email address and
  # password:
  #
  #  require 'net/ldap'
  #
  #  user, psw = "joe_user@yourcompany.com", "joes_psw"
  #
  #  ldap = Net::LDAP.new
  #  ldap.host = "192.168.0.100"
  #  ldap.port = 389
  #  ldap.auth "cn=manager, dc=yourcompany, dc=com", "topsecret"
  #
  #  result = ldap.bind_as(:base => "dc=yourcompany, dc=com",
  #                        :filter => "(mail=#{user})",
  #                        :password => psw)
  #  if result
  #    puts "Authenticated #{result.first.dn}"
  #  else
  #    puts "Authentication FAILED."
  #  end
  #
  # source://net-ldap//lib/net/ldap.rb#924
  def bind_as(args = T.unsafe(nil)); end

  # Internal: Set @open_connection for testing
  #
  # source://net-ldap//lib/net/ldap.rb#1293
  def connection=(connection); end

  # Delete an entry from the LDAP directory. Takes a hash of arguments. The
  # only supported argument is :dn, which must give the complete DN of the
  # entry to be deleted.
  #
  # Returns True or False to indicate whether the delete succeeded. Extended
  # status information is available by calling #get_operation_result.
  #
  #  dn = "mail=deleteme@example.com, ou=people, dc=example, dc=com"
  #  ldap.delete :dn => dn
  #
  # source://net-ldap//lib/net/ldap.rb#1171
  def delete(args); end

  # Delete an attribute and all its values. Takes the full DN of the entry
  # to modify, and the name (Symbol or String) of the attribute to delete.
  #
  # Returns True or False to indicate whether the operation succeeded or
  # failed, with extended information available by calling
  # #get_operation_result. See also #add_attribute and #replace_attribute.
  #
  #  dn = "cn=modifyme, dc=example, dc=com"
  #  ldap.delete_attribute dn, :mail
  #
  # source://net-ldap//lib/net/ldap.rb#1145
  def delete_attribute(dn, attribute); end

  # Delete an entry from the LDAP directory along with all subordinate entries.
  # the regular delete method will fail to delete an entry if it has subordinate
  # entries. This method sends an extra control code to tell the LDAP server
  # to do a tree delete. ('1.2.840.113556.1.4.805')
  #
  # If the LDAP server does not support the DELETE_TREE control code, subordinate
  # entries are deleted recursively instead.
  #
  # Returns True or False to indicate whether the delete succeeded. Extended
  # status information is available by calling #get_operation_result.
  #
  #  dn = "mail=deleteme@example.com, ou=people, dc=example, dc=com"
  #  ldap.delete_tree :dn => dn
  #
  # source://net-ldap//lib/net/ldap.rb#1193
  def delete_tree(args); end

  # Convenience method to specify encryption characteristics for connections
  # to LDAP servers. Called implicitly by #new and #open, but may also be
  # called by user code if desired. The single argument is generally a Hash
  # (but see below for convenience alternatives). This implementation is
  # currently a stub, supporting only a few encryption alternatives. As
  # additional capabilities are added, more configuration values will be
  # added here.
  #
  # This method is deprecated.
  #
  # source://net-ldap//lib/net/ldap.rb#621
  def encryption(args); end

  # Returns a meaningful result any time after a protocol operation (#bind,
  # #search, #add, #modify, #rename, #delete) has completed. It returns an
  # #OpenStruct containing an LDAP result code (0 means success), and a
  # human-readable string.
  #
  #  unless ldap.bind
  #    puts "Result: #{ldap.get_operation_result.code}"
  #    puts "Message: #{ldap.get_operation_result.message}"
  #  end
  #
  # Certain operations return additional information, accessible through
  # members of the object returned from #get_operation_result. Check
  # #get_operation_result.error_message and
  # #get_operation_result.matched_dn.
  #
  # --
  # Modified the implementation, 20Mar07. We might get a hash of LDAP
  # response codes instead of a simple numeric code.
  # ++
  #
  # source://net-ldap//lib/net/ldap.rb#666
  def get_operation_result; end

  # Returns the value of attribute host.
  #
  # source://net-ldap//lib/net/ldap.rb#455
  def host; end

  # Sets the attribute host
  #
  # @param value the value to set the attribute host to.
  #
  # source://net-ldap//lib/net/ldap.rb#455
  def host=(_arg0); end

  # Returns the value of attribute hosts.
  #
  # source://net-ldap//lib/net/ldap.rb#457
  def hosts; end

  # Sets the attribute hosts
  #
  # @param value the value to set the attribute hosts to.
  #
  # source://net-ldap//lib/net/ldap.rb#457
  def hosts=(_arg0); end

  # Mask auth password
  #
  # source://net-ldap//lib/net/ldap.rb#1286
  def inspect; end

  # Modifies the attribute values of a particular entry on the LDAP
  # directory. Takes a hash with arguments. Supported arguments are:
  # :dn :: (the full DN of the entry whose attributes are to be modified)
  # :operations :: (the modifications to be performed, detailed next)
  #
  # This method returns True or False to indicate whether the operation
  # succeeded or failed, with extended information available by calling
  # #get_operation_result.
  #
  # Also see #add_attribute, #replace_attribute, or #delete_attribute, which
  # provide simpler interfaces to this functionality.
  #
  # The LDAP protocol provides a full and well thought-out set of operations
  # for changing the values of attributes, but they are necessarily somewhat
  # complex and not always intuitive. If these instructions are confusing or
  # incomplete, please send us email or create an issue on GitHub.
  #
  # The :operations parameter to #modify takes an array of
  # operation-descriptors. Each individual operation is specified in one
  # element of the array, and most LDAP servers will attempt to perform the
  # operations in order.
  #
  # Each of the operations appearing in the Array must itself be an Array
  # with exactly three elements:
  # an operator :: must be :add, :replace, or :delete
  # an attribute name :: the attribute name (string or symbol) to modify
  # a value :: either a string or an array of strings.
  #
  # The :add operator will, unsurprisingly, add the specified values to the
  # specified attribute. If the attribute does not already exist, :add will
  # create it. Most LDAP servers will generate an error if you try to add a
  # value that already exists.
  #
  # :replace will erase the current value(s) for the specified attribute, if
  # there are any, and replace them with the specified value(s).
  #
  # :delete will remove the specified value(s) from the specified attribute.
  # If you pass nil, an empty string, or an empty array as the value
  # parameter to a :delete operation, the _entire_ _attribute_ will be
  # deleted, along with all of its values.
  #
  # For example:
  #
  #  dn = "mail=modifyme@example.com, ou=people, dc=example, dc=com"
  #  ops = [
  #    [:add, :mail, "aliasaddress@example.com"],
  #    [:replace, :mail, ["newaddress@example.com", "newalias@example.com"]],
  #    [:delete, :sn, nil]
  #  ]
  #  ldap.modify :dn => dn, :operations => ops
  #
  # <i>(This example is contrived since you probably wouldn't add a mail
  # value right before replacing the whole attribute, but it shows that
  # order of execution matters. Also, many LDAP servers won't let you delete
  # SN because that would be a schema violation.)</i>
  #
  # It's essential to keep in mind that if you specify more than one
  # operation in a call to #modify, most LDAP servers will attempt to
  # perform all of the operations in the order you gave them. This matters
  # because you may specify operations on the same attribute which must be
  # performed in a certain order.
  #
  # Most LDAP servers will _stop_ processing your modifications if one of
  # them causes an error on the server (such as a schema-constraint
  # violation). If this happens, you will probably get a result code from
  # the server that reflects only the operation that failed, and you may or
  # may not get extended information that will tell you which one failed.
  # #modify has no notion of an atomic transaction. If you specify a chain
  # of modifications in one call to #modify, and one of them fails, the
  # preceding ones will usually not be "rolled back", resulting in a
  # partial update. This is a limitation of the LDAP protocol, not of
  # Net::LDAP.
  #
  # The lack of transactional atomicity in LDAP means that you're usually
  # better off using the convenience methods #add_attribute,
  # #replace_attribute, and #delete_attribute, which are wrappers over
  # #modify. However, certain LDAP servers may provide concurrency
  # semantics, in which the several operations contained in a single #modify
  # call are not interleaved with other modification-requests received
  # simultaneously by the server. It bears repeating that this concurrency
  # does _not_ imply transactional atomicity, which LDAP does not provide.
  #
  # source://net-ldap//lib/net/ldap.rb#1052
  def modify(args); end

  # Rename an entry on the remote DIS by changing the last RDN of its DN.
  #
  # _Documentation_ _stub_
  #
  # source://net-ldap//lib/net/ldap.rb#1152
  def modify_rdn(args); end

  # Opens a network connection to the server and then passes <tt>self</tt>
  # to the caller-supplied block. The connection is closed when the block
  # completes. Used for executing multiple LDAP operations without requiring
  # a separate network connection (and authentication) for each one.
  # <i>Note:</i> You do not need to log-in or "bind" to the server. This
  # will be done for you automatically. For an even simpler approach, see
  # the class method Net::LDAP#open.
  #
  #  # (PSEUDOCODE)
  #  auth = { :method => :simple, :username => username, :password => password }
  #  ldap = Net::LDAP.new(:host => ipaddress, :port => 389, :auth => auth)
  #  ldap.open do |ldap|
  #    ldap.search(...)
  #    ldap.add(...)
  #    ldap.modify(...)
  #  end
  #
  # @raise [Net::LDAP::AlreadyOpenedError]
  #
  # source://net-ldap//lib/net/ldap.rb#704
  def open; end

  # --
  # Convenience method to query server capabilities.
  # Only do this once per Net::LDAP object.
  # Note, we call a search, and we might be called from inside a search!
  # MUST refactor the root_dse call out.
  # ++
  #
  # @return [Boolean]
  #
  # source://net-ldap//lib/net/ldap.rb#1276
  def paged_searches_supported?; end

  # Password Modify
  #
  # Change existing password:
  #
  #  dn = 'uid=modify-password-user1,ou=People,dc=rubyldap,dc=com'
  #  auth = {
  #    method: :simple,
  #    username: dn,
  #    password: 'passworD1'
  #  }
  #  ldap.password_modify(dn: dn,
  #                       auth: auth,
  #                       old_password: 'passworD1',
  #                       new_password: 'passworD2')
  #
  # Or get the LDAP server to generate a password for you:
  #
  #  dn = 'uid=modify-password-user1,ou=People,dc=rubyldap,dc=com'
  #  auth = {
  #    method: :simple,
  #    username: dn,
  #    password: 'passworD1'
  #  }
  #  ldap.password_modify(dn: dn,
  #                       auth: auth,
  #                       old_password: 'passworD1')
  #
  #  ldap.get_operation_result.extended_response[0][0] #=> 'VtcgGf/G'
  #
  # source://net-ldap//lib/net/ldap.rb#1090
  def password_modify(args); end

  # Returns the value of attribute port.
  #
  # source://net-ldap//lib/net/ldap.rb#456
  def port; end

  # Sets the attribute port
  #
  # @param value the value to set the attribute port to.
  #
  # source://net-ldap//lib/net/ldap.rb#456
  def port=(_arg0); end

  # Rename an entry on the remote DIS by changing the last RDN of its DN.
  #
  # _Documentation_ _stub_
  #
  # source://net-ldap//lib/net/ldap.rb#1152
  def rename(args); end

  # Replace the value of an attribute. #replace_attribute can be thought of
  # as equivalent to calling #delete_attribute followed by #add_attribute.
  # It takes the full DN of the entry to modify, the name (Symbol or String)
  # of the attribute, and the value (String or Array). If the attribute does
  # not exist, it will be created with the caller-specified value(s). If the
  # attribute does exist, its values will be _discarded_ and replaced with
  # the caller-specified values.
  #
  # Returns True or False to indicate whether the operation succeeded or
  # failed, with extended information available by calling
  # #get_operation_result. See also #add_attribute and #delete_attribute.
  #
  #  dn = "cn=modifyme, dc=example, dc=com"
  #  ldap.replace_attribute dn, :mail, "newmailaddress@example.com"
  #
  # source://net-ldap//lib/net/ldap.rb#1132
  def replace_attribute(dn, attribute, value); end

  # Searches the LDAP directory for directory entries. Takes a hash argument
  # with parameters. Supported parameters include:
  # * :base (a string specifying the tree-base for the search);
  # * :filter (an object of type Net::LDAP::Filter, defaults to
  #   objectclass=*);
  # * :attributes (a string or array of strings specifying the LDAP
  #   attributes to return from the server);
  # * :return_result (a boolean specifying whether to return a result set).
  # * :attributes_only (a boolean flag, defaults false)
  # * :scope (one of: Net::LDAP::SearchScope_BaseObject,
  #   Net::LDAP::SearchScope_SingleLevel,
  #   Net::LDAP::SearchScope_WholeSubtree. Default is WholeSubtree.)
  # * :size (an integer indicating the maximum number of search entries to
  #   return. Default is zero, which signifies no limit.)
  # * :time (an integer restricting the maximum time in seconds allowed for a search. Default is zero, no time limit RFC 4511 4.5.1.5)
  # * :deref (one of: Net::LDAP::DerefAliases_Never, Net::LDAP::DerefAliases_Search,
  #   Net::LDAP::DerefAliases_Find, Net::LDAP::DerefAliases_Always. Default is Never.)
  #
  # #search queries the LDAP server and passes <i>each entry</i> to the
  # caller-supplied block, as an object of type Net::LDAP::Entry. If the
  # search returns 1000 entries, the block will be called 1000 times. If the
  # search returns no entries, the block will not be called.
  #
  # #search returns either a result-set or a boolean, depending on the value
  # of the <tt>:return_result</tt> argument. The default behavior is to
  # return a result set, which is an Array of objects of class
  # Net::LDAP::Entry. If you request a result set and #search fails with an
  # error, it will return nil. Call #get_operation_result to get the error
  # information returned by
  # the LDAP server.
  #
  # When <tt>:return_result => false, </tt> #search will return only a
  # Boolean, to indicate whether the operation succeeded. This can improve
  # performance with very large result sets, because the library can discard
  # each entry from memory after your block processes it.
  #
  #  treebase = "dc=example, dc=com"
  #  filter = Net::LDAP::Filter.eq("mail", "a*.com")
  #  attrs = ["mail", "cn", "sn", "objectclass"]
  #  ldap.search(:base => treebase, :filter => filter, :attributes => attrs,
  #              :return_result => false) do |entry|
  #    puts "DN: #{entry.dn}"
  #    entry.each do |attr, values|
  #      puts ".......#{attr}:"
  #      values.each do |value|
  #        puts "          #{value}"
  #      end
  #    end
  #  end
  #
  # source://net-ldap//lib/net/ldap.rb#773
  def search(args = T.unsafe(nil)); end

  # This method is experimental and subject to change. Return the rootDSE
  # record from the LDAP server as a Net::LDAP::Entry, or an empty Entry if
  # the server doesn't return the record.
  # --
  # cf. RFC4512 graf 5.1.
  # Note that the rootDSE record we return on success has an empty DN, which
  # is correct. On failure, the empty Entry will have a nil DN. There's no
  # real reason for that, so it can be changed if desired. The funky
  # number-disagreements in the set of attribute names is correct per the
  # RFC. We may be called by #search itself, which may need to determine
  # things like paged search capabilities. So to avoid an infinite regress,
  # set :ignore_server_caps, which prevents us getting called recursively.
  # ++
  #
  # source://net-ldap//lib/net/ldap.rb#1214
  def search_root_dse; end

  # Return the root Subschema record from the LDAP server as a
  # Net::LDAP::Entry, or an empty Entry if the server doesn't return the
  # record. On success, the Net::LDAP::Entry returned from this call will
  # have the attributes :dn, :objectclasses, and :attributetypes. If there
  # is an error, call #get_operation_result for more information.
  #
  #  ldap = Net::LDAP.new
  #  ldap.host = "your.ldap.host"
  #  ldap.auth "your-user-dn", "your-psw"
  #  subschema_entry = ldap.search_subschema_entry
  #
  #  subschema_entry.attributetypes.each do |attrtype|
  #    # your code
  #  end
  #
  #  subschema_entry.objectclasses.each do |attrtype|
  #    # your code
  #  end
  # --
  # cf. RFC4512 section 4, particulary graff 4.4.
  # The :dn attribute in the returned Entry is the subschema name as
  # returned from the server. Set :ignore_server_caps, see the notes in
  # search_root_dse.
  # ++
  #
  # source://net-ldap//lib/net/ldap.rb#1254
  def search_subschema_entry; end

  private

  # Establish a new connection to the LDAP server
  #
  # source://net-ldap//lib/net/ldap.rb#1319
  def new_connection; end

  # Normalize encryption parameter the constructor accepts, expands a few
  # convenience symbols into recognizable hashes
  #
  # source://net-ldap//lib/net/ldap.rb#1341
  def normalize_encryption(args); end

  # Recursively delete a dn and it's subordinate children.
  # This is useful when a server does not support the DELETE_TREE control code.
  #
  # @raise [EmptyDNError]
  #
  # source://net-ldap//lib/net/ldap.rb#1353
  def recursive_delete(args); end

  # Yields an open connection if there is one, otherwise establishes a new
  # connection, binds, and yields it. If binding fails, it will return the
  # result from that, and :use_connection: will not yield at all. If not
  # the return value is whatever is returned from the block.
  #
  # source://net-ldap//lib/net/ldap.rb#1303
  def use_connection(args); end

  class << self
    # #open takes the same parameters as #new. #open makes a network
    # connection to the LDAP server and then passes a newly-created Net::LDAP
    # object to the caller-supplied block. Within the block, you can call any
    # of the instance methods of Net::LDAP to perform operations against the
    # LDAP directory. #open will perform all the operations in the
    # user-supplied block on the same network connection, which will be closed
    # automatically when the block finishes.
    #
    #  # (PSEUDOCODE)
    #  auth = { :method => :simple, :username => username, :password => password }
    #  Net::LDAP.open(:host => ipaddress, :port => 389, :auth => auth) do |ldap|
    #    ldap.search(...)
    #    ldap.add(...)
    #    ldap.modify(...)
    #  end
    #
    # source://net-ldap//lib/net/ldap.rb#642
    def open(args); end

    # source://net-ldap//lib/net/ldap.rb#451
    def result2string(code); end
  end
end

# source://net-ldap//lib/net/ldap/error.rb#4
class Net::LDAP::AlreadyOpenedError < ::Net::LDAP::Error; end

# source://net-ldap//lib/net/ldap.rb#332
Net::LDAP::AsnSyntax = T.let(T.unsafe(nil), Array)

# source://net-ldap//lib/net/ldap/auth_adapter.rb#3
class Net::LDAP::AuthAdapter
  # @return [AuthAdapter] a new instance of AuthAdapter
  #
  # source://net-ldap//lib/net/ldap/auth_adapter.rb#20
  def initialize(conn); end

  # source://net-ldap//lib/net/ldap/auth_adapter.rb#24
  def bind; end

  class << self
    # source://net-ldap//lib/net/ldap/auth_adapter.rb#12
    def [](name); end

    # source://net-ldap//lib/net/ldap/auth_adapter.rb#4
    def register(names, adapter); end
  end
end

# source://net-ldap//lib/net/ldap/auth_adapter/sasl.rb#6
class Net::LDAP::AuthAdapter::Sasl < ::Net::LDAP::AuthAdapter
  # --
  # Required parameters: :mechanism, :initial_credential and
  # :challenge_response
  #
  # Mechanism is a string value that will be passed in the SASL-packet's
  # "mechanism" field.
  #
  # Initial credential is most likely a string. It's passed in the initial
  # BindRequest that goes to the server. In some protocols, it may be empty.
  #
  # Challenge-response is a Ruby proc that takes a single parameter and
  # returns an object that will typically be a string. The
  # challenge-response block is called when the server returns a
  # BindResponse with a result code of 14 (saslBindInProgress). The
  # challenge-response block receives a parameter containing the data
  # returned by the server in the saslServerCreds field of the LDAP
  # BindResponse packet. The challenge-response block may be called multiple
  # times during the course of a SASL authentication, and each time it must
  # return a value that will be passed back to the server as the credential
  # data in the next BindRequest packet.
  # ++
  #
  # @raise [Net::LDAP::BindingInformationInvalidError]
  #
  # source://net-ldap//lib/net/ldap/auth_adapter/sasl.rb#30
  def bind(auth); end
end

# source://net-ldap//lib/net/ldap/auth_adapter/sasl.rb#7
Net::LDAP::AuthAdapter::Sasl::MAX_SASL_CHALLENGES = T.let(T.unsafe(nil), Integer)

# source://net-ldap//lib/net/ldap/auth_adapter/simple.rb#6
class Net::LDAP::AuthAdapter::Simple < ::Net::LDAP::AuthAdapter
  # @raise [Net::LDAP::BindingInformationInvalidError]
  #
  # source://net-ldap//lib/net/ldap/auth_adapter/simple.rb#7
  def bind(auth); end
end

# source://net-ldap//lib/net/ldap/error.rb#29
class Net::LDAP::AuthMethodUnsupportedError < ::Net::LDAP::Error; end

# source://net-ldap//lib/net/ldap/error.rb#43
class Net::LDAP::BERInvalidError < ::Net::LDAP::Error; end

# source://net-ldap//lib/net/ldap/error.rb#45
class Net::LDAP::BadAttributeError < ::Net::LDAP::Error; end

# source://net-ldap//lib/net/ldap/error.rb#30
class Net::LDAP::BindingInformationInvalidError < ::Net::LDAP::Error; end

# This is a private class used internally by the library. It should not
# be called by user code.
#
# source://net-ldap//lib/net/ldap/connection.rb#3
class Net::LDAP::Connection
  include ::Net::LDAP::Instrumentation

  # Initialize a connection to an LDAP server
  #
  # :server
  #   :hosts   Array of tuples specifying host, port
  #   :host    host
  #   :port    port
  #   :socket  prepared socket
  #
  # @return [Connection] a new instance of Connection
  # @yield [_self]
  # @yieldparam _self [Net::LDAP::Connection] the object that the method was called on
  #
  # source://net-ldap//lib/net/ldap/connection.rb#19
  def initialize(server = T.unsafe(nil)); end

  # --
  # TODO: need to support a time limit, in case the server fails to respond.
  # Unlike other operation-methods in this class, we return a result hash
  # rather than a simple result number. This is experimental, and eventually
  # we'll want to do this with all the others. The point is to have access
  # to the error message and the matched-DN returned by the server.
  # ++
  #
  # source://net-ldap//lib/net/ldap/connection.rb#627
  def add(args); end

  # source://net-ldap//lib/net/ldap/connection.rb#275
  def bind(auth); end

  # --
  # This is provided as a convenience method to make sure a connection
  # object gets closed without waiting for a GC to happen. Clients shouldn't
  # have to call it, but perhaps it will come in handy someday.
  # ++
  #
  # source://net-ldap//lib/net/ldap/connection.rb#184
  def close; end

  # --
  # TODO, need to support a time limit, in case the server fails to respond.
  # ++
  #
  # source://net-ldap//lib/net/ldap/connection.rb#673
  def delete(args); end

  # --
  # Allow the caller to specify a sort control
  #
  # The format of the sort control needs to be:
  #
  # :sort_control => ["cn"]  # just a string
  # or
  # :sort_control => [["cn", "matchingRule", true]] #attribute, matchingRule, direction (true / false)
  # or
  # :sort_control => ["givenname","sn"] #multiple strings or arrays
  #
  # source://net-ldap//lib/net/ldap/connection.rb#294
  def encode_sort_controls(sort_definitions); end

  # Internal: The internal queue of messages, read from the socket, grouped by
  # message ID.
  #
  # Used by `queued_read` to return messages sent by the server with the given
  # ID. If no messages are queued for that ID, `queued_read` will `read` from
  # the socket and queue messages that don't match the given ID for other
  # readers.
  #
  # Returns the message queue Hash.
  #
  # source://net-ldap//lib/net/ldap/connection.rb#221
  def message_queue; end

  # --
  # TODO: need to support a time limit, in case the server fails to respond.
  # TODO: We're throwing an exception here on empty DN. Should return a
  # proper error instead, probaby from farther up the chain.
  # TODO: If the user specifies a bogus opcode, we'll throw a confusing
  # error here ("to_ber_enumerated is not defined on nil").
  # ++
  #
  # source://net-ldap//lib/net/ldap/connection.rb#555
  def modify(args); end

  # source://net-ldap//lib/net/ldap/connection.rb#270
  def next_msgid; end

  # @raise [Net::LDAP::ConnectionError]
  #
  # source://net-ldap//lib/net/ldap/connection.rb#41
  def open_connection(server); end

  # Password Modify
  #
  # http://tools.ietf.org/html/rfc3062
  #
  # passwdModifyOID OBJECT IDENTIFIER ::= 1.3.6.1.4.1.4203.1.11.1
  #
  # PasswdModifyRequestValue ::= SEQUENCE {
  #   userIdentity    [0]  OCTET STRING OPTIONAL
  #   oldPasswd       [1]  OCTET STRING OPTIONAL
  #   newPasswd       [2]  OCTET STRING OPTIONAL }
  #
  # PasswdModifyResponseValue ::= SEQUENCE {
  #   genPasswd       [0]     OCTET STRING OPTIONAL }
  #
  # Encoded request:
  #
  #   00\x02\x01\x02w+\x80\x171.3.6.1.4.1.4203.1.11.1\x81\x100\x0E\x81\x05old\x82\x05new
  #
  # @raise [ArgumentError]
  #
  # source://net-ldap//lib/net/ldap/connection.rb#594
  def password_modify(args); end

  # source://net-ldap//lib/net/ldap/connection.rb#33
  def prepare_socket(server, timeout = T.unsafe(nil)); end

  # Internal: Reads messages by ID from a queue, falling back to reading from
  # the connected socket until a message matching the ID is read. Any messages
  # with mismatched IDs gets queued for subsequent reads by the origin of that
  # message ID.
  #
  # Returns a Net::LDAP::PDU object or nil.
  #
  # source://net-ldap//lib/net/ldap/connection.rb#196
  def queued_read(message_id); end

  # --
  # TODO: need to support a time limit, in case the server fails to respond.
  # ++
  #
  # source://net-ldap//lib/net/ldap/connection.rb#650
  def rename(args); end

  # --
  # Alternate implementation, this yields each search entry to the caller as
  # it are received.
  #
  # TODO: certain search parameters are hardcoded.
  # TODO: if we mis-parse the server results or the results are wrong, we
  # can block forever. That's because we keep reading results until we get a
  # type-5 packet, which might never come. We need to support the time-limit
  # in the protocol.
  # ++
  #
  # source://net-ldap//lib/net/ldap/connection.rb#321
  def search(args = T.unsafe(nil)); end

  # --
  # Helper method called only from prepare_socket or open_connection, and only
  # after we have a successfully-opened @conn instance variable, which is a TCP
  # connection.  Depending on the received arguments, we establish SSL,
  # potentially replacing the value of @conn accordingly. Don't generate any
  # errors here if no encryption is requested. DO raise Net::LDAP::Error objects
  # if encryption is requested and we have trouble setting it up. That includes
  # if OpenSSL is not set up on the machine. (Question: how does the Ruby
  # OpenSSL wrapper react in that case?) DO NOT filter exceptions raised by the
  # OpenSSL library. Let them pass back to the user. That should make it easier
  # for us to debug the problem reports. Presumably (hopefully?) that will also
  # produce recognizable errors if someone tries to use this on a machine
  # without OpenSSL.
  #
  # The simple_tls method is intended as the simplest, stupidest, easiest
  # solution for people who want nothing more than encrypted comms with the
  # LDAP server. It doesn't do any server-cert validation and requires
  # nothing in the way of key files and root-cert files, etc etc. OBSERVE:
  # WE REPLACE the value of @conn, which is presumed to be a connected
  # TCPSocket object.
  #
  # The start_tls method is supported by many servers over the standard LDAP
  # port. It does not require an alternative port for encrypted
  # communications, as with simple_tls. Thanks for Kouhei Sutou for
  # generously contributing the :start_tls path.
  # ++
  #
  # source://net-ldap//lib/net/ldap/connection.rb#151
  def setup_encryption(args, timeout = T.unsafe(nil)); end

  # Internal: Returns a Socket like object used internally to communicate with
  # LDAP server.
  #
  # Typically a TCPSocket, but can be a OpenSSL::SSL::SSLSocket
  #
  # source://net-ldap//lib/net/ldap/connection.rb#693
  def socket; end

  # source://net-ldap//lib/net/ldap/connection.rb#29
  def socket_class=(socket_class); end

  private

  # Internal: Reads and parses data from the configured connection.
  #
  # - syntax: the BER syntax to use to parse the read data with
  #
  # Returns parsed Net::LDAP::PDU object.
  #
  # source://net-ldap//lib/net/ldap/connection.rb#232
  def read(syntax = T.unsafe(nil)); end

  # Internal: Write a BER formatted packet with the next message id to the
  # configured connection.
  #
  # - request: required BER formatted request
  # - controls: optional BER formatted controls
  #
  # Returns the return value from writing to the connection, which in some
  # cases is the Integer number of bytes written to the socket.
  #
  # source://net-ldap//lib/net/ldap/connection.rb#262
  def write(request, controls = T.unsafe(nil), message_id = T.unsafe(nil)); end

  class << self
    # source://net-ldap//lib/net/ldap/connection.rb#533
    def modify_ops(operations); end

    # @raise [Net::LDAP::NoOpenSSLError]
    #
    # source://net-ldap//lib/net/ldap/connection.rb#89
    def wrap_with_ssl(io, tls_options = T.unsafe(nil), timeout = T.unsafe(nil)); end
  end
end

# Seconds before failing for socket connect timeout
#
# source://net-ldap//lib/net/ldap/connection.rb#7
Net::LDAP::Connection::DefaultConnectTimeout = T.let(T.unsafe(nil), Integer)

# Wrap around Socket.tcp to normalize with other Socket initializers
#
# source://net-ldap//lib/net/ldap/connection.rb#712
class Net::LDAP::Connection::DefaultSocket
  class << self
    # source://net-ldap//lib/net/ldap/connection.rb#713
    def new(host, port, socket_opts = T.unsafe(nil)); end
  end
end

# source://net-ldap//lib/net/ldap/connection.rb#82
module Net::LDAP::Connection::FixSSLSocketSyncClose
  # source://net-ldap//lib/net/ldap/connection.rb#83
  def close; end
end

# source://net-ldap//lib/net/ldap/connection.rb#75
module Net::LDAP::Connection::GetbyteForSSLSocket
  # source://net-ldap//lib/net/ldap/connection.rb#76
  def getbyte; end
end

# source://net-ldap//lib/net/ldap/connection.rb#9
Net::LDAP::Connection::LdapVersion = T.let(T.unsafe(nil), Integer)

# source://net-ldap//lib/net/ldap/connection.rb#527
Net::LDAP::Connection::MODIFY_OPERATIONS = T.let(T.unsafe(nil), Hash)

# source://net-ldap//lib/net/ldap/error.rb#6
class Net::LDAP::ConnectionError < ::Net::LDAP::Error
  # @return [ConnectionError] a new instance of ConnectionError
  #
  # source://net-ldap//lib/net/ldap/error.rb#18
  def initialize(errors); end

  class << self
    # source://net-ldap//lib/net/ldap/error.rb#7
    def new(errors); end
  end
end

# An LDAP Dataset. Used primarily as an intermediate format for converting
# to and from LDIF strings and Net::LDAP::Entry objects.
#
# source://net-ldap//lib/net/ldap/dataset.rb#5
class Net::LDAP::Dataset < ::Hash
  # @return [Dataset] a new instance of Dataset
  #
  # source://net-ldap//lib/net/ldap/dataset.rb#11
  def initialize(*args, &block); end

  # Returns the value of attribute comments.
  #
  # source://net-ldap//lib/net/ldap/dataset.rb#9
  def comments; end

  # Convert the parsed LDIF objects to Net::LDAP::Entry objects.
  #
  # source://net-ldap//lib/net/ldap/dataset.rb#59
  def to_entries; end

  # Outputs an LDAP Dataset as an array of strings representing LDIF
  # entries.
  #
  # source://net-ldap//lib/net/ldap/dataset.rb#20
  def to_ldif; end

  # Outputs an LDAP Dataset as an LDIF string.
  #
  # source://net-ldap//lib/net/ldap/dataset.rb#53
  def to_ldif_string; end

  # Dataset object version, comments.
  #
  # source://net-ldap//lib/net/ldap/dataset.rb#8
  def version; end

  # Dataset object version, comments.
  #
  # source://net-ldap//lib/net/ldap/dataset.rb#8
  def version=(_arg0); end

  private

  # This is an internal convenience method to determine if a value requires
  # base64-encoding before conversion to LDIF output. The standard approach
  # in most LDAP tools is to check whether the value is a password, or if
  # the first or last bytes are non-printable. Microsoft Active Directory,
  # on the other hand, sometimes sends values that are binary in the middle.
  #
  # In the worst cases, this could be a nasty performance killer, which is
  # why we handle the simplest cases first. Ideally, we would also test the
  # first/last byte, but it's a bit harder to do this in a way that's
  # compatible with both 1.8.6 and 1.8.7.
  #
  # @return [Boolean]
  #
  # source://net-ldap//lib/net/ldap/dataset.rb#82
  def value_is_binary?(value); end

  class << self
    # Creates a Dataset object from an Entry object. Used mostly to assist
    # with the conversion of
    #
    # source://net-ldap//lib/net/ldap/dataset.rb#104
    def from_entry(entry); end

    # Reads an object that returns data line-wise (using #gets) and parses
    # LDIF data into a Dataset object.
    #
    # source://net-ldap//lib/net/ldap/dataset.rb#118
    def read_ldif(io); end
  end
end

# source://net-ldap//lib/net/ldap.rb#338
Net::LDAP::DefaultAuth = T.let(T.unsafe(nil), Hash)

# source://net-ldap//lib/net/ldap.rb#340
Net::LDAP::DefaultForceNoPage = T.let(T.unsafe(nil), FalseClass)

# source://net-ldap//lib/net/ldap.rb#336
Net::LDAP::DefaultHost = T.let(T.unsafe(nil), String)

# source://net-ldap//lib/net/ldap.rb#337
Net::LDAP::DefaultPort = T.let(T.unsafe(nil), Integer)

# source://net-ldap//lib/net/ldap.rb#339
Net::LDAP::DefaultTreebase = T.let(T.unsafe(nil), String)

# source://net-ldap//lib/net/ldap.rb#274
Net::LDAP::DerefAliasesArray = T.let(T.unsafe(nil), Array)

# source://net-ldap//lib/net/ldap.rb#273
Net::LDAP::DerefAliases_Always = T.let(T.unsafe(nil), Integer)

# source://net-ldap//lib/net/ldap.rb#272
Net::LDAP::DerefAliases_Find = T.let(T.unsafe(nil), Integer)

# source://net-ldap//lib/net/ldap.rb#270
Net::LDAP::DerefAliases_Never = T.let(T.unsafe(nil), Integer)

# source://net-ldap//lib/net/ldap.rb#271
Net::LDAP::DerefAliases_Search = T.let(T.unsafe(nil), Integer)

# source://net-ldap//lib/net/ldap/error.rb#37
class Net::LDAP::EmptyDNError < ::Net::LDAP::Error; end

# source://net-ldap//lib/net/ldap/error.rb#28
class Net::LDAP::EncMethodUnsupportedError < ::Net::LDAP::Error; end

# source://net-ldap//lib/net/ldap/error.rb#27
class Net::LDAP::EncryptionUnsupportedError < ::Net::LDAP::Error; end

# Objects of this class represent individual entries in an LDAP directory.
# User code generally does not instantiate this class. Net::LDAP#search
# provides objects of this class to user code, either as block parameters or
# as return values.
#
# In LDAP-land, an "entry" is a collection of attributes that are uniquely
# and globally identified by a DN ("Distinguished Name"). Attributes are
# identified by short, descriptive words or phrases. Although a directory is
# free to implement any attribute name, most of them follow rigorous
# standards so that the range of commonly-encountered attribute names is not
# large.
#
# An attribute name is case-insensitive. Most directories also restrict the
# range of characters allowed in attribute names. To simplify handling
# attribute names, Net::LDAP::Entry internally converts them to a standard
# format. Therefore, the methods which take attribute names can take Strings
# or Symbols, and work correctly regardless of case or capitalization.
#
# An attribute consists of zero or more data items called <i>values.</i> An
# entry is the combination of a unique DN, a set of attribute names, and a
# (possibly-empty) array of values for each attribute.
#
# Class Net::LDAP::Entry provides convenience methods for dealing with LDAP
# entries. In addition to the methods documented below, you may access
# individual attributes of an entry simply by giving the attribute name as
# the name of a method call. For example:
#
#   ldap.search( ... ) do |entry|
#     puts "Common name: #{entry.cn}"
#     puts "Email addresses:"
#     entry.mail.each {|ma| puts ma}
#   end
#
# If you use this technique to access an attribute that is not present in a
# particular Entry object, a NoMethodError exception will be raised.
#
# --
# Ugly problem to fix someday: We key off the internal hash with a canonical
# form of the attribute name: convert to a string, downcase, then take the
# symbol. Unfortunately we do this in at least three places. Should do it in
# ONE place.
#
# source://net-ldap//lib/net/ldap/entry.rb#44
class Net::LDAP::Entry
  # This constructor is not generally called by user code.
  #
  # @return [Entry] a new instance of Entry
  #
  # source://net-ldap//lib/net/ldap/entry.rb#47
  def initialize(dn = T.unsafe(nil)); end

  # source://net-ldap//lib/net/ldap/entry.rb#198
  def ==(other); end

  # Reads the array of values for the provided attribute. The attribute name
  # is canonicalized prior to reading. Returns an empty array if the
  # attribute does not exist.
  #
  # source://net-ldap//lib/net/ldap/entry.rb#111
  def [](name); end

  # Sets or replaces the array of values for the provided attribute. The
  # attribute name is canonicalized prior to assignment.
  #
  # When an attribute is set using this, that attribute is now made
  # accessible through methods as well.
  #
  #   entry = Net::LDAP::Entry.new("dc=com")
  #   entry.foo             # => NoMethodError
  #   entry["foo"] = 12345  # => [12345]
  #   entry.foo             # => [12345]
  #
  # source://net-ldap//lib/net/ldap/entry.rb#103
  def []=(name, value); end

  # Use the LDIF format for Marshal serialization.
  #
  # source://net-ldap//lib/net/ldap/entry.rb#54
  def _dump(depth); end

  # Returns an array of the attribute names present in the Entry.
  #
  # source://net-ldap//lib/net/ldap/entry.rb#132
  def attribute_names; end

  # Returns the first distinguished name (dn) of the Entry as a \String.
  #
  # source://net-ldap//lib/net/ldap/entry.rb#126
  def dn; end

  # Accesses each of the attributes present in the Entry.
  #
  # Calls a user-supplied block with each attribute in turn, passing two
  # arguments to the block: a Symbol giving the name of the attribute, and a
  # (possibly empty) \Array of data values.
  #
  # source://net-ldap//lib/net/ldap/entry.rb#149
  def each; end

  # Accesses each of the attributes present in the Entry.
  #
  # Calls a user-supplied block with each attribute in turn, passing two
  # arguments to the block: a Symbol giving the name of the attribute, and a
  # (possibly empty) \Array of data values.
  #
  # source://net-ldap//lib/net/ldap/entry.rb#149
  def each_attribute; end

  # Read the first value for the provided attribute. The attribute name
  # is canonicalized prior to reading. Returns nil if the attribute does
  # not exist.
  #
  # source://net-ldap//lib/net/ldap/entry.rb#120
  def first(name); end

  # source://net-ldap//lib/net/ldap/entry.rb#169
  def method_missing(sym, *args, &block); end

  # @return [Boolean]
  #
  # source://net-ldap//lib/net/ldap/entry.rb#164
  def respond_to?(sym, include_all = T.unsafe(nil)); end

  # Creates a duplicate of the internal Hash containing the attributes
  # of the entry.
  #
  # source://net-ldap//lib/net/ldap/entry.rb#139
  def to_h; end

  # Converts the Entry to an LDIF-formatted String
  #
  # source://net-ldap//lib/net/ldap/entry.rb#160
  def to_ldif; end

  private

  # Returns true if the symbol ends with an equal sign.
  #
  # @return [Boolean]
  #
  # source://net-ldap//lib/net/ldap/entry.rb#193
  def setter?(sym); end

  # Given a valid attribute symbol, returns true.
  #
  # @return [Boolean]
  #
  # source://net-ldap//lib/net/ldap/entry.rb#187
  def valid_attribute?(attr_name); end

  class << self
    # Use the LDIF format for Marshal serialization.
    #
    # source://net-ldap//lib/net/ldap/entry.rb#60
    def _load(entry); end

    # Canonicalizes an LDAP attribute name as a \Symbol. The name is
    # lowercased and, if present, a trailing equals sign is removed.
    #
    # source://net-ldap//lib/net/ldap/entry.rb#85
    def attribute_name(name); end

    # Converts a single LDIF entry string into an Entry object. Useful for
    # Marshal serialization. If a string with multiple LDIF entries is
    # provided, an exception will be raised.
    #
    # @raise [Net::LDAP::EntryOverflowError]
    #
    # source://net-ldap//lib/net/ldap/entry.rb#69
    def from_single_ldif_string(ldif); end
  end
end

# source://net-ldap//lib/net/ldap/error.rb#48
class Net::LDAP::EntryOverflowError < ::Net::LDAP::Error; end

# source://net-ldap//lib/net/ldap/error.rb#2
class Net::LDAP::Error < ::StandardError; end

# Class Net::LDAP::Filter is used to constrain LDAP searches. An object of
# this class is passed to Net::LDAP#search in the parameter :filter.
#
# Net::LDAP::Filter supports the complete set of search filters available in
# LDAP, including conjunction, disjunction and negation (AND, OR, and NOT).
# This class supplants the (infamous) RFC 2254 standard notation for
# specifying LDAP search filters.
# --
# NOTE: This wording needs to change as we will be supporting LDAPv3 search
# filter strings (RFC 4515).
# ++
#
# Here's how to code the familiar "objectclass is present" filter:
#  f = Net::LDAP::Filter.present("objectclass")
#
# The object returned by this code can be passed directly to the
# <tt>:filter</tt> parameter of Net::LDAP#search.
#
# See the individual class and instance methods below for more examples.
#
# source://net-ldap//lib/net/ldap/filter.rb#23
class Net::LDAP::Filter
  # @return [Filter] a new instance of Filter
  #
  # source://net-ldap//lib/net/ldap/filter.rb#28
  def initialize(op, left, right); end

  # Joins two or more filters so that all conditions must be true.
  #
  #   # Selects only entries that have an <tt>objectclass</tt> attribute.
  #   x = Net::LDAP::Filter.present("objectclass")
  #   # Selects only entries that have a <tt>mail</tt> attribute that begins
  #   # with "George".
  #   y = Net::LDAP::Filter.eq("mail", "George*")
  #   # Selects only entries that meet both conditions above.
  #   z = x & y
  #
  # source://net-ldap//lib/net/ldap/filter.rb#375
  def &(filter); end

  # Equality operator for filters, useful primarily for constructing unit tests.
  #
  # source://net-ldap//lib/net/ldap/filter.rb#406
  def ==(filter); end

  # This is a private helper method for dealing with chains of ANDs and ORs
  # that are longer than two. If BOTH of our branches are of the specified
  # type of joining operator, then return both of them as an array (calling
  # coalesce recursively). If they're not, then return an array consisting
  # only of self.
  #
  # source://net-ldap//lib/net/ldap/filter.rb#619
  def coalesce(operator); end

  # Perform filter operations against a user-supplied block. This is useful
  # when implementing an LDAP directory server. The caller's block will be
  # called with two arguments: first, a symbol denoting the "operation" of
  # the filter; and second, an array consisting of arguments to the
  # operation. The user-supplied block (which is MANDATORY) should perform
  # some desired application-defined processing, and may return a
  # locally-meaningful object that will appear as a parameter in the :and,
  # :or and :not operations detailed below.
  #
  # A typical object to return from the user-supplied block is an array of
  # Net::LDAP::Filter objects.
  #
  # These are the possible values that may be passed to the user-supplied
  # block:
  #   * :equalityMatch (the arguments will be an attribute name and a value
  #     to be matched);
  #   * :substrings (two arguments: an attribute name and a value containing
  #     one or more "*" characters);
  #   * :present (one argument: an attribute name);
  #   * :greaterOrEqual (two arguments: an attribute name and a value to be
  #     compared against);
  #   * :lessOrEqual (two arguments: an attribute name and a value to be
  #     compared against);
  #   * :and (two or more arguments, each of which is an object returned
  #     from a recursive call to #execute, with the same block;
  #   * :or (two or more arguments, each of which is an object returned from
  #     a recursive call to #execute, with the same block; and
  #   * :not (one argument, which is an object returned from a recursive
  #     call to #execute with the the same block.
  #
  # source://net-ldap//lib/net/ldap/filter.rb#592
  def execute(&block); end

  # --
  # We got a hash of attribute values.
  # Do we match the attributes?
  # Return T/F, and call match recursively as necessary.
  # ++
  #
  # source://net-ldap//lib/net/ldap/filter.rb#633
  def match(entry); end

  # Converts the filter to BER format.
  # --
  # Filter ::=
  #     CHOICE {
  #         and             [0] SET OF Filter,
  #         or              [1] SET OF Filter,
  #         not             [2] Filter,
  #         equalityMatch   [3] AttributeValueAssertion,
  #         substrings      [4] SubstringFilter,
  #         greaterOrEqual  [5] AttributeValueAssertion,
  #         lessOrEqual     [6] AttributeValueAssertion,
  #         present         [7] AttributeType,
  #         approxMatch     [8] AttributeValueAssertion,
  #         extensibleMatch [9] MatchingRuleAssertion
  #     }
  #
  # SubstringFilter ::=
  #     SEQUENCE {
  #         type               AttributeType,
  #         SEQUENCE OF CHOICE {
  #             initial        [0] LDAPString,
  #             any            [1] LDAPString,
  #             final          [2] LDAPString
  #         }
  #     }
  #
  # MatchingRuleAssertion ::=
  #     SEQUENCE {
  #       matchingRule    [1] MatchingRuleId OPTIONAL,
  #       type            [2] AttributeDescription OPTIONAL,
  #       matchValue      [3] AssertionValue,
  #       dnAttributes    [4] BOOLEAN DEFAULT FALSE
  #     }
  #
  # Matching Rule Suffixes
  #     Less than   [.1] or .[lt]
  #     Less than or equal to  [.2] or [.lte]
  #     Equality  [.3] or  [.eq] (default)
  #     Greater than or equal to  [.4] or [.gte]
  #     Greater than  [.5] or [.gt]
  #     Substring  [.6] or  [.sub]
  #
  # ++
  #
  # source://net-ldap//lib/net/ldap/filter.rb#488
  def to_ber; end

  # source://net-ldap//lib/net/ldap/filter.rb#413
  def to_raw_rfc2254; end

  # Converts the Filter object to an RFC 2254-compatible text format.
  #
  # source://net-ldap//lib/net/ldap/filter.rb#436
  def to_rfc2254; end

  # source://net-ldap//lib/net/ldap/filter.rb#440
  def to_s; end

  # Creates a disjoint comparison between two or more filters. Selects
  # entries where either the left or right side are true.
  #
  #   # Selects only entries that have an <tt>objectclass</tt> attribute.
  #   x = Net::LDAP::Filter.present("objectclass")
  #   # Selects only entries that have a <tt>mail</tt> attribute that begins
  #   # with "George".
  #   y = Net::LDAP::Filter.eq("mail", "George*")
  #   # Selects only entries that meet either condition above.
  #   z = x | y
  #
  # source://net-ldap//lib/net/ldap/filter.rb#390
  def |(filter); end

  # source://net-ldap//lib/net/ldap/filter.rb#400
  def ~; end

  private

  # Converts escaped characters (e.g., "\\28") to unescaped characters
  # The binary form of 5936AE79-664F-44EA-BCCB-5C39399514C6 triggers a BINARY -> UTF-8 conversion error
  #
  # @note slawson20170317: Don't attempt to unescape 16 byte binary data which we assume are objectGUIDs
  #
  # source://net-ldap//lib/net/ldap/filter.rb#650
  def unescape(right); end

  class << self
    # Creates a Filter object indicating that the value of a particular
    # attribute must begin with a particular string. The attribute value is
    # escaped, so the "*" character is interpreted literally.
    #
    # source://net-ldap//lib/net/ldap/filter.rb#156
    def begins(attribute, value); end

    # Creates a Filter object indicating a binary comparison.
    # this prevents the search data from being forced into a UTF-8 string.
    #
    # This is primarily used for Microsoft Active Directory to compare
    # GUID values.
    #
    #    # for guid represented as hex charecters
    #    guid = "6a31b4a12aa27a41aca9603f27dd5116"
    #    guid_bin = [guid].pack("H*")
    #    f = Net::LDAP::Filter.bineq("objectGUID", guid_bin)
    #
    # This filter does not perform any escaping.
    #
    # source://net-ldap//lib/net/ldap/filter.rb#81
    def bineq(attribute, value); end

    # Converts an LDAP filter-string (in the prefix syntax specified in RFC-2254)
    # to a Net::LDAP::Filter.
    #
    # source://net-ldap//lib/net/ldap/filter.rb#340
    def construct(ldap_filter_string); end

    # Creates a Filter object indicating that the value of a particular
    # attribute must contain a particular string. The attribute value is
    # escaped, so the "*" character is interpreted literally.
    #
    # source://net-ldap//lib/net/ldap/filter.rb#172
    def contains(attribute, value); end

    # Creates a Filter object indicating that the value of a particular
    # attribute must end with a particular string. The attribute value is
    # escaped, so the "*" character is interpreted literally.
    #
    # source://net-ldap//lib/net/ldap/filter.rb#164
    def ends(attribute, value); end

    # Creates a Filter object indicating that the value of a particular
    # attribute must either be present or match a particular string.
    #
    # Specifying that an attribute is 'present' means only directory entries
    # which contain a value for the particular attribute will be selected by
    # the filter. This is useful in case of optional attributes such as
    # <tt>mail.</tt> Presence is indicated by giving the value "*" in the
    # second parameter to #eq. This example selects only entries that have
    # one or more values for <tt>sAMAccountName:</tt>
    #
    #   f = Net::LDAP::Filter.eq("sAMAccountName", "*")
    #
    # To match a particular range of values, pass a string as the second
    # parameter to #eq. The string may contain one or more "*" characters as
    # wildcards: these match zero or more occurrences of any character. Full
    # regular-expressions are <i>not</i> supported due to limitations in the
    # underlying LDAP protocol. This example selects any entry with a
    # <tt>mail</tt> value containing the substring "anderson":
    #
    #   f = Net::LDAP::Filter.eq("mail", "*anderson*")
    #
    # This filter does not perform any escaping
    #
    # source://net-ldap//lib/net/ldap/filter.rb#64
    def eq(attribute, value); end

    # Creates a Filter object indicating that the value of a particular
    # attribute must match a particular string. The attribute value is
    # escaped, so the "*" character is interpreted literally.
    #
    # source://net-ldap//lib/net/ldap/filter.rb#148
    def equals(attribute, value); end

    # Escape a string for use in an LDAP filter
    #
    # source://net-ldap//lib/net/ldap/filter.rb#262
    def escape(string); end

    # Creates a Filter object indicating extensible comparison. This Filter
    # object is currently considered EXPERIMENTAL.
    #
    #   sample_attributes = ['cn:fr', 'cn:fr.eq',
    #     'cn:1.3.6.1.4.1.42.2.27.9.4.49.1.3', 'cn:dn:fr', 'cn:dn:fr.eq']
    #   attr = sample_attributes.first # Pick an extensible attribute
    #   value = 'roberts'
    #
    #   filter = "#{attr}:=#{value}" # Basic String Filter
    #   filter = Net::LDAP::Filter.ex(attr, value) # Net::LDAP::Filter
    #
    #   # Perform a search with the Extensible Match Filter
    #   Net::LDAP.search(:filter => filter)
    # --
    # The LDIF required to support the above examples on the OpenDS LDAP
    # server:
    #
    #   version: 1
    #
    #   dn: dc=example,dc=com
    #   objectClass: domain
    #   objectClass: top
    #   dc: example
    #
    #   dn: ou=People,dc=example,dc=com
    #   objectClass: organizationalUnit
    #   objectClass: top
    #   ou: People
    #
    #   dn: uid=1,ou=People,dc=example,dc=com
    #   objectClass: person
    #   objectClass: organizationalPerson
    #   objectClass: inetOrgPerson
    #   objectClass: top
    #   cn:: csO0YsOpcnRz
    #   sn:: YsO0YiByw7Riw6lydHM=
    #   givenName:: YsO0Yg==
    #   uid: 1
    #
    # =Refs:
    # * http://www.ietf.org/rfc/rfc2251.txt
    # * http://www.novell.com/documentation/edir88/edir88/?page=/documentation/edir88/edir88/data/agazepd.html
    # * https://docs.opends.org/2.0/page/SearchingUsingInternationalCollationRules
    # ++
    #
    # source://net-ldap//lib/net/ldap/filter.rb#130
    def ex(attribute, value); end

    # Converts an LDAP filter-string (in the prefix syntax specified in RFC-2254)
    # to a Net::LDAP::Filter.
    #
    # source://net-ldap//lib/net/ldap/filter.rb#340
    def from_rfc2254(ldap_filter_string); end

    # Converts an LDAP filter-string (in the prefix syntax specified in RFC-2254)
    # to a Net::LDAP::Filter.
    #
    # source://net-ldap//lib/net/ldap/filter.rb#340
    def from_rfc4515(ldap_filter_string); end

    # Creates a Filter object indicating that a particular attribute value
    # is greater than or equal to the specified value.
    #
    # source://net-ldap//lib/net/ldap/filter.rb#179
    def ge(attribute, value); end

    # Creates a disjoint comparison between two or more filters. Selects
    # entries where either the left or right side are true. Calling
    # <tt>Filter.intersect(left, right)</tt> is the same as <tt>left |
    # right</tt>.
    #
    #   # Selects only entries that have an <tt>objectclass</tt> attribute.
    #   x = Net::LDAP::Filter.present("objectclass")
    #   # Selects only entries that have a <tt>mail</tt> attribute that begins
    #   # with "George".
    #   y = Net::LDAP::Filter.eq("mail", "George*")
    #   # Selects only entries that meet either condition above.
    #   z = x | y
    #
    # source://net-ldap//lib/net/ldap/filter.rb#219
    def intersect(left, right); end

    # Joins two or more filters so that all conditions must be true. Calling
    # <tt>Filter.join(left, right)</tt> is the same as <tt>left &
    # right</tt>.
    #
    #   # Selects only entries that have an <tt>objectclass</tt> attribute.
    #   x = Net::LDAP::Filter.present("objectclass")
    #   # Selects only entries that have a <tt>mail</tt> attribute that begins
    #   # with "George".
    #   y = Net::LDAP::Filter.eq("mail", "George*")
    #   # Selects only entries that meet both conditions above.
    #   z = Net::LDAP::Filter.join(x, y)
    #
    # source://net-ldap//lib/net/ldap/filter.rb#202
    def join(left, right); end

    # Creates a Filter object indicating that a particular attribute value
    # is less than or equal to the specified value.
    #
    # source://net-ldap//lib/net/ldap/filter.rb#186
    def le(attribute, value); end

    # Creates a Filter object indicating that a particular attribute value
    # is either not present or does not match a particular string; see
    # Filter::eq for more information.
    #
    # This filter does not perform any escaping
    #
    # source://net-ldap//lib/net/ldap/filter.rb#140
    def ne(attribute, value); end

    # Negates a filter. Calling <tt>Fitler.negate(filter)</tt> i s the same
    # as <tt>~filter</tt>.
    #
    #   # Selects only entries that do not have an <tt>objectclass</tt>
    #   # attribute.
    #   x = ~Net::LDAP::Filter.present("objectclass")
    #
    # source://net-ldap//lib/net/ldap/filter.rb#230
    def negate(filter); end

    # Converts an LDAP search filter in BER format to an Net::LDAP::Filter
    # object. The incoming BER object most likely came to us by parsing an
    # LDAP searchRequest PDU. See also the comments under #to_ber, including
    # the grammar snippet from the RFC.
    # --
    # We're hardcoding the BER constants from the RFC. These should be
    # broken out insto constants.
    #
    # source://net-ldap//lib/net/ldap/filter.rb#274
    def parse_ber(ber); end

    # Convert an RFC-1777 LDAP/BER "Filter" object to a Net::LDAP::Filter
    # object.
    # --
    # TODO, we're hardcoding the RFC-1777 BER-encodings of the various
    # filter types. Could pull them out into a constant.
    # ++
    #
    # source://net-ldap//lib/net/ldap/filter.rb#353
    def parse_ldap_filter(obj); end

    # This is a synonym for #eq(attribute, "*"). Also known as #present and
    # #pres.
    #
    # @return [Boolean]
    #
    # source://net-ldap//lib/net/ldap/filter.rb#237
    def pres(attribute); end

    # This is a synonym for #eq(attribute, "*"). Also known as #present and
    # #pres.
    #
    # @return [Boolean]
    #
    # source://net-ldap//lib/net/ldap/filter.rb#237
    def present(attribute); end

    # This is a synonym for #eq(attribute, "*"). Also known as #present and
    # #pres.
    #
    # @return [Boolean]
    #
    # source://net-ldap//lib/net/ldap/filter.rb#237
    def present?(attribute); end

    private

    def new(*_arg0); end
  end
end

# Parses RFC 2254-style string representations of LDAP filters into Filter
# object hierarchies.
#
# source://net-ldap//lib/net/ldap/filter.rb#663
class Net::LDAP::Filter::FilterParser
  # @raise [Net::LDAP::FilterSyntaxInvalidError]
  # @return [FilterParser] a new instance of FilterParser
  #
  # source://net-ldap//lib/net/ldap/filter.rb#678
  def initialize(str); end

  # The constructed filter.
  #
  # source://net-ldap//lib/net/ldap/filter.rb#666
  def filter; end

  private

  # Join ("&") and intersect ("|") operations are presented in branches.
  # That is, the expression <tt>(&(test1)(test2)</tt> has two branches:
  # test1 and test2. Each of these is parsed separately and then pushed
  # into a branch array for filter merging using the parent operation.
  #
  # This method calls #parse_branches to generate the branch list and then
  # merges them into a single Filter tree by calling the provided
  # operation.
  #
  # source://net-ldap//lib/net/ldap/filter.rb#719
  def merge_branches(op, scanner); end

  # Parse the string contained in the StringScanner provided. Parsing
  # tries to parse a standalone expression first. If that fails, it tries
  # to parse a parenthesized expression.
  #
  # source://net-ldap//lib/net/ldap/filter.rb#688
  def parse(scanner); end

  # Join ("&") and intersect ("|") operations are presented in branches.
  # That is, the expression <tt>(&(test1)(test2)</tt> has two branches:
  # test1 and test2. Each of these is parsed separately and then pushed
  # into a branch array for filter merging using the parent operation.
  #
  # This method parses the branch text out into an array of filter
  # objects.
  #
  # source://net-ldap//lib/net/ldap/filter.rb#701
  def parse_branches(scanner); end

  # This parses a given expression inside of parentheses.
  #
  # source://net-ldap//lib/net/ldap/filter.rb#756
  def parse_filter_branch(scanner); end

  # source://net-ldap//lib/net/ldap/filter.rb#734
  def parse_paren_expression(scanner); end

  class << self
    # Construct a filter tree from the provided string and return it.
    #
    # source://net-ldap//lib/net/ldap/filter.rb#673
    def parse(ldap_filter_string); end

    private

    def new(*_arg0); end
  end
end

# Known filter types.
#
# source://net-ldap//lib/net/ldap/filter.rb#26
Net::LDAP::Filter::FilterTypes = T.let(T.unsafe(nil), Array)

# source://net-ldap//lib/net/ldap/error.rb#47
class Net::LDAP::FilterSyntaxInvalidError < ::Net::LDAP::Error; end

# source://net-ldap//lib/net/ldap/error.rb#46
class Net::LDAP::FilterTypeUnknownError < ::Net::LDAP::Error; end

# source://net-ldap//lib/net/ldap.rb#10
Net::LDAP::HasOpenSSL = T.let(T.unsafe(nil), TrueClass)

# source://net-ldap//lib/net/ldap/error.rb#39
class Net::LDAP::HashTypeUnsupportedError < ::Net::LDAP::Error; end

# source://net-ldap//lib/net/ldap/instrumentation.rb#1
module Net::LDAP::Instrumentation
  private

  # Internal: Instrument a block with the defined instrumentation service.
  #
  # Yields the event payload if a block is given.
  #
  # Skips instrumentation if no service is set.
  #
  # Returns the return value of the block.
  #
  # source://net-ldap//lib/net/ldap/instrumentation.rb#12
  def instrument(event, payload = T.unsafe(nil)); end

  # Returns the value of attribute instrumentation_service.
  #
  # source://net-ldap//lib/net/ldap/instrumentation.rb#2
  def instrumentation_service; end
end

# source://net-ldap//lib/net/ldap/error.rb#38
class Net::LDAP::InvalidDNError < ::Net::LDAP::Error; end

# source://net-ldap//lib/net/ldap.rb#444
module Net::LDAP::LDAPControls; end

# source://net-ldap//lib/net/ldap.rb#448
Net::LDAP::LDAPControls::DELETE_TREE = T.let(T.unsafe(nil), String)

# Microsoft evil from RFC 2696
#
# source://net-ldap//lib/net/ldap.rb#445
Net::LDAP::LDAPControls::PAGED_RESULTS = T.let(T.unsafe(nil), String)

# source://net-ldap//lib/net/ldap.rb#446
Net::LDAP::LDAPControls::SORT_REQUEST = T.let(T.unsafe(nil), String)

# source://net-ldap//lib/net/ldap.rb#447
Net::LDAP::LDAPControls::SORT_RESPONSE = T.let(T.unsafe(nil), String)

# source://net-ldap//lib/net/ldap/error.rb#31
class Net::LDAP::NoBindResultError < ::Net::LDAP::Error; end

# source://net-ldap//lib/net/ldap/error.rb#23
class Net::LDAP::NoOpenSSLError < ::Net::LDAP::Error; end

# source://net-ldap//lib/net/ldap/error.rb#25
class Net::LDAP::NoSearchBaseError < ::Net::LDAP::Error; end

# source://net-ldap//lib/net/ldap/error.rb#24
class Net::LDAP::NoStartTLSResultError < ::Net::LDAP::Error; end

# source://net-ldap//lib/net/ldap/error.rb#40
class Net::LDAP::OperatorError < ::Net::LDAP::Error; end

# Defines the Protocol Data Unit (PDU) for LDAP. An LDAP PDU always looks
# like a BER SEQUENCE with at least two elements: an INTEGER message ID
# number and an application-specific SEQUENCE. Some LDAPv3 packets also
# include an optional third element, a sequence of "controls" (see RFC 2251
# section 4.1.12 for more information).
#
# The application-specific tag in the sequence tells us what kind of packet
# it is, and each kind has its own format, defined in RFC-1777.
#
# Observe that many clients (such as ldapsearch) do not necessarily enforce
# the expected application tags on received protocol packets. This
# implementation does interpret the RFC strictly in this regard, and it
# remains to be seen whether there are servers out there that will not work
# well with our approach.
#
# Currently, we only support controls on SearchResult.
#
# http://tools.ietf.org/html/rfc4511#section-4.1.1
# http://tools.ietf.org/html/rfc4511#section-4.1.9
#
# source://net-ldap//lib/net/ldap/pdu.rb#24
class Net::LDAP::PDU
  # Messy. Does this functionality belong somewhere else?
  #
  # @return [PDU] a new instance of PDU
  #
  # source://net-ldap//lib/net/ldap/pdu.rb#85
  def initialize(ber_object); end

  # The application protocol format tag.
  #
  # source://net-ldap//lib/net/ldap/pdu.rb#71
  def app_tag; end

  # Returns the value of attribute bind_parameters.
  #
  # source://net-ldap//lib/net/ldap/pdu.rb#76
  def bind_parameters; end

  # source://net-ldap//lib/net/ldap/pdu.rb#140
  def error_message; end

  # Returns the value of attribute extended_response.
  #
  # source://net-ldap//lib/net/ldap/pdu.rb#77
  def extended_response; end

  # @return [Boolean]
  #
  # source://net-ldap//lib/net/ldap/pdu.rb#160
  def failure?; end

  # Returns RFC-2251 Controls if any.
  #
  # source://net-ldap//lib/net/ldap/pdu.rb#81
  def ldap_controls; end

  # The LDAP packet message ID.
  #
  # source://net-ldap//lib/net/ldap/pdu.rb#66
  def message_id; end

  # The LDAP packet message ID.
  #
  # source://net-ldap//lib/net/ldap/pdu.rb#66
  def msg_id; end

  # Returns a hash which (usually) defines the members :resultCode,
  # :errorMessage, and :matchedDN. These values come directly from an LDAP
  # response packet returned by the remote peer. Also see #result_code.
  #
  # source://net-ldap//lib/net/ldap/pdu.rb#136
  def result; end

  # This returns an LDAP result code taken from the PDU, but it will be nil
  # if there wasn't a result code. That can easily happen depending on the
  # type of packet.
  #
  # source://net-ldap//lib/net/ldap/pdu.rb#148
  def result_code(code = T.unsafe(nil)); end

  # Returns RFC-2251 Controls if any.
  #
  # source://net-ldap//lib/net/ldap/pdu.rb#81
  def result_controls; end

  # Return serverSaslCreds, which are only present in BindResponse packets.
  # --
  # Messy. Does this functionality belong somewhere else? We ought to
  # refactor the accessors of this class before they get any kludgier.
  #
  # source://net-ldap//lib/net/ldap/pdu.rb#169
  def result_server_sasl_creds; end

  # Returns the value of attribute search_entry.
  #
  # source://net-ldap//lib/net/ldap/pdu.rb#73
  def search_entry; end

  # Returns the value of attribute search_parameters.
  #
  # source://net-ldap//lib/net/ldap/pdu.rb#75
  def search_parameters; end

  # Returns the value of attribute search_referrals.
  #
  # source://net-ldap//lib/net/ldap/pdu.rb#74
  def search_referrals; end

  # source://net-ldap//lib/net/ldap/pdu.rb#152
  def status; end

  # @return [Boolean]
  #
  # source://net-ldap//lib/net/ldap/pdu.rb#156
  def success?; end

  private

  # (provisional, must document)
  #
  # source://net-ldap//lib/net/ldap/pdu.rb#289
  def parse_bind_request(sequence); end

  # A Bind Response may have an additional field, ID [7], serverSaslCreds,
  # per RFC 2251 pgh 4.2.3.
  #
  # source://net-ldap//lib/net/ldap/pdu.rb#210
  def parse_bind_response(sequence); end

  # Per RFC 2251, an LDAP "control" is a sequence of tuples, each consisting
  # of an OID, a boolean criticality flag defaulting FALSE, and an OPTIONAL
  # Octet String. If only two fields are given, the second one may be either
  # criticality or data, since criticality has a default value. Someday we
  # may want to come back here and add support for some of more-widely used
  # controls. RFC-2696 is a good example.
  #
  # source://net-ldap//lib/net/ldap/pdu.rb#266
  def parse_controls(sequence); end

  # Parse an extended response
  #
  # http://www.ietf.org/rfc/rfc2251.txt
  #
  # Each Extended operation consists of an Extended request and an
  # Extended response.
  #
  #      ExtendedRequest ::= [APPLICATION 23] SEQUENCE {
  #           requestName      [0] LDAPOID,
  #           requestValue     [1] OCTET STRING OPTIONAL }
  #
  # source://net-ldap//lib/net/ldap/pdu.rb#196
  def parse_extended_response(sequence); end

  # source://net-ldap//lib/net/ldap/pdu.rb#173
  def parse_ldap_result(sequence); end

  # (provisional, must document)
  #
  # source://net-ldap//lib/net/ldap/pdu.rb#280
  def parse_ldap_search_request(sequence); end

  # A search referral is a sequence of one or more LDAP URIs. Any number of
  # search-referral replies can be returned by the server, interspersed with
  # normal replies in any order.
  # --
  # Until I can think of a better way to do this, we'll return the referrals
  # as an array. It'll be up to higher-level handlers to expose something
  # reasonable to the client.
  #
  # source://net-ldap//lib/net/ldap/pdu.rb#254
  def parse_search_referral(uris); end

  # Definition from RFC 1777 (we're handling application-4 here).
  #
  # Search Response ::=
  #   CHOICE {
  #     entry      [APPLICATION 4] SEQUENCE {
  #                  objectName     LDAPDN,
  #                  attributes     SEQUENCE OF SEQUENCE {
  #                    AttributeType,
  #                    SET OF AttributeValue
  #                  }
  #                },
  #     resultCode [APPLICATION 5] LDAPResult
  #   }
  #
  # We concoct a search response that is a hash of the returned attribute
  # values.
  #
  # NOW OBSERVE CAREFULLY: WE ARE DOWNCASING THE RETURNED ATTRIBUTE NAMES.
  #
  # This is to make them more predictable for user programs, but it may not
  # be a good idea. Maybe this should be configurable.
  #
  # source://net-ldap//lib/net/ldap/pdu.rb#239
  def parse_search_return(sequence); end

  # (provisional, must document)
  # UnbindRequest has no content so this is a no-op.
  #
  # source://net-ldap//lib/net/ldap/pdu.rb#298
  def parse_unbind_request(sequence); end
end

# http://tools.ietf.org/html/rfc4511#section-4.11
#
# source://net-ldap//lib/net/ldap/pdu.rb#55
Net::LDAP::PDU::AbandonRequest = T.let(T.unsafe(nil), Integer)

# http://tools.ietf.org/html/rfc4511#section-4.7
#
# source://net-ldap//lib/net/ldap/pdu.rb#43
Net::LDAP::PDU::AddRequest = T.let(T.unsafe(nil), Integer)

# source://net-ldap//lib/net/ldap/pdu.rb#44
Net::LDAP::PDU::AddResponse = T.let(T.unsafe(nil), Integer)

# http://tools.ietf.org/html/rfc4511#section-4.2
#
# source://net-ldap//lib/net/ldap/pdu.rb#28
Net::LDAP::PDU::BindRequest = T.let(T.unsafe(nil), Integer)

# http://tools.ietf.org/html/rfc4511#section-4.2.2
#
# source://net-ldap//lib/net/ldap/pdu.rb#30
Net::LDAP::PDU::BindResult = T.let(T.unsafe(nil), Integer)

# http://tools.ietf.org/html/rfc4511#section-4.10
#
# source://net-ldap//lib/net/ldap/pdu.rb#52
Net::LDAP::PDU::CompareRequest = T.let(T.unsafe(nil), Integer)

# source://net-ldap//lib/net/ldap/pdu.rb#53
Net::LDAP::PDU::CompareResponse = T.let(T.unsafe(nil), Integer)

# http://tools.ietf.org/html/rfc4511#section-4.8
#
# source://net-ldap//lib/net/ldap/pdu.rb#46
Net::LDAP::PDU::DeleteRequest = T.let(T.unsafe(nil), Integer)

# source://net-ldap//lib/net/ldap/pdu.rb#47
Net::LDAP::PDU::DeleteResponse = T.let(T.unsafe(nil), Integer)

# source://net-ldap//lib/net/ldap/pdu.rb#25
class Net::LDAP::PDU::Error < ::RuntimeError; end

# http://tools.ietf.org/html/rfc4511#section-4.12
#
# source://net-ldap//lib/net/ldap/pdu.rb#59
Net::LDAP::PDU::ExtendedRequest = T.let(T.unsafe(nil), Integer)

# source://net-ldap//lib/net/ldap/pdu.rb#60
Net::LDAP::PDU::ExtendedResponse = T.let(T.unsafe(nil), Integer)

# unused: http://tools.ietf.org/html/rfc4511#section-4.13
#
# source://net-ldap//lib/net/ldap/pdu.rb#62
Net::LDAP::PDU::IntermediateResponse = T.let(T.unsafe(nil), Integer)

# http://tools.ietf.org/html/rfc4511#section-4.9
#
# source://net-ldap//lib/net/ldap/pdu.rb#49
Net::LDAP::PDU::ModifyRDNRequest = T.let(T.unsafe(nil), Integer)

# source://net-ldap//lib/net/ldap/pdu.rb#50
Net::LDAP::PDU::ModifyRDNResponse = T.let(T.unsafe(nil), Integer)

# see also SearchResultReferral (19)
# http://tools.ietf.org/html/rfc4511#section-4.6
#
# source://net-ldap//lib/net/ldap/pdu.rb#40
Net::LDAP::PDU::ModifyRequest = T.let(T.unsafe(nil), Integer)

# source://net-ldap//lib/net/ldap/pdu.rb#41
Net::LDAP::PDU::ModifyResponse = T.let(T.unsafe(nil), Integer)

# http://tools.ietf.org/html/rfc4511#section-4.5.1
#
# source://net-ldap//lib/net/ldap/pdu.rb#34
Net::LDAP::PDU::SearchRequest = T.let(T.unsafe(nil), Integer)

# source://net-ldap//lib/net/ldap/pdu.rb#37
Net::LDAP::PDU::SearchResult = T.let(T.unsafe(nil), Integer)

# http://tools.ietf.org/html/rfc4511#section-4.5.2
#
# source://net-ldap//lib/net/ldap/pdu.rb#57
Net::LDAP::PDU::SearchResultReferral = T.let(T.unsafe(nil), Integer)

# http://tools.ietf.org/html/rfc4511#section-4.5.2
#
# source://net-ldap//lib/net/ldap/pdu.rb#36
Net::LDAP::PDU::SearchReturnedData = T.let(T.unsafe(nil), Integer)

# http://tools.ietf.org/html/rfc4511#section-4.3
#
# source://net-ldap//lib/net/ldap/pdu.rb#32
Net::LDAP::PDU::UnbindRequest = T.let(T.unsafe(nil), Integer)

# source://net-ldap//lib/net/ldap.rb#343
Net::LDAP::PasswdModifyOid = T.let(T.unsafe(nil), String)

# source://net-ldap//lib/net/ldap/password.rb#8
class Net::LDAP::Password
  class << self
    # Generate a password-hash suitable for inclusion in an LDAP attribute.
    # Pass a hash type as a symbol (:md5, :sha, :ssha) and a plaintext
    # password. This function will return a hashed representation.
    #
    # --
    # STUB: This is here to fulfill the requirements of an RFC, which
    # one?
    #
    # TODO:
    # * maybe salted-md5
    # * Should we provide sha1 as a synonym for sha1? I vote no because then
    #   should you also provide ssha1 for symmetry?
    #
    # source://net-ldap//lib/net/ldap/password.rb#23
    def generate(type, str); end
  end
end

# source://net-ldap//lib/net/ldap/error.rb#36
class Net::LDAP::ResponseMissingOrInvalidError < ::Net::LDAP::Error; end

# source://net-ldap//lib/net/ldap/error.rb#35
class Net::LDAP::ResponseTypeInvalidError < ::Net::LDAP::Error; end

# source://net-ldap//lib/net/ldap.rb#357
Net::LDAP::ResultCodeAdminLimitExceeded = T.let(T.unsafe(nil), Integer)

# source://net-ldap//lib/net/ldap.rb#383
Net::LDAP::ResultCodeAffectsMultipleDSAs = T.let(T.unsafe(nil), Integer)

# source://net-ldap//lib/net/ldap.rb#370
Net::LDAP::ResultCodeAliasDereferencingProblem = T.let(T.unsafe(nil), Integer)

# source://net-ldap//lib/net/ldap.rb#368
Net::LDAP::ResultCodeAliasProblem = T.let(T.unsafe(nil), Integer)

# source://net-ldap//lib/net/ldap.rb#365
Net::LDAP::ResultCodeAttributeOrValueExists = T.let(T.unsafe(nil), Integer)

# source://net-ldap//lib/net/ldap.rb#354
Net::LDAP::ResultCodeAuthMethodNotSupported = T.let(T.unsafe(nil), Integer)

# source://net-ldap//lib/net/ldap.rb#374
Net::LDAP::ResultCodeBusy = T.let(T.unsafe(nil), Integer)

# source://net-ldap//lib/net/ldap.rb#352
Net::LDAP::ResultCodeCompareFalse = T.let(T.unsafe(nil), Integer)

# source://net-ldap//lib/net/ldap.rb#353
Net::LDAP::ResultCodeCompareTrue = T.let(T.unsafe(nil), Integer)

# source://net-ldap//lib/net/ldap.rb#359
Net::LDAP::ResultCodeConfidentialityRequired = T.let(T.unsafe(nil), Integer)

# source://net-ldap//lib/net/ldap.rb#364
Net::LDAP::ResultCodeConstraintViolation = T.let(T.unsafe(nil), Integer)

# source://net-ldap//lib/net/ldap.rb#381
Net::LDAP::ResultCodeEntryAlreadyExists = T.let(T.unsafe(nil), Integer)

# source://net-ldap//lib/net/ldap.rb#371
Net::LDAP::ResultCodeInappropriateAuthentication = T.let(T.unsafe(nil), Integer)

# source://net-ldap//lib/net/ldap.rb#363
Net::LDAP::ResultCodeInappropriateMatching = T.let(T.unsafe(nil), Integer)

# source://net-ldap//lib/net/ldap.rb#373
Net::LDAP::ResultCodeInsufficientAccessRights = T.let(T.unsafe(nil), Integer)

# source://net-ldap//lib/net/ldap.rb#366
Net::LDAP::ResultCodeInvalidAttributeSyntax = T.let(T.unsafe(nil), Integer)

# source://net-ldap//lib/net/ldap.rb#372
Net::LDAP::ResultCodeInvalidCredentials = T.let(T.unsafe(nil), Integer)

# source://net-ldap//lib/net/ldap.rb#369
Net::LDAP::ResultCodeInvalidDNSyntax = T.let(T.unsafe(nil), Integer)

# source://net-ldap//lib/net/ldap.rb#377
Net::LDAP::ResultCodeNamingViolation = T.let(T.unsafe(nil), Integer)

# source://net-ldap//lib/net/ldap.rb#361
Net::LDAP::ResultCodeNoSuchAttribute = T.let(T.unsafe(nil), Integer)

# source://net-ldap//lib/net/ldap.rb#367
Net::LDAP::ResultCodeNoSuchObject = T.let(T.unsafe(nil), Integer)

# source://net-ldap//lib/net/ldap.rb#379
Net::LDAP::ResultCodeNotAllowedOnNonLeaf = T.let(T.unsafe(nil), Integer)

# source://net-ldap//lib/net/ldap.rb#380
Net::LDAP::ResultCodeNotAllowedOnRDN = T.let(T.unsafe(nil), Integer)

# source://net-ldap//lib/net/ldap.rb#382
Net::LDAP::ResultCodeObjectClassModsProhibited = T.let(T.unsafe(nil), Integer)

# source://net-ldap//lib/net/ldap.rb#378
Net::LDAP::ResultCodeObjectClassViolation = T.let(T.unsafe(nil), Integer)

# source://net-ldap//lib/net/ldap.rb#348
Net::LDAP::ResultCodeOperationsError = T.let(T.unsafe(nil), Integer)

# source://net-ldap//lib/net/ldap.rb#384
Net::LDAP::ResultCodeOther = T.let(T.unsafe(nil), Integer)

# source://net-ldap//lib/net/ldap.rb#349
Net::LDAP::ResultCodeProtocolError = T.let(T.unsafe(nil), Integer)

# source://net-ldap//lib/net/ldap.rb#356
Net::LDAP::ResultCodeReferral = T.let(T.unsafe(nil), Integer)

# source://net-ldap//lib/net/ldap.rb#360
Net::LDAP::ResultCodeSaslBindInProgress = T.let(T.unsafe(nil), Integer)

# source://net-ldap//lib/net/ldap.rb#351
Net::LDAP::ResultCodeSizeLimitExceeded = T.let(T.unsafe(nil), Integer)

# source://net-ldap//lib/net/ldap.rb#355
Net::LDAP::ResultCodeStrongerAuthRequired = T.let(T.unsafe(nil), Integer)

# https://tools.ietf.org/html/rfc4511#section-4.1.9
# https://tools.ietf.org/html/rfc4511#appendix-A
#
# source://net-ldap//lib/net/ldap.rb#347
Net::LDAP::ResultCodeSuccess = T.let(T.unsafe(nil), Integer)

# source://net-ldap//lib/net/ldap.rb#350
Net::LDAP::ResultCodeTimeLimitExceeded = T.let(T.unsafe(nil), Integer)

# source://net-ldap//lib/net/ldap.rb#375
Net::LDAP::ResultCodeUnavailable = T.let(T.unsafe(nil), Integer)

# source://net-ldap//lib/net/ldap.rb#358
Net::LDAP::ResultCodeUnavailableCriticalExtension = T.let(T.unsafe(nil), Integer)

# source://net-ldap//lib/net/ldap.rb#362
Net::LDAP::ResultCodeUndefinedAttributeType = T.let(T.unsafe(nil), Integer)

# source://net-ldap//lib/net/ldap.rb#376
Net::LDAP::ResultCodeUnwillingToPerform = T.let(T.unsafe(nil), Integer)

# https://tools.ietf.org/html/rfc4511#appendix-A.1
#
# source://net-ldap//lib/net/ldap.rb#387
Net::LDAP::ResultCodesNonError = T.let(T.unsafe(nil), Array)

# nonstandard list of "successful" result codes for searches
#
# source://net-ldap//lib/net/ldap.rb#396
Net::LDAP::ResultCodesSearchSuccess = T.let(T.unsafe(nil), Array)

# map of result code to human message
#
# source://net-ldap//lib/net/ldap.rb#403
Net::LDAP::ResultStrings = T.let(T.unsafe(nil), Hash)

# source://net-ldap//lib/net/ldap/error.rb#32
class Net::LDAP::SASLChallengeOverflowError < ::Net::LDAP::Error; end

# source://net-ldap//lib/net/ldap/error.rb#42
class Net::LDAP::SearchFilterError < ::Net::LDAP::Error; end

# source://net-ldap//lib/net/ldap/error.rb#44
class Net::LDAP::SearchFilterTypeUnknownError < ::Net::LDAP::Error; end

# source://net-ldap//lib/net/ldap/error.rb#34
class Net::LDAP::SearchScopeInvalidError < ::Net::LDAP::Error; end

# source://net-ldap//lib/net/ldap.rb#264
Net::LDAP::SearchScope_BaseObject = T.let(T.unsafe(nil), Integer)

# source://net-ldap//lib/net/ldap.rb#265
Net::LDAP::SearchScope_SingleLevel = T.let(T.unsafe(nil), Integer)

# source://net-ldap//lib/net/ldap.rb#266
Net::LDAP::SearchScope_WholeSubtree = T.let(T.unsafe(nil), Integer)

# source://net-ldap//lib/net/ldap.rb#267
Net::LDAP::SearchScopes = T.let(T.unsafe(nil), Array)

# source://net-ldap//lib/net/ldap/error.rb#33
class Net::LDAP::SearchSizeInvalidError < ::Net::LDAP::Error; end

# source://net-ldap//lib/net/ldap/error.rb#5
class Net::LDAP::SocketError < ::Net::LDAP::Error; end

# source://net-ldap//lib/net/ldap/error.rb#26
class Net::LDAP::StartTLSError < ::Net::LDAP::Error; end

# source://net-ldap//lib/net/ldap.rb#342
Net::LDAP::StartTlsOid = T.let(T.unsafe(nil), String)

# source://net-ldap//lib/net/ldap/error.rb#41
class Net::LDAP::SubstringFilterError < ::Net::LDAP::Error; end

# source://net-ldap//lib/net/ldap/version.rb#3
Net::LDAP::VERSION = T.let(T.unsafe(nil), String)

# source://net-ldap//lib/net/ber/core_ext.rb#13
class OpenSSL::SSL::SSLSocket
  include ::Prelude::Enumerator
  include ::Enumerable
  include ::OpenSSL::Buffering
  include ::OpenSSL::SSL::SocketForwarder
  include ::Net::BER::BERParser
end

# source://net-ldap//lib/net/ber/core_ext.rb#24
class String
  include ::Comparable
  include ::MessagePack::CoreExt
  include ::JSON::Ext::Generator::GeneratorMethods::String
  include ::Net::BER::BERParser
  include ::Net::BER::Extensions::String
  extend ::JSON::Ext::Generator::GeneratorMethods::String::Extend
end

# source://net-ldap//lib/net/ber/core_ext.rb#8
class StringIO
  include ::Prelude::Enumerator
  include ::Enumerable
  include ::Net::BER::BERParser
end

# source://net-ldap//lib/net/ber/core_ext.rb#45
class TrueClass
  include ::MessagePack::CoreExt
  include ::JSON::Ext::Generator::GeneratorMethods::TrueClass
  include ::Net::BER::Extensions::TrueClass
end
