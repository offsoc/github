{"version":3,"file":"app_assets_modules_github_editor_codemirror-linter-util_ts-app_assets_modules_github_editor_y-89a4a6-xxxxxxxxxxxx.js","mappings":"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","sources":["app/assets/modules/github/editor/codemirror-linter-util.ts","app/assets/modules/github/editor/jsyaml.ts","app/assets/modules/github/editor/yaml-editors/autocomplete-util.ts","app/assets/modules/github/editor/yaml-editors/utils.ts","app/assets/modules/github/editor/yaml-editors/yaml-linters.ts","app/assets/modules/github/editor/yaml-editors/yaml-rule-util.ts"],"sourcesContent":["// FIXME This bundle implicitly loads CodeMirror off of the window global. This should\n// explicitly import the dependency to ensure it exists on the page. We usually include\n// all editors in the same bundle as CodeMirror but this stack-template bundle is separate.\n// Maybe dynamic imports solve this.\n\nimport type {Editor, MarkerRange, TextMarker} from 'codemirror'\nimport {render} from 'lit-html'\nimport type {TemplateResult} from 'lit-html'\n\ndeclare const CodeMirror: {\n  Pos: (line: number, ch: number) => {line: number; ch: number}\n  on(...args: unknown[]): void\n  Pass: unknown\n}\n\nexport type CodeMirrorElement = Element & {\n  CodeMirror: Editor\n}\n\n// Generic type compatible with CodeMirror\ninterface Position {\n  line: number\n  ch: number\n}\n\nexport interface Validation {\n  message?: TemplateResult\n  severity: string\n  fixes?: string[]\n}\n\n// This is the structure required by our custom linter\nexport type LintMessage = Validation & {\n  from: Position\n  to: Position\n}\n\ntype Mark = TextMarker<MarkerRange> & {\n  keepTooltip?: () => void\n  destroyTooltip?: () => void\n  __message: LintMessage\n}\n\nexport interface TokenInfo {\n  from: Position\n  to: Position\n}\n\nexport interface PathInfo {\n  key: TokenInfo\n  value: TokenInfo\n}\n\nexport abstract class CodeMirrorLintingHelper {\n  lintMarks: Mark[] = []\n  lintTimeout: ReturnType<typeof setTimeout>\n\n  abstract updateLinting(cm: Editor): void\n\n  clearState() {\n    for (const mark of this.lintMarks) {\n      mark.clear()\n      if (mark.destroyTooltip) mark.destroyTooltip()\n    }\n    this.lintMarks.splice(0)\n  }\n\n  createMarks(cm: Editor, messages: LintMessage[]) {\n    for (const message of messages) {\n      const {from, to, severity} = message\n      const mark = cm.markText(from, to, {\n        className: `CodeMirror-lint-mark CodeMirror-lint-mark-${severity}`,\n        __message: message,\n      } as Mark) as unknown as Mark\n      this.lintMarks.push(mark)\n    }\n  }\n\n  showTooltip(cm: Editor, event: Event) {\n    const target = (event.target || event.srcElement)! as HTMLElement\n\n    if (!target.classList.contains('CodeMirror-lint-mark')) return\n\n    const box = target.getBoundingClientRect()\n    const left = (box.left + box.right) / 2\n    const top = (box.top + box.bottom) / 2\n    const mark = findMark(cm, left, top)\n    if (!mark) return\n\n    const {__message: message} = mark\n    if (!message) return\n\n    const tooltip = this.createTooltip(message, box.left, top)\n    const select = tooltip.querySelector<HTMLSelectElement>('select')!\n    const button = tooltip.querySelector<HTMLElement>('button')!\n\n    let timeout: ReturnType<typeof setTimeout> | null = null\n\n    const destroyTooltip = () => {\n      if (document.activeElement === select) return\n      timeout = setTimeout(() => {\n        delete mark.keepTooltip\n        delete mark.destroyTooltip\n        if (!tooltip.parentElement) return\n        // animate it\n        tooltip.style.opacity = '0'\n        setTimeout(() => tooltip.parentElement && tooltip.parentElement.removeChild(tooltip), 600)\n      }, 100)\n    }\n\n    const keepTooltip = () => clearTimeout(timeout!)\n\n    CodeMirror.on(tooltip, 'mouseout', destroyTooltip)\n    CodeMirror.on(target, 'mouseout', destroyTooltip)\n\n    CodeMirror.on(tooltip, 'mouseover', keepTooltip)\n    CodeMirror.on(target, 'mouseover', keepTooltip)\n\n    mark.keepTooltip = keepTooltip\n    mark.destroyTooltip = destroyTooltip\n\n    const replaceValue = (value: string) => {\n      const location = mark.find()!\n      cm.focus()\n      cm.setSelection(location.from, location.to)\n      cm.replaceSelection(value)\n      destroyTooltip()\n    }\n\n    button.addEventListener('click', () => replaceValue(button.textContent!))\n    select.addEventListener('change', () => replaceValue(select.value))\n    select.addEventListener('focusout', destroyTooltip)\n  }\n\n  createTooltip(lintMessage: LintMessage, left: number, top: number): HTMLElement {\n    const {message, fixes} = lintMessage\n    const tooltipTemplate = document.querySelector<HTMLTemplateElement>('#yaml-lint-template')!\n    const tooltip = document.importNode(tooltipTemplate.content, true).querySelector<HTMLElement>('.js-yaml-lint')!\n    const tooltipHeader = tooltip.querySelector<HTMLElement>('.js-yaml-lint-header')!\n    const tooltipTitle = tooltip.querySelector<HTMLElement>('.js-yaml-lint-title')!\n    const tooltipSubtitle = tooltip.querySelector<HTMLElement>('.js-yaml-lint-subtitle')!\n    const tooltipMessage = tooltip.querySelector<HTMLElement>('.js-yaml-lint-message')!\n    const tooltipFixes = tooltip.querySelector<HTMLElement>('.js-yaml-lint-fixes')!\n    const fixButton = tooltipSubtitle.querySelector<HTMLElement>('button')!\n\n    tooltipHeader.hidden = !fixes\n    tooltipMessage.hidden = !!fixes\n    tooltipSubtitle.hidden = !fixes\n    tooltipFixes.hidden = !fixes || fixes.length < 2\n\n    if (fixes) {\n      render(message, tooltipTitle)\n      const firstFix = fixes[0]!\n      fixButton.textContent = firstFix\n      const select = tooltipFixes.querySelector<HTMLElement>('select')!\n      for (const fix of fixes.slice(1)) {\n        const option = document.createElement('option')\n        option.textContent = fix\n        select.appendChild(option)\n      }\n    } else {\n      render(message, tooltipMessage)\n    }\n    document.body.appendChild(tooltip)\n\n    tooltip.classList.add('CodeMirror-lint-tooltip')\n    tooltip.style.opacity = '1'\n    tooltip.style.left = `${left}px`\n    tooltip.style.top = `${top - tooltip.clientHeight - 18}px`\n    return tooltip\n  }\n}\n\nfunction findMark(cm: Editor, left: number, top: number) {\n  const marks = cm.findMarksAt(cm.coordsChar({left, top}, 'window')) as unknown as Mark[]\n  if (marks.length === 0) return null\n  const mark = marks[0]!\n  if (mark.keepTooltip) {\n    mark.keepTooltip()\n    return null\n  }\n  return mark\n}\n\nexport function fileOffsetToLineAndColumn(doc: string, offset: number) {\n  const lines = doc.split('\\n')\n  let startLine = 0\n  let startColumn = 0\n  let lineOffset = 0\n  while (lineOffset + lines[startLine]!.length < offset) {\n    lineOffset += lines[startLine]!.length + 1\n    startLine++\n  }\n  startColumn = offset - lineOffset\n  return {startLine, startColumn}\n}\n","import jsyaml from 'js-yaml'\n\nexport const yaml = {\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  load: jsyaml.load as any,\n}\n","import {\n  type Rule,\n  type Rules,\n  type getYamlRootRuleSignature,\n  ruleForPath,\n  ruleValues,\n  type suggestionsForExpressionSignature,\n} from './yaml-rule-util'\nimport {findNode, getCurrentNode, getSimplifiedText, keysForPath, parse} from './utils'\n\nexport interface Suggestion {\n  displayText: string\n  snippet: Snippet\n  replace: string\n  description?: string\n}\n\nexport interface Snippet {\n  // odd elements will generate placeholders that the user can navigate pressing tabulator\n  // e.g ['format(', 'string', ', ', '...values', ')']\n  // In this case both \"string\" and \"...values\" will be placeholders\n  tokens: string[]\n  // Help information to show in the UI about each placeholder\n  help?: string[]\n  keepCursorLocation?: boolean\n}\n\nexport interface Context {\n  type?: string\n  keys?: {\n    [key: string]: Context | string\n  }\n  map?: Context\n  resolver?: (workflow: unknown, path: string[]) => Promise<string[]>\n}\n\n/*\n * Used to not suggest already used values\n */\nfunction usedValues(result: unknown, path: string[]): string[] {\n  const arr = findNode(result, path)\n  return Array.isArray(arr) ? arr.map(String) : []\n}\n\n/*\n * Used when filtering values.\n * Prevents infinite loop with editor.showHint() auto-completing the same thing already wrote\n */\nexport function startsWithAndNotEquals(prefix: string, text: string) {\n  return text.startsWith(prefix) && prefix !== text\n}\n\ninterface Text {\n  text: string\n}\n\nexport function filterValues<T extends string | Text>(\n  values: T[],\n  lastValue: string,\n  ignoredValues: string[] = [],\n): T[] {\n  const lowerCasedLastValue = lastValue.toLowerCase()\n  const lowerCasedIgnoredValues = ignoredValues.map(s => s.toLowerCase())\n  return values.filter(value => {\n    const valueLower = String((typeof value == 'object' && 'text' in value ? value.text : null) || value).toLowerCase()\n    return startsWithAndNotEquals(lowerCasedLastValue, valueLower) && !lowerCasedIgnoredValues.includes(valueLower)\n  })\n}\n\nexport type ContextSuggestion = Text & {\n  terminal: boolean\n}\n\nfunction autoCompleteAfterKey(rule: Rule): string {\n  if (rule.single || rule.values) return ' '\n  if (rule.rules && !rule.items && !rule.map) return '\\n\\t'\n  if (!rule.rules && rule.items && !rule.map) return '\\n\\t- '\n  return ''\n}\n\nexport async function suggestionsFromValuesWithoutExpression(\n  yaml: unknown,\n  path: string[],\n  rule: Rule,\n  lastValue: string,\n  ignoreItems: string[],\n  makeItAnArray: boolean,\n) {\n  let values\n  if (rule.single && rule.single.length === 1 && rule.single[0] === 'boolean') {\n    values = ['true', 'false']\n  } else if (rule.values) {\n    values = await ruleValues(rule, yaml, path)\n  } else return null\n\n  const filtered = filterValues(values, lastValue, ignoreItems)\n  if (filtered.length === 0) return null\n  return filtered.map(str => ({\n    displayText: str,\n    snippet: {tokens: [makeItAnArray ? `[${str}]` : str]},\n    replace: lastValue,\n  }))\n}\n\nexport function suggestionsFromRules(rules: Rules, lastValue: string, ignoreKeys: string[]): Suggestion[] {\n  return filterValues(Object.keys(rules), lastValue, ignoreKeys).map(key => {\n    const rule = rules[key]!\n    const after = autoCompleteAfterKey(rule)\n    return {\n      displayText: key,\n      snippet: {tokens: [`${key}:${after}`]},\n      replace: lastValue,\n      description: rule.description,\n    }\n  })\n}\n\nexport async function autocomplete(\n  fullText: string,\n  textBeforeCursor: string,\n  getRootRule: getYamlRootRuleSignature,\n  suggestionsForExpression: suggestionsForExpressionSignature,\n): Promise<Suggestion[] | null> {\n  try {\n    const {simplifiedText, lastLine} = getSimplifiedText(textBeforeCursor)\n    const {result, lastValue: lastParsedValue, consumeKey} = parse(simplifiedText, '')\n    const {path, lastValue: lastDataValue} = getCurrentNode(result)\n    const lastValue = lastParsedValue != null ? lastParsedValue : lastDataValue\n    if (consumeKey) path.pop()\n    const nested = lastLine.match(/^\\s*(-\\s*)?$/) !== null || lastLine.indexOf(':') === -1\n    const {result: workflow} = parse(textBeforeCursor, fullText.substring(textBeforeCursor.length))\n    const ignoreKeys = keysForPath(workflow, path)\n    const ignoreValues = usedValues(workflow, path)\n    return await getSuggestions(\n      getRootRule,\n      suggestionsForExpression,\n      workflow,\n      path,\n      lastValue,\n      [...ignoreKeys, ...ignoreValues],\n      nested,\n    )\n  } catch (err) {\n    return null\n  }\n}\n\nexport async function getSuggestions(\n  getRootRule: getYamlRootRuleSignature,\n  suggestionsForExpression: suggestionsForExpressionSignature,\n  workflow: unknown,\n  path: string[],\n  lastValue: string,\n  ignoreItems: string[],\n  nested: boolean,\n): Promise<Suggestion[] | null> {\n  const rootRule = getRootRule({})\n  const rule = ruleForPath(path, rootRule)\n  if (!rule) return null\n\n  const currentValue = findNode(workflow, path)\n  const isArray = Array.isArray(currentValue)\n  if (isArray && rule.multipleValues !== true) return null\n  if (!nested || isArray || !rule.rules) {\n    const makeItAnArray = !isArray && rule.multipleValues === true\n    return (\n      (suggestionsForExpression ? await suggestionsForExpression(workflow, path, lastValue) : null) ||\n      (await suggestionsFromValuesWithoutExpression(workflow, path, rule, lastValue, ignoreItems, makeItAnArray))\n    )\n  }\n  return suggestionsFromRules(rule.rules, lastValue, ignoreItems)\n}\n\nexport function unescapeContext(name: string): string {\n  const match = name.match(/^\\.(.+)?|\\['(.+?)('\\])?$/)\n  return match ? match[1] || match[2] || '' : name\n}\n","import type {YamlFile} from './yaml-rule-util'\nimport type {TemplateResult} from 'lit-html'\nimport {html} from 'lit-html'\nimport leven from 'leven'\nimport {yaml} from '../jsyaml'\nimport type {Validation} from '../codemirror-linter-util'\n\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nfunction objectKeys(obj: any): string[] {\n  if (obj == null || typeof obj !== 'object' || Array.isArray(obj)) return []\n  return Object.keys(obj)\n}\n\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nfunction findNode(result: any, path: string[]): any {\n  let cursor = result\n  for (const key of path) {\n    if (typeof cursor !== 'object' || cursor == null) return null\n    cursor = cursor[key]\n  }\n  return cursor\n}\n\nfunction keysForPath(result: unknown, path: string[]): string[] {\n  return objectKeys(findNode(result, path))\n}\n\nfunction codeTag(value: string): TemplateResult {\n  return html` <code>${value}</code> `\n}\n\nfunction joinCodeTags(values: string[]): TemplateResult {\n  return html` ${values.map((value, i) => html` ${i > 0 ? ', ' : ''}${codeTag(value)} `)} `\n}\n\nfunction getIndentation(line: string): string {\n  const match = line.match(/^\\s*/)\n  return match ? match[0] : ''\n}\n\nexport function replaceWhitespaces(text: string, tab: string, ind: string) {\n  return text.replace(/\\t/g, tab).replace(/\\n/g, `\\n${ind}`)\n}\n\nfunction containsExpression(str: string): boolean {\n  return str.includes('${{')\n}\n\n// Checks if a github supported expression is used.\nfunction isExpressionFunction(str: string): boolean {\n  const regexPattern = /\\${{\\s*(fromJSON|toJSON|contains|startsWith|endsWith|format|join)\\((.*)\\)\\s*}}/\n  const isExpressionRegex = new RegExp(regexPattern, 'i')\n  return str.match(isExpressionRegex) != null\n}\n\n// Check if a string contains a fromJSON expression, matches on ${{ fromJSON(<arbitary_content>) }}\nfunction isFromJsonExpression(str: string): boolean {\n  const fromJSONExpression = new RegExp(/\\${{\\s*fromJSON\\((.*)\\)\\s*}}/, 'i')\n  return str.match(fromJSONExpression) != null\n}\n\n// Get expression content ${{ github.run_id }}_${{matrix.id}}_result: words -> [ 'github.run_id', 'matrix.id']\n// This function gets the content between expression brackets ${{<this_content>}} and doesn't relate to expression\n// functions like fromJSON, toJSON, format, etc.\nfunction getExpressionContexts(str: string): string[] {\n  const contextExpression = new RegExp(/\\${{(.+?)}}/, 'g')\n  const matches: string[] = []\n  let match: RegExpExecArray | null\n  while ((match = contextExpression.exec(str)) !== null) {\n    matches.push(<string>match[1]?.trim())\n  }\n\n  return matches\n}\n\n// 'test ${{ inputs.input1 - inputs.input2 }}' => ['inputs.input1', 'inputs.input2']\nfunction extractInputsExpressions(str: string): string[] {\n  const results: string[] = []\n\n  // 'test ${{ inputs.input1 }}' => ['${{ inputs.input1 }}']\n  const expressionSyntaxArray = str.match(/\\${{([^}]*)}}/g) || []\n  for (const expressionSyntax of expressionSyntaxArray) {\n    // '${{ inputs.input1 }}' => 'inputs.input1'\n    const inputsExpressions = expressionSyntax.match(/inputs\\.([^\\s}]+)/g) || []\n    for (const inputExpression of inputsExpressions) {\n      results.push(inputExpression)\n    }\n  }\n\n  return results\n}\n\nfunction isStringWithExpressions(str: string): boolean {\n  const expressionsRemovedStr = str.replace(/\\${{([^}]*)}}/g, '').trim()\n  return expressionsRemovedStr !== ''\n}\n\n/*\n * In order to simplify the autocomplete algorithm this function deletes part of the text that are no relevant\n * to what the user is typing. Specifically it removes lines that have greater or equal indentation than the current line\n * with the exception of lines starting with \"-\"\n */\nfunction getSimplifiedText(textBeforeCursor: string): {simplifiedText: string; lastLine: string} {\n  const lines = textBeforeCursor.split('\\n')\n  const lastLine = lines[lines.length - 1]!\n  const indentation = getIndentation(lastLine)\n  const lineStartsWithDash = lastLine.substring(indentation.length).startsWith('-')\n\n  const simplified = lines.slice(0, lines.length - 1).map(ln => {\n    const lineIndentation = getIndentation(ln)\n    // If the indentation is greater, we don't care about this line\n    if (lineIndentation.length > indentation.length) return ''\n    // If the identation is the same, we only care about this line\n    // the line is important if the last line (current one) starts an array element. e.g.\n    // steps:\n    // - id: foo # the previous line has the same indentation. If this line didn't start with - we would not care about the previous one\n    if (lineIndentation.length === indentation.length && !lineStartsWithDash) return ''\n    // Check if this line is for an array element\n    const remaining = ln.substring(lineIndentation.length)\n    const arrStart = remaining.match(/^-\\s+/)\n    if (arrStart && lineIndentation.length + arrStart[0].length >= indentation.length) {\n      const totalIndentationLength = lineIndentation.length + arrStart[0].length\n      // If the indentation is greater, we don't care about this line\n      if (totalIndentationLength > indentation.length) return ''\n      // If the indentation is the same, we care abut it being an array, but not about the rest of the content\n      if (totalIndentationLength === indentation.length) return `${lineIndentation}-`\n    }\n    return ln\n  })\n  simplified.push(lastLine)\n  return {simplifiedText: simplified.join('\\n'), lastLine}\n}\n\n/*\n * Returns the path and current value of the node the user is editing.\n * Returns the latest and deepest node in the data structure. This is possible to do this way because\n * we only have in consideration the text before the cursor and we simplify the document by removing all\n * lines with greater indentation than the current line.\n */\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nfunction getCurrentNode(result: any): {path: string[]; lastValue: string} {\n  const path = []\n  let obj = result\n  while (obj && typeof obj === 'object') {\n    const keys = Object.keys(obj)\n    const key = keys[keys.length - 1]!\n    path.push(key)\n    obj = obj[key]\n  }\n  const lastValue = obj != null ? String(obj) : ''\n  return {path, lastValue}\n}\n\n/*\n * Parses the document and tries to fix small malformed defects such as `on: [push` (no closing bracket because the user is typing).\n * Since the user may be typing in the middle of the file, we need the content split into the part before the cursor (`start` argument) and\n * after it (`end` argument).\n */\nfunction parse(start: string, end: string): {result: unknown; lastValue?: string; consumeKey: boolean} {\n  try {\n    return {result: yaml.load(start + end), consumeKey: false}\n  } catch (err) {\n    // @ts-expect-error catch blocks are bound to `unknown` so we need to validate the type before using it\n    const {message} = err\n    if (message.includes('mapping')) {\n      const match = start.match(/\\w+$/)\n      return {result: yaml.load(`${start}:${end}`), lastValue: match ? match[0] : undefined, consumeKey: true}\n    }\n    if (message.includes('collection')) {\n      const match = start.match(/,\\s*$/)\n      let full = match ? start.substring(0, start.length - match[0].length) : start\n      full += end.match(/^\\]/) ? end : ']'\n      const lastValue = match ? '' : undefined\n      return {result: yaml.load(full), lastValue, consumeKey: true}\n    }\n    throw err\n  }\n}\n\nfunction similarity(a: string, b: string): number {\n  const value = leven(a, b)\n  if (a.endsWith('-latest')) return value - 1\n  return value\n}\n\nfunction sortBySimilarity(values: string[], currentValue: string): string[] {\n  return values.sort((a, b) => similarity(a, currentValue) - similarity(b, currentValue))\n}\n\nconst validateGlob = async (yamlContent: YamlFile, path: string[], value: unknown): Promise<Validation | undefined> => {\n  if (typeof value !== 'string') return\n  const scanner: Scanner = new Scanner(value)\n  while (!scanner.atEnd()) {\n    const escape = scanner.scan(escapeRegex)\n    if (escape !== null && escape[0] === '\\\\') {\n      return toHtmlError('trailing backslash')\n      continue\n    }\n\n    const stars = scanner.scan(starsRegex)\n    if (stars !== null) {\n      if (stars[0].length > 2) return toHtmlError('too many sequential * characters')\n      if (scanner.isNext('+')) return toHtmlError('+ cannot follow *')\n      if (scanner.isNext('?')) return toHtmlError('? cannot follow *')\n      continue\n    }\n\n    const questionMarks = scanner.scan(questionMarksRegex)\n    if (questionMarks !== null) {\n      if (questionMarks[0].length > 1) return toHtmlError('? cannot follow ?')\n      continue\n    }\n\n    const pluses = scanner.scan(plusesRegex)\n    if (pluses !== null) {\n      if (pluses[0].length > 1) return toHtmlError('+ cannot follow +')\n      if (scanner.isNext('?')) return toHtmlError('? cannot follow +')\n      continue\n    }\n\n    if (scanner.isNext('[')) {\n      scanner.takeOne()\n      const rangeContent = scanner.scan(rangeContentRegex)\n\n      if (rangeContent === null) return toHtmlError('empty character range')\n      if (!scanner.isNext(']')) return toHtmlError('unterminated character range')\n      if (!rangeContent[0].match(validRangeContentRegex)) return toHtmlError('invalid character range')\n\n      scanner.takeOne()\n      continue\n    }\n\n    scanner.takeOne()\n  }\n}\n\nconst escapeRegex = /^\\\\.?/\nconst plusesRegex = /^\\++/\nconst questionMarksRegex = /^\\?+/\nconst starsRegex = /^\\*+/\nconst rangeContentRegex = /^[^\\]]+/ // Anything but ]\n// Optional ^ followed by one or more of: single digit or letter, digit range, letter range\nconst validRangeContentRegex = /^\\^?(?:(?:\\d(?:-\\d)?)|(?:[a-z](?:-[a-z])?))+$/i\n\nfunction toHtmlError(message: string) {\n  return {\n    message: html` ${message} `,\n    severity: 'error',\n  }\n}\n\nclass Scanner {\n  value: string\n\n  constructor(value: string) {\n    this.value = value\n  }\n\n  atEnd(): boolean {\n    return this.value.length === 0\n  }\n\n  isNext(char: string): boolean {\n    return this.value[0] === char\n  }\n\n  scan(regex: RegExp): RegExpMatchArray | null {\n    const result = this.value.match(regex)\n    if (result !== null) {\n      this.value = this.value.substring(result[0].length)\n    }\n    return result\n  }\n\n  takeOne(): string {\n    this.value = this.value.substring(1)\n    return this.value[0]!\n  }\n}\n\nexport {\n  codeTag,\n  containsExpression,\n  joinCodeTags,\n  findNode,\n  getIndentation,\n  keysForPath,\n  parse,\n  getCurrentNode,\n  getExpressionContexts,\n  getSimplifiedText,\n  sortBySimilarity,\n  validateGlob,\n  isFromJsonExpression,\n  extractInputsExpressions,\n  isStringWithExpressions,\n  isExpressionFunction,\n}\n","import {\n  type Rule,\n  type YamlFile,\n  type getYamlRootRuleSignature,\n  type processExpressionSignature,\n  ruleValues,\n} from './yaml-rule-util'\nimport {codeTag, containsExpression, joinCodeTags, sortBySimilarity} from './utils'\nimport type {TemplateResult} from 'lit-html'\nimport {html} from 'lit-html'\nimport {yaml} from '../jsyaml'\nimport type {LintMessage, PathInfo, TokenInfo, Validation} from '../codemirror-linter-util'\n\ntype Paths = {[key: string]: PathInfo}\n\nfunction isObject(value: unknown): boolean {\n  return typeof value === 'object' && value !== null\n}\n\n/*\n * If we are unable to calculate the position of a key or value, we highligh the whole line.\n * This function returns a TokenInfo object with the content of the whole function without\n * the first whitespaces\n */\nfunction lineInfo(lineNumber: number, line: string): TokenInfo {\n  const indentation = (line.match(/^\\s*/) || [''])[0]\n  return {\n    from: {line: lineNumber, ch: indentation.length},\n    to: {line: lineNumber, ch: line.length},\n  }\n}\n\n/*\n * Calculates the location of a key in a line\n */\nfunction keyInfo(lineNumber: number, line: string, key: string): TokenInfo {\n  const ch = line.indexOf(key)\n  if (ch === -1) return lineInfo(lineNumber, line)\n  return {\n    from: {line: lineNumber, ch},\n    to: {line: lineNumber, ch: ch + key.length},\n  }\n}\n\n/*\n * Calculates the location of a value in a line\n */\nfunction valueInfo(lineNumber: number, line: string, value: unknown): TokenInfo {\n  if (isObject(value)) return lineInfo(lineNumber, line)\n  const asString = String(value)\n  const ch = line.lastIndexOf(asString)\n  if (ch === -1) return lineInfo(lineNumber, line)\n  return {\n    from: {line: lineNumber, ch},\n    to: {line: lineNumber, ch: ch + asString.length},\n  }\n}\n\nfunction buildKeyMessage(paths: Paths, path: string[], validation: Validation): LintMessage {\n  const fullPath = path.join('.')\n  const pathInfo = paths[fullPath]!\n  const {message, fixes, severity} = validation\n  return {message, fixes, severity, from: pathInfo.key.from, to: pathInfo.key.to}\n}\n\nfunction buildValueMessage(paths: Paths, path: string[], validation: Validation): LintMessage {\n  const fullPath = path.join('.')\n  const pathInfo = paths[fullPath]!\n  const {message, fixes, severity} = validation\n  return {message, fixes, severity, from: pathInfo.value.from, to: pathInfo.value.to}\n}\n\n/*\n * Calculates the repeated values of an array of strings\n */\nfunction repeatedValues(array: string[]): string[] {\n  const set = new Set()\n  const repeated = new Set<string>()\n  for (const value of array) {\n    if (set.has(value)) repeated.add(value)\n    set.add(value)\n  }\n  return [...repeated]\n}\n\nexport function unexpectedTypeMessage(expected: string[], found: string | TemplateResult): Validation {\n  const part =\n    expected.length === 1\n      ? html` ${codeTag(expected[0]!)} was expected `\n      : html` one of ${joinCodeTags(expected)} were expected `\n  return {\n    message: html` Invalid type found: ${part} but ${found} was found `,\n    severity: 'error',\n  }\n}\n\nasync function validate(\n  yamlContent: YamlFile,\n  paths: Paths,\n  path: string[],\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  object: any,\n  rule: Rule,\n  messages: LintMessage[],\n  processExpression?: processExpressionSignature,\n) {\n  if (object === undefined) return\n\n  if (rule.validateKey) {\n    const validation = await rule.validateKey(yamlContent, path)\n    if (validation) {\n      messages.push(buildKeyMessage(paths, path, validation))\n      if (validation.severity === 'error') return // Stop validation of nested values\n    }\n  }\n\n  if (object === null) {\n    if (rule.nullable === true) return\n    messages.push(\n      buildValueMessage(paths, path, {\n        message: html` This value cannot be null `,\n        severity: 'error',\n      }),\n    )\n  } else if (typeof object === 'object') {\n    if (Array.isArray(object)) {\n      if (rule.maxLength && object.length > rule.maxLength) {\n        messages.push(\n          buildValueMessage(paths, path, {\n            message: html` Maximum of ${rule.maxLength.toString()} elements allowed `,\n            severity: 'error',\n          }),\n        )\n      }\n\n      if (rule.values) {\n        if (rule.multipleValues !== true) {\n          messages.push(\n            buildValueMessage(paths, path, {\n              message: html` Only a single value is allowed here `,\n              severity: 'error',\n            }),\n          )\n          return\n        }\n        const values = await ruleValues(rule, yamlContent, path)\n        const unknown = object.map(String).filter(value => !values.includes(value))\n        const known = object.map(String).filter(value => values.includes(value))\n        const repeated = repeatedValues(known)\n        if (repeated.length > 0 || unknown.length > 0) {\n          const message = html`\n            ${repeated.length > 0 ? html` Repeated values: ${joinCodeTags(repeated)} ` : ''}\n            ${repeated.length > 0 && unknown.length > 0 ? html` <br /> ` : ''}\n            ${unknown.length > 0 ? html` Invalid values: ${joinCodeTags(unknown)} ` : ''}\n          `\n          messages.push(buildValueMessage(paths, path, {message, severity: 'error'}))\n        }\n      } else if (rule.items) {\n        for (const index in object) {\n          await validate(yamlContent, paths, [...path, index], object[index], rule.items, messages, processExpression)\n        }\n      } else if (rule.single || rule.map || rule.rules) {\n        const expected = rule.single || []\n        if (rule.map) expected.push('map')\n        if (rule.rules) expected.push('object')\n        messages.push(buildValueMessage(paths, path, unexpectedTypeMessage(expected, 'an array')))\n      }\n    } else {\n      if (rule.map) {\n        for (const index in object) {\n          await validate(yamlContent, paths, [...path, index], object[index], rule.map, messages, processExpression)\n        }\n      } else if (rule.rules) {\n        const {rules} = rule\n        for (const ruleKey in rules) {\n          if (object[ruleKey] !== undefined) {\n            // Validate existing rule/key\n            await validate(\n              yamlContent,\n              paths,\n              [...path, ruleKey],\n              object[ruleKey],\n              rules[ruleKey]!,\n              messages,\n              processExpression,\n            )\n          } else if (rules[ruleKey]!.required === true) {\n            // Look for missing required properties\n            const keyMessage = path.length === 0 ? 'root key' : 'key'\n            messages.push(\n              buildKeyMessage(paths, path, {\n                message: html` Missing required ${keyMessage} ${codeTag(ruleKey)} `,\n                severity: 'error',\n              }),\n            )\n          }\n        }\n        // Look for unknown keys\n        for (const index in object) {\n          if (!rule.rules[index]) {\n            const expected = Object.keys(rule.rules).filter(key => object[key] === undefined)\n            const message = html` Unknown key ${codeTag(index)} `\n            const fixes = rule.sortSuggestions === false ? expected : sortBySimilarity(expected, index)\n            messages.push(buildKeyMessage(paths, [...path, index], {message, fixes, severity: 'error'}))\n          }\n        }\n      } else if (rule.single || rule.items) {\n        const expected = rule.single || []\n        if (rule.values || rule.items) expected.push('array')\n        messages.push(\n          buildValueMessage(\n            paths,\n            path,\n            unexpectedTypeMessage(expected, object instanceof Date ? 'a date' : 'an object'),\n          ),\n        )\n      }\n    }\n  } else {\n    const str = String(object)\n    if (containsExpression(str) && processExpression) {\n      const validation = await processExpression(yamlContent, path, str, rule)\n      if (validation) messages.push(buildValueMessage(paths, path, validation))\n      return\n    }\n\n    if (rule.validateValue) {\n      const validation = await rule.validateValue(yamlContent, path, object)\n      if (validation) {\n        messages.push(buildValueMessage(paths, path, validation))\n        if (validation.severity === 'error') return\n      }\n    }\n    if (rule.single) {\n      const {single: types} = rule\n      const objectType = typeof object\n\n      if (!types.includes(objectType)) {\n        messages.push(buildValueMessage(paths, path, unexpectedTypeMessage(types, codeTag(objectType))))\n      }\n    } else if (rule.values) {\n      const values = await ruleValues(rule, yamlContent, path)\n      // If the rule is caseInsensitive we assume the values in the rule are already case insensitive\n      const includesValue = values.includes(rule.caseInsensitive ? str.toLowerCase() : str)\n      if (!includesValue) {\n        const fixes = rule.sortSuggestions === false ? values : sortBySimilarity(values, String(object))\n        messages.push(\n          buildValueMessage(paths, path, {\n            message: html` Invalid value: ${codeTag(str)} `,\n            fixes,\n            severity: 'error',\n          }),\n        )\n      }\n    } else if (rule.map || rule.rules || rule.items) {\n      const objectType = object === null ? 'null' : typeof object\n      const expected = []\n      if (rule.map || rule.rules) expected.push('object')\n      if (rule.items) expected.push('array')\n      messages.push(buildValueMessage(paths, path, unexpectedTypeMessage(expected, codeTag(objectType))))\n    }\n  }\n}\n\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nfunction findNewPaths(paths: Paths, lines: string[], value: any, path: string[], lineNumber: number) {\n  if (value === undefined) return\n  const fullPath = path.join('.')\n  if (fullPath && !paths[fullPath]) {\n    const line = lines[lineNumber]!\n    const lastKey = path[path.length - 1]!\n    paths[fullPath] = {\n      key: keyInfo(lineNumber, line, lastKey),\n      value: valueInfo(lineNumber, line, value),\n    }\n  }\n  if (typeof value !== 'object') return\n  for (const key in value) {\n    if (!value.hasOwnProperty(key)) continue\n    findNewPaths(paths, lines, value[key], [...path, key], lineNumber)\n  }\n}\n\nexport default async function lint(text: string, getRootRule: getYamlRootRuleSignature): Promise<LintMessage[]> {\n  const paths: Paths = {}\n  const lines = text.split('\\n')\n  try {\n    if (lines.length > 0) {\n      // This is needed to show error messages for the root object.\n      // Only case right now: missing root keys, such as `on`\n      const info = {\n        from: {line: 0, ch: 0},\n        to: {line: lines.length - 1, ch: lines[lines.length - 1]!.length},\n      }\n      paths[''] = {\n        key: info,\n        value: info,\n      }\n    }\n\n    // The parser does not return any information of the position of the data in the original text.\n    // So we parse the text N times: first including the first line, then including the first two lines, and so on.\n    // In each iteration we find new paths, we know that they are in the latest line being parsed.\n    let yamlObject = null\n    for (let i = 0; i < lines.length; i++) {\n      const partial = lines.slice(0, i + 1).join('\\n')\n      yamlObject = yaml.load(partial)\n\n      findNewPaths(paths, lines, yamlObject, [], i)\n    }\n\n    const messages: LintMessage[] = []\n    const rootRule = getRootRule(yamlObject)\n    await validate(yamlObject, paths, [], yamlObject, rootRule, messages, rootRule.processExpression)\n\n    return messages\n  } catch (err) {\n    // @ts-expect-error catch blocks are bound to `unknown` so we need to validate the type before using it\n    const {mark} = err\n    if (!mark) return [] // Unknown error\n    const {line: lineIndex, column} = mark\n    // Sometimes js-yaml reports an invalid line number. E.g. reports 1 when the document only has one line\n    const line =\n      // @ts-expect-error catch blocks are bound to `unknown` so we need to validate the type before using it\n      lineIndex >= lines.length || err.reason.match(/end of the stream within a flow collection/)\n        ? lineIndex - 1\n        : lineIndex\n    const ch = column >= lines[line]!.length ? 0 : column\n    return [\n      {\n        // @ts-expect-error catch blocks are bound to `unknown` so we need to validate the type before using it\n        message: html` ${err.reason} `,\n        severity: 'error',\n        from: {line, ch},\n        to: {line, ch: lines[line]!.length},\n      },\n    ]\n  }\n}\n","import type {Validation} from '../codemirror-linter-util'\nimport type {Suggestion} from './autocomplete-util'\n\nexport type YamlFile = unknown\n\nexport async function ruleValues(rule: Rule, yaml: YamlFile, path: string[]): Promise<string[]> {\n  if (!rule.values) throw new Error('Cannot get values of rule because `values` is not defined')\n  return typeof rule.values === 'function' ? await rule.values(yaml, path) : rule.values\n}\n\n// Types for the rule system\nexport interface Rule {\n  description?: string // description for this key to be shown in autocomplete\n  single?: string[] // can be a single value? Of which type?  'string' | 'number' | 'boolean'\n  required?: boolean // is it required?\n  values?: string[] | ((yaml: unknown, path: string[]) => Promise<string[]>)\n  multipleValues?: boolean // can be an array of things in \"values\"\n  caseInsensitive?: boolean // the values are case insensitive?\n  nullable?: boolean // can be null? We could've used `single: ['null']` but that'd change some behaviors\n  // can be an object? Which rules its properties have?\n  rules?: Rules // if the value expected is another object, define it using rules\n  map?: Rule // can be an object with user-defined keys? What rule applies to the values?\n  keyPlaceholder?: string // placeholder when using smart indentation\n  keyPlaceholderHelp?: string // help to show when selecting the placeholder\n  items?: Rule // can be an array? What are the rules for its elements?\n  maxLength?: number // maximum number of elements if object is an array\n  validateKey?: (yaml: YamlFile, path: string[]) => Promise<Validation | undefined>\n  validateValue?: (yaml: YamlFile, path: string[], value: unknown) => Promise<Validation | undefined>\n  sortSuggestions?: boolean // default true, should we sort suggestions by similarity?\n}\n\nexport type suggestionsForExpressionSignature = (\n  yaml: YamlFile,\n  path: string[],\n  lastValue: string,\n) => Promise<Suggestion[] | null>\n\nexport type processExpressionSignature = (\n  yamlContent: YamlFile,\n  path: string[],\n  expression: string,\n  rule: Rule,\n) => Promise<Validation | undefined>\n\nexport type getYamlRootRuleSignature = (yaml: YamlFile) => RootRule\n\nexport interface RootRule extends Rule {\n  processExpression?: processExpressionSignature\n  suggestionsForExpression?: suggestionsForExpressionSignature\n}\n\nexport interface Rules {\n  [index: string]: Rule\n}\n\nexport function ruleForPath(path: string[], fullRootRule: RootRule): Rule | null {\n  let rule = fullRootRule\n  for (const key of path) {\n    if (Number.isInteger(+key)) {\n      if (!rule.items) return null\n      rule = rule.items\n    } else if (rule.map) {\n      rule = rule.map\n    } else if (rule.rules && rule.rules[key]) {\n      rule = rule.rules[key]!\n    } else {\n      return null\n    }\n  }\n  return rule\n}\n"],"names":["CodeMirrorLintingHelper","clearState","mark","lintMarks","clear","destroyTooltip","splice","createMarks","cm","messages","message","from","to","severity","markText","className","__message","push","showTooltip","event","target","srcElement","classList","contains","box","getBoundingClientRect","left","right","top","bottom","findMark","marks","findMarksAt","coordsChar","length","keepTooltip","tooltip","createTooltip","select","querySelector","button","timeout","document","activeElement","setTimeout","parentElement","style","opacity","removeChild","clearTimeout","CodeMirror","on","replaceValue","location","find","focus","setSelection","replaceSelection","value","addEventListener","textContent","lintMessage","fixes","tooltipTemplate","importNode","content","tooltipHeader","tooltipTitle","tooltipSubtitle","tooltipMessage","tooltipFixes","fixButton","hidden","render","firstFix","fix","slice","option","createElement","appendChild","body","add","clientHeight","fileOffsetToLineAndColumn","doc","offset","lines","split","startLine","lineOffset","startColumn","yaml","load","jsyaml","startsWithAndNotEquals","prefix","text","startsWith","filterValues","values","lastValue","ignoredValues","lowerCasedLastValue","toLowerCase","lowerCasedIgnoredValues","map","s","filter","valueLower","String","includes","suggestionsFromValuesWithoutExpression","path","rule","ignoreItems","makeItAnArray","single","ruleValues","filtered","str","displayText","snippet","tokens","replace","autocomplete","fullText","textBeforeCursor","getRootRule","suggestionsForExpression","simplifiedText","lastLine","getSimplifiedText","result","lastParsedValue","consumeKey","parse","lastDataValue","getCurrentNode","pop","nested","match","indexOf","workflow","substring","ignoreKeys","keysForPath","ignoreValues","usedValues","arr","findNode","Array","isArray","getSuggestions","err","rules","rootRule","ruleForPath","multipleValues","Object","keys","key","after","items","description","unescapeContext","name","cursor","obj","codeTag","html","joinCodeTags","i","getIndentation","line","replaceWhitespaces","tab","ind","containsExpression","isExpressionFunction","isExpressionRegex","isFromJsonExpression","fromJSONExpression","getExpressionContexts","contextExpression","matches","exec","trim","extractInputsExpressions","results","expressionSyntax","inputExpression","isStringWithExpressions","expressionsRemovedStr","indentation","lineStartsWithDash","simplified","ln","lineIndentation","arrStart","remaining","totalIndentationLength","join","start","end","undefined","full","similarity","a","b","leven","endsWith","sortBySimilarity","currentValue","sort","validateGlob","yamlContent","scanner","Scanner","atEnd","escape","scan","escapeRegex","toHtmlError","stars","starsRegex","isNext","questionMarks","questionMarksRegex","pluses","plusesRegex","takeOne","rangeContent","rangeContentRegex","validRangeContentRegex","char","regex","constructor","lineInfo","lineNumber","ch","buildKeyMessage","paths","validation","pathInfo","buildValueMessage","unexpectedTypeMessage","expected","found","part","validate","object","processExpression","validateKey","nullable","maxLength","toString","unknown","repeated","repeatedValues","array","set","Set","has","index","ruleKey","required","keyMessage","sortSuggestions","Date","validateValue","types","objectType","caseInsensitive","lint","info","yamlObject","partial","findNewPaths","fullPath","lastKey","keyInfo","valueInfo","asString","lastIndexOf","hasOwnProperty","lineIndex","column","reason","fullRootRule","Number","isInteger"],"sourceRoot":""}