#!/usr/bin/env safe-ruby
# frozen_string_literal: true

# VIEWMAPPER
#
# Viewmapper is a static analysis tool for Rails views. Given a controller or
# a controller/action, emit the tree of all possible views, partials, and
# components rendered from those actions.
#
# To trace a view, run `bin/viewfinder controller` or `bin/viewfinder controller#action`

# Bring in the big environment so we can introspect routes
require_relative "../config/environment"

require "rubocop"
require "parser/current"
require_relative "../test/rubocop/erb_parser"

class Viewmapper
  # Public: Locate the source file containing the definition of a controller and action from a Rails route.
  class ActionLocation
    def initialize(route)
      @controller_name = route.requirements[:controller]
      @action_name = route.requirements[:action]

      @desc = "#{@controller_name}##{@action_name} " + route.path.spec.to_s.gsub("(.:format)", "")
      @desc = "#{@desc} (#{route.name})" if route.name.present?
    end

    attr_reader :desc

    # Public: Determine if this controller/action pair matches any user-requested spec.
    #
    # queries - Array of pairs (controller name, action name or nil). If the action name is nil, that query will match
    #   any action within the controller.
    def matches_any?(queries)
      return false if @controller_name.nil? || @action_name.nil?

      queries.any? do |controller_q, action_q|
        controller_q == @controller_name && (action_q.nil? || action_q == @action_name)
      end
    end

    # Public: Lazily load the controller class. Log a message to stderr and return `nil` if the controller cannot be loaded.
    def controller_class
      return @controller_class if defined? @controller_class
      return @controller_class = nil if @controller_name.nil? || @action_name.nil?

      @controller_class = begin
        ActiveSupport::Inflector.constantize("#{@controller_name.underscore.camelize}Controller")
      rescue NameError => error
        $stderr.puts "Unable to load controller class: #{@controller_name}."
        nil
      end
    end

    # Public: Lazily construct an instance of the routed controller. Return `nil` if the controller class is unavailable.
    def controller
      return @controller if defined? @controller

      @controller = controller_class&.new
    end

    # Lazily locate the source file containing the definition of the routed action. Return `nil` if the controller
    # class is unavailable. Log a message to stderr and return `nil` if the action is not defined.
    def source_path
      return @source_path if defined? @source_path
      return @source_path = nil unless controller_class.present?

      @source_path = begin
        @controller_class.instance_method(@action_name).source_location.first
      rescue NameError => error
        $stderr.puts "Unable to locate controller action: #{@controller_name}##{@action_name}."
        nil
      end
    end

    # Return true if this route's action was able to be successfully mapped the whole way to a definition in a source
    # file.
    def valid?
      source_path.present?
    end

    # Return true because this Location's #source_path corresponds to a controller definition as opposed to a
    # view component or an .erb template.
    def controller?
      true
    end

    # Return the Symbol used to constrain AST traversal to a single method definition within the parsed #source_path.
    def action_filter
      @action_name&.to_sym
    end
  end

  # Locate an .erb template corresponding to a rendered ActionView partial or file. Generated from RenderTargets
  # identified during AST traversal during a Tracer#trace call to find the next source files to parse.
  class TemplateLocation
    def initialize(desc, source_path)
      @desc = desc
      @source_path = source_path
    end

    attr_reader :desc, :source_path

    # Return false because this Location's #source_path corresponds to an .erb template instead of a controller
    # definition.
    def controller?
      false
    end

    # Return `nil` so template AST traversals are not constrained to a specific method definition.
    def action_filter
      nil
    end

    # Construct an Array of (zero, one or many) TemplateLocations found by resolving a RenderTarget.
    #
    # controller - Instantiated controller instance from for the current Tracer traversal, used to locate templates.
    # target - RenderTarget generated by a render method call
    def self.all_from_target(controller, target)
      if target.component?
        all_from_component_target(target)
      else
        all_from_view_target(controller, target)
      end
    end

    # Locate .erb templates used by a named view component class (note that there may be more than one; we follow all
    # of them). Logs a message to stderr and returns an empty Array if the named component class cannot be found.
    #
    # target - RenderTarget from a render call that renders a view component. Its #name is expected to be a
    #  fully-qualified ViewComponent::Base subclass.
    def self.all_from_component_target(target)
      begin
        component_class = ActiveSupport::Inflector.constantize(target.name)
        template_paths = component_class.compiler.send(:templates).map { |t| t[:path] }
        template_paths.map { |template_path| new(component_class.name, template_path) }
      rescue NameError => error
        $stderr.puts "Unable to find view component #{target.name.inspect}."
        []
      end
    end
    private_class_method :all_from_component_target

    # Locate the .erb template used for a file or partial render call. Logs a message to stderr and returns an empty
    # Array if the template cannot be located.
    #
    # controller - Controller instance for this Tracer traversal used to accurately locate view templates.
    # target - RenderTarget from a render call that renders a file or partial. Its #name should be a shorthand
    #  template identifier (`"discussions/show"`).
    def self.all_from_view_target(controller, target)
      begin
        context = controller.view_renderer.lookup_context
        template = context.find(target.name, [], target.partial?)
        [new(template.virtual_path, template.identifier)]
      rescue ActionView::MissingTemplate => error
        $stderr.puts "Unable to find view template #{target.name.inspect}."
        []
      end
    end
    private_class_method :all_from_view_target
  end

  # Captures information from a render-related method call in a parsed AST from a controller or an .erb template. This
  # is an abstract base class; only its inner subclasses (RenderTarget::File, RenderTarget::Partial,
  # RenderTarget::Component) should be instantiated. Constructed during AST traversal within a Tracer#trace call and
  # passed to TemplateLocation.all_from_target to identify the next hops in the render tree.
  class RenderTarget
    # name - Template identifier ("discussions/show") or view component class name ("Primer::Beta::Link").
    def initialize(name)
      @name = name
    end

    attr_reader :name

    def file?
      false
    end

    def partial?
      false
    end

    def component?
      false
    end

    # Render call that resolves to a `file:`, such as `app/views/discussions/show.html.erb`.
    class File < self
      def file? ; true ; end
    end

    # Render call that resolves to a `partial:`, such as `app/views/discussions/_title.html.erb`.
    class Partial < self
      def partial? ; true ; end
    end

    # Render call that resolves to a view component, such as `Primer::LayoutComponent`.
    class Component < self
      def component? ; true ; end
    end

    # Instantiate a RenderTarget::Partial or a RenderTarget::File based on a Boolean.
    def self.view(name, partial:)
      (partial ? Partial : File).new(name)
    end
  end

  # Member of the tree of rendered things. The output from a Tracer#trace call.
  class RenderNode
    # Construct a RenderNode.
    #
    # desc - Human-friendly String describing this rendered "thing". Either a short template identifier
    #  ("discussions/show", "discussions/_child_comments") or a view component class name ("Primer::Beta::Link").
    # children - Array of RenderNodes representing other things that may be rendered by this. Must be empty (the
    #   default) if `recursive` is true.
    # recursive - Boolean indicating if this node has already occurred as an ancestor.
    def initialize(desc, children: [], recursive: false)
      @desc = desc
      @children = children
      @recursive = recursive
    end

    # Recursively produce output to stdout describing all possible render paths. Formats output as an indented tree of
    # markdown lists, with emoji decorations for paths truncated due to infinite loops.
    def print_tree(indent = 0)
      line = StringIO.new
      line << " " * indent
      if indent.zero?
        line << "#"
      else
        line << "*"
      end
      line << " "
      line << @desc
      if @recursive
        line << " (♻️ )"
      end

      puts line.string

      @children.each { |child_node| child_node.print_tree(indent + 2) }
    end
  end

  # Parse Ruby and AST source files to follow statically-resolvable render calls from a single root.
  class Tracer
    # Establish a trace starting at a fixed root ActionLocation.
    def initialize(root_location)
      @root_location = root_location
    end

    # Parse and identify RenderTargets within the AST of a source file. Resolve each to zero, one or many
    # TemplateLocations, then recursively dive into each.
    #
    # location - ActionLocation or TemplateLocation used to locate the current #source_path to be parsed and
    #   characterize the thing we're parsing (controller or not).
    # seen_paths - Set of #source_paths that have already been parsed along this branch of the render tree. Only you
    #   can prevent stack overflows.
    #
    # Returns a RenderNode for this location with either its `children` or `recursive` populated appropriately.
    def trace(location = @root_location, seen_paths = Set.new)
      source_path = location.source_path

      if seen_paths.include?(source_path)
        return RenderNode.new(location.desc, recursive: true)
      end
      seen_paths.add(source_path)

      buffer = Parser::Source::Buffer.new("(erb)")
      buffer.source = RuboCop::ProcessedSource.from_file_with_rails_erb(source_path, 2.7).raw_source
      root_node = Parser::CurrentRuby.new(RuboCop::AST::Builder.new).parse(buffer)

      targets = extract_render_targets(root_node, location)
      targets.compact!

      sibling_paths = Set.new
      children = targets.flat_map do |target|
        templates = TemplateLocation.all_from_target(@root_location.controller, target)

        templates.delete_if do |template|
          if sibling_paths.include?(template.source_path)
            true
          else
            sibling_paths.add(template.source_path)
            false
          end
        end

        templates.map { |template| trace(template, seen_paths.dup) }
      end

      RenderNode.new(location.desc, children: children)
    end

    private

    # Given a current AST node and a location for context, recursively descend through an AST for a source file and
    # return an Array of RenderTargets corresponding to "render" method calls encountered at this node or its children.
    # If the current location has a non-nil #action_filter, method definitions for methods that don't match the filter
    # will be truncated (not traversed into).
    #
    # node - Current Parser::AST::Node.
    # location - ActionLocation or TemplateLocation for the current traversal.
    # current_action - Symbol name of the method defined by the most recently encountered :def node, or `nil` if we
    #   haven't gotten there yet.
    def extract_render_targets(node, location, current_action = nil)
      return [] unless node.is_a?(Parser::AST::Node)
      return [] if current_action && location.controller? && location.action_filter != current_action

      targets = []

      if node.type == :send
        case node.method_name
        when :render
          targets << extract_target_from_render_node(node, location.controller?)
        when :render_template_view
          targets << extract_target_from_view_node(node, false)
        when :render_partial_view
          targets << extract_target_from_view_node(node, true)
        when :render_to_string
          targets << extract_target_from_render_to_string_node(node, location.controller?)
        end
      end

      node.child_nodes.each do |child|
        # Truncate recursion into methods definitions other than the current action
        child_action = current_action
        if location.controller? && current_action.nil? && child.type == :def
          child_action = child.method_name
        end

        targets += extract_render_targets(child, location, child_action)
      end

      targets.compact
    end

    # Attempt to generate a RenderTarget from the AST node of a :render call.
    #
    # Examples:
    # render("discussions/show")
    # render(partial: "discussions/_event")
    def extract_target_from_render_node(node, is_controller)
      if node.node_parts[2].type == :str
        RenderTarget.view(node.node_parts[2].value, partial: !is_controller)
      elsif node.node_parts.last.type == :hash
        partial_node =
          node.node_parts.last.children.find do |pair|
            pair.node_parts.first.value == :partial && pair.node_parts.last.respond_to?(:value)
          end

        RenderTarget::Partial.new(partial_node.node_parts.last.value) if partial_node
      elsif node.node_parts.last.type == :send
        if node.node_parts.last.children.first&.type == :const
          RenderTarget::Component.new(node.node_parts.last.children.first.source)
        end
      end
    end

    # Attempt to generate a RenderTarget from the AST node of a :render_template_view or :render_partial_view call.
    #
    # Examples:
    # render_template_view("actions/new")
    # render_partial_view("stafftools/abilities/list")
    def extract_target_from_view_node(node, is_partial)
      if node.node_parts[2].type == :str
        RenderTarget.view(node.node_parts[2].value, partial: is_partial)
      end
    end

    # Attempt to generate a RenderTarget from the AST node of a :render_to_string call.
    #
    # Examples:
    # render_to_string(partial: "edit_repositories/admin_screen/team")
    def extract_target_from_render_to_string_node(node, is_controller)
      if node.node_parts.last.respond_to?(:type) && node.node_parts.last.type == :hash
        partial_node =
          node.node_parts.last.children.find do |pair|
            pair.node_parts.first.value == :partial
          end

        RenderTarget::Partial.new(partial_node.node_parts.last.value)
      end
    end
  end

  def initialize(query_phrases)
    @query_phrases = query_phrases
  end

  def call
    # Show usage if nothing, --help, or -h is passed
    if @query_phrases.blank? || @query_phrases.include?("--help") || @query_phrases.include?("-h")
      puts <<~USAGE
        To trace a view tree, run `viewmapper controller` or `viewmapper controller#action`. For example:
        \nbin/viewmapper discussions
        bin/viewmapper discussions#show
      USAGE
      exit 1
    end

    # Use Rails routes to identify source locations of each matching action
    queries = @query_phrases.map { |phrase| phrase.split(/#/, 2) }
    action_locations =
      Rails.application.routes.routes.routes.flat_map do |route|
        location = ActionLocation.new(route)
        next [] unless location.matches_any?(queries)
        next [] unless location.valid?
        [location]
      end

    action_locations.each do |location|
      Tracer.new(location).trace.print_tree
    end
  end
end

Viewmapper.new(ARGV).call
