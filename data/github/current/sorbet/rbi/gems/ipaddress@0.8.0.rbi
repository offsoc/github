# typed: true

# DO NOT EDIT MANUALLY
# This is an autogenerated file for types exported from the `ipaddress` gem.
# Please instead update this file by running `bin/tapioca gem ipaddress`.

module ERB::Escape
  private

  def html_escape(_arg0); end

  class << self
    def html_escape(_arg0); end
  end
end

# source://ipaddress//lib/ipaddress/prefix.rb#1
module IPAddress
  # True if the object is an IPv4 address
  #
  #   ip = IPAddress("192.168.10.100/24")
  #
  #   ip.ipv4?
  #     #-> true
  #
  # @return [Boolean]
  #
  # source://ipaddress//lib/ipaddress.rb#59
  def ipv4?; end

  # True if the object is an IPv6 address
  #
  #   ip = IPAddress("192.168.10.100/24")
  #
  #   ip.ipv6?
  #     #-> false
  #
  # @return [Boolean]
  #
  # source://ipaddress//lib/ipaddress.rb#71
  def ipv6?; end

  class << self
    # Deprecate method
    #
    # source://ipaddress//lib/ipaddress.rb#149
    def deprecate(message = T.unsafe(nil)); end

    # Parse the argument string to create a new
    # IPv4, IPv6 or Mapped IP object
    #
    #   ip  = IPAddress.parse "172.16.10.1/24"
    #   ip6 = IPAddress.parse "2001:db8::8:800:200c:417a/64"
    #   ip_mapped = IPAddress.parse "::ffff:172.16.10.1/128"
    #
    # All the object created will be instances of the
    # correct class:
    #
    #  ip.class
    #    #=> IPAddress::IPv4
    #  ip6.class
    #    #=> IPAddress::IPv6
    #  ip_mapped.class
    #    #=> IPAddress::IPv6::Mapped
    #
    # source://ipaddress//lib/ipaddress.rb#42
    def parse(str); end

    # Checks if the given string is a valid IP address,
    # either IPv4 or IPv6
    #
    # Example:
    #
    #   IPAddress::valid? "2002::1"
    #     #=> true
    #
    #   IPAddress::valid? "10.0.0.256"
    #     #=> false
    #
    # @return [Boolean]
    #
    # source://ipaddress//lib/ipaddress.rb#87
    def valid?(addr); end

    # Checks if the given string is a valid IPv4 address
    #
    # Example:
    #
    #   IPAddress::valid_ipv4? "2002::1"
    #     #=> false
    #
    #   IPAddress::valid_ipv4? "172.16.10.1"
    #     #=> true
    #
    # @return [Boolean]
    #
    # source://ipaddress//lib/ipaddress.rb#102
    def valid_ipv4?(addr); end

    # Checks if the argument is a valid IPv4 netmask
    # expressed in dotted decimal format.
    #
    #   IPAddress.valid_ipv4_netmask? "255.255.0.0"
    #     #=> true
    #
    # @return [Boolean]
    #
    # source://ipaddress//lib/ipaddress.rb#116
    def valid_ipv4_netmask?(addr); end

    # Checks if the given string is a valid IPv6 address
    #
    # Example:
    #
    #   IPAddress::valid_ipv6? "2002::1"
    #     #=> true
    #
    #   IPAddress::valid_ipv6? "2002::DEAD::BEEF"
    #     #=> false
    #
    # @return [Boolean]
    #
    # source://ipaddress//lib/ipaddress.rb#134
    def valid_ipv6?(addr); end
  end
end

# source://ipaddress//lib/ipaddress.rb#22
IPAddress::AUTHORS = T.let(T.unsafe(nil), Array)

# source://ipaddress//lib/ipaddress.rb#21
IPAddress::GEM = T.let(T.unsafe(nil), String)

# =Name
#
# IPAddress::IPv4 - IP version 4 address manipulation library
#
# =Synopsis
#
#    require 'ipaddress'
#
# =Description
#
# Class IPAddress::IPv4 is used to handle IPv4 type addresses.
#
# source://ipaddress//lib/ipaddress/ipv4.rb#17
class IPAddress::IPv4
  include ::IPAddress
  include ::Prelude::Enumerator
  include ::Enumerable
  include ::Comparable

  # Creates a new IPv4 address object.
  #
  # An IPv4 address can be expressed in any of the following forms:
  #
  # * "10.1.1.1/24": ip +address+ and +prefix+. This is the common and
  # suggested way to create an object                  .
  # * "10.1.1.1/255.255.255.0": ip +address+ and +netmask+. Although
  # convenient sometimes, this format is less clear than the previous
  # one.
  # * "10.1.1.1": if the address alone is specified, the prefix will be
  # set as default 32, also known as the host prefix
  #
  # Examples:
  #
  #   # These two are the same
  #   ip = IPAddress::IPv4.new("10.0.0.1/24")
  #   ip = IPAddress("10.0.0.1/24")
  #
  #   # These two are the same
  #   IPAddress::IPv4.new "10.0.0.1/8"
  #   IPAddress::IPv4.new "10.0.0.1/255.0.0.0"
  #
  # @return [IPv4] a new instance of IPv4
  #
  # source://ipaddress//lib/ipaddress/ipv4.rb#63
  def initialize(str); end

  # Returns a new IPv4 object which is the result
  # of the summarization, if possible, of the two
  # objects
  #
  # Example:
  #
  #   ip1 = IPAddress("172.16.10.1/24")
  #   ip2 = IPAddress("172.16.11.2/24")
  #
  #   p (ip1 + ip2).map {|i| i.to_string}
  #     #=> ["172.16.10.0/23"]
  #
  # If the networks are not contiguous, returns
  # the two network numbers from the objects
  #
  #   ip1 = IPAddress("10.0.0.1/24")
  #   ip2 = IPAddress("10.0.2.1/24")
  #
  #   p (ip1 + ip2).map {|i| i.to_string}
  #     #=> ["10.0.0.0/24","10.0.2.0/24"]
  #
  # source://ipaddress//lib/ipaddress/ipv4.rb#729
  def +(oth); end

  # Returns the difference between two IP addresses
  # in unsigned int 32 bits format
  #
  # Example:
  #
  #   ip1 = IPAddress("172.16.10.0/24")
  #   ip2 = IPAddress("172.16.11.0/24")
  #
  #   puts ip1 - ip2
  #     #=> 256
  #
  # source://ipaddress//lib/ipaddress/ipv4.rb#703
  def -(oth); end

  # Splits a network into different subnets
  #
  # If the IP Address is a network, it can be divided into
  # multiple networks. If +self+ is not a network, this
  # method will calculate the network from the IP and then
  # subnet it.
  #
  # If +subnets+ is an power of two number, the resulting
  # networks will be divided evenly from the supernet.
  #
  #   network = IPAddress("172.16.10.0/24")
  #
  #   network / 4   # implies map{|i| i.to_string}
  #     #=> ["172.16.10.0/26",
  #          "172.16.10.64/26",
  #          "172.16.10.128/26",
  #          "172.16.10.192/26"]
  #
  # If +num+ is any other number, the supernet will be
  # divided into some networks with a even number of hosts and
  # other networks with the remaining addresses.
  #
  #   network = IPAddress("172.16.10.0/24")
  #
  #   network / 3   # implies map{|i| i.to_string}
  #     #=> ["172.16.10.0/26",
  #          "172.16.10.64/26",
  #          "172.16.10.128/25"]
  #
  # Returns an array of IPv4 objects
  #
  # source://ipaddress//lib/ipaddress/ipv4.rb#618
  def /(subnets = T.unsafe(nil)); end

  # Spaceship operator to compare IPv4 objects
  #
  # Comparing IPv4 addresses is useful to ordinate
  # them into lists that match our intuitive
  # perception of ordered IP addresses.
  #
  # The first comparison criteria is the u32 value.
  # For example, 10.100.100.1 will be considered
  # to be less than 172.16.0.1, because, in a ordered list,
  # we expect 10.100.100.1 to come before 172.16.0.1.
  #
  # The second criteria, in case two IPv4 objects
  # have identical addresses, is the prefix. An higher
  # prefix will be considered greater than a lower
  # prefix. This is because we expect to see
  # 10.100.100.0/24 come before 10.100.100.0/25.
  #
  # Example:
  #
  #   ip1 = IPAddress "10.100.100.1/8"
  #   ip2 = IPAddress "172.16.0.1/16"
  #   ip3 = IPAddress "10.100.100.1/16"
  #
  #   ip1 < ip2
  #     #=> true
  #   ip1 > ip3
  #     #=> false
  #
  #   [ip1,ip2,ip3].sort.map{|i| i.to_string}
  #     #=> ["10.100.100.1/8","10.100.100.1/16","172.16.0.1/16"]
  #
  # source://ipaddress//lib/ipaddress/ipv4.rb#460
  def <=>(oth); end

  # Returns the octet specified by index
  #
  #   ip = IPAddress("172.16.100.50/24")
  #
  #   ip[0]
  #     #=> 172
  #   ip[1]
  #     #=> 16
  #   ip[2]
  #     #=> 100
  #   ip[3]
  #     #=> 50
  #
  # source://ipaddress//lib/ipaddress/ipv4.rb#270
  def [](index); end

  # Checks whether the ip address belongs to a
  # RFC 791 CLASS A network, no matter
  # what the subnet mask is.
  #
  # Example:
  #
  #   ip = IPAddress("10.0.0.1/24")
  #
  #   ip.a?
  #     #=> true
  #
  # @return [Boolean]
  #
  # source://ipaddress//lib/ipaddress/ipv4.rb#745
  def a?; end

  # Returns the address portion of the IPv4 object
  # as a string.
  #
  #   ip = IPAddress("172.16.100.4/22")
  #
  #   ip.address
  #     #=> "172.16.100.4"
  #
  # source://ipaddress//lib/ipaddress/ipv4.rb#103
  def address; end

  # Returns the IP address in in-addr.arpa format
  # for DNS lookups
  #
  #   ip = IPAddress("172.16.100.50/24")
  #
  #   ip.reverse
  #     #=> "50.100.16.172.in-addr.arpa"
  #
  # source://ipaddress//lib/ipaddress/ipv4.rb#581
  def arpa; end

  # Checks whether the ip address belongs to a
  # RFC 791 CLASS B network, no matter
  # what the subnet mask is.
  #
  # Example:
  #
  #   ip = IPAddress("172.16.10.1/24")
  #
  #   ip.b?
  #     #=> true
  #
  # @return [Boolean]
  #
  # source://ipaddress//lib/ipaddress/ipv4.rb#761
  def b?; end

  # Returns the address portion of an IP in binary format,
  # as a string containing a sequence of 0 and 1
  #
  #   ip = IPAddress("127.0.0.1")
  #
  #   ip.bits
  #     #=> "01111111000000000000000000000001"
  #
  # source://ipaddress//lib/ipaddress/ipv4.rb#284
  def bits; end

  # Returns the broadcast address for the given IP.
  #
  #   ip = IPAddress("172.16.10.64/24")
  #
  #   ip.broadcast.to_s
  #     #=> "172.16.10.255"
  #
  # source://ipaddress//lib/ipaddress/ipv4.rb#296
  def broadcast; end

  # Returns the broadcast address in Unsigned 32bits format
  #
  #   ip = IPaddress("10.0.0.1/29")
  #
  #   ip.broadcast_u32
  #     #=> 167772167
  #
  # source://ipaddress//lib/ipaddress/ipv4.rb#517
  def broadcast_u32; end

  # Checks whether the ip address belongs to a
  # RFC 791 CLASS C network, no matter
  # what the subnet mask is.
  #
  # Example:
  #
  #   ip = IPAddress("192.168.1.1/30")
  #
  #   ip.c?
  #     #=> true
  #
  # @return [Boolean]
  #
  # source://ipaddress//lib/ipaddress/ipv4.rb#777
  def c?; end

  # Returns the address portion of an IPv4 object
  # in a network byte order format.
  #
  #   ip = IPAddress("172.16.10.1/24")
  #
  #   ip.data
  #     #=> "\254\020\n\001"
  #
  # It is usually used to include an IP address
  # in a data packet to be sent over a socket
  #
  #   a = Socket.open(params) # socket details here
  #   ip = IPAddress("10.1.1.0/24")
  #   binary_data = ["Address: "].pack("a*") + ip.data
  #
  #   # Send binary data
  #   a.puts binary_data
  #
  # source://ipaddress//lib/ipaddress/ipv4.rb#252
  def data; end

  # Iterates over all the IP addresses for the given
  # network (or IP address).
  #
  # The object yielded is a new IPv4 object created
  # from the iteration.
  #
  #   ip = IPAddress("10.0.0.1/29")
  #
  #   ip.each do |i|
  #     p i.address
  #   end
  #     #=> "10.0.0.0"
  #     #=> "10.0.0.1"
  #     #=> "10.0.0.2"
  #     #=> "10.0.0.3"
  #     #=> "10.0.0.4"
  #     #=> "10.0.0.5"
  #     #=> "10.0.0.6"
  #     #=> "10.0.0.7"
  #
  # source://ipaddress//lib/ipaddress/ipv4.rb#422
  def each; end

  # Iterates over all the hosts IP addresses for the given
  # network (or IP address).
  #
  #   ip = IPAddress("10.0.0.1/29")
  #
  #   ip.each_host do |i|
  #     p i.to_s
  #   end
  #     #=> "10.0.0.1"
  #     #=> "10.0.0.2"
  #     #=> "10.0.0.3"
  #     #=> "10.0.0.4"
  #     #=> "10.0.0.5"
  #     #=> "10.0.0.6"
  #
  # source://ipaddress//lib/ipaddress/ipv4.rb#395
  def each_host; end

  # Returns a new IPv4 object with the
  # first host IP address in the range.
  #
  # Example: given the 192.168.100.0/24 network, the first
  # host IP address is 192.168.100.1.
  #
  #   ip = IPAddress("192.168.100.0/24")
  #
  #   ip.first.to_s
  #     #=> "192.168.100.1"
  #
  # The object IP doesn't need to be a network: the method
  # automatically gets the network number from it
  #
  #   ip = IPAddress("192.168.100.50/24")
  #
  #   ip.first.to_s
  #     #=> "192.168.100.1"
  #
  # source://ipaddress//lib/ipaddress/ipv4.rb#350
  def first; end

  # Returns an array with the IP addresses of
  # all the hosts in the network.
  #
  #   ip = IPAddress("10.0.0.1/29")
  #
  #   ip.hosts.map {|i| i.address}
  #     #=> ["10.0.0.1",
  #     #=>  "10.0.0.2",
  #     #=>  "10.0.0.3",
  #     #=>  "10.0.0.4",
  #     #=>  "10.0.0.5",
  #     #=>  "10.0.0.6"]
  #
  # source://ipaddress//lib/ipaddress/ipv4.rb#493
  def hosts; end

  # Checks whether a subnet includes the given IP address.
  #
  # Accepts an IPAddress::IPv4 object.
  #
  #   ip = IPAddress("192.168.10.100/24")
  #
  #   addr = IPAddress("192.168.10.102/24")
  #
  #   ip.include? addr
  #     #=> true
  #
  #   ip.include? IPAddress("172.16.0.48/16")
  #     #=> false
  #
  # @return [Boolean]
  #
  # source://ipaddress//lib/ipaddress/ipv4.rb#536
  def include?(oth); end

  # Checks whether a subnet includes all the
  # given IPv4 objects.
  #
  #   ip = IPAddress("192.168.10.100/24")
  #
  #   addr1 = IPAddress("192.168.10.102/24")
  #   addr2 = IPAddress("192.168.10.103/24")
  #
  #   ip.include_all?(addr1,addr2)
  #     #=> true
  #
  # @return [Boolean]
  #
  # source://ipaddress//lib/ipaddress/ipv4.rb#552
  def include_all?(*others); end

  # Like its sibling method IPv4#first, this method
  # returns a new IPv4 object with the
  # last host IP address in the range.
  #
  # Example: given the 192.168.100.0/24 network, the last
  # host IP address is 192.168.100.254
  #
  #   ip = IPAddress("192.168.100.0/24")
  #
  #   ip.last.to_s
  #     #=> "192.168.100.254"
  #
  # The object IP doesn't need to be a network: the method
  # automatically gets the network number from it
  #
  #   ip = IPAddress("192.168.100.50/24")
  #
  #   ip.last.to_s
  #     #=> "192.168.100.254"
  #
  # source://ipaddress//lib/ipaddress/ipv4.rb#375
  def last; end

  # Returns the prefix as a string in IP format
  #
  #   ip = IPAddress("172.16.100.4/22")
  #
  #   ip.netmask
  #     #=> "255.255.252.0"
  #
  # source://ipaddress//lib/ipaddress/ipv4.rb#191
  def netmask; end

  # Like IPv4#prefix=, this method allow you to
  # change the prefix / netmask of an IP address
  # object.
  #
  #   ip = IPAddress("172.16.100.4")
  #
  #   puts ip
  #     #=> 172.16.100.4/16
  #
  #   ip.netmask = "255.255.252.0"
  #
  #   puts ip
  #     #=> 172.16.100.4/22
  #
  # source://ipaddress//lib/ipaddress/ipv4.rb#210
  def netmask=(addr); end

  # Returns a new IPv4 object with the network number
  # for the given IP.
  #
  #   ip = IPAddress("172.16.10.64/24")
  #
  #   ip.network.to_s
  #     #=> "172.16.10.0"
  #
  # source://ipaddress//lib/ipaddress/ipv4.rb#326
  def network; end

  # Checks if the IP address is actually a network
  #
  #   ip = IPAddress("172.16.10.64/24")
  #
  #   ip.network?
  #     #=> false
  #
  #   ip = IPAddress("172.16.10.64/26")
  #
  #   ip.network?
  #     #=> true
  #
  # @return [Boolean]
  #
  # source://ipaddress//lib/ipaddress/ipv4.rb#313
  def network?; end

  # Returns the network number in Unsigned 32bits format
  #
  #   ip = IPAddress("10.0.0.1/29")
  #
  #   ip.network_u32
  #     #=> 167772160
  #
  # source://ipaddress//lib/ipaddress/ipv4.rb#505
  def network_u32; end

  # Returns the octet specified by index
  #
  #   ip = IPAddress("172.16.100.50/24")
  #
  #   ip[0]
  #     #=> 172
  #   ip[1]
  #     #=> 16
  #   ip[2]
  #     #=> 100
  #   ip[3]
  #     #=> 50
  #
  # source://ipaddress//lib/ipaddress/ipv4.rb#270
  def octet(index); end

  # Returns the address as an array of decimal values
  #
  #   ip = IPAddress("172.16.100.4")
  #
  #   ip.octets
  #     #=> [172, 16, 100, 4]
  #
  # source://ipaddress//lib/ipaddress/ipv4.rb#153
  def octets; end

  # Returns the prefix portion of the IPv4 object
  # as a IPAddress::Prefix32 object
  #
  #   ip = IPAddress("172.16.100.4/22")
  #
  #   ip.prefix
  #     #=> 22
  #
  #   ip.prefix.class
  #     #=> IPAddress::Prefix32
  #
  # source://ipaddress//lib/ipaddress/ipv4.rb#119
  def prefix; end

  # Set a new prefix number for the object
  #
  # This is useful if you want to change the prefix
  # to an object created with IPv4::parse_u32 or
  # if the object was created using the classful
  # mask.
  #
  #   ip = IPAddress("172.16.100.4")
  #
  #   puts ip
  #     #=> 172.16.100.4/16
  #
  #   ip.prefix = 22
  #
  #   puts ip
  #     #=> 172.16.100.4/22
  #
  # source://ipaddress//lib/ipaddress/ipv4.rb#141
  def prefix=(num); end

  # Checks if an IPv4 address objects belongs
  # to a private network RFC1918
  #
  # Example:
  #
  #   ip = IPAddress "10.1.1.1/24"
  #   ip.private?
  #     #=> true
  #
  # @return [Boolean]
  #
  # source://ipaddress//lib/ipaddress/ipv4.rb#566
  def private?; end

  # Returns the IP address in in-addr.arpa format
  # for DNS lookups
  #
  #   ip = IPAddress("172.16.100.50/24")
  #
  #   ip.reverse
  #     #=> "50.100.16.172.in-addr.arpa"
  #
  # source://ipaddress//lib/ipaddress/ipv4.rb#581
  def reverse; end

  # Returns the number of IP addresses included
  # in the network. It also counts the network
  # address and the broadcast address.
  #
  #   ip = IPAddress("10.0.0.1/29")
  #
  #   ip.size
  #     #=> 8
  #
  # source://ipaddress//lib/ipaddress/ipv4.rb#475
  def size; end

  # Splits a network into different subnets
  #
  # If the IP Address is a network, it can be divided into
  # multiple networks. If +self+ is not a network, this
  # method will calculate the network from the IP and then
  # subnet it.
  #
  # If +subnets+ is an power of two number, the resulting
  # networks will be divided evenly from the supernet.
  #
  #   network = IPAddress("172.16.10.0/24")
  #
  #   network / 4   # implies map{|i| i.to_string}
  #     #=> ["172.16.10.0/26",
  #          "172.16.10.64/26",
  #          "172.16.10.128/26",
  #          "172.16.10.192/26"]
  #
  # If +num+ is any other number, the supernet will be
  # divided into some networks with a even number of hosts and
  # other networks with the remaining addresses.
  #
  #   network = IPAddress("172.16.10.0/24")
  #
  #   network / 3   # implies map{|i| i.to_string}
  #     #=> ["172.16.10.0/26",
  #          "172.16.10.64/26",
  #          "172.16.10.128/25"]
  #
  # Returns an array of IPv4 objects
  #
  # source://ipaddress//lib/ipaddress/ipv4.rb#618
  def split(subnets = T.unsafe(nil)); end

  # This method implements the subnetting function
  # similar to the one described in RFC3531.
  #
  # By specifying a new prefix, the method calculates
  # the network number for the given IPv4 object
  # and calculates the subnets associated to the new
  # prefix.
  #
  # For example, given the following network:
  #
  #   ip = IPAddress "172.16.10.0/24"
  #
  # we can calculate the subnets with a /26 prefix
  #
  #   ip.subnets(26).map{&:to_string)
  #     #=> ["172.16.10.0/26", "172.16.10.64/26",
  #          "172.16.10.128/26", "172.16.10.192/26"]
  #
  # The resulting number of subnets will of course always be
  # a power of two.
  #
  # source://ipaddress//lib/ipaddress/ipv4.rb#682
  def subnet(subprefix); end

  # Returns a new IPv4 object from the supernetting
  # of the instance network.
  #
  # Supernetting is similar to subnetting, except
  # that you getting as a result a network with a
  # smaller prefix (bigger host space). For example,
  # given the network
  #
  #   ip = IPAddress("172.16.10.0/24")
  #
  # you can supernet it with a new /23 prefix
  #
  #   ip.supernet(23).to_string
  #     #=> "172.16.10.0/23"
  #
  # However if you supernet it with a /22 prefix, the
  # network address will change:
  #
  #   ip.supernet(22).to_string
  #     #=> "172.16.8.0/22"
  #
  # If +new_prefix+ is less than 1, returns 0.0.0.0/0
  #
  # @raise [ArgumentError]
  #
  # source://ipaddress//lib/ipaddress/ipv4.rb#654
  def supernet(new_prefix); end

  # Returns the address portion in unsigned
  # 32 bits integer format.
  #
  # This method is identical to the C function
  # inet_pton to create a 32 bits address family
  # structure.
  #
  #   ip = IPAddress("10.0.0.0/8")
  #
  #   ip.to_i
  #     #=> 167772160
  #
  # source://ipaddress//lib/ipaddress/ipv4.rb#227
  def to_i; end

  # Return the ip address in a format compatible
  # with the IPv6 Mapped IPv4 addresses
  #
  # Example:
  #
  #   ip = IPAddress("172.16.10.1/24")
  #
  #   ip.to_ipv6
  #     #=> "ac10:0a01"
  #
  # source://ipaddress//lib/ipaddress/ipv4.rb#792
  def to_ipv6; end

  # Returns a string with the address portion of
  # the IPv4 object
  #
  #   ip = IPAddress("172.16.100.4/22")
  #
  #   ip.to_s
  #     #=> "172.16.100.4"
  #
  # source://ipaddress//lib/ipaddress/ipv4.rb#166
  def to_s; end

  # Returns a string with the IP address in canonical
  # form.
  #
  #   ip = IPAddress("172.16.100.4/22")
  #
  #   ip.to_string
  #     #=> "172.16.100.4/22"
  #
  # source://ipaddress//lib/ipaddress/ipv4.rb#179
  def to_string; end

  # Returns the address portion in unsigned
  # 32 bits integer format.
  #
  # This method is identical to the C function
  # inet_pton to create a 32 bits address family
  # structure.
  #
  #   ip = IPAddress("10.0.0.0/8")
  #
  #   ip.to_i
  #     #=> 167772160
  #
  # source://ipaddress//lib/ipaddress/ipv4.rb#227
  def to_u32; end

  # Returns the address portion in unsigned
  # 32 bits integer format.
  #
  # This method is identical to the C function
  # inet_pton to create a 32 bits address family
  # structure.
  #
  #   ip = IPAddress("10.0.0.0/8")
  #
  #   ip.to_i
  #     #=> 167772160
  #
  # source://ipaddress//lib/ipaddress/ipv4.rb#227
  def u32; end

  private

  # source://ipaddress//lib/ipaddress/ipv4.rb#992
  def aggregate(ip1, ip2); end

  # source://ipaddress//lib/ipaddress/ipv4.rb#972
  def newprefix(num); end

  # source://ipaddress//lib/ipaddress/ipv4.rb#980
  def sum_first_found(arr); end

  class << self
    # Extract an IPv4 address from a string and
    # returns a new object
    #
    # Example:
    #
    #   str = "foobar172.16.10.1barbaz"
    #   ip = IPAddress::IPv4::extract str
    #
    #   ip.to_s
    #     #=> "172.16.10.1"
    #
    # source://ipaddress//lib/ipaddress/ipv4.rb#846
    def extract(str); end

    # Creates a new IPv4 address object by parsing the
    # address in a classful way.
    #
    # Classful addresses have a fixed netmask based on the
    # class they belong to:
    #
    # * Class A, from 0.0.0.0 to 127.255.255.255
    # * Class B, from 128.0.0.0 to 191.255.255.255
    # * Class C, D and E, from 192.0.0.0 to 255.255.255.254
    #
    # Example:
    #
    #   ip = IPAddress::IPv4.parse_classful "10.0.0.1"
    #
    #   ip.netmask
    #     #=> "255.0.0.0"
    #   ip.a?
    #     #=> true
    #
    # Note that classes C, D and E will all have a default
    # prefix of /24 or 255.255.255.0
    #
    # source://ipaddress//lib/ipaddress/ipv4.rb#957
    def parse_classful(ip); end

    # Creates a new IPv4 object from binary data,
    # like the one you get from a network stream.
    #
    # For example, on a network stream the IP 172.16.0.1
    # is represented with the binary "\254\020\n\001".
    #
    #   ip = IPAddress::IPv4::parse_data "\254\020\n\001"
    #   ip.prefix = 24
    #
    #   ip.to_string
    #     #=> "172.16.10.1/24"
    #
    # source://ipaddress//lib/ipaddress/ipv4.rb#830
    def parse_data(str, prefix = T.unsafe(nil)); end

    # Creates a new IPv4 object from an
    # unsigned 32bits integer.
    #
    #   ip = IPAddress::IPv4::parse_u32(167772160)
    #
    #   ip.prefix = 8
    #   ip.to_string
    #     #=> "10.0.0.0/8"
    #
    # The +prefix+ parameter is optional:
    #
    #   ip = IPAddress::IPv4::parse_u32(167772160, 8)
    #
    #   ip.to_string
    #     #=> "10.0.0.0/8"
    #
    # source://ipaddress//lib/ipaddress/ipv4.rb#813
    def parse_u32(u32, prefix = T.unsafe(nil)); end

    # Summarization (or aggregation) is the process when two or more
    # networks are taken together to check if a supernet, including all
    # and only these networks, exists. If it exists then this supernet
    # is called the summarized (or aggregated) network.
    #
    # It is very important to understand that summarization can only
    # occur if there are no holes in the aggregated network, or, in other
    # words, if the given networks fill completely the address space
    # of the supernet. So the two rules are:
    #
    # 1) The aggregate network must contain +all+ the IP addresses of the
    #    original networks;
    # 2) The aggregate network must contain +only+ the IP addresses of the
    #    original networks;
    #
    # A few examples will help clarify the above. Let's consider for
    # instance the following two networks:
    #
    #   ip1 = IPAddress("172.16.10.0/24")
    #   ip2 = IPAddress("172.16.11.0/24")
    #
    # These two networks can be expressed using only one IP address
    # network if we change the prefix. Let Ruby do the work:
    #
    #   IPAddress::IPv4::summarize(ip1,ip2).to_s
    #     #=> "172.16.10.0/23"
    #
    # We note how the network "172.16.10.0/23" includes all the addresses
    # specified in the above networks, and (more important) includes
    # ONLY those addresses.
    #
    # If we summarized +ip1+ and +ip2+ with the following network:
    #
    #   "172.16.0.0/16"
    #
    # we would have satisfied rule #1 above, but not rule #2. So "172.16.0.0/16"
    # is not an aggregate network for +ip1+ and +ip2+.
    #
    # If it's not possible to compute a single aggregated network for all the
    # original networks, the method returns an array with all the aggregate
    # networks found. For example, the following four networks can be
    # aggregated in a single /22:
    #
    #   ip1 = IPAddress("10.0.0.1/24")
    #   ip2 = IPAddress("10.0.1.1/24")
    #   ip3 = IPAddress("10.0.2.1/24")
    #   ip4 = IPAddress("10.0.3.1/24")
    #
    #   IPAddress::IPv4::summarize(ip1,ip2,ip3,ip4).to_string
    #     #=> "10.0.0.0/22",
    #
    # But the following networks can't be summarized in a single network:
    #
    #   ip1 = IPAddress("10.0.1.1/24")
    #   ip2 = IPAddress("10.0.2.1/24")
    #   ip3 = IPAddress("10.0.3.1/24")
    #   ip4 = IPAddress("10.0.4.1/24")
    #
    #   IPAddress::IPv4::summarize(ip1,ip2,ip3,ip4).map{|i| i.to_string}
    #     #=> ["10.0.1.0/24","10.0.2.0/23","10.0.4.0/24"]
    #
    # source://ipaddress//lib/ipaddress/ipv4.rb#912
    def summarize(*args); end
  end
end

# This Hash contains the prefix values for Classful networks
#
# Note that classes C, D and E will all have a default
# prefix of /24 or 255.255.255.0
#
# source://ipaddress//lib/ipaddress/ipv4.rb#29
IPAddress::IPv4::CLASSFUL = T.let(T.unsafe(nil), Hash)

# Regular expression to match an IPv4 address
#
# source://ipaddress//lib/ipaddress/ipv4.rb#38
IPAddress::IPv4::REGEXP = T.let(T.unsafe(nil), Regexp)

# =Name
#
# IPAddress::IPv6 - IP version 6 address manipulation library
#
# =Synopsis
#
#    require 'ipaddress'
#
# =Description
#
# Class IPAddress::IPv6 is used to handle IPv6 type addresses.
#
# == IPv6 addresses
#
# IPv6 addresses are 128 bits long, in contrast with IPv4 addresses
# which are only 32 bits long. An IPv6 address is generally written as
# eight groups of four hexadecimal digits, each group representing 16
# bits or two octect. For example, the following is a valid IPv6
# address:
#
#   2001:0db8:0000:0000:0008:0800:200c:417a
#
# Letters in an IPv6 address are usually written downcase, as per
# RFC. You can create a new IPv6 object using uppercase letters, but
# they will be converted.
#
# === Compression
#
# Since IPv6 addresses are very long to write, there are some
# semplifications and compressions that you can use to shorten them.
#
# * Leading zeroes: all the leading zeroes within a group can be
#   omitted: "0008" would become "8"
#
# * A string of consecutive zeroes can be replaced by the string
#   "::". This can be only applied once.
#
# Using compression, the IPv6 address written above can be shorten into
# the following, equivalent, address
#
#   2001:db8::8:800:200c:417a
#
# This short version is often used in human representation.
#
# === Network Mask
#
# As we used to do with IPv4 addresses, an IPv6 address can be written
# using the prefix notation to specify the subnet mask:
#
#   2001:db8::8:800:200c:417a/64
#
# The /64 part means that the first 64 bits of the address are
# representing the network portion, and the last 64 bits are the host
# portion.
#
# source://ipaddress//lib/ipaddress/ipv6.rb#61
class IPAddress::IPv6
  include ::IPAddress
  include ::Prelude::Enumerator
  include ::Enumerable
  include ::Comparable

  # Creates a new IPv6 address object.
  #
  # An IPv6 address can be expressed in any of the following forms:
  #
  # * "2001:0db8:0000:0000:0008:0800:200C:417A": IPv6 address with no compression
  # * "2001:db8:0:0:8:800:200C:417A": IPv6 address with leading zeros compression
  # * "2001:db8::8:800:200C:417A": IPv6 address with full compression
  #
  # In all these 3 cases, a new IPv6 address object will be created, using the default
  # subnet mask /128
  #
  # You can also specify the subnet mask as with IPv4 addresses:
  #
  #   ip6 = IPAddress "2001:db8::8:800:200c:417a/64"
  #
  # @return [IPv6] a new instance of IPv6
  #
  # source://ipaddress//lib/ipaddress/ipv6.rb#89
  def initialize(str); end

  # Spaceship operator to compare IPv6 objects
  #
  # Comparing IPv6 addresses is useful to ordinate
  # them into lists that match our intuitive
  # perception of ordered IP addresses.
  #
  # The first comparison criteria is the u128 value.
  # For example, 2001:db8:1::1 will be considered
  # to be less than 2001:db8:2::1, because, in a ordered list,
  # we expect 2001:db8:1::1 to come before 2001:db8:2::1.
  #
  # The second criteria, in case two IPv6 objects
  # have identical addresses, is the prefix. An higher
  # prefix will be considered greater than a lower
  # prefix. This is because we expect to see
  # 2001:db8:1::1/64 come before 2001:db8:1::1/65
  #
  # Example:
  #
  #   ip1 = IPAddress "2001:db8:1::1/64"
  #   ip2 = IPAddress "2001:db8:2::1/64"
  #   ip3 = IPAddress "2001:db8:1::1/65"
  #
  #   ip1 < ip2
  #     #=> true
  #   ip1 < ip3
  #     #=> false
  #
  #   [ip1,ip2,ip3].sort.map{|i| i.to_string}
  #     #=> ["2001:db8:1::1/64","2001:db8:1::1/65","2001:db8:2::1/64"]
  #
  # source://ipaddress//lib/ipaddress/ipv6.rb#480
  def <=>(oth); end

  # Returns the 16-bits value specified by index
  #
  #   ip = IPAddress("2001:db8::8:800:200c:417a/64")
  #
  #   ip[0]
  #     #=> 8193
  #   ip[1]
  #     #=> 3512
  #   ip[2]
  #     #=> 0
  #   ip[3]
  #     #=> 0
  #
  # source://ipaddress//lib/ipaddress/ipv6.rb#250
  def [](index); end

  # Returns the IPv6 address in uncompressed form:
  #
  #   ip6 = IPAddress "2001:db8::8:800:200c:417a/64"
  #
  #   ip6.address
  #     #=> "2001:0db8:0000:0000:0008:0800:200c:417a"
  #
  # source://ipaddress//lib/ipaddress/ipv6.rb#116
  def address; end

  # Returns the IPv6 address in a DNS reverse lookup
  # string, as per RFC3172 and RFC2874.
  #
  #   ip6 = IPAddress "3ffe:505:2::f"
  #
  #   ip6.reverse
  #     #=> "f.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.2.0.0.0.5.0.5.0.e.f.f.3.ip6.arpa"
  #
  # source://ipaddress//lib/ipaddress/ipv6.rb#314
  def arpa; end

  # Returns the address portion of an IP in binary format,
  # as a string containing a sequence of 0 and 1
  #
  #   ip6 = IPAddress("2001:db8::8:800:200c:417a")
  #
  #   ip6.bits
  #     #=> "0010000000000001000011011011100000 [...] "
  #
  # source://ipaddress//lib/ipaddress/ipv6.rb#494
  def bits; end

  # Returns the broadcast address in Unsigned 128bits format
  #
  #   ip6 = IPAddress "2001:db8::8:800:200c:417a/64"
  #
  #   ip6.broadcast_u128
  #     #=> 42540766411282592875350729025363378175
  #
  # Please note that there is no Broadcast concept in IPv6
  # addresses as in IPv4 addresses, and this method is just
  # an helper to other functions.
  #
  # source://ipaddress//lib/ipaddress/ipv6.rb#343
  def broadcast_u128; end

  # Compressed form of the IPv6 address
  #
  #   ip6 = IPAddress "2001:db8::8:800:200c:417a/64"
  #
  #   ip6.compressed
  #     #=> "2001:db8::8:800:200c:417a"
  #
  # source://ipaddress//lib/ipaddress/ipv6.rb#387
  def compressed; end

  # Returns the address portion of an IPv6 object
  # in a network byte order format.
  #
  #   ip6 = IPAddress "2001:db8::8:800:200c:417a/64"
  #
  #   ip6.data
  #     #=> " \001\r\270\000\000\000\000\000\b\b\000 \fAz"
  #
  # It is usually used to include an IP address
  # in a data packet to be sent over a socket
  #
  #   a = Socket.open(params) # socket details here
  #   ip6 = IPAddress "2001:db8::8:800:200c:417a/64"
  #   binary_data = ["Address: "].pack("a*") + ip.data
  #
  #   # Send binary data
  #   a.puts binary_data
  #
  # source://ipaddress//lib/ipaddress/ipv6.rb#286
  def data; end

  # Iterates over all the IP addresses for the given
  # network (or IP address).
  #
  # The object yielded is a new IPv6 object created
  # from the iteration.
  #
  #   ip6 = IPAddress("2001:db8::4/125")
  #
  #   ip6.each do |i|
  #     p i.compressed
  #   end
  #     #=> "2001:db8::"
  #     #=> "2001:db8::1"
  #     #=> "2001:db8::2"
  #     #=> "2001:db8::3"
  #     #=> "2001:db8::4"
  #     #=> "2001:db8::5"
  #     #=> "2001:db8::6"
  #     #=> "2001:db8::7"
  #
  # WARNING: if the host portion is very large, this method
  # can be very slow and possibly hang your system!
  #
  # source://ipaddress//lib/ipaddress/ipv6.rb#442
  def each; end

  # Returns the 16-bits value specified by index
  #
  #   ip = IPAddress("2001:db8::8:800:200c:417a/64")
  #
  #   ip[0]
  #     #=> 8193
  #   ip[1]
  #     #=> 3512
  #   ip[2]
  #     #=> 0
  #   ip[3]
  #     #=> 0
  #
  # source://ipaddress//lib/ipaddress/ipv6.rb#250
  def group(index); end

  # Returns an array with the 16 bits groups in decimal
  # format:
  #
  #   ip6 = IPAddress "2001:db8::8:800:200c:417a/64"
  #
  #   ip6.groups
  #     #=> [8193, 3512, 0, 0, 8, 2048, 8204, 16762]
  #
  # source://ipaddress//lib/ipaddress/ipv6.rb#129
  def groups; end

  # Returns an array of the 16 bits groups in hexdecimal
  # format:
  #
  #   ip6 = IPAddress "2001:db8::8:800:200c:417a/64"
  #
  #   ip6.hexs
  #     #=> ["2001", "0db8", "0000", "0000", "0008", "0800", "200c", "417a"]
  #
  # Not to be confused with the similar IPv6#to_hex method.
  #
  # source://ipaddress//lib/ipaddress/ipv6.rb#301
  def hexs; end

  # Checks whether a subnet includes the given IP address.
  #
  # Example:
  #
  #   ip6 = IPAddress "2001:db8::8:800:200c:417a/64"
  #   addr = IPAddress "2001:db8::8:800:200c:1/128"
  #
  #   ip6.include? addr
  #     #=> true
  #
  #   ip6.include? IPAddress("2001:db8:1::8:800:200c:417a/76")
  #     #=> false
  #
  # @return [Boolean]
  #
  # source://ipaddress//lib/ipaddress/ipv6.rb#375
  def include?(oth); end

  # Literal version of the IPv6 address
  #
  #   ip6 = IPAddress "2001:db8::8:800:200c:417a/64"
  #
  #   ip6.literal
  #     #=> "2001-0db8-0000-0000-0008-0800-200c-417a.ipv6-literal.net"
  #
  # source://ipaddress//lib/ipaddress/ipv6.rb#526
  def literal; end

  # Returns true if the address is a loopback address
  #
  # See IPAddress::IPv6::Loopback for more information
  #
  # @return [Boolean]
  #
  # source://ipaddress//lib/ipaddress/ipv6.rb#405
  def loopback?; end

  # Returns true if the address is a mapped address
  #
  # See IPAddress::IPv6::Mapped for more information
  #
  # @return [Boolean]
  #
  # source://ipaddress//lib/ipaddress/ipv6.rb#414
  def mapped?; end

  # Returns a new IPv6 object with the network number
  # for the given IP.
  #
  #   ip = IPAddress "2001:db8:1:1:1:1:1:1/32"
  #
  #   ip.network.to_string
  #     #=> "2001:db8::/32"
  #
  # source://ipaddress//lib/ipaddress/ipv6.rb#539
  def network; end

  # True if the IPv6 address is a network
  #
  #   ip6 = IPAddress "2001:db8::8:800:200c:417a/64"
  #
  #   ip6.network?
  #     #=> false
  #
  #   ip6 = IPAddress "2001:db8:8:800::/64"
  #
  #   ip6.network?
  #     #=> true
  #
  # @return [Boolean]
  #
  # source://ipaddress//lib/ipaddress/ipv6.rb#232
  def network?; end

  # Returns the network number in Unsigned 128bits format
  #
  #   ip6 = IPAddress "2001:db8::8:800:200c:417a/64"
  #
  #   ip6.network_u128
  #     #=> 42540766411282592856903984951653826560
  #
  # source://ipaddress//lib/ipaddress/ipv6.rb#327
  def network_u128; end

  # Returns an instance of the prefix object
  #
  #   ip6 = IPAddress "2001:db8::8:800:200c:417a/64"
  #
  #   ip6.prefix
  #     #=> 64
  #
  # source://ipaddress//lib/ipaddress/ipv6.rb#141
  def prefix; end

  # Set a new prefix number for the object
  #
  # This is useful if you want to change the prefix
  # to an object created with IPv6::parse_u128 or
  # if the object was created using the default prefix
  # of 128 bits.
  #
  #   ip6 = IPAddress("2001:db8::8:800:200c:417a")
  #
  #   puts ip6.to_string
  #     #=> "2001:db8::8:800:200c:417a/128"
  #
  #   ip6.prefix = 64
  #   puts ip6.to_string
  #     #=> "2001:db8::8:800:200c:417a/64"
  #
  # source://ipaddress//lib/ipaddress/ipv6.rb#162
  def prefix=(num); end

  # Returns the IPv6 address in a DNS reverse lookup
  # string, as per RFC3172 and RFC2874.
  #
  #   ip6 = IPAddress "3ffe:505:2::f"
  #
  #   ip6.reverse
  #     #=> "f.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.2.0.0.0.5.0.5.0.e.f.f.3.ip6.arpa"
  #
  # source://ipaddress//lib/ipaddress/ipv6.rb#314
  def reverse; end

  # Returns the number of IP addresses included
  # in the network. It also counts the network
  # address and the broadcast address.
  #
  #   ip6 = IPAddress("2001:db8::8:800:200c:417a/64")
  #
  #   ip6.size
  #     #=> 18446744073709551616
  #
  # source://ipaddress//lib/ipaddress/ipv6.rb#357
  def size; end

  # Returns a Base16 number representing the IPv6
  # address
  #
  #   ip6 = IPAddress "2001:db8::8:800:200c:417a/64"
  #
  #   ip6.to_hex
  #     #=> "20010db80000000000080800200c417a"
  #
  # source://ipaddress//lib/ipaddress/ipv6.rb#264
  def to_hex; end

  # Returns a decimal format (unsigned 128 bit) of the
  # IPv6 address
  #
  #   ip6 = IPAddress "2001:db8::8:800:200c:417a/64"
  #
  #   ip6.to_i
  #     #=> 42540766411282592856906245548098208122
  #
  # source://ipaddress//lib/ipaddress/ipv6.rb#214
  def to_i; end

  # Returns the IPv6 address in a human readable form,
  # using the compressed address.
  #
  #   ip6 = IPAddress "2001:db8::8:800:200c:417a/64"
  #
  #   ip6.to_s
  #     #=> "2001:db8::8:800:200c:417a"
  #
  # source://ipaddress//lib/ipaddress/ipv6.rb#201
  def to_s; end

  # Returns the IPv6 address in a human readable form,
  # using the compressed address.
  #
  #   ip6 = IPAddress "2001:0db8:0000:0000:0008:0800:200c:417a/64"
  #
  #   ip6.to_string
  #     #=> "2001:db8::8:800:200c:417a/64"
  #
  # source://ipaddress//lib/ipaddress/ipv6.rb#188
  def to_string; end

  # Unlike its counterpart IPv6#to_string method, IPv6#to_string_uncompressed
  # returns the whole IPv6 address and prefix in an uncompressed form
  #
  #   ip6 = IPAddress "2001:db8::8:800:200c:417a/64"
  #
  #   ip6.to_string_uncompressed
  #     #=> "2001:0db8:0000:0000:0008:0800:200c:417a/64"
  #
  # source://ipaddress//lib/ipaddress/ipv6.rb#175
  def to_string_uncompressed; end

  # Returns a decimal format (unsigned 128 bit) of the
  # IPv6 address
  #
  #   ip6 = IPAddress "2001:db8::8:800:200c:417a/64"
  #
  #   ip6.to_i
  #     #=> 42540766411282592856906245548098208122
  #
  # source://ipaddress//lib/ipaddress/ipv6.rb#214
  def to_u128; end

  # Returns true if the address is an unspecified address
  #
  # See IPAddress::IPv6::Unspecified for more information
  #
  # @return [Boolean]
  #
  # source://ipaddress//lib/ipaddress/ipv6.rb#396
  def unspecified?; end

  private

  # source://ipaddress//lib/ipaddress/ipv6.rb#624
  def compress_address; end

  class << self
    # Compress an IPv6 address in its compressed form
    #
    #   IPAddress::IPv6.compress "2001:0DB8:0000:CD30:0000:0000:0000:0000"
    #     #=> "2001:db8:0:cd30::"
    #
    # source://ipaddress//lib/ipaddress/ipv6.rb#514
    def compress(str); end

    # Expands an IPv6 address in the canocical form
    #
    #   IPAddress::IPv6.expand "2001:0DB8:0:CD30::"
    #     #=> "2001:0DB8:0000:CD30:0000:0000:0000:0000"
    #
    # source://ipaddress//lib/ipaddress/ipv6.rb#504
    def expand(str); end

    # Extract 16 bits groups from a string
    #
    # source://ipaddress//lib/ipaddress/ipv6.rb#546
    def groups(str); end

    # Creates a new IPv6 object from binary data,
    # like the one you get from a network stream.
    #
    # For example, on a network stream the IP
    #
    #  "2001:db8::8:800:200c:417a"
    #
    # is represented with the binary data
    #
    #   " \001\r\270\000\000\000\000\000\b\b\000 \fAz"
    #
    # With that data you can create a new IPv6 object:
    #
    #   ip6 = IPAddress::IPv6::parse_data " \001\r\270\000\000\000\000\000\b\b\000 \fAz"
    #   ip6.prefix = 64
    #
    #   ip6.to_s
    #     #=> "2001:db8::8:800:200c:417a/64"
    #
    # source://ipaddress//lib/ipaddress/ipv6.rb#575
    def parse_data(str); end

    # Creates a new IPv6 object from a number expressed in
    # hexdecimal format:
    #
    #   ip6 = IPAddress::IPv6::parse_hex("20010db80000000000080800200c417a")
    #   ip6.prefix = 64
    #
    #   ip6.to_string
    #     #=> "2001:db8::8:800:200c:417a/64"
    #
    # The +prefix+ parameter is optional:
    #
    #   ip6 = IPAddress::IPv6::parse_hex("20010db80000000000080800200c417a", 64)
    #
    #   ip6.to_string
    #     #=> "2001:db8::8:800:200c:417a/64"
    #
    # source://ipaddress//lib/ipaddress/ipv6.rb#618
    def parse_hex(hex, prefix = T.unsafe(nil)); end

    # Creates a new IPv6 object from an
    # unsigned 128 bits integer.
    #
    #   ip6 = IPAddress::IPv6::parse_u128(42540766411282592856906245548098208122)
    #   ip6.prefix = 64
    #
    #   ip6.to_string
    #     #=> "2001:db8::8:800:200c:417a/64"
    #
    # The +prefix+ parameter is optional:
    #
    #   ip6 = IPAddress::IPv6::parse_u128(42540766411282592856906245548098208122, 64)
    #
    #   ip6.to_string
    #     #=> "2001:db8::8:800:200c:417a/64"
    #
    # source://ipaddress//lib/ipaddress/ipv6.rb#596
    def parse_u128(u128, prefix = T.unsafe(nil)); end
  end
end

# Format string to pretty print IPv6 addresses
#
# source://ipaddress//lib/ipaddress/ipv6.rb#71
IPAddress::IPv6::IN6FORMAT = T.let(T.unsafe(nil), String)

# The loopback  address is a unicast localhost address. If an
# application in a host sends packets to this address, the IPv6 stack
# will loop these packets back on the same virtual interface.
#
# Loopback addresses are expressed in the following form:
#
#   ::1
#
# or, with their appropriate prefix,
#
#   ::1/128
#
# As for the unspecified addresses, IPv6 loopbacks can be created with
# IPAddress calling their own class:
#
#   ip = IPAddress::IPv6::Loopback.new
#
#   ip.to_string
#     #=> "::1/128"
#
# or by using the wrapper:
#
#   ip = IPAddress "::1"
#
#   ip.to_string
#     #=> "::1/128"
#
# Checking if an address is loopback is easy with the IPv6#loopback?
# method:
#
#   ip.loopback?
#     #=> true
#
# The IPv6 loopback address corresponds to 127.0.0.1 in IPv4.
#
# source://ipaddress//lib/ipaddress/ipv6.rb#736
class IPAddress::IPv6::Loopback < ::IPAddress::IPv6
  # Creates a new IPv6 unspecified address
  #
  #   ip = IPAddress::IPv6::Loopback.new
  #
  #   ip.to_string
  #     #=> "::1/128"
  #
  # @return [Loopback] a new instance of Loopback
  #
  # source://ipaddress//lib/ipaddress/ipv6.rb#745
  def initialize; end
end

# It is usually identified as a IPv4 mapped IPv6 address, a particular
# IPv6 address which aids the transition from IPv4 to IPv6. The
# structure of the address is
#
#   ::ffff:w.y.x.z
#
# where w.x.y.z is a normal IPv4 address. For example, the following is
# a mapped IPv6 address:
#
#   ::ffff:192.168.100.1
#
# IPAddress is very powerful in handling mapped IPv6 addresses, as the
# IPv4 portion is stored internally as a normal IPv4 object. Let's have
# a look at some examples. To create a new mapped address, just use the
# class builder itself
#
#   ip6 = IPAddress::IPv6::Mapped.new "::ffff:172.16.10.1/128"
#
# or just use the wrapper method
#
#   ip6 = IPAddress "::ffff:172.16.10.1/128"
#
# Let's check it's really a mapped address:
#
#   ip6.mapped?
#     #=> true
#
#   ip6.to_string
#     #=> "::FFFF:172.16.10.1/128"
#
# Now with the +ipv4+ attribute, we can easily access the IPv4 portion
# of the mapped IPv6 address:
#
#   ip6.ipv4.address
#     #=> "172.16.10.1"
#
# Internally, the IPv4 address is stored as two 16 bits
# groups. Therefore all the usual methods for an IPv6 address are
# working perfectly fine:
#
#   ip6.to_hex
#     #=> "00000000000000000000ffffac100a01"
#
#   ip6.address
#     #=> "0000:0000:0000:0000:0000:ffff:ac10:0a01"
#
# A mapped IPv6 can also be created just by specify the address in the
# following format:
#
#   ip6 = IPAddress "::172.16.10.1"
#
# That is, two colons and the IPv4 address. However, as by RFC, the ffff
# group will be automatically added at the beginning
#
#   ip6.to_string
#     => "::ffff:172.16.10.1/128"
#
# making it a mapped IPv6 compatible address.
#
# source://ipaddress//lib/ipaddress/ipv6.rb#813
class IPAddress::IPv6::Mapped < ::IPAddress::IPv6
  # Creates a new IPv6 IPv4-mapped address
  #
  #   ip6 = IPAddress::IPv6::Mapped.new "::ffff:172.16.10.1/128"
  #
  #   ipv6.ipv4.class
  #     #=> IPAddress::IPv4
  #
  # An IPv6 IPv4-mapped address can also be created using the
  # IPv6 only format of the address:
  #
  #   ip6 = IPAddress::IPv6::Mapped.new "::0d01:4403"
  #
  #   ip6.to_string
  #     #=> "::ffff:13.1.68.3"
  #
  # @return [Mapped] a new instance of Mapped
  #
  # source://ipaddress//lib/ipaddress/ipv6.rb#834
  def initialize(str); end

  # Access the internal IPv4 address
  #
  # source://ipaddress//lib/ipaddress/ipv6.rb#816
  def ipv4; end

  # Checks if the IPv6 address is IPv4 mapped
  #
  #   ip6 = IPAddress "::ffff:172.16.10.1/128"
  #
  #   ip6.mapped?
  #     #=> true
  #
  # @return [Boolean]
  #
  # source://ipaddress//lib/ipaddress/ipv6.rb#880
  def mapped?; end

  # Similar to IPv6#to_s, but prints out the IPv4 address
  # in dotted decimal format
  #
  #   ip6 = IPAddress "::ffff:172.16.10.1/128"
  #
  #   ip6.to_s
  #     #=> "::ffff:172.16.10.1"
  #
  # source://ipaddress//lib/ipaddress/ipv6.rb#854
  def to_s; end

  # Similar to IPv6#to_string, but prints out the IPv4 address
  # in dotted decimal format
  #
  #
  #   ip6 = IPAddress "::ffff:172.16.10.1/128"
  #
  #   ip6.to_string
  #     #=> "::ffff:172.16.10.1/128"
  #
  # source://ipaddress//lib/ipaddress/ipv6.rb#868
  def to_string; end
end

# The address with all zero bits is called the +unspecified+ address
# (corresponding to 0.0.0.0 in IPv4). It should be something like this:
#
#   0000:0000:0000:0000:0000:0000:0000:0000
#
# but, with the use of compression, it is usually written as just two
# colons:
#
#   ::
#
# or, specifying the netmask:
#
#   ::/128
#
# With IPAddress, create a new unspecified IPv6 address using its own
# subclass:
#
#   ip = IPAddress::IPv6::Unspecified.new
#
#   ip.to_s
#     #=> => "::/128"
#
# You can easily check if an IPv6 object is an unspecified address by
# using the IPv6#unspecified? method
#
#   ip.unspecified?
#     #=> true
#
# An unspecified IPv6 address can also be created with the wrapper
# method, like we've seen before
#
#   ip = IPAddress "::"
#
#   ip.unspecified?
#     #=> true
#
# This address must never be assigned to an interface and is to be used
# only in software before the application has learned its host's source
# address appropriate for a pending connection. Routers must not forward
# packets with the unspecified address.
#
# source://ipaddress//lib/ipaddress/ipv6.rb#683
class IPAddress::IPv6::Unspecified < ::IPAddress::IPv6
  # Creates a new IPv6 unspecified address
  #
  #   ip = IPAddress::IPv6::Unspecified.new
  #
  #   ip.to_s
  #      #=> => "::/128"
  #
  # @return [Unspecified] a new instance of Unspecified
  #
  # source://ipaddress//lib/ipaddress/ipv6.rb#692
  def initialize; end
end

# source://ipaddress//lib/ipaddress.rb#20
IPAddress::NAME = T.let(T.unsafe(nil), String)

# =NAME
#
# IPAddress::Prefix
#
# =SYNOPSIS
#
# Parent class for Prefix32 and Prefix128
#
# =DESCRIPTION
#
# IPAddress::Prefix is the parent class for IPAddress::Prefix32
# and IPAddress::Prefix128, defining some modules in common for
# both the subclasses.
#
# IPAddress::Prefix shouldn't be accesses directly, unless
# for particular needs.
#
# source://ipaddress//lib/ipaddress/prefix.rb#21
class IPAddress::Prefix
  include ::Comparable

  # Creates a new general prefix
  #
  # @return [Prefix] a new instance of Prefix
  #
  # source://ipaddress//lib/ipaddress/prefix.rb#30
  def initialize(num); end

  # Sums two prefixes or a prefix to a
  # number, returns a Fixnum
  #
  # source://ipaddress//lib/ipaddress/prefix.rb#60
  def +(oth); end

  # Returns the difference between two
  # prefixes, or a prefix and a number,
  # as a Fixnum
  #
  # source://ipaddress//lib/ipaddress/prefix.rb#73
  def -(oth); end

  # Compare the prefix
  #
  # source://ipaddress//lib/ipaddress/prefix.rb#52
  def <=>(oth); end

  # Returns a string with the prefix
  #
  # source://ipaddress//lib/ipaddress/prefix.rb#37
  def inspect; end

  # Returns the value of attribute prefix.
  #
  # source://ipaddress//lib/ipaddress/prefix.rb#25
  def prefix; end

  # Returns the prefix
  #
  # source://ipaddress//lib/ipaddress/prefix.rb#45
  def to_i; end

  # Returns a string with the prefix
  #
  # source://ipaddress//lib/ipaddress/prefix.rb#37
  def to_s; end
end

# class Prefix32 < Prefix
#
# source://ipaddress//lib/ipaddress/prefix.rb#208
class IPAddress::Prefix128 < ::IPAddress::Prefix
  # Creates a new prefix object for 128 bits IPv6 addresses
  #
  #   prefix = IPAddress::Prefix128.new 64
  #     #=> 64
  #
  # @return [Prefix128] a new instance of Prefix128
  #
  # source://ipaddress//lib/ipaddress/prefix.rb#216
  def initialize(num = T.unsafe(nil)); end

  # Transforms the prefix into a string of bits
  # representing the netmask
  #
  #   prefix = IPAddress::Prefix128.new 64
  #
  #   prefix.bits
  #     #=> "1111111111111111111111111111111111111111111111111111111111111111"
  #         "0000000000000000000000000000000000000000000000000000000000000000"
  #
  # source://ipaddress//lib/ipaddress/prefix.rb#233
  def bits; end

  # Returns the length of the host portion
  # of a netmask.
  #
  #   prefix = Prefix128.new 96
  #
  #   prefix.host_prefix
  #     #=> 32
  #
  # source://ipaddress//lib/ipaddress/prefix.rb#259
  def host_prefix; end

  # Unsigned 128 bits decimal number representing
  # the prefix
  #
  #   prefix = IPAddress::Prefix128.new 64
  #
  #   prefix.to_u128
  #     #=> 340282366920938463444927863358058659840
  #
  # source://ipaddress//lib/ipaddress/prefix.rb#246
  def to_u128; end
end

# source://ipaddress//lib/ipaddress/prefix.rb#84
class IPAddress::Prefix32 < ::IPAddress::Prefix
  # Creates a new prefix object for 32 bits IPv4 addresses
  #
  #   prefix = IPAddress::Prefix32.new 24
  #     #=> 24
  #
  # @return [Prefix32] a new instance of Prefix32
  #
  # source://ipaddress//lib/ipaddress/prefix.rb#94
  def initialize(num); end

  # Shortcut for the octecs in the dotted decimal
  # representation
  #
  #   prefix = IPAddress::Prefix32.new 24
  #
  #   prefix[2]
  #     #=> 255
  #
  # source://ipaddress//lib/ipaddress/prefix.rb#175
  def [](index); end

  # Transforms the prefix into a string of bits
  # representing the netmask
  #
  #   prefix = IPAddress::Prefix32.new 24
  #
  #   prefix.bits
  #     #=> "11111111111111111111111100000000"
  #
  # source://ipaddress//lib/ipaddress/prefix.rb#123
  def bits; end

  # Returns the length of the host portion
  # of a netmask.
  #
  #   prefix = Prefix32.new 24
  #
  #   prefix.host_prefix
  #     #=> 8
  #
  # source://ipaddress//lib/ipaddress/prefix.rb#110
  def host_prefix; end

  # The hostmask is the contrary of the subnet mask,
  # as it shows the bits that can change within the
  # hosts
  #
  #   prefix = IPAddress::Prefix32.new 24
  #
  #   prefix.hostmask
  #     #=> "0.0.0.255"
  #
  # source://ipaddress//lib/ipaddress/prefix.rb#189
  def hostmask; end

  # An array of octets of the IPv4 dotted decimal
  # format
  #
  #   prefix = IPAddress::Prefix32.new 24
  #
  #   prefix.octets
  #     #=> [255, 255, 255, 0]
  #
  # source://ipaddress//lib/ipaddress/prefix.rb#149
  def octets; end

  # Gives the prefix in IPv4 dotted decimal format,
  # i.e. the canonical netmask we're all used to
  #
  #   prefix = IPAddress::Prefix32.new 24
  #
  #   prefix.to_ip
  #     #=> "255.255.255.0"
  #
  # source://ipaddress//lib/ipaddress/prefix.rb#136
  def to_ip; end

  # Unsigned 32 bits decimal number representing
  # the prefix
  #
  #   prefix = IPAddress::Prefix32.new 24
  #
  #   prefix.to_u32
  #     #=> 4294967040
  #
  # source://ipaddress//lib/ipaddress/prefix.rb#162
  def to_u32; end

  class << self
    # Creates a new prefix by parsing a netmask in
    # dotted decimal form
    #
    #   prefix = IPAddress::Prefix32::parse_netmask "255.255.255.0"
    #     #=> 24
    #
    # source://ipaddress//lib/ipaddress/prefix.rb#200
    def parse_netmask(netmask); end
  end
end

# source://ipaddress//lib/ipaddress/prefix.rb#86
IPAddress::Prefix32::IN4MASK = T.let(T.unsafe(nil), Integer)

class Object < ::BasicObject
  include ::Kernel
  include ::JSON::Ext::Generator::GeneratorMethods::Object
  include ::PP::ObjectMixin
  include ::ActiveSupport::Tryable
  include ::ERB::Escape
  include ::ActiveSupport::CoreExt::ERBUtil
  include ::ActiveSupport::CoreExt::ERBUtilPrivate

  private

  # source://ipaddress//lib/ipaddress.rb#185
  def IPAddress(str); end
end
