# typed: true

# DO NOT EDIT MANUALLY
# This is an autogenerated file for types exported from the `licensed` gem.
# Please instead update this file by running `bin/tapioca gem licensed`.

# source://licensed//lib/licensed/sources/bundler/missing_specification.rb#61
class Bundler::LazySpecification
  include ::Licensed::Bundler::LazySpecification
  include ::Bundler::GemHelpers
end

# This monkey patch instead creates MissingSpecification objects to
# identify missing specs without raising errors and halting enumeration.
# It was the most minimal-touch solution I could think of that should reliably
# work across many bundler versions
#
# source://licensed//lib/licensed/version.rb#2
module Licensed
  class << self
    # source://licensed//lib/licensed/version.rb#5
    def previous_major_versions; end
  end
end

# source://licensed//lib/licensed/configuration.rb#5
class Licensed::AppConfiguration < ::Hash
  # @return [AppConfiguration] a new instance of AppConfiguration
  #
  # source://licensed//lib/licensed/configuration.rb#23
  def initialize(options = T.unsafe(nil), inherited_options = T.unsafe(nil)); end

  # source://licensed//lib/licensed/configuration.rb#117
  def additional_terms_for_dependency(dependency); end

  # source://licensed//lib/licensed/configuration.rb#112
  def allow(license); end

  # source://licensed//lib/licensed/configuration.rb#93
  def allowed?(license); end

  # Returns the path to the app cache directory as a Pathname
  #
  # source://licensed//lib/licensed/configuration.rb#50
  def cache_path; end

  # Returns whether a source type is enabled
  #
  # @return [Boolean]
  #
  # source://licensed//lib/licensed/configuration.rb#71
  def enabled?(source_type); end

  # Ignore a dependency
  #
  # source://licensed//lib/licensed/configuration.rb#98
  def ignore(dependency, at_version: T.unsafe(nil)); end

  # Is the given dependency ignored?
  #
  # @return [Boolean]
  #
  # source://licensed//lib/licensed/configuration.rb#88
  def ignored?(dependency, require_version: T.unsafe(nil)); end

  # source://licensed//lib/licensed/configuration.rb#59
  def pwd; end

  # Set a dependency as reviewed
  #
  # source://licensed//lib/licensed/configuration.rb#105
  def review(dependency, at_version: T.unsafe(nil)); end

  # Is the given dependency reviewed?
  #
  # @return [Boolean]
  #
  # source://licensed//lib/licensed/configuration.rb#78
  def reviewed?(dependency, require_version: T.unsafe(nil)); end

  # Find all reviewed dependencies that match the provided dependency's name
  #
  # source://licensed//lib/licensed/configuration.rb#83
  def reviewed_versions(dependency); end

  # Returns the path to the workspace root as a Pathname.
  #
  # source://licensed//lib/licensed/configuration.rb#45
  def root; end

  # Returns the path to the app source directory as a Pathname
  #
  # source://licensed//lib/licensed/configuration.rb#55
  def source_path; end

  # Returns an array of enabled app sources
  #
  # source://licensed//lib/licensed/configuration.rb#64
  def sources; end

  private

  # @return [Boolean]
  #
  # source://licensed//lib/licensed/configuration.rb#124
  def any_list_pattern_matched?(list, dependency, require_version: T.unsafe(nil)); end

  # Returns the cache path for the application based on:
  # 1. An explicitly set cache path for the application, if set
  # 2. An inherited shared cache path
  # 3. An inherited cache path joined with the app name if not shared
  # 4. The default cache path joined with the app name
  #
  # source://licensed//lib/licensed/configuration.rb#176
  def detect_cache_path(options, inherited_options); end

  # Returns a name for the application as one of:
  # 1. An explicitly configured app name, if set
  # 2. A generated app name based on an configured "name" options hash
  # 3. A default value - the source_path directory name
  #
  # source://licensed//lib/licensed/configuration.rb#198
  def generate_app_name; end

  # Returns an app name from the relative path from the configured app root
  # to the configured app source path.
  #
  # source://licensed//lib/licensed/configuration.rb#223
  def relative_path_app_name; end

  # source://licensed//lib/licensed/configuration.rb#162
  def similar_list_patterns(list, dependency); end

  # Returns an app name from the directory name of the configured source path
  #
  # source://licensed//lib/licensed/configuration.rb#217
  def source_path_directory_app_name; end

  # @raise [Licensed::Configuration::LoadError]
  #
  # source://licensed//lib/licensed/configuration.rb#188
  def verify_arg(property); end

  class << self
    # Returns the root for a configuration in following order of precedence:
    # 1. explicitly configured "root" property
    # 2. a found git repository root
    # 3. the current directory
    #
    # source://licensed//lib/licensed/configuration.rb#19
    def root_for(configuration); end
  end
end

# source://licensed//lib/licensed/configuration.rb#9
Licensed::AppConfiguration::ALL_NAME_GENERATOR_KEYS = T.let(T.unsafe(nil), Array)

# source://licensed//lib/licensed/configuration.rb#13
Licensed::AppConfiguration::ANY_VERSION_REQUIREMENT = T.let(T.unsafe(nil), String)

# source://licensed//lib/licensed/configuration.rb#11
Licensed::AppConfiguration::DEFAULT_CACHE_PATH = T.let(T.unsafe(nil), String)

# source://licensed//lib/licensed/configuration.rb#8
Licensed::AppConfiguration::DEFAULT_RELATIVE_PATH_NAME_SEPARATOR = T.let(T.unsafe(nil), String)

# source://licensed//lib/licensed/configuration.rb#6
Licensed::AppConfiguration::DIRECTORY_NAME_GENERATOR_KEY = T.let(T.unsafe(nil), String)

# source://licensed//lib/licensed/configuration.rb#7
Licensed::AppConfiguration::RELATIVE_PATH_GENERATOR_KEY = T.let(T.unsafe(nil), String)

# source://licensed//lib/licensed/sources/bundler/missing_specification.rb#14
module Licensed::Bundler; end

# source://licensed//lib/licensed/sources/bundler/definition.rb#5
module Licensed::Bundler::DefinitionExtensions
  # source://licensed//lib/licensed/sources/bundler/definition.rb#29
  def bundler_query; end

  # Returns the value of attribute force_exclude_groups.
  #
  # source://licensed//lib/licensed/sources/bundler/definition.rb#6
  def force_exclude_groups; end

  # Sets the attribute force_exclude_groups
  #
  # @param value the value to set the attribute force_exclude_groups to.
  #
  # source://licensed//lib/licensed/sources/bundler/definition.rb#6
  def force_exclude_groups=(_arg0); end

  # source://licensed//lib/licensed/sources/bundler/definition.rb#39
  def requested_groups; end

  # source://licensed//lib/licensed/sources/bundler/definition.rb#15
  def specs; end
end

# source://licensed//lib/licensed/sources/bundler/missing_specification.rb#42
module Licensed::Bundler::LazySpecification
  # source://licensed//lib/licensed/sources/bundler/missing_specification.rb#50
  def __materialize__(*args, **kwargs); end

  # source://licensed//lib/licensed/sources/bundler/missing_specification.rb#43
  def materialize_for_installation(*args); end
end

# source://licensed//lib/licensed/sources/bundler/missing_specification.rb#15
class Licensed::Bundler::MissingSpecification < ::Gem::BasicSpecification
  include ::Bundler::GemHelpers
  include ::Bundler::MatchPlatform

  # @return [MissingSpecification] a new instance of MissingSpecification
  #
  # source://licensed//lib/licensed/sources/bundler/missing_specification.rb#19
  def initialize(name:, version:, platform:, source:); end

  # source://licensed//lib/licensed/sources/bundler/missing_specification.rb#26
  def dependencies; end

  # source://licensed//lib/licensed/sources/bundler/missing_specification.rb#37
  def error; end

  # source://licensed//lib/licensed/sources/bundler/missing_specification.rb#30
  def gem_dir; end

  # source://licensed//lib/licensed/sources/bundler/missing_specification.rb#31
  def gems_dir; end

  # source://licensed//lib/licensed/sources/bundler/missing_specification.rb#35
  def homepage; end

  # Returns the value of attribute name.
  #
  # source://licensed//lib/licensed/sources/bundler/missing_specification.rb#18
  def name; end

  # Returns the value of attribute platform.
  #
  # source://licensed//lib/licensed/sources/bundler/missing_specification.rb#18
  def platform; end

  # Returns the value of attribute source.
  #
  # source://licensed//lib/licensed/sources/bundler/missing_specification.rb#18
  def source; end

  # source://licensed//lib/licensed/sources/bundler/missing_specification.rb#34
  def summary; end

  # Returns the value of attribute version.
  #
  # source://licensed//lib/licensed/sources/bundler/missing_specification.rb#18
  def version; end
end

# source://licensed//lib/licensed/commands.rb#3
module Licensed::Commands; end

# source://licensed//lib/licensed/commands/cache.rb#4
class Licensed::Commands::Cache < ::Licensed::Commands::Command
  # source://licensed//lib/licensed/commands/cache.rb#10
  def default_reporter(options); end

  protected

  # Set of unique cache paths that are evaluted during the run
  #
  # source://licensed//lib/licensed/commands/cache.rb#155
  def cache_paths; end

  # Clean up cached files that dont match current dependencies
  #
  # Returns nothing
  #
  # source://licensed//lib/licensed/commands/cache.rb#144
  def clear_stale_cached_records; end

  # Cache dependency record data.
  #
  # app - The application configuration for the dependency
  # source - The dependency source enumerator for the dependency
  # dependency - An application dependency
  # report - A report hash for the command to provide extra data for the report output.
  #
  # Returns true.
  #
  # source://licensed//lib/licensed/commands/cache.rb#72
  def evaluate_dependency(app, source, dependency, report); end

  # Set of unique absolute file paths of cached records evaluted during the run
  #
  # source://licensed//lib/licensed/commands/cache.rb#160
  def files; end

  # source://licensed//lib/licensed/commands/cache.rb#39
  def run_app(app, report); end

  # Run the command.
  # Removes any cached records that don't match a current application
  # dependency.
  #
  # options - Options to run the command with
  #
  # Returns whether the command was a success
  #
  # source://licensed//lib/licensed/commands/cache.rb#23
  def run_command(report); end

  # Run the command for all enumerated dependencies found in a dependency source,
  # recording results in a report.
  # Enumerating dependencies in the source is skipped if a :sources option
  # is provided and the evaluated `source.class.type` is not in the :sources values
  #
  # app - The application configuration for the source
  # source - A dependency source enumerator
  #
  # Returns whether the command succeeded for the dependency source enumerator
  #
  # source://licensed//lib/licensed/commands/cache.rb#54
  def run_source(app, source, report); end

  # Determine if the current dependency's record should be saved.
  # The record should be saved if:
  # 1. there is no cached record
  # 2. the cached record doesn't have a version set
  # 3. the cached record version doesn't match the current dependency version
  #
  # dependency - An application dependency
  # cached_record - A dependency record to compare with the dependency
  #
  # Returns true if dependency's record should be saved
  #
  # @return [Boolean]
  #
  # source://licensed//lib/licensed/commands/cache.rb#114
  def save_dependency_record?(dependency, cached_record); end

  # Update dependency metadata from the cached record, to support:
  # 1. continuity between cache runs to cut down on churn
  # 2. notifying users when changed content needs to be reviewed
  #
  # source://licensed//lib/licensed/commands/cache.rb#127
  def update_dependency_from_cached_record(app, source, dependency, cached_record); end

  # source://licensed//lib/licensed/commands/cache.rb#165
  def with_licensee_configuration(app, report); end
end

# source://licensed//lib/licensed/commands/command.rb#4
class Licensed::Commands::Command
  # @return [Command] a new instance of Command
  #
  # source://licensed//lib/licensed/commands/command.rb#9
  def initialize(config:); end

  # Returns the value of attribute config.
  #
  # source://licensed//lib/licensed/commands/command.rb#5
  def config; end

  # Creates a reporter to use during a command run
  #
  # options - The options the command was run with
  #
  # Returns the reporter to use during the command run
  #
  # source://licensed//lib/licensed/commands/command.rb#34
  def create_reporter(options); end

  # Returns the default reporter to use during the command run
  #
  # options - The options the command was run with
  #
  # Raises an error
  #
  # source://licensed//lib/licensed/commands/command.rb#50
  def default_reporter(options); end

  # Returns the value of attribute options.
  #
  # source://licensed//lib/licensed/commands/command.rb#7
  def options; end

  # Returns the value of attribute reporter.
  #
  # source://licensed//lib/licensed/commands/command.rb#6
  def reporter; end

  # Run the command
  #
  # options - Options to run the command with
  #
  # Returns whether the command was a success
  #
  # source://licensed//lib/licensed/commands/command.rb#18
  def run(**options); end

  protected

  # Evaluate a dependency for the command.  Must be implemented by a command implementation.
  #
  # app - The application configuration for the dependency
  # source - The dependency source enumerator for the dependency
  # dependency - An application dependency
  # report - A report hash for the command to provide extra data for the report output.
  #
  # Returns whether the command succeeded for the dependency
  #
  # source://licensed//lib/licensed/commands/command.rb#196
  def evaluate_dependency(app, source, dependency, report); end

  # Run the command for all enabled sources for an application configuration,
  # recording results in a report.
  #
  # app - An application configuration
  # report - A report object for this application
  #
  # Returns whether the command succeeded for the application.
  #
  # source://licensed//lib/licensed/commands/command.rb#86
  def run_app(app, report); end

  # source://licensed//lib/licensed/commands/command.rb#61
  def run_command(report); end

  # Run the command for a dependency, evaluating the dependency and
  # recording results in a report.  Dependencies that were found with errors
  # are not evaluated and add any errors to the dependency report.
  #
  # app - The application configuration for the dependency
  # source - The dependency source enumerator for the dependency
  # dependency - An application dependency
  # report - A report object for this dependency
  #
  # Returns whether the command succeeded for the dependency
  #
  # source://licensed//lib/licensed/commands/command.rb#168
  def run_dependency(app, source, dependency, report); end

  # Run the command for all enumerated dependencies found in a dependency source,
  # recording results in a report.
  #
  # app - The application configuration for the source
  # source - A dependency source enumerator
  # report - A report object for this source
  #
  # Returns whether the command succeeded, failed, or was skipped for the dependency source enumerator
  #
  # source://licensed//lib/licensed/commands/command.rb#125
  def run_source(app, source, report); end

  # source://licensed//lib/licensed/commands/command.rb#200
  def sources_overrides; end
end

# source://licensed//lib/licensed/commands/environment.rb#4
class Licensed::Commands::Environment < ::Licensed::Commands::Command
  # source://licensed//lib/licensed/commands/environment.rb#37
  def default_reporter(options); end

  protected

  # source://licensed//lib/licensed/commands/environment.rb#48
  def run_app(app, report); end

  # source://licensed//lib/licensed/commands/environment.rb#43
  def run_command(report); end

  # source://licensed//lib/licensed/commands/environment.rb#53
  def run_source(app, source, report); end
end

# source://licensed//lib/licensed/commands/environment.rb#5
class Licensed::Commands::Environment::AppEnvironment
  include ::Licensed::Sources::ContentVersioning

  # @return [AppEnvironment] a new instance of AppEnvironment
  #
  # source://licensed//lib/licensed/commands/environment.rb#9
  def initialize(config); end

  # Returns the value of attribute config.
  #
  # source://licensed//lib/licensed/commands/environment.rb#8
  def config; end

  # source://licensed//lib/licensed/commands/environment.rb#13
  def enabled_source_types; end

  # source://licensed//lib/licensed/commands/environment.rb#17
  def to_h; end
end

# source://licensed//lib/licensed/commands/list.rb#4
class Licensed::Commands::List < ::Licensed::Commands::Command
  # source://licensed//lib/licensed/commands/list.rb#10
  def default_reporter(options); end

  protected

  # Listing dependencies requires no extra work.
  #
  # app - The application configuration for the dependency
  # source - The dependency source enumerator for the dependency
  # dependency - An application dependency
  # report - A report hash for the command to provide extra data for the report output.
  #
  # Returns true.
  #
  # source://licensed//lib/licensed/commands/list.rb#24
  def evaluate_dependency(app, source, dependency, report); end
end

# source://licensed//lib/licensed/commands/notices.rb#4
class Licensed::Commands::Notices < ::Licensed::Commands::Command
  # source://licensed//lib/licensed/commands/notices.rb#10
  def default_reporter(options); end

  protected

  # Load a dependency record data and add it to the notices report.
  #
  # app - The application configuration for the dependency
  # source - The dependency source enumerator for the dependency
  # dependency - An application dependency
  # report - A report hash for the command to provide extra data for the report output.
  #
  # Returns true.
  #
  # source://licensed//lib/licensed/commands/notices.rb#24
  def evaluate_dependency(app, source, dependency, report); end

  # Loads a dependency record from a cached file.
  #
  # app - The application configuration for the dependency
  # source - The dependency source enumerator for the dependency
  # dependency - An application dependency
  # report - A report hash for the command to provide extra data for the report output.
  #
  # Returns a dependency record or nil if one doesn't exist
  #
  # source://licensed//lib/licensed/commands/notices.rb#43
  def load_cached_dependency_record(app, source, dependency, report); end

  # source://licensed//lib/licensed/commands/notices.rb#53
  def load_dependency_record_from_files; end
end

# source://licensed//lib/licensed/commands/status.rb#6
class Licensed::Commands::Status < ::Licensed::Commands::Command
  # source://licensed//lib/licensed/commands/status.rb#12
  def default_reporter(options); end

  protected

  # Set of unique cache paths that are evaluted during the run
  #
  # source://licensed//lib/licensed/commands/status.rb#189
  def cache_paths; end

  # source://licensed//lib/licensed/commands/status.rb#161
  def cached_record(filename); end

  # source://licensed//lib/licensed/commands/status.rb#157
  def data_source; end

  # source://licensed//lib/licensed/commands/status.rb#81
  def evaluate_dependency(app, source, dependency, report); end

  # Set of unique absolute file paths of cached records evaluted during the run
  #
  # source://licensed//lib/licensed/commands/status.rb#194
  def files; end

  # source://licensed//lib/licensed/commands/status.rb#168
  def license_from_text(text); end

  # source://licensed//lib/licensed/commands/status.rb#114
  def license_needs_review?(app, source, record); end

  # source://licensed//lib/licensed/commands/status.rb#138
  def needs_review_error_message(app, record); end

  # source://licensed//lib/licensed/commands/status.rb#24
  def run_command(report); end

  # Run the command for all enumerated dependencies found in a dependency source,
  # recording results in a report.
  # Enumerating dependencies in the source is skipped if a :sources option
  # is provided and the evaluated `source.class.type` is not in the :sources values
  #
  # app - The application configuration for the source
  # source - A dependency source enumerator
  #
  # Returns whether the command succeeded for the dependency source enumerator
  #
  # source://licensed//lib/licensed/commands/status.rb#60
  def run_source(app, source, report); end

  # Check for cached files that don't match current dependencies
  #
  # Returns an array of any cached records that do not match a currently used dependency
  #
  # source://licensed//lib/licensed/commands/status.rb#181
  def stale_cached_records; end
end

# source://licensed//lib/licensed/configuration.rb#254
class Licensed::Configuration
  # @return [Configuration] a new instance of Configuration
  #
  # source://licensed//lib/licensed/configuration.rb#276
  def initialize(options = T.unsafe(nil)); end

  # source://licensed//lib/licensed/configuration.rb#289
  def [](key); end

  # source://licensed//lib/licensed/configuration.rb#264
  def apps; end

  private

  # source://licensed//lib/licensed/configuration.rb#396
  def default_options; end

  class << self
    # source://licensed//lib/licensed/configuration.rb#295
    def expand_app_source_path(app_config); end

    # Expand any roots specified in a configuration file based on the configuration
    # files directory.
    #
    # source://licensed//lib/licensed/configuration.rb#384
    def expand_config_roots(config, config_path); end

    # source://licensed//lib/licensed/configuration.rb#354
    def find_config(directory); end

    # source://licensed//lib/licensed/configuration.rb#270
    def load_from(path); end

    # source://licensed//lib/licensed/configuration.rb#365
    def parse_config(config_path); end
  end
end

# source://licensed//lib/licensed/configuration.rb#255
Licensed::Configuration::DEFAULT_CONFIG_FILES = T.let(T.unsafe(nil), Array)

# source://licensed//lib/licensed/configuration.rb#261
class Licensed::Configuration::LoadError < ::StandardError; end

# source://licensed//lib/licensed/dependency.rb#5
class Licensed::Dependency < ::Licensee::Projects::FSProject
  # source://licensed//lib/licensed/dependency.rb#25
  def initialize(name:, version:, path:, search_root: T.unsafe(nil), metadata: T.unsafe(nil), errors: T.unsafe(nil)); end

  # Returns the value of attribute additional_terms.
  #
  # source://licensed//lib/licensed/dependency.rb#12
  def additional_terms; end

  # Returns the value of attribute errors.
  #
  # source://licensed//lib/licensed/dependency.rb#10
  def errors; end

  # Returns true if the dependency has any errors, false otherwise
  #
  # @return [Boolean]
  #
  # source://licensed//lib/licensed/dependency.rb#55
  def errors?; end

  # Returns whether the dependency exists locally
  #
  # @return [Boolean]
  #
  # source://licensed//lib/licensed/dependency.rb#46
  def exist?; end

  # source://licensed//lib/licensed/dependency.rb#76
  def license_contents; end

  # source://licensed//lib/licensed/dependency.rb#69
  def license_key; end

  # Returns a hash of basic metadata about the dependency - name, version, type, etc
  #
  # source://licensed//lib/licensed/dependency.rb#103
  def metadata; end

  # Returns the value of attribute name.
  #
  # source://licensed//lib/licensed/dependency.rb#8
  def name; end

  # Returns legal notices found at the dependency path
  #
  # source://licensed//lib/licensed/dependency.rb#93
  def notice_contents; end

  # Returns the value of attribute path.
  #
  # source://licensed//lib/licensed/dependency.rb#11
  def path; end

  # source://licensed//lib/licensed/dependency.rb#88
  def project_files; end

  # Returns a record for this dependency including metadata and legal contents
  #
  # source://licensed//lib/licensed/dependency.rb#60
  def record; end

  # Returns the value of attribute version.
  #
  # source://licensed//lib/licensed/dependency.rb#9
  def version; end

  private

  # source://licensed//lib/licensed/dependency.rb#178
  def additional_license_terms_files; end

  # source://licensed//lib/licensed/dependency.rb#157
  def generated_license_contents; end

  # source://licensed//lib/licensed/dependency.rb#122
  def license_content_sources(files); end

  # Returns the metadata that represents this dependency.  This metadata
  # is written to YAML in the dependencys cached text file
  #
  # source://licensed//lib/licensed/dependency.rb#148
  def license_metadata; end

  # source://licensed//lib/licensed/dependency.rb#134
  def normalize_source_path(path); end

  # source://licensed//lib/licensed/dependency.rb#115
  def read_file_with_encoding_check(file_path); end
end

# source://licensed//lib/licensed/dependency.rb#6
Licensed::Dependency::LEGAL_FILES_PATTERN = T.let(T.unsafe(nil), Regexp)

# source://licensed//lib/licensed/dependency_record.rb#7
class Licensed::DependencyRecord
  include ::Licensee::ContentHelper
  extend ::Forwardable

  # source://licensed//lib/licensed/dependency_record.rb#72
  def initialize(licenses: T.unsafe(nil), notices: T.unsafe(nil), metadata: T.unsafe(nil)); end

  # source://forwardable/1.3.3/forwardable.rb#231
  def [](*args, **_arg1, &block); end

  # source://forwardable/1.3.3/forwardable.rb#231
  def []=(*args, **_arg1, &block); end

  # source://licensed//lib/licensed/dependency_record.rb#93
  def content; end

  # source://licensed//lib/licensed/dependency_record.rb#64
  def licenses; end

  # Returns whether two records match based on their contents
  #
  # @return [Boolean]
  #
  # source://licensed//lib/licensed/dependency_record.rb#99
  def matches?(other); end

  # Returns the value of attribute notices.
  #
  # source://licensed//lib/licensed/dependency_record.rb#65
  def notices; end

  # Save the metadata and text to a file
  #
  # filename - The destination file to save record contents at
  #
  # source://licensed//lib/licensed/dependency_record.rb#81
  def save(filename); end

  class << self
    # source://licensed//lib/licensed/dependency_record.rb#50
    def read(filename); end
  end
end

# source://licensed//lib/licensed/dependency_record.rb#43
Licensed::DependencyRecord::EXTENSION = T.let(T.unsafe(nil), String)

# source://licensed//lib/licensed/dependency_record.rb#8
class Licensed::DependencyRecord::Error < ::StandardError; end

# source://licensed//lib/licensed/dependency_record.rb#10
class Licensed::DependencyRecord::License
  # @return [License] a new instance of License
  #
  # source://licensed//lib/licensed/dependency_record.rb#12
  def initialize(content); end

  # source://licensed//lib/licensed/dependency_record.rb#31
  def key; end

  # Returns the value of attribute sources.
  #
  # source://licensed//lib/licensed/dependency_record.rb#11
  def sources; end

  # Returns the value of attribute text.
  #
  # source://licensed//lib/licensed/dependency_record.rb#11
  def text; end

  # source://licensed//lib/licensed/dependency_record.rb#23
  def to_cache; end
end

# source://licensed//lib/licensed/git.rb#3
module Licensed::Git
  class << self
    # Returns whether git commands are available
    #
    # @return [Boolean]
    #
    # source://licensed//lib/licensed/git.rb#6
    def available?; end

    # Returns the commit date for the provided SHA as a timestamp
    #
    # sha - commit sha to retrieve date
    #
    # source://licensed//lib/licensed/git.rb#36
    def commit_date(sha); end

    # Returns the files in the git repository from `git ls-files --recurse-submodules`
    #
    # source://licensed//lib/licensed/git.rb#42
    def files; end

    # Returns true if a git repository is found, false otherwise
    #
    # @return [Boolean]
    #
    # source://licensed//lib/licensed/git.rb#20
    def git_repo?; end

    # Returns the root of the current git repository
    # or nil if not in a git repository.
    #
    # source://licensed//lib/licensed/git.rb#12
    def repository_root; end

    # Returns the most recent git SHA for a file or directory
    # or nil if SHA is not available
    #
    # descriptor - file or directory to retrieve latest SHA for
    #
    # source://licensed//lib/licensed/git.rb#28
    def version(descriptor); end
  end
end

# source://licensed//lib/licensed/migrations.rb#4
module Licensed::Migrations; end

# source://licensed//lib/licensed/migrations/v2.rb#6
class Licensed::Migrations::V2
  class << self
    # source://licensed//lib/licensed/migrations/v2.rb#11
    def migrate(config_path, shell = T.unsafe(nil)); end

    # find the yaml and non-yaml data according to parsing logic from v1
    #
    # source://licensed//lib/licensed/migrations/v2.rb#57
    def parse_file(filename); end
  end
end

# source://licensed//lib/licensed/migrations/v2.rb#9
Licensed::Migrations::V2::LICENSE_SEPARATOR = T.let(T.unsafe(nil), String)

# source://licensed//lib/licensed/migrations/v2.rb#8
Licensed::Migrations::V2::TEXT_SEPARATOR = T.let(T.unsafe(nil), String)

# source://licensed//lib/licensed/migrations/v2.rb#7
Licensed::Migrations::V2::YAML_FRONTMATTER_PATTERN = T.let(T.unsafe(nil), Regexp)

# source://licensed//lib/licensed/report.rb#4
class Licensed::Report < ::Hash
  # @return [Report] a new instance of Report
  #
  # source://licensed//lib/licensed/report.rb#7
  def initialize(name:, target:); end

  # source://licensed//lib/licensed/report.rb#25
  def all_reports; end

  # source://licensed//lib/licensed/report.rb#17
  def errors; end

  # Returns the value of attribute name.
  #
  # source://licensed//lib/licensed/report.rb#5
  def name; end

  # source://licensed//lib/licensed/report.rb#13
  def reports; end

  # Returns the value of attribute target.
  #
  # source://licensed//lib/licensed/report.rb#6
  def target; end

  # Returns the data from the report as a hash
  #
  # source://licensed//lib/licensed/report.rb#32
  def to_h; end

  # source://licensed//lib/licensed/report.rb#21
  def warnings; end
end

# source://licensed//lib/licensed/reporters.rb#3
module Licensed::Reporters; end

# source://licensed//lib/licensed/reporters/cache_reporter.rb#4
class Licensed::Reporters::CacheReporter < ::Licensed::Reporters::Reporter
  # Reports the start of caching records for an app
  #
  # app - An application configuration
  # report - A report containing information about the app evaluation
  #
  # source://licensed//lib/licensed/reporters/cache_reporter.rb#9
  def begin_report_app(app, report); end

  # Reports the start of caching records for a dependency source
  #
  # source - A dependency source enumerator
  # report - A report containing information about the source evaluation
  #
  # source://licensed//lib/licensed/reporters/cache_reporter.rb#17
  def begin_report_source(source, report); end

  # Reports whether the dependency's record was cached or reused.
  #
  # dependency - An application dependency
  # report - A report containing information about the dependency evaluation
  #
  # source://licensed//lib/licensed/reporters/cache_reporter.rb#65
  def end_report_dependency(dependency, report); end

  # Reports warnings and errors found while evaluating the dependency source
  #
  # source - A dependency source enumerator
  # report - A report containing information about the source evaluation
  #
  # source://licensed//lib/licensed/reporters/cache_reporter.rb#25
  def end_report_source(source, report); end
end

# source://licensed//lib/licensed/reporters/json_reporter.rb#6
class Licensed::Reporters::JsonReporter < ::Licensed::Reporters::Reporter
  # Add source report information to the app report hash
  #
  # app - An application configuration
  # report - A report object containing information about the app evaluation
  #
  # source://licensed//lib/licensed/reporters/json_reporter.rb#20
  def end_report_app(app, report); end

  # Report all information from the command run to the shell as a JSON object
  #
  # command - The command being run
  # report - A report object containing information about the command run
  #
  # source://licensed//lib/licensed/reporters/json_reporter.rb#11
  def end_report_command(command, report); end

  # Add dependency report information to the source report hash
  #
  # source - A dependency source enumerator
  # report - A report object containing information about the source evaluation
  #
  # source://licensed//lib/licensed/reporters/json_reporter.rb#28
  def end_report_source(source, report); end
end

# source://licensed//lib/licensed/reporters/list_reporter.rb#5
class Licensed::Reporters::ListReporter < ::Licensed::Reporters::Reporter
  # Reports the start of application configuration in a list command run
  #
  # app - An application configuration
  # report - A report object containing information about the app evaluation
  #
  # source://licensed//lib/licensed/reporters/list_reporter.rb#10
  def begin_report_app(app, report); end

  # Reports the start of a source evaluation
  #
  # source - A dependency source enumerator
  # report - A report object containing information about the source evaluation
  #
  # source://licensed//lib/licensed/reporters/list_reporter.rb#18
  def begin_report_source(source, report); end

  # Reports on a dependency in a list command run.
  #
  # dependency - An application dependency
  # report - A report object containing information about the dependency evaluation
  #
  # source://licensed//lib/licensed/reporters/list_reporter.rb#67
  def end_report_dependency(dependency, report); end

  # Report the type and count of dependencies found by the source,
  # along with any warnings and errors
  #
  # source - A dependency source enumerator
  # report - A report object containing information about the source evaluation
  #
  # source://licensed//lib/licensed/reporters/list_reporter.rb#27
  def end_report_source(source, report); end
end

# source://licensed//lib/licensed/reporters/notices_reporter.rb#5
class Licensed::Reporters::NoticesReporter < ::Licensed::Reporters::Reporter
  # Returns the path to an applications notices file
  #
  # source://licensed//lib/licensed/reporters/notices_reporter.rb#80
  def app_notices_path(app); end

  # Reports the start of an application evaluation in a notices command run
  #
  # app - An application configuration
  # report - A report object containing information about the app evaluation
  #
  # source://licensed//lib/licensed/reporters/notices_reporter.rb#13
  def begin_report_app(app, report); end

  # Writes the licensing information gathered during the application evaluation
  # to a notices file
  #
  # app - An application configuration
  # report - A report object containing information about the app evaluation
  #
  # source://licensed//lib/licensed/reporters/notices_reporter.rb#22
  def end_report_app(app, report); end

  # Reports on a dependency in a notices command run.
  #
  # dependency - An application dependency
  # report - A report object containing information about the dependency evaluation
  #
  # source://licensed//lib/licensed/reporters/notices_reporter.rb#47
  def end_report_dependency(dependency, report); end

  # Reports any warnings encountered during the run.
  #
  # source - A dependency source enumerator
  # report - A report object containing information about the source evaluation
  #
  # source://licensed//lib/licensed/reporters/notices_reporter.rb#37
  def end_report_source(source, report); end

  # Returns notices information for a dependency report
  #
  # source://licensed//lib/licensed/reporters/notices_reporter.rb#54
  def notices(report); end
end

# source://licensed//lib/licensed/reporters/notices_reporter.rb#7
Licensed::Reporters::NoticesReporter::LICENSE_SEPARATOR = T.let(T.unsafe(nil), String)

# source://licensed//lib/licensed/reporters/notices_reporter.rb#6
Licensed::Reporters::NoticesReporter::TEXT_SEPARATOR = T.let(T.unsafe(nil), String)

# source://licensed//lib/licensed/reporters/reporter.rb#4
class Licensed::Reporters::Reporter
  # @return [Reporter] a new instance of Reporter
  #
  # source://licensed//lib/licensed/reporters/reporter.rb#7
  def initialize(shell = T.unsafe(nil)); end

  # Report the beginning of an app evaluation
  #
  # app - An application configuration
  # report - A report object containing information about the app evaluation
  #
  # source://licensed//lib/licensed/reporters/reporter.rb#29
  def begin_report_app(app, report); end

  # Report the beginning of a command evaluation
  #
  # command - The command being run
  # report - A report object containing information about the command run
  #
  # source://licensed//lib/licensed/reporters/reporter.rb#15
  def begin_report_command(command, report); end

  # Report the beginning of a dependency evaluation
  #
  # dependency - An application dependency
  # source - A report object containing information about the dependency evaluation
  #
  # source://licensed//lib/licensed/reporters/reporter.rb#57
  def begin_report_dependency(dependency, report); end

  # Report the beginning of a source evaluation
  #
  # source - A dependency source enumerator
  # report - A report object containing information about the source evaluation
  #
  # source://licensed//lib/licensed/reporters/reporter.rb#43
  def begin_report_source(source, report); end

  # Report the end of an app evaluation
  #
  # app - An application configuration
  # report - A report object containing information about the app evaluation
  #
  # source://licensed//lib/licensed/reporters/reporter.rb#36
  def end_report_app(app, report); end

  # Report the end of a command evaluation
  #
  # command - The command being run
  # report - A report object containing information about the command run
  #
  # source://licensed//lib/licensed/reporters/reporter.rb#22
  def end_report_command(command, report); end

  # Report the end of a dependency evaluation
  #
  # dependency - An application dependency
  # source - A report object containing information about the dependency evaluation
  #
  # source://licensed//lib/licensed/reporters/reporter.rb#64
  def end_report_dependency(dependency, report); end

  # Report the end of a source evaluation
  #
  # source - A dependency source enumerator
  # report - A report object containing information about the source evaluation
  #
  # source://licensed//lib/licensed/reporters/reporter.rb#50
  def end_report_source(source, report); end

  protected

  # Returns the value of attribute shell.
  #
  # source://licensed//lib/licensed/reporters/reporter.rb#69
  def shell; end
end

# source://licensed//lib/licensed/reporters/reporter.rb#5
class Licensed::Reporters::Reporter::ReportingError < ::StandardError; end

# source://licensed//lib/licensed/reporters/status_reporter.rb#5
class Licensed::Reporters::StatusReporter < ::Licensed::Reporters::Reporter
  # Reports the start of checking records for an app
  #
  # app - An application configuration
  # report - A report containing information about the app evaluation
  #
  # source://licensed//lib/licensed/reporters/status_reporter.rb#26
  def begin_report_app(app, report); end

  # Reports any errors found when checking status, as well as
  # overall number of dependencies checked
  #
  # app - An application configuration
  # report - A report containing information about the app evaluation
  #
  # source://licensed//lib/licensed/reporters/status_reporter.rb#35
  def end_report_app(app, report); end

  # Reports any errors encountered at the command level
  #
  # command - The command being run
  # report - A report object containing information about the command run
  #
  # source://licensed//lib/licensed/reporters/status_reporter.rb#10
  def end_report_command(command, report); end

  # Reports whether the dependency's status is valid in dot format
  #
  # dependency - An application dependency
  # report - A report containing information about the dependency evaluation
  #
  # source://licensed//lib/licensed/reporters/status_reporter.rb#82
  def end_report_dependency(dependency, report); end
end

# source://licensed//lib/licensed/reporters/yaml_reporter.rb#4
class Licensed::Reporters::YamlReporter < ::Licensed::Reporters::Reporter
  # Add source report information to the app report hash
  #
  # app - An application configuration
  # report - A report object containing information about the app evaluation
  #
  # source://licensed//lib/licensed/reporters/yaml_reporter.rb#18
  def end_report_app(app, report); end

  # Report all information from the command run to the shell as a YAML object
  #
  # command - The command being run
  # report - A report object containing information about the command run
  #
  # source://licensed//lib/licensed/reporters/yaml_reporter.rb#9
  def end_report_command(command, report); end

  # Add dependency report information to the source report hash
  #
  # source - A dependency source enumerator
  # report - A report object containing information about the source evaluation
  #
  # source://licensed//lib/licensed/reporters/yaml_reporter.rb#26
  def end_report_source(source, report); end

  # source://licensed//lib/licensed/reporters/yaml_reporter.rb#30
  def sanitize(object); end
end

# source://licensed//lib/licensed/shell.rb#5
module Licensed::Shell
  class << self
    # Ensure that content that is returned from shell commands is in a usable
    # encoding for the rest of the application
    #
    # source://licensed//lib/licensed/shell.rb#72
    def encode_content(content); end

    # Executes a command, returning its standard output on success.
    # On failure it raises an exception that contains the error output, unless
    # `allow_failure` is true.
    #
    # source://licensed//lib/licensed/shell.rb#9
    def execute(cmd, *args, allow_failure: T.unsafe(nil), env: T.unsafe(nil)); end

    # Executes a command and returns a boolean value indicating if the command
    # was succesful
    #
    # @return [Boolean]
    #
    # source://licensed//lib/licensed/shell.rb#22
    def success?(cmd, *args); end

    # Returns a boolean indicating whether a CLI tool is available in the
    # current environment
    #
    # @return [Boolean]
    #
    # source://licensed//lib/licensed/shell.rb#29
    def tool_available?(tool); end
  end
end

# source://licensed//lib/licensed/shell.rb#62
Licensed::Shell::ENCODING = T.let(T.unsafe(nil), Encoding)

# source://licensed//lib/licensed/shell.rb#63
Licensed::Shell::ENCODING_OPTIONS = T.let(T.unsafe(nil), Hash)

# source://licensed//lib/licensed/shell.rb#34
class Licensed::Shell::Error < ::RuntimeError
  # @return [Error] a new instance of Error
  #
  # source://licensed//lib/licensed/shell.rb#36
  def initialize(cmd, status, stderr); end

  # Returns the value of attribute cmd.
  #
  # source://licensed//lib/licensed/shell.rb#35
  def cmd; end

  # source://licensed//lib/licensed/shell.rb#48
  def escape_cmd; end

  # source://licensed//lib/licensed/shell.rb#43
  def message; end

  # Returns the value of attribute status.
  #
  # source://licensed//lib/licensed/shell.rb#35
  def status; end

  # Returns the value of attribute stderr.
  #
  # source://licensed//lib/licensed/shell.rb#35
  def stderr; end
end

# source://licensed//lib/licensed/sources.rb#3
module Licensed::Sources; end

# source://licensed//lib/licensed/sources/bower.rb#6
class Licensed::Sources::Bower < ::Licensed::Sources::Source
  # Returns a parsed ".bowerrc" configuration, or an empty hash if not found
  #
  # source://licensed//lib/licensed/sources/bower.rb#31
  def bower_config; end

  # Returns the expected path to bower components.
  # Note this does not validate that the returned path is valid
  #
  # source://licensed//lib/licensed/sources/bower.rb#40
  def bower_path; end

  # @return [Boolean]
  #
  # source://licensed//lib/licensed/sources/bower.rb#7
  def enabled?; end

  # source://licensed//lib/licensed/sources/bower.rb#13
  def enumerate_dependencies; end
end

# source://licensed//lib/licensed/sources/bundler.rb#12
class Licensed::Sources::Bundler < ::Licensed::Sources::Source
  # source://licensed//lib/licensed/sources/bundler.rb#74
  def definition; end

  # @return [Boolean]
  #
  # source://licensed//lib/licensed/sources/bundler.rb#43
  def enabled?; end

  # source://licensed//lib/licensed/sources/bundler.rb#52
  def enumerate_dependencies; end

  # source://licensed//lib/licensed/sources/bundler.rb#86
  def exclude_groups; end

  # helper to clear all bundler environment around a yielded block
  #
  # source://licensed//lib/licensed/sources/bundler.rb#95
  def with_application_environment; end
end

# source://licensed//lib/licensed/sources/bundler.rb#41
Licensed::Sources::Bundler::DEFAULT_WITHOUT_GROUPS = T.let(T.unsafe(nil), Array)

# source://licensed//lib/licensed/sources/bundler.rb#13
class Licensed::Sources::Bundler::Dependency < ::Licensed::Dependency
  # @return [Dependency] a new instance of Dependency
  #
  # source://licensed//lib/licensed/sources/bundler.rb#16
  def initialize(name:, version:, path:, loaded_from:, errors: T.unsafe(nil), metadata: T.unsafe(nil)); end

  # Returns the value of attribute loaded_from.
  #
  # source://licensed//lib/licensed/sources/bundler.rb#14
  def loaded_from; end

  # source://licensed//lib/licensed/sources/bundler.rb#23
  def package_file; end

  private

  # Find a package manager file from the given bundler specification's
  # `loaded_from` if available.
  #
  # source://licensed//lib/licensed/sources/bundler.rb#31
  def spec_file; end
end

# source://licensed//lib/licensed/sources/cabal.rb#6
class Licensed::Sources::Cabal < ::Licensed::Sources::Source
  # Returns a set of the top-level dependencies found in cabal files
  #
  # source://licensed//lib/licensed/sources/cabal.rb#154
  def cabal_file_dependencies; end

  # Find `build-depends` lists from specified targets in a cabal file
  #
  # source://licensed//lib/licensed/sources/cabal.rb#184
  def cabal_file_regex; end

  # Returns the targets to search for `build-depends` in a cabal file
  #
  # source://licensed//lib/licensed/sources/cabal.rb#201
  def cabal_file_targets; end

  # Returns an array of the local directory cabal package files
  #
  # source://licensed//lib/licensed/sources/cabal.rb#208
  def cabal_files; end

  # Returns an installed package id for the package.
  #
  # source://licensed//lib/licensed/sources/cabal.rb#172
  def cabal_package_id(package_name); end

  # @return [Boolean]
  #
  # source://licensed//lib/licensed/sources/cabal.rb#10
  def enabled?; end

  # source://licensed//lib/licensed/sources/cabal.rb#14
  def enumerate_dependencies; end

  # Returns whether the ghc cli tool is available
  #
  # @return [Boolean]
  #
  # source://licensed//lib/licensed/sources/cabal.rb#219
  def ghc?; end

  # Runs a `ghc-pkg field` command for a given set of fields and arguments
  # Automatically includes ghc package DB locations in the command
  #
  # source://licensed//lib/licensed/sources/cabal.rb#130
  def ghc_pkg_field_command(id, fields, *args); end

  # Returns the ghc cli tool version
  #
  # source://licensed//lib/licensed/sources/cabal.rb#213
  def ghc_version; end

  # Returns a package info structure with an error set
  #
  # source://licensed//lib/licensed/sources/cabal.rb#224
  def missing_package(id); end

  # Returns an array of ghc package DB locations as specified in the app
  # configuration
  #
  # source://licensed//lib/licensed/sources/cabal.rb#136
  def package_db_args; end

  # Returns an array of dependency package names for the cabal package
  # given by `id`
  #
  # source://licensed//lib/licensed/sources/cabal.rb#97
  def package_dependencies(id); end

  # Returns the output of running `ghc-pkg field depends` for a package id
  # Optionally allows for interpreting the given id as an
  # installed package id (`--ipid`)
  #
  # source://licensed//lib/licensed/sources/cabal.rb#104
  def package_dependencies_command(id); end

  # Returns the packages document directory and search root directory
  # as an array
  #
  # source://licensed//lib/licensed/sources/cabal.rb#50
  def package_docs_dirs(package); end

  # Parses the name and version pieces from an id or package requirement string
  #
  # source://licensed//lib/licensed/sources/cabal.rb#230
  def package_id_name_version(id); end

  # Returns package information as a hash for the given id
  #
  # source://licensed//lib/licensed/sources/cabal.rb#110
  def package_info(id); end

  # Returns the output of running `ghc-pkg field` to obtain package information
  #
  # source://licensed//lib/licensed/sources/cabal.rb#123
  def package_info_command(id); end

  # Returns a list of all detected packages
  #
  # source://licensed//lib/licensed/sources/cabal.rb#33
  def packages; end

  # Returns a ghc package path with template markers replaced by live
  # data
  #
  # source://licensed//lib/licensed/sources/cabal.rb#149
  def realized_ghc_package_path(path); end

  # Recursively finds the dependencies for each cabal package.
  # Returns a `Set` containing the package names for all dependencies
  #
  # source://licensed//lib/licensed/sources/cabal.rb#81
  def recursive_dependencies(package_names, results = T.unsafe(nil)); end

  # Returns a homepage url that enforces https and removes url fragments
  #
  # source://licensed//lib/licensed/sources/cabal.rb#72
  def safe_homepage(homepage); end
end

# source://licensed//lib/licensed/sources/cabal.rb#8
Licensed::Sources::Cabal::DEFAULT_TARGETS = T.let(T.unsafe(nil), Array)

# source://licensed//lib/licensed/sources/cabal.rb#7
Licensed::Sources::Cabal::DEPENDENCY_REGEX = T.let(T.unsafe(nil), Regexp)

# source://licensed//lib/licensed/sources/cargo.rb#7
class Licensed::Sources::Cargo < ::Licensed::Sources::Source
  # Returns parsed JSON metadata returned from the cargo CLI
  #
  # source://licensed//lib/licensed/sources/cargo.rb#56
  def cargo_metadata; end

  # Runs a command to get cargo metadata for the current package
  #
  # source://licensed//lib/licensed/sources/cargo.rb#64
  def cargo_metadata_command; end

  # Returns a hash of id => package pairs sourced from the "packages" cargo metadata property
  #
  # source://licensed//lib/licensed/sources/cargo.rb#44
  def cargo_metadata_packages; end

  # Returns the ids of all resolved nodes used to build the current package
  #
  # source://licensed//lib/licensed/sources/cargo.rb#36
  def cargo_metadata_resolved_node_ids; end

  # Returns a set of the ids of packages in the current workspace
  #
  # source://licensed//lib/licensed/sources/cargo.rb#51
  def cargo_metadata_workspace_members; end

  # Source is enabled when the cargo tool and Cargo.toml manifest file are available
  #
  # @return [Boolean]
  #
  # source://licensed//lib/licensed/sources/cargo.rb#9
  def enabled?; end

  # source://licensed//lib/licensed/sources/cargo.rb#14
  def enumerate_dependencies; end

  # Returns the package data for all dependencies used to build the current package
  #
  # source://licensed//lib/licensed/sources/cargo.rb#31
  def packages; end
end

# source://licensed//lib/licensed/sources/cocoapods.rb#8
class Licensed::Sources::Cocoapods < ::Licensed::Sources::Source
  # @return [Boolean]
  #
  # source://licensed//lib/licensed/sources/cocoapods.rb#12
  def enabled?; end

  # source://licensed//lib/licensed/sources/cocoapods.rb#18
  def enumerate_dependencies; end

  private

  # source://licensed//lib/licensed/sources/cocoapods.rb#39
  def cocoapods_dependencies_json; end

  # source://licensed//lib/licensed/sources/cocoapods.rb#59
  def pod_command; end

  # source://licensed//lib/licensed/sources/cocoapods.rb#35
  def pods; end

  # source://licensed//lib/licensed/sources/cocoapods.rb#54
  def targets; end
end

# source://licensed//lib/licensed/sources/cocoapods.rb#9
Licensed::Sources::Cocoapods::DEFAULT_POD_COMMAND = T.let(T.unsafe(nil), String)

# source://licensed//lib/licensed/sources/cocoapods.rb#10
Licensed::Sources::Cocoapods::MISSING_PLUGIN_MESSAGE = T.let(T.unsafe(nil), String)

# source://licensed//lib/licensed/sources/composer.rb#6
class Licensed::Sources::Composer < ::Licensed::Sources::Source
  # source://licensed//lib/licensed/sources/composer.rb#54
  def composer_application_path; end

  # source://licensed//lib/licensed/sources/composer.rb#59
  def composer_lock; end

  # @return [Boolean]
  #
  # source://licensed//lib/licensed/sources/composer.rb#9
  def enabled?; end

  # source://licensed//lib/licensed/sources/composer.rb#14
  def enumerate_dependencies; end

  # source://licensed//lib/licensed/sources/composer.rb#64
  def include_dev?; end

  # Returns the output from running `php composer.phar` to get package metadata
  #
  # source://licensed//lib/licensed/sources/composer.rb#38
  def package_paths; end

  # source://licensed//lib/licensed/sources/composer.rb#30
  def packages; end
end

# source://licensed//lib/licensed/sources/composer.rb#7
Licensed::Sources::Composer::DEFAULT_COMPOSER_APPLICATON_PATH = T.let(T.unsafe(nil), String)

# source://licensed//lib/licensed/sources/helpers/content_versioning.rb#7
module Licensed::Sources::ContentVersioning
  # Find the version for a list of paths using their file contents
  #
  # paths - list of paths to find version
  #
  # Returns a hash of the path contents as an identifier for the group
  #
  # source://licensed//lib/licensed/sources/helpers/content_versioning.rb#59
  def contents_hash(paths); end

  # Find the version for a list of paths using the version strategy
  # specified for the source from the configuration
  #
  # paths - list of paths to find version
  #
  # Returns a version identifier for the given files
  #
  # source://licensed//lib/licensed/sources/helpers/content_versioning.rb#17
  def contents_version(*paths); end

  # Find the version for a list of paths using Git commit information
  #
  # paths - list of paths to find version
  #
  # Returns the most recent git SHA from the given paths
  #
  # source://licensed//lib/licensed/sources/helpers/content_versioning.rb#46
  def git_version(paths); end

  # Returns the version strategy configured for the source
  #
  # source://licensed//lib/licensed/sources/helpers/content_versioning.rb#27
  def version_strategy; end
end

# source://licensed//lib/licensed/sources/helpers/content_versioning.rb#9
Licensed::Sources::ContentVersioning::CONTENTS = T.let(T.unsafe(nil), String)

# source://licensed//lib/licensed/sources/helpers/content_versioning.rb#8
Licensed::Sources::ContentVersioning::GIT = T.let(T.unsafe(nil), String)

# source://licensed//lib/licensed/sources/dep.rb#6
class Licensed::Sources::Dep < ::Licensed::Sources::Source
  # @return [Boolean]
  #
  # source://licensed//lib/licensed/sources/dep.rb#7
  def enabled?; end

  # source://licensed//lib/licensed/sources/dep.rb#11
  def enumerate_dependencies; end

  # @return [Boolean]
  #
  # source://licensed//lib/licensed/sources/dep.rb#57
  def go_dep_available?; end

  # Returns whether the package is part of the go std list.  Replaces
  # "golang.org" with "golang_org" to match packages listed in `go list std`
  # as "vendor/golang_org/*" but are vendored as "vendor/golang.org/*"
  #
  # @return [Boolean]
  #
  # source://licensed//lib/licensed/sources/dep.rb#52
  def go_std_package?(import_path); end

  # Returns a list of go standard packages
  #
  # source://licensed//lib/licensed/sources/dep.rb#66
  def go_std_packages; end

  # source://licensed//lib/licensed/sources/dep.rb#61
  def gopkg_lock_path; end

  # Returns the pkg.go.dev page for a package.
  #
  # source://licensed//lib/licensed/sources/dep.rb#44
  def homepage(import_path); end

  # Returns an array of dependency packages specified from Gopkg.lock
  #
  # source://licensed//lib/licensed/sources/dep.rb#30
  def packages; end
end

# source://licensed//lib/licensed/sources/git_submodule.rb#5
class Licensed::Sources::GitSubmodule < ::Licensed::Sources::Source
  # @return [Boolean]
  #
  # source://licensed//lib/licensed/sources/git_submodule.rb#14
  def enabled?; end

  # source://licensed//lib/licensed/sources/git_submodule.rb#19
  def enumerate_dependencies; end

  # source://licensed//lib/licensed/sources/git_submodule.rb#49
  def git_submodules_command; end

  # source://licensed//lib/licensed/sources/git_submodule.rb#53
  def gitmodules_path; end

  # source://licensed//lib/licensed/sources/git_submodule.rb#45
  def submodule_paths; end
end

# source://licensed//lib/licensed/sources/git_submodule.rb#7
Licensed::Sources::GitSubmodule::GIT_SUBMODULES_ARGUMENTS = T.let(T.unsafe(nil), Array)

# source://licensed//lib/licensed/sources/git_submodule.rb#6
Licensed::Sources::GitSubmodule::REMOTE_URL_ARGUMENT = T.let(T.unsafe(nil), String)

# source://licensed//lib/licensed/sources/go.rb#8
class Licensed::Sources::Go < ::Licensed::Sources::Source
  include ::Licensed::Sources::ContentVersioning

  # Determines the arguments to pass to contents_version based on which
  # version strategy is selected
  #
  # Returns an array of arguments to pass to contents version
  #
  # source://licensed//lib/licensed/sources/go.rb#114
  def contents_version_arguments; end

  # @return [Boolean]
  #
  # source://licensed//lib/licensed/sources/go.rb#11
  def enabled?; end

  # source://licensed//lib/licensed/sources/go.rb#15
  def enumerate_dependencies; end

  # Returns the list of dependencies as returned by "go list -json -deps"
  # available in go 1.11
  #
  # source://licensed//lib/licensed/sources/go.rb#48
  def go_list_deps; end

  # Returns whether go source is found
  #
  # @return [Boolean]
  #
  # source://licensed//lib/licensed/sources/go.rb#185
  def go_source?; end

  # Returns whether the given package import path belongs to the
  # go std library or not
  #
  # package - package to check as part of the go standard library
  #
  # @return [Boolean]
  #
  # source://licensed//lib/licensed/sources/go.rb#64
  def go_std_package?(package); end

  # Returns a list of go standard packages
  #
  # source://licensed//lib/licensed/sources/go.rb#190
  def go_std_packages; end

  # Returns a GOPATH value from either a configuration value or ENV["GOPATH"],
  # with the configuration value preferred over the ENV var
  #
  # source://licensed//lib/licensed/sources/go.rb#196
  def gopath; end

  # Returns the pkg.go.dev page for a package.
  #
  # source://licensed//lib/licensed/sources/go.rb#123
  def homepage(import_path); end

  # Returns whether the package is local to the current project
  #
  # @return [Boolean]
  #
  # source://licensed//lib/licensed/sources/go.rb#86
  def local_package?(package); end

  # Returns the non-vendored portion of the package import path if vendored,
  # otherwise returns the package's import path as given
  #
  # package - Package to get the non-vendored import path for
  #
  # source://licensed//lib/licensed/sources/go.rb#168
  def non_vendored_import_path(package); end

  # Returns package information as a JSON string
  #
  # args - additional arguments to `go list`, e.g. Go package import path
  #
  # source://licensed//lib/licensed/sources/go.rb#180
  def package_info_command(*args); end

  # Returns the version for a given package
  #
  # package - package to get version of
  #
  # source://licensed//lib/licensed/sources/go.rb#95
  def package_version(package); end

  # Returns an array of dependency package import paths
  #
  # source://licensed//lib/licensed/sources/go.rb#38
  def packages; end

  # source://licensed//lib/licensed/sources/go.rb#131
  def search_root(package); end

  # If the package is vendored, returns a Match object containing named
  # :vendor_path and :import_path match groups based on the packages "Dir" value
  #
  # If the package is not vendored, returns nil
  #
  # package - Package to get vendored path information for
  #
  # source://licensed//lib/licensed/sources/go.rb#159
  def vendored_path_parts(package); end

  private

  # Execute a block with ENV["GOPATH"] set to the value of #gopath.
  # Any pre-existing ENV["GOPATH"] value is restored after the block ends.
  #
  # source://licensed//lib/licensed/sources/go.rb#211
  def with_configured_gopath(&block); end
end

# source://licensed//lib/licensed/sources/gradle.rb#11
class Licensed::Sources::Gradle < ::Licensed::Sources::Source
  # @return [Boolean]
  #
  # source://licensed//lib/licensed/sources/gradle.rb#44
  def enabled?; end

  # source://licensed//lib/licensed/sources/gradle.rb#48
  def enumerate_dependencies; end

  private

  # source://licensed//lib/licensed/sources/gradle.rb#81
  def configurations; end

  # Returns a key to uniquely identify a name and version in the obtained CSV content
  #
  # source://licensed//lib/licensed/sources/gradle.rb#100
  def csv_key(name:, version:); end

  # source://licensed//lib/licensed/sources/gradle.rb#65
  def executable; end

  # source://licensed//lib/licensed/sources/gradle.rb#75
  def gradle_runner; end

  # Returns the path to the Gradle wrapper.
  #
  # source://licensed//lib/licensed/sources/gradle.rb#92
  def gradlew; end

  # source://licensed//lib/licensed/sources/gradle.rb#112
  def load_csv; end

  # source://licensed//lib/licensed/sources/gradle.rb#104
  def package_url(name:, version:); end

  # Returns the cached url for the given dependency
  #
  # source://licensed//lib/licensed/sources/gradle.rb#130
  def url_for(dependency); end
end

# source://licensed//lib/licensed/sources/gradle.rb#12
Licensed::Sources::Gradle::DEFAULT_CONFIGURATIONS = T.let(T.unsafe(nil), Array)

# source://licensed//lib/licensed/sources/gradle.rb#15
class Licensed::Sources::Gradle::Dependency < ::Licensed::Dependency
  # @return [Dependency] a new instance of Dependency
  #
  # source://licensed//lib/licensed/sources/gradle.rb#23
  def initialize(name:, version:, path:, url:, metadata: T.unsafe(nil)); end

  # Returns whether the dependency content exists
  #
  # @return [Boolean]
  #
  # source://licensed//lib/licensed/sources/gradle.rb#29
  def exist?; end

  # source://licensed//lib/licensed/sources/gradle.rb#36
  def project_files; end

  class << self
    # source://licensed//lib/licensed/sources/gradle.rb#18
    def retrieve_license(url); end
  end
end

# source://licensed//lib/licensed/sources/gradle.rb#14
Licensed::Sources::Gradle::GRADLE_LICENSES_CSV_NAME = T.let(T.unsafe(nil), String)

# source://licensed//lib/licensed/sources/gradle.rb#13
Licensed::Sources::Gradle::GRADLE_LICENSES_PATH = T.let(T.unsafe(nil), String)

# The Gradle::Runner class is a wrapper which provides
# an interface to run gradle commands with the init script initialized
#
# source://licensed//lib/licensed/sources/gradle.rb#136
class Licensed::Sources::Gradle::Runner
  # @return [Runner] a new instance of Runner
  #
  # source://licensed//lib/licensed/sources/gradle.rb#137
  def initialize(configurations, executable); end

  # source://licensed//lib/licensed/sources/gradle.rb#142
  def run(command); end

  private

  # source://licensed//lib/licensed/sources/gradle.rb#152
  def create_init_script(configurations); end

  # Returns the version of gradle used during execution
  #
  # source://licensed//lib/licensed/sources/gradle.rb#209
  def gradle_version; end
end

# source://licensed//lib/licensed/sources/manifest.rb#7
class Licensed::Sources::Manifest < ::Licensed::Sources::Source
  include ::Licensed::Sources::ContentVersioning

  # source://licensed//lib/licensed/sources/manifest.rb#129
  def configured_dependencies; end

  # source://licensed//lib/licensed/sources/manifest.rb#30
  def configured_license_path(package_name); end

  # @return [Boolean]
  #
  # source://licensed//lib/licensed/sources/manifest.rb#10
  def enabled?; end

  # source://licensed//lib/licensed/sources/manifest.rb#14
  def enumerate_dependencies; end

  # Finds and returns all files in the project that match
  # the glob pattern arguments.
  #
  # source://licensed//lib/licensed/sources/manifest.rb#148
  def files_from_pattern_list(patterns); end

  # source://licensed//lib/licensed/sources/manifest.rb#95
  def generate_manifest; end

  # Returns whether a manifest should be generated automatically
  #
  # @return [Boolean]
  #
  # source://licensed//lib/licensed/sources/manifest.rb#89
  def generate_manifest?; end

  # Returns the set of project files that are included in dependency evaluation
  #
  # source://licensed//lib/licensed/sources/manifest.rb#142
  def included_files; end

  # Returns parsed or generated manifest data for the app
  #
  # source://licensed//lib/licensed/sources/manifest.rb#69
  def manifest; end

  # Returns the manifest location for the app
  #
  # source://licensed//lib/licensed/sources/manifest.rb#81
  def manifest_path; end

  # Returns a map of package names -> array of full source paths found
  # in the app manifest
  #
  # source://licensed//lib/licensed/sources/manifest.rb#60
  def packages; end

  # Returns the top-most directory that is common to all paths in `sources`
  #
  # source://licensed//lib/licensed/sources/manifest.rb#40
  def sources_license_path(sources); end

  # Returns all tracked files in the project as the intersection of what git tracks and the files in the project
  #
  # source://licensed//lib/licensed/sources/manifest.rb#166
  def tracked_files; end

  # source://licensed//lib/licensed/sources/manifest.rb#104
  def verify_configured_dependencies!; end
end

# source://licensed//lib/licensed/sources/manifest.rb#171
class Licensed::Sources::Manifest::Dependency < ::Licensed::Dependency
  # @return [Dependency] a new instance of Dependency
  #
  # source://licensed//lib/licensed/sources/manifest.rb#181
  def initialize(name:, version:, path:, sources:, metadata: T.unsafe(nil)); end

  # source://licensed//lib/licensed/sources/manifest.rb#186
  def project_files; end

  # source://licensed//lib/licensed/sources/manifest.rb#194
  def source_files; end

  private

  # Returns the comment text with leading * and whitespace stripped
  #
  # source://licensed//lib/licensed/sources/manifest.rb#216
  def source_comment_text(comment); end

  # Returns all source header comments for a file
  #
  # source://licensed//lib/licensed/sources/manifest.rb#208
  def source_file_comments(file); end
end

# source://licensed//lib/licensed/sources/manifest.rb#172
Licensed::Sources::Manifest::Dependency::ANY_EXCEPT_COMMENT_CLOSE_REGEX = T.let(T.unsafe(nil), Regexp)

# source://licensed//lib/licensed/sources/manifest.rb#173
Licensed::Sources::Manifest::Dependency::HEADER_LICENSE_REGEX = T.let(T.unsafe(nil), Regexp)

# source://licensed//lib/licensed/sources/mix.rb#5
class Licensed::Sources::Mix < ::Licensed::Sources::Source
  # Returns whether a mix.lock is present
  #
  # @return [Boolean]
  #
  # source://licensed//lib/licensed/sources/mix.rb#10
  def enabled?; end

  # source://licensed//lib/licensed/sources/mix.rb#14
  def enumerate_dependencies; end

  private

  # Check that the package has been installed in deps/.
  #
  # pkg - The package information as a Hash
  #
  # Returns an Array with two members; the path as a String and an Array of
  # any errors.
  #
  # source://licensed//lib/licensed/sources/mix.rb#55
  def check_dep_path(pkg); end

  # Converts a raw package representation to a dependency.
  #
  # name - The name of the package as a String.
  # pkg  - The parsed package data as a Hash.
  #
  # Returns a Dependency.
  #
  # source://licensed//lib/licensed/sources/mix.rb#38
  def convert_package_to_dependency(pkg); end

  # Generate the absolute path to the named package.
  #
  # name - The name of the package dependency as a String.
  #
  # Returns a Pathname.
  #
  # source://licensed//lib/licensed/sources/mix.rb#69
  def dep_path(name); end

  # Returns the parsed mix.lock information as an Array of Hash objects.
  #
  # source://licensed//lib/licensed/sources/mix.rb#23
  def find_packages; end

  # Returns the absolute path to the mix.lock as a Pathname.
  #
  # source://licensed//lib/licensed/sources/mix.rb#28
  def lockfile_path; end
end

# source://licensed//lib/licensed/sources/mix.rb#7
Licensed::Sources::Mix::LOCKFILE = T.let(T.unsafe(nil), String)

# source://licensed//lib/licensed/sources/mix.rb#73
class Licensed::Sources::Mix::LockfileParser
  # @return [LockfileParser] a new instance of LockfileParser
  #
  # source://licensed//lib/licensed/sources/mix.rb#125
  def initialize(lines); end

  # Parses the input lines.
  #
  # Returns an Array of Hash package entries, or raises a ParseError if
  # unsuccessful.
  #
  # source://licensed//lib/licensed/sources/mix.rb#133
  def result; end

  private

  # Format an invalid package entry.
  #
  # match - A MatchData containing name and scm information.
  # line  - The line from mix.lock that could not be parsed, as a String.
  #
  # Returns a Hash representing the package, with error information.
  #
  # source://licensed//lib/licensed/sources/mix.rb#185
  def invalid_package_entry(match, line); end

  # Parse a line from the mix.lock file.
  #
  # line - A line of input as a String.
  #
  # Returns a Hash package entry, or raises a ParserError if unsuccessful.
  #
  # source://licensed//lib/licensed/sources/mix.rb#148
  def parse_line(line); end

  # Format a valid package entry.
  #
  # match - A MatchData containing name and scm information.
  # data  - A MatchData containing version and repo information.
  #
  # Returns a Hash representing the package.
  #
  # source://licensed//lib/licensed/sources/mix.rb#168
  def valid_package_entry(match, data); end

  class << self
    # Parses a mix.lock to extract raw package information.
    #
    # path - The path to the mix.lock as a Pathname or String.
    #
    # Returns an Array of Hash package entries, or raises a ParserError if
    # unsuccessful.
    #
    # source://licensed//lib/licensed/sources/mix.rb#120
    def read(path); end
  end
end

# Top-level pattern extracting the name and Mix.SCM type
#
# source://licensed//lib/licensed/sources/mix.rb#78
Licensed::Sources::Mix::LockfileParser::LINE_PATTERN = T.let(T.unsafe(nil), Regexp)

# source://licensed//lib/licensed/sources/mix.rb#75
class Licensed::Sources::Mix::LockfileParser::ParseError < ::RuntimeError; end

# Patterns to extract the version and repo information for each Mix.SCM type.
#
# source://licensed//lib/licensed/sources/mix.rb#89
Licensed::Sources::Mix::LockfileParser::SCM_PATTERN = T.let(T.unsafe(nil), Hash)

# source://licensed//lib/licensed/sources/npm.rb#6
class Licensed::Sources::NPM < ::Licensed::Sources::Source
  # @return [Boolean]
  #
  # source://licensed//lib/licensed/sources/npm.rb#26
  def enabled?; end

  # source://licensed//lib/licensed/sources/npm.rb#30
  def enumerate_dependencies; end

  # source://licensed//lib/licensed/sources/npm.rb#161
  def extract_version(parent, name); end

  # source://licensed//lib/licensed/sources/npm.rb#135
  def include_non_production?; end

  # @return [Boolean]
  #
  # source://licensed//lib/licensed/sources/npm.rb#139
  def missing_peer?(parent, dependency, name); end

  # Returns the currently installed version of npm as a Gem::Version object
  #
  # source://licensed//lib/licensed/sources/npm.rb#123
  def npm_version; end

  # Returns the parse package.json for the current project
  #
  # source://licensed//lib/licensed/sources/npm.rb#172
  def package_json; end

  # source://licensed//lib/licensed/sources/npm.rb#181
  def package_json_path; end

  # Returns parsed package metadata returned from `npm list`
  #
  # source://licensed//lib/licensed/sources/npm.rb#83
  def package_metadata; end

  # Returns an array of arguments that should be used for all `npm list`
  # calls, regardless of how the output is formatted
  #
  # source://licensed//lib/licensed/sources/npm.rb#111
  def package_metadata_args; end

  # Returns the output from running `npm list` to get package metadata
  #
  # source://licensed//lib/licensed/sources/npm.rb#102
  def package_metadata_command; end

  # Returns an error, if one exists, from running `npm list` to get package metadata
  #
  # source://licensed//lib/licensed/sources/npm.rb#94
  def package_metadata_error; end

  # source://licensed//lib/licensed/sources/npm.rb#50
  def packages; end

  # source://licensed//lib/licensed/sources/npm.rb#151
  def peer_dependency(parent, name); end

  # Returns the current projects name
  #
  # source://licensed//lib/licensed/sources/npm.rb#166
  def project_name; end

  # Recursively parse dependency JSON data.  Returns a hash mapping the
  # package name to it's metadata
  #
  # source://licensed//lib/licensed/sources/npm.rb#67
  def recursive_dependencies(dependencies, result = T.unsafe(nil), parent = T.unsafe(nil)); end

  # Returns true if a yarn.lock file exists in the current directory
  #
  # source://licensed//lib/licensed/sources/npm.rb#130
  def yarn_lock_present; end
end

# source://licensed//lib/licensed/sources/npm.rb#7
class Licensed::Sources::NPM::Dependency < ::Licensed::Dependency
  # source://licensed//lib/licensed/sources/npm.rb#11
  def license_metadata; end
end

# Only supports ProjectReference (project.assets.json) style restore used in .NET Core.
# Does not currently support packages.config style restore.
#
# source://licensed//lib/licensed/sources/nuget.rb#9
class Licensed::Sources::NuGet < ::Licensed::Sources::Source
  # @return [Boolean]
  #
  # source://licensed//lib/licensed/sources/nuget.rb#186
  def enabled?; end

  # Inspect project.assets.json files for package references.
  # Ideally we'd use `dotnet list package` instead, but its output isn't
  # easily machine readable and doesn't contain everything we need.
  #
  # source://licensed//lib/licensed/sources/nuget.rb#193
  def enumerate_dependencies; end

  # Returns a dependency's path, if it exists, in one of the project's global or fallback package folders
  #
  # source://licensed//lib/licensed/sources/nuget.rb#227
  def full_dependency_path(reference_key); end

  # source://licensed//lib/licensed/sources/nuget.rb#182
  def nuget_obj_path; end

  # source://licensed//lib/licensed/sources/nuget.rb#170
  def project_assets_file; end

  # source://licensed//lib/licensed/sources/nuget.rb#166
  def project_assets_file_path; end

  # source://licensed//lib/licensed/sources/nuget.rb#175
  def project_assets_json; end

  # Returns a unique set of the package reference keys used across all target groups
  #
  # source://licensed//lib/licensed/sources/nuget.rb#217
  def reference_keys; end

  class << self
    # source://licensed//lib/licensed/sources/nuget.rb#10
    def type_and_version; end
  end
end

# source://licensed//lib/licensed/sources/nuget.rb#14
class Licensed::Sources::NuGet::NuGetDependency < ::Licensed::Dependency
  # source://licensed//lib/licensed/sources/nuget.rb#51
  def description; end

  # Returns the metadata that represents this dependency.  This metadata
  # is written to YAML in the dependencys cached text file
  #
  # source://licensed//lib/licensed/sources/nuget.rb#22
  def license_metadata; end

  # source://licensed//lib/licensed/sources/nuget.rb#34
  def nuspec_contents; end

  # source://licensed//lib/licensed/sources/nuget.rb#81
  def nuspec_local_license_file; end

  # source://licensed//lib/licensed/sources/nuget.rb#29
  def nuspec_path; end

  # source://licensed//lib/licensed/sources/nuget.rb#97
  def nuspec_remote_license_file; end

  # source://licensed//lib/licensed/sources/nuget.rb#60
  def project_files; end

  # source://licensed//lib/licensed/sources/nuget.rb#42
  def project_url; end

  class << self
    # source://licensed//lib/licensed/sources/nuget.rb#140
    def fetch_content(url, redirect_limit = T.unsafe(nil)); end

    # @return [Boolean]
    #
    # source://licensed//lib/licensed/sources/nuget.rb#117
    def ignored_url?(url); end

    # source://licensed//lib/licensed/sources/nuget.rb#129
    def retrieve_license(url); end

    # source://licensed//lib/licensed/sources/nuget.rb#110
    def strip_html(html); end

    # source://licensed//lib/licensed/sources/nuget.rb#123
    def text_content_url(url); end
  end
end

# source://licensed//lib/licensed/sources/nuget.rb#15
Licensed::Sources::NuGet::NuGetDependency::LICENSE_FILE_REGEX = T.let(T.unsafe(nil), Regexp)

# source://licensed//lib/licensed/sources/nuget.rb#16
Licensed::Sources::NuGet::NuGetDependency::LICENSE_URL_REGEX = T.let(T.unsafe(nil), Regexp)

# source://licensed//lib/licensed/sources/nuget.rb#18
Licensed::Sources::NuGet::NuGetDependency::PROJECT_DESC_REGEX = T.let(T.unsafe(nil), Regexp)

# source://licensed//lib/licensed/sources/nuget.rb#17
Licensed::Sources::NuGet::NuGetDependency::PROJECT_URL_REGEX = T.let(T.unsafe(nil), Regexp)

# source://licensed//lib/licensed/sources/pnpm.rb#6
class Licensed::Sources::PNPM < ::Licensed::Sources::Source
  # Returns true when pnpm is installed and a pnpm-lock.yaml file is found,
  # otherwise false
  #
  # @return [Boolean]
  #
  # source://licensed//lib/licensed/sources/pnpm.rb#15
  def enabled?; end

  # source://licensed//lib/licensed/sources/pnpm.rb#20
  def enumerate_dependencies; end

  # source://licensed//lib/licensed/sources/pnpm.rb#53
  def include_non_production?; end

  # source://licensed//lib/licensed/sources/pnpm.rb#46
  def package_metadata_command; end

  # source://licensed//lib/licensed/sources/pnpm.rb#38
  def packages; end

  class << self
    # The PNPM source requires matching reviewed or ignored dependencies
    # on both name and version
    #
    # source://licensed//lib/licensed/sources/pnpm.rb#9
    def require_matched_dependency_version; end
  end
end

# source://licensed//lib/licensed/sources/pip.rb#9
class Licensed::Sources::Pip < ::Licensed::Sources::Source
  # @return [Boolean]
  #
  # source://licensed//lib/licensed/sources/pip.rb#12
  def enabled?; end

  # source://licensed//lib/licensed/sources/pip.rb#16
  def enumerate_dependencies; end

  protected

  # Returns the command to run pip
  #
  # source://licensed//lib/licensed/sources/pip.rb#34
  def pip_command; end

  private

  # source://licensed//lib/licensed/sources/pip.rb#43
  def package_license_location(package); end

  # Returns the names of all of the packages used by the current project,
  # as returned from `pip list`
  #
  # source://licensed//lib/licensed/sources/pip.rb#65
  def package_names; end

  # Returns parsed information for all packages used by the project,
  # using `pip list` to determine what packages are used and `pip show`
  # to gather package information
  #
  # source://licensed//lib/licensed/sources/pip.rb#56
  def packages; end

  # Returns a hash filled with package info parsed from the email-header formatted output
  # returned by `pip show`
  #
  # source://licensed//lib/licensed/sources/pip.rb#76
  def parse_package_info(package_info); end

  # Returns the output from `pip list --format=json`
  #
  # source://licensed//lib/licensed/sources/pip.rb#87
  def pip_list_command; end

  # Returns the output from `pip show <package> <package> ...`
  #
  # source://licensed//lib/licensed/sources/pip.rb#92
  def pip_show_command(packages); end

  # source://licensed//lib/licensed/sources/pip.rb#96
  def virtual_env_dir; end
end

# source://licensed//lib/licensed/sources/pip.rb#10
Licensed::Sources::Pip::PACKAGE_INFO_SEPARATOR = T.let(T.unsafe(nil), String)

# source://licensed//lib/licensed/sources/pipenv.rb#7
class Licensed::Sources::Pipenv < ::Licensed::Sources::Pip
  # @return [Boolean]
  #
  # source://licensed//lib/licensed/sources/pipenv.rb#8
  def enabled?; end

  protected

  # Returns the command to run pip
  #
  # source://licensed//lib/licensed/sources/pipenv.rb#15
  def pip_command; end
end

# source://licensed//lib/licensed/sources/source.rb#5
class Licensed::Sources::Source
  # @return [Source] a new instance of Source
  #
  # source://licensed//lib/licensed/sources/source.rb#65
  def initialize(configuration); end

  # all sources have a configuration
  #
  # source://licensed//lib/licensed/sources/source.rb#63
  def config; end

  # all sources have a configuration
  #
  # source://licensed//lib/licensed/sources/source.rb#63
  def config=(_arg0); end

  # Returns all dependencies that should be evaluated.
  # Excludes ignored dependencies.
  #
  # source://licensed//lib/licensed/sources/source.rb#77
  def dependencies; end

  # source://licensed//lib/licensed/sources/source.rb#71
  def enabled?; end

  # Enumerate all source dependencies.  Must be implemented by each source class.
  #
  # @raise [DependencyEnumerationNotImplementedError]
  #
  # source://licensed//lib/licensed/sources/source.rb#84
  def enumerate_dependencies; end

  # Returns whether a dependency is ignored in the configuration.
  #
  # @return [Boolean]
  #
  # source://licensed//lib/licensed/sources/source.rb#89
  def ignored?(dependency); end

  # Returns configuration options set for the current source
  #
  # source://licensed//lib/licensed/sources/source.rb#94
  def source_config; end

  private

  # Add any additional_terms for this dependency that have been added to the configuration
  #
  # source://licensed//lib/licensed/sources/source.rb#106
  def add_additional_terms_from_configuration(dependency); end

  # Returns a cached list of dependencies
  #
  # source://licensed//lib/licensed/sources/source.rb#101
  def cached_dependencies; end

  class << self
    # source://licensed//lib/licensed/sources/source.rb#39
    def full_type; end

    # @private
    #
    # source://licensed//lib/licensed/sources/source.rb#16
    def inherited(klass); end

    # source://licensed//lib/licensed/sources/source.rb#21
    def register_source(klass); end

    # Returns true if the source requires matching reviewed and ignored dependencies'
    # versions as well as their name
    #
    # source://licensed//lib/licensed/sources/source.rb#57
    def require_matched_dependency_version; end

    # Returns the value of attribute sources.
    #
    # source://licensed//lib/licensed/sources/source.rb#15
    def sources; end

    # source://licensed//lib/licensed/sources/source.rb#31
    def type; end

    # Returns an array that includes the source's type name at the first index, and
    # optionally a version string for the source as the second index.
    # Callers should override this function and not `type` or `full_type` when
    # needing to adjust the default type and version parsing logic
    #
    # source://licensed//lib/licensed/sources/source.rb#47
    def type_and_version; end
  end
end

# source://licensed//lib/licensed/sources/source.rb#6
class Licensed::Sources::Source::DependencyEnumerationNotImplementedError < ::StandardError
  # @return [DependencyEnumerationNotImplementedError] a new instance of DependencyEnumerationNotImplementedError
  #
  # source://licensed//lib/licensed/sources/source.rb#7
  def initialize(message = T.unsafe(nil)); end
end

# source://licensed//lib/licensed/sources/source.rb#12
class Licensed::Sources::Source::Error < ::StandardError; end

# source://licensed//lib/licensed/sources/swift.rb#8
class Licensed::Sources::Swift < ::Licensed::Sources::Source
  # @return [Boolean]
  #
  # source://licensed//lib/licensed/sources/swift.rb#9
  def enabled?; end

  # source://licensed//lib/licensed/sources/swift.rb#14
  def enumerate_dependencies; end

  private

  # source://licensed//lib/licensed/sources/swift.rb#48
  def dependency_path_for_url(url); end

  # source://licensed//lib/licensed/sources/swift.rb#54
  def homepage_for_url(url); end

  # source://licensed//lib/licensed/sources/swift.rb#60
  def package_resolved_file_path; end

  # source://licensed//lib/licensed/sources/swift.rb#36
  def pins; end

  # @return [Boolean]
  #
  # source://licensed//lib/licensed/sources/swift.rb#64
  def swift_package?; end
end

# source://licensed//lib/licensed/sources/yarn.rb#5
module Licensed::Sources::Yarn
  mixes_in_class_methods ::Licensed::Sources::Yarn::ClassMethods

  # Returns a hash that maps all dependency names to their location on disk
  # by parsing every package.json file under node_modules.
  #
  # source://licensed//lib/licensed/sources/yarn.rb#29
  def dependency_paths; end

  # @return [Boolean]
  #
  # source://licensed//lib/licensed/sources/yarn.rb#16
  def enabled?; end

  # source://licensed//lib/licensed/sources/yarn.rb#23
  def yarn_version; end

  class << self
    # @private
    #
    # source://licensed//lib/licensed/sources/yarn.rb#12
    def included(klass); end
  end
end

# source://licensed//lib/licensed/sources/yarn/berry.rb#6
class Licensed::Sources::Yarn::Berry < ::Licensed::Sources::Source
  include ::Licensed::Sources::Yarn
  extend ::Licensed::Sources::Yarn::ClassMethods

  # source://licensed//lib/licensed/sources/yarn/berry.rb#13
  def enumerate_dependencies; end

  # source://licensed//lib/licensed/sources/yarn/berry.rb#29
  def packages; end

  # source://licensed//lib/licensed/sources/yarn/berry.rb#63
  def yarn_info_command; end

  class << self
    # source://licensed//lib/licensed/sources/yarn/berry.rb#9
    def version_requirement; end
  end
end

# source://licensed//lib/licensed/sources/yarn.rb#6
module Licensed::Sources::Yarn::ClassMethods
  # source://licensed//lib/licensed/sources/yarn.rb#7
  def type; end
end

# source://licensed//lib/licensed/sources/yarn/v1.rb#6
class Licensed::Sources::Yarn::V1 < ::Licensed::Sources::Source
  include ::Licensed::Sources::Yarn
  extend ::Licensed::Sources::Yarn::ClassMethods

  # source://licensed//lib/licensed/sources/yarn/v1.rb#90
  def dependency_urls; end

  # source://licensed//lib/licensed/sources/yarn/v1.rb#20
  def enumerate_dependencies; end

  # source://licensed//lib/licensed/sources/yarn/v1.rb#131
  def include_non_production?; end

  # source://licensed//lib/licensed/sources/yarn/v1.rb#36
  def packages; end

  # source://licensed//lib/licensed/sources/yarn/v1.rb#58
  def recursive_dependencies(dependencies, result = T.unsafe(nil)); end

  # source://licensed//lib/licensed/sources/yarn/v1.rb#124
  def yarn_licenses_command; end

  # source://licensed//lib/licensed/sources/yarn/v1.rb#117
  def yarn_list_command; end

  # source://licensed//lib/licensed/sources/yarn/v1.rb#77
  def yarn_package_tree; end

  class << self
    # source://licensed//lib/licensed/sources/yarn/v1.rb#16
    def version_requirement; end
  end
end

# source://licensed//lib/licensed/sources/yarn/v1.rb#12
Licensed::Sources::Yarn::V1::YARN_NAME_HEAD = T.let(T.unsafe(nil), String)

# source://licensed//lib/licensed/sources/yarn/v1.rb#14
Licensed::Sources::Yarn::V1::YARN_URL_HEAD = T.let(T.unsafe(nil), String)

# source://licensed//lib/licensed/sources/yarn/v1.rb#13
Licensed::Sources::Yarn::V1::YARN_VERSION_HEAD = T.let(T.unsafe(nil), String)

# source://licensed//lib/licensed/ui/shell.rb#5
module Licensed::UI; end

# source://licensed//lib/licensed/ui/shell.rb#6
class Licensed::UI::Shell
  # @return [Shell] a new instance of Shell
  #
  # source://licensed//lib/licensed/ui/shell.rb#9
  def initialize; end

  # source://licensed//lib/licensed/ui/shell.rb#22
  def confirm(msg, newline = T.unsafe(nil)); end

  # source://licensed//lib/licensed/ui/shell.rb#14
  def debug(msg, newline = T.unsafe(nil)); end

  # source://licensed//lib/licensed/ui/shell.rb#30
  def error(msg, newline = T.unsafe(nil)); end

  # source://licensed//lib/licensed/ui/shell.rb#18
  def info(msg, newline = T.unsafe(nil)); end

  # @raise [ArgumentError]
  #
  # source://licensed//lib/licensed/ui/shell.rb#38
  def level=(level); end

  # @return [Boolean]
  #
  # source://licensed//lib/licensed/ui/shell.rb#43
  def level?(name = T.unsafe(nil)); end

  # source://licensed//lib/licensed/ui/shell.rb#34
  def newline; end

  # source://licensed//lib/licensed/ui/shell.rb#47
  def silence; end

  # source://licensed//lib/licensed/ui/shell.rb#26
  def warn(msg, newline = T.unsafe(nil)); end
end

# source://licensed//lib/licensed/ui/shell.rb#7
Licensed::UI::Shell::LEVELS = T.let(T.unsafe(nil), Array)

# source://licensed//lib/licensed/version.rb#3
Licensed::VERSION = T.let(T.unsafe(nil), String)
