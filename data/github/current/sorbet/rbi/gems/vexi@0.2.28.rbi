# typed: true

# DO NOT EDIT MANUALLY
# This is an autogenerated file for types exported from the `vexi` gem.
# Please instead update this file by running `bin/tapioca gem vexi`.

# source://vexi//lib/vexi/adapters/feature_flag_hub_adapter.rb#10
FFDV1 = FeatureManagement::FeatureFlags::Data::V1

# source://vexi//lib/vexi/adapters/monolith_optimized_feature_flag_data_adapter.rb#11
FFDV2 = FeatureManagement::FeatureFlags::Data::V2

# Public: The main Vexi module for performing feature flag enabled checks.
#
# source://vexi//lib/vexi/actor.rb#4
module Vexi
  class << self
    # Public: This method can be used to simply configure and create a new vexi instance
    #         The returned client is not storead in a thread-safe way so it is generally
    #         recommended to use `configure()` followed by `instance()` instead.
    #
    # source://vexi//lib/vexi.rb#22
    sig { params(blk: T.proc.params(config: ::Vexi::Builder).void).returns(::Vexi::Client) }
    def build(&blk); end

    # source://vexi//lib/vexi.rb#50
    sig { returns(::Vexi::Configuration) }
    def configuration; end

    # Public: Configure Vexi
    #
    # source://vexi//lib/vexi.rb#33
    sig { params(blk: T.proc.params(config: ::Vexi::Builder).void).void }
    def configure(&blk); end

    # Public: Get the vexi instance for the currently running thread, requires the Vexi to be configured first
    #
    # source://vexi//lib/vexi.rb#45
    sig { returns(::Vexi::Client) }
    def instance; end
  end
end

# Public: Vexi service is an abstract base class. It has a generic get to fetch entities from the adapter or cache.
#
# @abstract It cannot be directly instantiated. Subclasses must implement the `abstract` methods below.
#
# source://vexi//lib/vexi/abstract_entity_service.rb#8
class Vexi::AbstractEntityService
  extend T::Generic

  abstract!

  EntityType = type_member { { upper: Vexi::Entity } }

  # source://vexi//lib/vexi/abstract_entity_service.rb#19
  sig { params(adapter: ::Vexi::Adapter, cache_config: T.nilable(::Vexi::CacheConfig)).void }
  def initialize(adapter, cache_config = T.unsafe(nil)); end

  # @abstract
  #
  # source://vexi//lib/vexi/abstract_entity_service.rb#27
  sig { abstract.returns(T::Class[EntityType]) }
  def entity_type; end

  # @abstract
  #
  # source://vexi//lib/vexi/abstract_entity_service.rb#30
  sig { abstract.returns(::String) }
  def entity_type_name; end

  # source://vexi//lib/vexi/abstract_entity_service.rb#46
  sig do
    params(
      fetch_directly_from_adapter: T::Boolean,
      cache_without_expiry: T::Boolean,
      _allow_context_overrides: T::Boolean,
      names: T::Array[::String]
    ).returns(T::Array[EntityType])
  end
  def get(fetch_directly_from_adapter: T.unsafe(nil), cache_without_expiry: T.unsafe(nil), _allow_context_overrides: T.unsafe(nil), names: T.unsafe(nil)); end

  # source://vexi//lib/vexi/abstract_entity_service.rb#33
  sig { params(value: T::Boolean).void }
  def memoize=(value); end

  private

  # @abstract
  #
  # source://vexi//lib/vexi/abstract_entity_service.rb#78
  sig { abstract.params(name: ::String).returns(::String) }
  def get_cache_key(name); end

  # source://vexi//lib/vexi/abstract_entity_service.rb#87
  sig { params(names: T::Array[::String]).returns(T::Array[::String]) }
  def get_cache_keys(names); end

  # @abstract
  #
  # source://vexi//lib/vexi/abstract_entity_service.rb#84
  sig { abstract.params(name: ::String).returns(EntityType) }
  def get_default_entity_instance(name); end

  # source://vexi//lib/vexi/abstract_entity_service.rb#126
  sig { params(entity_names: T::Array[::String], cache_without_expiry: T::Boolean).returns(T::Array[EntityType]) }
  def get_entities_from_adapter(entity_names, cache_without_expiry); end

  # source://vexi//lib/vexi/abstract_entity_service.rb#106
  sig do
    params(
      entity_names: T::Array[::String],
      fetch_directly_from_adapter: T::Boolean
    ).returns(T::Array[EntityType])
  end
  def get_entities_from_cache(entity_names, fetch_directly_from_adapter); end

  # source://vexi//lib/vexi/abstract_entity_service.rb#92
  sig do
    params(
      entity_names: T::Array[::String],
      fetch_directly_from_adapter: T::Boolean
    ).returns(T::Array[EntityType])
  end
  def get_entities_from_memoization(entity_names, fetch_directly_from_adapter); end

  # @abstract
  #
  # source://vexi//lib/vexi/abstract_entity_service.rb#81
  sig { abstract.params(names: T::Array[::String]).returns(T::Array[::Vexi::GetEntityResponse]) }
  def get_entity_responses(names); end
end

# Vexi actor interface.
#
# @abstract Subclasses must implement the `abstract` methods below.
#
# source://vexi//lib/vexi/actor.rb#6
module Vexi::Actor
  include ::Kernel

  interface!

  # The ID stored for this actor to enable per-actor or
  # percent-of-actors enabling of features.
  #
  # @abstract
  #
  # source://vexi//lib/vexi/actor.rb#16
  sig { abstract.returns(::String) }
  def vexi_id; end
end

# @abstract Subclasses must implement the `abstract` methods below.
#
# source://vexi//lib/vexi/actor_collection.rb#5
module Vexi::ActorCollection
  interface!

  # @abstract
  #
  # source://vexi//lib/vexi/actor_collection.rb#20
  sig { abstract.params(key: ::String).returns(T.nilable(T::Boolean)) }
  def [](key); end

  # @abstract
  #
  # source://vexi//lib/vexi/actor_collection.rb#23
  sig { abstract.params(key: ::String, value: T::Boolean).void }
  def []=(key, value); end

  # @abstract
  #
  # source://vexi//lib/vexi/actor_collection.rb#26
  sig { abstract.params(key: ::String).void }
  def delete(key); end

  # @abstract
  #
  # source://vexi//lib/vexi/actor_collection.rb#17
  sig { abstract.params(blk: T.proc.params(elem: [::String, T::Boolean]).returns(::BasicObject)).void }
  def each(&blk); end

  # @abstract
  #
  # source://vexi//lib/vexi/actor_collection.rb#29
  sig { abstract.returns(T::Array[::String]) }
  def keys; end

  # @abstract
  #
  # source://vexi//lib/vexi/actor_collection.rb#35
  sig { abstract.returns(::Numeric) }
  def length; end

  # @abstract
  #
  # source://vexi//lib/vexi/actor_collection.rb#32
  sig { abstract.returns(T::Array[T::Boolean]) }
  def values; end
end

# Public: Vexi adapters interface.
#
# @abstract Subclasses must implement the `abstract` methods below.
#
# source://vexi//lib/vexi/adapter.rb#6
module Vexi::Adapter
  interface!

  # @abstract
  #
  # source://vexi//lib/vexi/adapter.rb#18
  sig { abstract.returns(::String) }
  def adapter_name; end

  # @abstract
  #
  # source://vexi//lib/vexi/adapter.rb#12
  sig { abstract.params(_names: T::Array[::String]).returns(T::Array[::Vexi::GetFeatureFlagResponse]) }
  def get_feature_flags(_names); end

  # @abstract
  #
  # source://vexi//lib/vexi/adapter.rb#15
  sig { abstract.params(_names: T::Array[::String]).returns(T::Array[::Vexi::GetSegmentResponse]) }
  def get_segments(_names); end
end

# source://vexi//lib/vexi/adapters/feature_flag_hub_adapter.rb#13
module Vexi::Adapters; end

# source://vexi//lib/vexi/adapters/array_actor_collection.rb#8
class Vexi::Adapters::ArrayActorCollection
  include ::Vexi::ActorCollection

  # source://vexi//lib/vexi/adapters/array_actor_collection.rb#18
  sig { params(actors_array: T::Array[::String]).void }
  def initialize(actors_array); end

  # source://vexi//lib/vexi/adapters/array_actor_collection.rb#77
  sig { override.params(obj: T.untyped).returns(T::Boolean) }
  def ==(obj); end

  # source://vexi//lib/vexi/adapters/array_actor_collection.rb#23
  sig { override.params(key: ::String).returns(T.nilable(T::Boolean)) }
  def [](key); end

  # @raise [NotImplementedError]
  #
  # source://vexi//lib/vexi/adapters/array_actor_collection.rb#37
  sig { override.params(key: ::String, value: T::Boolean).void }
  def []=(key, value); end

  # source://vexi//lib/vexi/adapters/array_actor_collection.rb#15
  sig { returns(T::Array[::String]) }
  def actors_array; end

  # @raise [NotImplementedError]
  #
  # source://vexi//lib/vexi/adapters/array_actor_collection.rb#52
  sig { override.params(key: ::String).void }
  def delete(key); end

  # source://vexi//lib/vexi/adapters/array_actor_collection.rb#47
  sig { override.params(blk: T.proc.params(elem: [::String, T::Boolean]).returns(::BasicObject)).void }
  def each(&blk); end

  # source://vexi//lib/vexi/adapters/array_actor_collection.rb#72
  sig { override.returns(::String) }
  def inspect; end

  # source://vexi//lib/vexi/adapters/array_actor_collection.rb#57
  sig { override.returns(T::Array[::String]) }
  def keys; end

  # source://vexi//lib/vexi/adapters/array_actor_collection.rb#62
  sig { override.returns(::Numeric) }
  def length; end

  # source://vexi//lib/vexi/adapters/array_actor_collection.rb#67
  sig { override.returns(T::Array[T::Boolean]) }
  def values; end
end

# Public: File adapter for Vexi.
#
# source://vexi//lib/vexi/adapters/feature_flag_hub_adapter.rb#15
class Vexi::Adapters::FeatureFlagHubAdapter
  include ::Vexi::Adapter

  # source://vexi//lib/vexi/adapters/feature_flag_hub_adapter.rb#138
  sig { params(client: ::FeatureManagement::FeatureFlags::Data::V1::ChecksClient).void }
  def initialize(client); end

  # source://vexi//lib/vexi/adapters/feature_flag_hub_adapter.rb#98
  sig { override.returns(::String) }
  def adapter_name; end

  # source://vexi//lib/vexi/adapters/feature_flag_hub_adapter.rb#49
  sig { override.params(names: T::Array[::String]).returns(T::Array[::Vexi::GetFeatureFlagResponse]) }
  def get_feature_flags(names); end

  # source://vexi//lib/vexi/adapters/feature_flag_hub_adapter.rb#75
  sig { override.params(names: T::Array[::String]).returns(T::Array[::Vexi::GetSegmentResponse]) }
  def get_segments(names); end

  private

  # source://vexi//lib/vexi/adapters/feature_flag_hub_adapter.rb#143
  sig { params(response: T::Hash[::Symbol, T.untyped]).returns(::Vexi::FeatureFlag) }
  def convert_feature_flag_response(response); end

  # source://vexi//lib/vexi/adapters/feature_flag_hub_adapter.rb#162
  sig { params(response: T::Hash[::Symbol, T.untyped]).returns(::Vexi::Segment) }
  def convert_segment_response(response); end

  # source://vexi//lib/vexi/adapters/feature_flag_hub_adapter.rb#170
  sig { params(data: T::Hash[::Symbol, T.untyped]).returns(T::Hash[::String, ::Vexi::FeatureFlag]) }
  def create_feature_flags_found_hash(data); end

  class << self
    # source://vexi//lib/vexi/adapters/feature_flag_hub_adapter.rb#32
    sig { params(conn: ::Faraday::Connection).returns(::Vexi::Adapters::FeatureFlagHubAdapter) }
    def new_from_connection(conn); end

    # source://vexi//lib/vexi/adapters/feature_flag_hub_adapter.rb#40
    sig { params(hmac_key: ::String).returns(::Vexi::Adapters::FeatureFlagHubAdapter) }
    def new_from_env(hmac_key); end

    # source://vexi//lib/vexi/adapters/feature_flag_hub_adapter.rb#23
    sig { params(hmac_key: ::String, url: ::String).returns(::Vexi::Adapters::FeatureFlagHubAdapter) }
    def new_from_url(hmac_key, url); end

    private

    # source://vexi//lib/vexi/adapters/feature_flag_hub_adapter.rb#105
    sig { params(hmac_key: ::String, url: ::String).returns(::Faraday::Connection) }
    def connection(hmac_key, url); end

    # @raise [Errors::ValidationError]
    #
    # source://vexi//lib/vexi/adapters/feature_flag_hub_adapter.rb#119
    sig { returns(::String) }
    def feature_flag_hub_url; end
  end
end

# source://vexi//lib/vexi/adapters/feature_flag_hub_adapter.rb#20
Vexi::Adapters::FeatureFlagHubAdapter::DEFAULT_MAX_RETRIES = T.let(T.unsafe(nil), Integer)

# seconds
#
# source://vexi//lib/vexi/adapters/feature_flag_hub_adapter.rb#19
Vexi::Adapters::FeatureFlagHubAdapter::DEFAULT_OPEN_TIMEOUT = T.let(T.unsafe(nil), Float)

# seconds
#
# source://vexi//lib/vexi/adapters/feature_flag_hub_adapter.rb#18
Vexi::Adapters::FeatureFlagHubAdapter::DEFAULT_TIMEOUT = T.let(T.unsafe(nil), Float)

# Public: File adapter for Vexi.
#
# source://vexi//lib/vexi/adapters/file_adapter.rb#9
class Vexi::Adapters::FileAdapter
  include ::Vexi::Adapter

  # source://vexi//lib/vexi/adapters/file_adapter.rb#22
  sig { params(feature_flag_base_path: ::String, segments_base_path: ::String).void }
  def initialize(feature_flag_base_path, segments_base_path); end

  # source://vexi//lib/vexi/adapters/file_adapter.rb#53
  sig { override.returns(::String) }
  def adapter_name; end

  # @raise [ArgumentError]
  #
  # source://vexi//lib/vexi/adapters/file_adapter.rb#120
  sig { params(name: T.any(::String, ::Symbol), actor: T.any(::String, ::Vexi::Actor)).void }
  def add_actor(name, actor); end

  # @raise [ArgumentError]
  #
  # source://vexi//lib/vexi/adapters/file_adapter.rb#172
  sig { params(name: T.any(::String, ::Symbol), custom_gate: ::String).void }
  def add_custom_gate(name, custom_gate); end

  # source://vexi//lib/vexi/adapters/file_adapter.rb#65
  sig { params(feature_flag: ::Vexi::FeatureFlag).void }
  def create(feature_flag); end

  # source://vexi//lib/vexi/adapters/file_adapter.rb#85
  sig { params(name: T.any(::String, ::Symbol)).void }
  def delete(name); end

  # @raise [ArgumentError]
  #
  # source://vexi//lib/vexi/adapters/file_adapter.rb#104
  sig { params(name: T.any(::String, ::Symbol)).void }
  def disable(name); end

  # @raise [ArgumentError]
  #
  # source://vexi//lib/vexi/adapters/file_adapter.rb#93
  sig { params(name: T.any(::String, ::Symbol)).void }
  def enable(name); end

  # @raise [ArgumentError]
  #
  # source://vexi//lib/vexi/adapters/file_adapter.rb#152
  sig { params(name: T.any(::String, ::Symbol), percentage: ::Float).void }
  def enable_percentage_of_actors(name, percentage); end

  # @raise [ArgumentError]
  #
  # source://vexi//lib/vexi/adapters/file_adapter.rb#162
  sig { params(name: T.any(::String, ::Symbol), percentage: ::Float).void }
  def enable_percentage_of_calls(name, percentage); end

  # source://vexi//lib/vexi/adapters/file_adapter.rb#16
  sig { returns(::String) }
  def feature_flag_base_path; end

  # source://vexi//lib/vexi/adapters/file_adapter.rb#75
  sig { params(name: T.any(::String, ::Symbol)).returns(T.nilable(::Vexi::FeatureFlag)) }
  def get_feature_flag(name); end

  # source://vexi//lib/vexi/adapters/file_adapter.rb#29
  sig { override.params(names: T::Array[::String]).returns(T::Array[::Vexi::GetFeatureFlagResponse]) }
  def get_feature_flags(names); end

  # source://vexi//lib/vexi/adapters/file_adapter.rb#41
  sig { override.params(names: T::Array[::String]).returns(T::Array[::Vexi::GetSegmentResponse]) }
  def get_segments(names); end

  # source://vexi//lib/vexi/adapters/file_adapter.rb#57
  sig { params(name: ::String).returns(::Vexi::Segment) }
  def load_segment(name); end

  # @raise [ArgumentError]
  #
  # source://vexi//lib/vexi/adapters/file_adapter.rb#136
  sig { params(name: T.any(::String, ::Symbol), actor: T.any(::String, ::Vexi::Actor)).void }
  def remove_actor(name, actor); end

  # @raise [ArgumentError]
  #
  # source://vexi//lib/vexi/adapters/file_adapter.rb#182
  sig { params(name: T.any(::String, ::Symbol), custom_gate: ::String).void }
  def remove_custom_gate(name, custom_gate); end

  # source://vexi//lib/vexi/adapters/file_adapter.rb#19
  sig { returns(::String) }
  def segments_base_path; end

  private

  # source://vexi//lib/vexi/adapters/file_adapter.rb#207
  sig { params(name: T.any(::String, ::Symbol)).returns(::String) }
  def feature_flag_file_path(name); end

  # source://vexi//lib/vexi/adapters/file_adapter.rb#194
  sig { params(name: ::String).returns(::Vexi::FeatureFlag) }
  def load_feature_flag(name); end

  # source://vexi//lib/vexi/adapters/file_adapter.rb#212
  sig { params(feature_flag: ::Vexi::FeatureFlag).void }
  def write_feature_flag(feature_flag); end
end

# Public: In memory adapter for Vexi.
#
# source://vexi//lib/vexi/adapters/in_memory_adapter.rb#17
class Vexi::Adapters::InMemoryAdapter
  include ::Vexi::Adapter

  # source://vexi//lib/vexi/adapters/in_memory_adapter.rb#24
  sig { params(mode: ::Vexi::Adapters::InMemoryAdapterMode, exception_feature_flags: T::Array[::String]).void }
  def initialize(mode, exception_feature_flags: T.unsafe(nil)); end

  # source://vexi//lib/vexi/adapters/in_memory_adapter.rb#60
  sig { override.returns(::String) }
  def adapter_name; end

  # Adds an actor to the feature flag. Requires the feature flag to exist.
  #
  # @raise [ArgumentError]
  #
  # source://vexi//lib/vexi/adapters/in_memory_adapter.rb#127
  sig { params(name: T.any(::String, ::Symbol), actor: T.any(::String, ::Vexi::Actor)).void }
  def add_actor(name, actor); end

  # Adds a custom gate to the feature flag. Requires the feature flag to exist.
  #
  # @raise [ArgumentError]
  #
  # source://vexi//lib/vexi/adapters/in_memory_adapter.rb#179
  sig { params(name: T.any(::String, ::Symbol), custom_gate: ::String).void }
  def add_custom_gate(name, custom_gate); end

  # Creates a new feature flag with the given name. Will raise an error if the feature flag already exists.
  #
  # source://vexi//lib/vexi/adapters/in_memory_adapter.rb#71
  sig { params(feature_flag: ::Vexi::FeatureFlag).void }
  def create(feature_flag); end

  # Deletes a feature flag from the adapter.
  #
  # source://vexi//lib/vexi/adapters/in_memory_adapter.rb#93
  sig { params(name: T.any(::String, ::Symbol)).void }
  def delete(name); end

  # Disables the feature flag. It will create it if it does not exist.
  #
  # source://vexi//lib/vexi/adapters/in_memory_adapter.rb#108
  sig { params(name: T.any(::String, ::Symbol)).void }
  def disable(name); end

  # Fully enables the feature flag. It will create it if it does not exist.
  #
  # source://vexi//lib/vexi/adapters/in_memory_adapter.rb#100
  sig { params(name: T.any(::String, ::Symbol)).void }
  def enable(name); end

  # Enables the feature flag for a percentage of actors. Requires the feature flag to exist.
  #
  # @raise [ArgumentError]
  #
  # source://vexi//lib/vexi/adapters/in_memory_adapter.rb#169
  sig { params(name: T.any(::String, ::Symbol), percentage: ::Float).void }
  def enable_percentage_of_actors(name, percentage); end

  # Enables the feature flag for a percentage of calls. Requires the feature flag to exist.
  #
  # @raise [ArgumentError]
  #
  # source://vexi//lib/vexi/adapters/in_memory_adapter.rb#159
  sig { params(name: T.any(::String, ::Symbol), percentage: ::Float).void }
  def enable_percentage_of_calls(name, percentage); end

  # source://vexi//lib/vexi/adapters/in_memory_adapter.rb#82
  sig { params(name: T.any(::String, ::Symbol)).returns(T.nilable(::Vexi::FeatureFlag)) }
  def get(name); end

  # source://vexi//lib/vexi/adapters/in_memory_adapter.rb#41
  sig { override.params(names: T::Array[::String]).returns(T::Array[::Vexi::GetFeatureFlagResponse]) }
  def get_feature_flags(names); end

  # source://vexi//lib/vexi/adapters/in_memory_adapter.rb#55
  sig { override.params(_names: T::Array[::String]).returns(T::Array[::Vexi::GetSegmentResponse]) }
  def get_segments(_names); end

  # Removes an actor from the feature flag. Requires the feature flag to exist.
  #
  # @raise [ArgumentError]
  #
  # source://vexi//lib/vexi/adapters/in_memory_adapter.rb#143
  sig { params(name: T.any(::String, ::Symbol), actor: T.any(::String, ::Vexi::Actor)).void }
  def remove_actor(name, actor); end

  # Removes a custom gate from the feature flag. Requires the feature flag to exist.
  #
  # @raise [ArgumentError]
  #
  # source://vexi//lib/vexi/adapters/in_memory_adapter.rb#189
  sig { params(name: T.any(::String, ::Symbol), custom_gate: ::String).void }
  def remove_custom_gate(name, custom_gate); end

  # Resets the adapter to its initial state.
  #
  # source://vexi//lib/vexi/adapters/in_memory_adapter.rb#199
  sig { void }
  def reset; end
end

# Public: In memory adapter mode enum
#
# source://vexi//lib/vexi/adapters/in_memory_adapter.rb#9
class Vexi::Adapters::InMemoryAdapterMode < ::T::Enum
  enums do
    DisabledByDefault = new
    EnabledByDefault = new
  end
end

# Public: File adapter for Vexi.
#
# source://vexi//lib/vexi/adapters/monolith_optimized_feature_flag_data_adapter.rb#16
class Vexi::Adapters::MonolithOptimizedFeatureFlagDataAdapter
  include ::Vexi::Adapter

  # source://vexi//lib/vexi/adapters/monolith_optimized_feature_flag_data_adapter.rb#146
  sig { params(client: ::FeatureManagement::FeatureFlags::Data::V2::MonolithOptimizedChecksClient).void }
  def initialize(client); end

  # source://vexi//lib/vexi/adapters/monolith_optimized_feature_flag_data_adapter.rb#105
  sig { override.returns(::String) }
  def adapter_name; end

  # source://vexi//lib/vexi/adapters/monolith_optimized_feature_flag_data_adapter.rb#50
  sig { override.params(names: T::Array[::String]).returns(T::Array[::Vexi::GetFeatureFlagResponse]) }
  def get_feature_flags(names); end

  # source://vexi//lib/vexi/adapters/monolith_optimized_feature_flag_data_adapter.rb#77
  sig { override.params(names: T::Array[::String]).returns(T::Array[::Vexi::GetSegmentResponse]) }
  def get_segments(names); end

  private

  # source://vexi//lib/vexi/adapters/monolith_optimized_feature_flag_data_adapter.rb#151
  sig { params(response: T::Hash[::Symbol, T.untyped]).returns(::Vexi::FeatureFlag) }
  def convert_feature_flag_response(response); end

  # source://vexi//lib/vexi/adapters/monolith_optimized_feature_flag_data_adapter.rb#167
  sig { params(response: T::Hash[::Symbol, T.untyped]).returns(::Vexi::Segment) }
  def convert_segment_response(response); end

  # source://vexi//lib/vexi/adapters/monolith_optimized_feature_flag_data_adapter.rb#175
  sig { params(data: T::Hash[::Symbol, T.untyped]).returns(T::Hash[::String, ::Vexi::FeatureFlag]) }
  def create_feature_flags_found_hash(data); end

  # source://vexi//lib/vexi/adapters/monolith_optimized_feature_flag_data_adapter.rb#184
  sig { params(data: T::Hash[::Symbol, T.untyped]).returns(T::Hash[::String, ::Vexi::Segment]) }
  def create_segments_found_hash(data); end

  class << self
    # source://vexi//lib/vexi/adapters/monolith_optimized_feature_flag_data_adapter.rb#33
    sig { params(conn: ::Faraday::Connection).returns(::Vexi::Adapters::MonolithOptimizedFeatureFlagDataAdapter) }
    def new_from_connection(conn); end

    # source://vexi//lib/vexi/adapters/monolith_optimized_feature_flag_data_adapter.rb#41
    sig { params(hmac_key: ::String).returns(::Vexi::Adapters::MonolithOptimizedFeatureFlagDataAdapter) }
    def new_from_env(hmac_key); end

    # source://vexi//lib/vexi/adapters/monolith_optimized_feature_flag_data_adapter.rb#24
    sig do
      params(
        hmac_key: ::String,
        url: ::String
      ).returns(::Vexi::Adapters::MonolithOptimizedFeatureFlagDataAdapter)
    end
    def new_from_url(hmac_key, url); end

    private

    # source://vexi//lib/vexi/adapters/monolith_optimized_feature_flag_data_adapter.rb#112
    sig { params(hmac_key: ::String, url: ::String).returns(::Faraday::Connection) }
    def connection(hmac_key, url); end

    # @raise [Errors::ValidationError]
    #
    # source://vexi//lib/vexi/adapters/monolith_optimized_feature_flag_data_adapter.rb#127
    sig { returns(::String) }
    def feature_flag_data_url; end
  end
end

# source://vexi//lib/vexi/adapters/monolith_optimized_feature_flag_data_adapter.rb#21
Vexi::Adapters::MonolithOptimizedFeatureFlagDataAdapter::DEFAULT_MAX_RETRIES = T.let(T.unsafe(nil), Integer)

# seconds
#
# source://vexi//lib/vexi/adapters/monolith_optimized_feature_flag_data_adapter.rb#20
Vexi::Adapters::MonolithOptimizedFeatureFlagDataAdapter::DEFAULT_OPEN_TIMEOUT = T.let(T.unsafe(nil), Float)

# seconds
#
# source://vexi//lib/vexi/adapters/monolith_optimized_feature_flag_data_adapter.rb#19
Vexi::Adapters::MonolithOptimizedFeatureFlagDataAdapter::DEFAULT_TIMEOUT = T.let(T.unsafe(nil), Float)

# source://vexi//lib/vexi/builder.rb#11
class Vexi::Builder
  # source://vexi//lib/vexi/builder.rb#17
  sig { params(config: ::Vexi::Configuration).void }
  def initialize(config); end

  # source://vexi//lib/vexi/builder.rb#26
  sig { returns(::Vexi::Builders::AdapterBuilder) }
  def adapter; end

  # source://vexi//lib/vexi/builder.rb#31
  sig { returns(::Vexi::Builders::CacheBuilder) }
  def cache; end

  # source://vexi//lib/vexi/builder.rb#36
  sig { returns(::Vexi::Builders::CustomGatesEvaluatorBuilder) }
  def custom_gates_evaluator; end

  # source://vexi//lib/vexi/builder.rb#41
  sig do
    params(
      fallback_evaluator: T.proc.params(feature_flag_name: ::String, actors: T::Array[T.any(::String, ::Vexi::Actor)]).returns(T::Boolean)
    ).void
  end
  def fallback_evaluator(fallback_evaluator); end
end

# source://vexi//lib/vexi/builder.rb#14
class Vexi::Builder::BuilderError < ::StandardError; end

# source://vexi//lib/vexi/builders/adapter_builder.rb#12
module Vexi::Builders; end

# source://vexi//lib/vexi/builders/adapter_builder.rb#13
class Vexi::Builders::AdapterBuilder
  # source://vexi//lib/vexi/builders/adapter_builder.rb#17
  sig { params(config: ::Vexi::Configuration).void }
  def initialize(config); end

  # source://vexi//lib/vexi/builders/adapter_builder.rb#52
  sig { params(adapter: ::Vexi::Adapter).void }
  def custom(adapter); end

  # source://vexi//lib/vexi/builders/adapter_builder.rb#42
  sig { params(conn: ::Faraday::Connection).returns(::Vexi::Adapter) }
  def feature_flag_hub_from_connection(conn); end

  # source://vexi//lib/vexi/builders/adapter_builder.rb#47
  sig { params(hmac_key: ::String).returns(::Vexi::Adapter) }
  def feature_flag_hub_from_env(hmac_key); end

  # source://vexi//lib/vexi/builders/adapter_builder.rb#37
  sig { params(hmac_key: ::String, url: ::String).returns(::Vexi::Adapter) }
  def feature_flag_hub_from_url(hmac_key, url); end

  # source://vexi//lib/vexi/builders/adapter_builder.rb#62
  sig { params(feature_flag_base_path: ::String, segments_base_path: ::String).void }
  def file(feature_flag_base_path, segments_base_path); end

  # source://vexi//lib/vexi/builders/adapter_builder.rb#57
  sig { params(mode: ::Vexi::Adapters::InMemoryAdapterMode, exception_feature_flags: T::Array[::String]).void }
  def in_memory(mode, exception_feature_flags: T.unsafe(nil)); end

  # source://vexi//lib/vexi/builders/adapter_builder.rb#27
  sig { params(conn: ::Faraday::Connection).returns(::Vexi::Adapter) }
  def monolith_optimized_feature_flag_data_from_connection(conn); end

  # source://vexi//lib/vexi/builders/adapter_builder.rb#32
  sig { params(hmac_key: ::String).returns(::Vexi::Adapter) }
  def monolith_optimized_feature_flag_data_from_env(hmac_key); end

  # source://vexi//lib/vexi/builders/adapter_builder.rb#22
  sig { params(hmac_key: ::String, url: ::String).returns(::Vexi::Adapter) }
  def monolith_optimized_feature_flag_data_from_url(hmac_key, url); end
end

# source://vexi//lib/vexi/builders/cache_builder.rb#11
class Vexi::Builders::CacheBuilder
  # source://vexi//lib/vexi/builders/cache_builder.rb#15
  sig { params(config: ::Vexi::Configuration).void }
  def initialize(config); end

  # source://vexi//lib/vexi/builders/cache_builder.rb#25
  sig { params(custom_cache: ::Vexi::Cache, ttl: ::Integer, not_found_ttl: ::Integer).void }
  def custom(custom_cache, ttl, not_found_ttl); end

  # source://vexi//lib/vexi/builders/cache_builder.rb#20
  sig { params(ttl: ::Integer, not_found_ttl: ::Integer).void }
  def in_memory(ttl = T.unsafe(nil), not_found_ttl = T.unsafe(nil)); end
end

# source://vexi//lib/vexi/builders/custom_gates_evaluator_builder.rb#11
class Vexi::Builders::CustomGatesEvaluatorBuilder
  # source://vexi//lib/vexi/builders/custom_gates_evaluator_builder.rb#15
  sig { params(config: ::Vexi::Configuration).void }
  def initialize(config); end

  # source://vexi//lib/vexi/builders/custom_gates_evaluator_builder.rb#29
  sig { params(custom_gates_evaluator: ::Vexi::CustomGatesEvaluator).void }
  def custom(custom_gates_evaluator); end

  # source://vexi//lib/vexi/builders/custom_gates_evaluator_builder.rb#24
  sig do
    params(
      custom_gate_funcs: T::Hash[::String, T.proc.params(feature_flag: ::String, actor: T.any(::String, ::Vexi::Actor)).returns(T::Boolean)]
    ).void
  end
  def serial_gate_and_actor_evaluator(custom_gate_funcs); end
end

# Vexi cache interface.
#
# @abstract Subclasses must implement the `abstract` methods below.
#
# source://vexi//lib/vexi/cache.rb#8
module Vexi::Cache
  include ::Kernel

  interface!

  # @abstract
  #
  # source://vexi//lib/vexi/cache.rb#30
  sig { abstract.returns(::String) }
  def cache_name; end

  # @abstract
  #
  # source://vexi//lib/vexi/cache.rb#22
  sig { abstract.params(keys: T::Array[::String]).returns(T::Array[T.untyped]) }
  def mget(keys); end

  # lifetime is in seconds.
  # If lifetime is Cache::TTL_NEVER_EXPIRE, the value will never expire.
  #
  # @abstract
  #
  # source://vexi//lib/vexi/cache.rb#27
  sig { abstract.params(key_value_pairs: T::Hash[::String, T.untyped], lifetime: ::Numeric).void }
  def mset(key_value_pairs, lifetime); end
end

# source://vexi//lib/vexi/cache.rb#15
Vexi::Cache::TTL_NEVER_EXPIRE = T.let(T.unsafe(nil), Integer)

# Vexi cache config
#
# source://vexi//lib/vexi/cache_config.rb#8
class Vexi::CacheConfig
  # source://vexi//lib/vexi/cache_config.rb#27
  sig { params(cache: ::Vexi::Cache, ttl: ::Integer, not_found_ttl: ::Integer).void }
  def initialize(cache, ttl, not_found_ttl); end

  # Cache instance.
  #
  # source://vexi//lib/vexi/cache_config.rb#16
  sig { returns(::Vexi::Cache) }
  def cache; end

  # TTL for caching entities not found from adapter.
  #
  # source://vexi//lib/vexi/cache_config.rb#24
  sig { returns(::Integer) }
  def not_found_ttl; end

  # TTL for caching entities returned from the adapter.
  #
  # source://vexi//lib/vexi/cache_config.rb#20
  sig { returns(::Integer) }
  def ttl; end
end

# source://vexi//lib/vexi/caches/in_memory.rb#8
module Vexi::Caches; end

# Public: InMemory Cache definition.
#
# source://vexi//lib/vexi/caches/in_memory.rb#10
class Vexi::Caches::InMemory
  include ::Vexi::Cache

  # source://vexi//lib/vexi/caches/in_memory.rb#16
  sig { void }
  def initialize; end

  # source://vexi//lib/vexi/caches/in_memory.rb#46
  sig { override.returns(::String) }
  def cache_name; end

  # source://vexi//lib/vexi/caches/in_memory.rb#24
  sig { override.params(keys: T::Array[::String]).returns(T.untyped) }
  def mget(keys); end

  # source://vexi//lib/vexi/caches/in_memory.rb#36
  sig { override.params(key_value_pairs: T::Hash[::String, T.untyped], lifetime: ::Numeric).void }
  def mset(key_value_pairs, lifetime); end
end

# Public: The main Vexi class for performing feature flag enabled checks.
#
# source://vexi//lib/vexi/client.rb#24
class Vexi::Client
  # source://vexi//lib/vexi/client.rb#34
  sig do
    params(
      config: ::Vexi::Configuration,
      feature_flag_service: Vexi::Services::FeatureFlagService,
      segment_service: Vexi::Services::SegmentService
    ).void
  end
  def initialize(config, feature_flag_service, segment_service); end

  # source://vexi//lib/vexi/client.rb#83
  sig { returns(T::Hash[::Symbol, ::String]) }
  def configuration_context; end

  # source://vexi//lib/vexi/client.rb#48
  sig { params(name: T.any(::String, ::Symbol), actors: T.any(::String, ::Vexi::Actor)).returns(T::Boolean) }
  def enabled?(name, *actors); end

  # source://vexi//lib/vexi/client.rb#55
  sig { params(value: T::Boolean).void }
  def memoize=(value); end

  # source://vexi//lib/vexi/client.rb#62
  sig { returns(T::Boolean) }
  def memoizing?; end

  # Preload the named feature flags and any related segments into the cache and/or memoization layer.
  # fetch_directly_from_adapter (default: true)
  #   If true, fetch the data directly from the adapter and replace any existing values in the cache.
  #   Use false to only fetch from the adapter on cache miss, but not to replace existing values in the cache. This can be used for preloading from the cache into the memoization layer.
  # cache_without_expiry (default: false)
  #   If true, preloaded records will be stored in cache without expiry.
  #      Use this along with a cache that has a TTL to ensure that preloaded records never expire (this assumes you have a separate process for updating the cache or calling preload).
  #      This enables any non-preloaded feature flags checked via enabled? calls to use the configured TTL for expiry.
  #   If false, preloaded records will be stored in the cache with the TTL configured along with the cache.
  #
  # source://vexi//lib/vexi/client.rb#76
  sig do
    params(
      names: T::Array[T.any(::String, ::Symbol)],
      fetch_directly_from_adapter: T::Boolean,
      cache_without_expiry: T::Boolean
    ).void
  end
  def preload(names, fetch_directly_from_adapter: T.unsafe(nil), cache_without_expiry: T.unsafe(nil)); end

  private

  # source://vexi//lib/vexi/client.rb#90
  sig { params(name: T.any(::String, ::Symbol), actors: T::Array[T.any(::String, ::Vexi::Actor)]).returns(T::Boolean) }
  def enabled_internal?(name, actors); end

  # @raise [Errors::ValidationError]
  #
  # source://vexi//lib/vexi/client.rb#165
  sig do
    params(
      names: T::Array[T.any(::String, ::Symbol)],
      fetch_directly_from_adapter: T::Boolean,
      cache_without_expiry: T::Boolean
    ).returns(T::Boolean)
  end
  def preload_internal(names, fetch_directly_from_adapter, cache_without_expiry); end
end

# source://vexi//lib/vexi/configuration.rb#11
class Vexi::Configuration
  # source://vexi//lib/vexi/configuration.rb#38
  sig do
    params(
      adapter: T.nilable(::Vexi::Adapter),
      cache_config: T.nilable(::Vexi::CacheConfig),
      custom_gates_evaluator: T.nilable(::Vexi::CustomGatesEvaluator)
    ).void
  end
  def initialize(adapter: T.unsafe(nil), cache_config: T.unsafe(nil), custom_gates_evaluator: T.unsafe(nil)); end

  # source://vexi//lib/vexi/configuration.rb#65
  sig { returns(::Vexi::Adapter) }
  def adapter; end

  # source://vexi//lib/vexi/configuration.rb#74
  sig { params(adapter: ::Vexi::Adapter).void }
  def adapter=(adapter); end

  # source://vexi//lib/vexi/configuration.rb#20
  sig { returns(T.nilable(::Vexi::CacheConfig)) }
  def cache_config; end

  # source://vexi//lib/vexi/configuration.rb#83
  sig { params(cache_config: ::Vexi::CacheConfig).void }
  def cache_config=(cache_config); end

  # source://vexi//lib/vexi/configuration.rb#48
  sig { returns(T::Boolean) }
  def configured?; end

  # source://vexi//lib/vexi/configuration.rb#107
  sig { returns(T::Hash[::Symbol, ::String]) }
  def context; end

  # source://vexi//lib/vexi/configuration.rb#53
  sig { returns(::Vexi::Client) }
  def create_instance; end

  # source://vexi//lib/vexi/configuration.rb#23
  sig { returns(T.nilable(::Vexi::CustomGatesEvaluator)) }
  def custom_gates_evaluator; end

  # source://vexi//lib/vexi/configuration.rb#92
  sig { params(custom_gates_evaluator: ::Vexi::CustomGatesEvaluator).void }
  def custom_gates_evaluator=(custom_gates_evaluator); end

  # source://vexi//lib/vexi/configuration.rb#29
  sig { returns(T::Array[::String]) }
  def errors; end

  # source://vexi//lib/vexi/configuration.rb#26
  sig do
    returns(T.proc.params(feature_flag_name: ::String, actors: T::Array[T.any(::String, ::Vexi::Actor)]).returns(T::Boolean))
  end
  def fallback_evaluator; end

  # source://vexi//lib/vexi/configuration.rb#101
  sig do
    params(
      fallback_evaluator: T.proc.params(feature_flag_name: ::String, actors: T::Array[T.any(::String, ::Vexi::Actor)]).returns(T::Boolean)
    ).void
  end
  def fallback_evaluator=(fallback_evaluator); end

  # source://vexi//lib/vexi/configuration.rb#120
  sig { returns(T::Boolean) }
  def valid?; end
end

# source://vexi//lib/vexi/configuration.rb#17
class Vexi::Configuration::ConfigurationError < ::StandardError; end

# source://vexi//lib/vexi/configuration.rb#15
Vexi::Configuration::DEFAULT_FALLBACK_EVALUATOR = T.let(T.unsafe(nil), Proc)

# source://vexi//lib/vexi/configuration.rb#14
Vexi::Configuration::FallbackEvaluator = T.type_alias { T.proc.params(feature_flag_name: ::String, actors: T::Array[T.any(::String, ::Vexi::Actor)]).returns(T::Boolean) }

# Public: Vexi custom gates evaluator interface.
#
# @abstract Subclasses must implement the `abstract` methods below.
#
# source://vexi//lib/vexi/custom_gates_evaluator.rb#6
module Vexi::CustomGatesEvaluator
  include ::Kernel

  interface!

  # @abstract
  #
  # source://vexi//lib/vexi/custom_gates_evaluator.rb#20
  sig { abstract.returns(::String) }
  def custom_gates_evaluator_name; end

  # @abstract
  #
  # source://vexi//lib/vexi/custom_gates_evaluator.rb#17
  sig do
    abstract
      .params(
        feature_name: ::String,
        custom_gate_names: T::Array[::String],
        actors: T::Array[T.any(::String, ::Vexi::Actor)]
      ).returns(T::Boolean)
  end
  def enabled?(feature_name, custom_gate_names, actors); end
end

# Public: Vexi Custom Gates evaluators that ship with the library.
#
# source://vexi//lib/vexi/custom_gates_evaluators/serial_gate_and_actor_evaluator.rb#8
module Vexi::CustomGatesEvaluators; end

# Public: Serially evaluates each custom gate for each actor id or actor individually.
# Does not support batching actors to a custom gate.
#
# source://vexi//lib/vexi/custom_gates_evaluators/serial_gate_and_actor_evaluator.rb#11
class Vexi::CustomGatesEvaluators::SerialGateAndActorEvaluator
  include ::Vexi::CustomGatesEvaluator

  # source://vexi//lib/vexi/custom_gates_evaluators/serial_gate_and_actor_evaluator.rb#22
  sig do
    params(
      custom_gate_funcs: T::Hash[::String, T.proc.params(feature_flag: ::String, actor: T.any(::String, ::Vexi::Actor)).returns(T::Boolean)]
    ).void
  end
  def initialize(custom_gate_funcs); end

  # source://vexi//lib/vexi/custom_gates_evaluators/serial_gate_and_actor_evaluator.rb#74
  sig { override.returns(::String) }
  def custom_gates_evaluator_name; end

  # source://vexi//lib/vexi/custom_gates_evaluators/serial_gate_and_actor_evaluator.rb#34
  sig do
    override
      .params(
        feature_flag: ::String,
        custom_gate_names: T::Array[::String],
        actors: T::Array[T.any(::String, ::Vexi::Actor)]
      ).returns(T::Boolean)
  end
  def enabled?(feature_flag, custom_gate_names, actors); end
end

# Public: Vexi entity interface.
#
# @abstract Subclasses must implement the `abstract` methods below.
#
# source://vexi//lib/vexi/entity.rb#8
module Vexi::Entity
  interface!

  # @abstract
  #
  # source://vexi//lib/vexi/entity.rb#14
  sig { abstract.returns(::String) }
  def name; end
end

# Public: Vexi errors that ship with the library.
#
# source://vexi//lib/vexi/errors/entity_not_found_error.rb#5
module Vexi::Errors; end

# Public: Vexi entity not found error.
#
# @abstract It cannot be directly instantiated. Subclasses must implement the `abstract` methods below.
#
# source://vexi//lib/vexi/errors/entity_not_found_error.rb#7
class Vexi::Errors::EntityNotFoundError < ::StandardError
  abstract!

  # source://vexi//lib/vexi/errors/entity_not_found_error.rb#21
  sig { params(entity_id: ::String, entity_type: ::String).void }
  def initialize(entity_id, entity_type); end

  # This is a getter method for @entity_id. It returns the value of @entity_id.
  #
  # source://vexi//lib/vexi/errors/entity_not_found_error.rb#14
  sig { returns(::String) }
  def entity_id; end

  # This is a getter method for @entity_type. It returns the value of @entity_type.
  #
  # source://vexi//lib/vexi/errors/entity_not_found_error.rb#18
  sig { returns(::String) }
  def entity_type; end
end

# Public: Vexi feature flag not found error.
#
# source://vexi//lib/vexi/errors/feature_flag_not_found_error.rb#7
class Vexi::Errors::FeatureFlagNotFoundError < ::Vexi::Errors::EntityNotFoundError
  # source://vexi//lib/vexi/errors/feature_flag_not_found_error.rb#11
  sig { params(entity_id: ::String).void }
  def initialize(entity_id); end
end

# Public: Vexi file not found error.
#
# source://vexi//lib/vexi/errors/file_not_found_error.rb#7
class Vexi::Errors::FileNotFoundError < ::Vexi::Errors::EntityNotFoundError
  # source://vexi//lib/vexi/errors/file_not_found_error.rb#11
  sig { params(entity_id: ::String).void }
  def initialize(entity_id); end
end

# Public: Vexi segment not found error.
#
# source://vexi//lib/vexi/errors/segment_not_found_error.rb#7
class Vexi::Errors::SegmentNotFoundError < ::Vexi::Errors::EntityNotFoundError
  # source://vexi//lib/vexi/errors/segment_not_found_error.rb#11
  sig { params(entity_id: ::String).void }
  def initialize(entity_id); end
end

# Public: Vexi validation error.
#
# source://vexi//lib/vexi/errors/validation_error.rb#7
class Vexi::Errors::ValidationError < ::StandardError; end

# FeatureFlag is the struct that represents a feature flag.
#
# source://vexi//lib/vexi/models/feature_flag.rb#11
class Vexi::FeatureFlag
  include ::Vexi::Entity

  # source://vexi//lib/vexi/models/feature_flag.rb#45
  sig { void }
  def initialize; end

  # source://vexi//lib/vexi/models/feature_flag.rb#36
  sig { returns(::Vexi::ActorCollection) }
  def actors; end

  # @return [ActorCollection]
  #
  # source://vexi//lib/vexi/models/feature_flag.rb#36
  def actors=(_arg0); end

  # source://vexi//lib/vexi/models/feature_flag.rb#21
  sig { returns(T::Boolean) }
  def boolean_gate; end

  # @return [Boolean]
  #
  # source://vexi//lib/vexi/models/feature_flag.rb#21
  def boolean_gate=(_arg0); end

  # source://vexi//lib/vexi/models/feature_flag.rb#33
  sig { returns(T::Array[::String]) }
  def custom_gates; end

  # @return [Array<String>]
  #
  # source://vexi//lib/vexi/models/feature_flag.rb#33
  def custom_gates=(_arg0); end

  # source://vexi//lib/vexi/models/feature_flag.rb#39
  sig { returns(::String) }
  def default_segment; end

  # @return [String]
  #
  # source://vexi//lib/vexi/models/feature_flag.rb#39
  def default_segment=(_arg0); end

  # source://vexi//lib/vexi/models/feature_flag.rb#42
  sig { returns(T::Boolean) }
  def is_default_segment_embedded; end

  # @return [Boolean]
  #
  # source://vexi//lib/vexi/models/feature_flag.rb#42
  def is_default_segment_embedded=(_arg0); end

  # source://vexi//lib/vexi/models/feature_flag.rb#58
  sig { override.returns(::String) }
  def name; end

  # source://vexi//lib/vexi/models/feature_flag.rb#18
  sig { params(name: ::String).void }
  def name=(name); end

  # source://vexi//lib/vexi/models/feature_flag.rb#24
  sig { returns(::Float) }
  def percentage_of_actors; end

  # @return [Float]
  #
  # source://vexi//lib/vexi/models/feature_flag.rb#24
  def percentage_of_actors=(_arg0); end

  # source://vexi//lib/vexi/models/feature_flag.rb#27
  sig { returns(::Float) }
  def percentage_of_calls; end

  # @return [Float]
  #
  # source://vexi//lib/vexi/models/feature_flag.rb#27
  def percentage_of_calls=(_arg0); end

  # source://vexi//lib/vexi/models/feature_flag.rb#30
  sig { returns(T::Array[::String]) }
  def segments; end

  # @return [Array<String>]
  #
  # source://vexi//lib/vexi/models/feature_flag.rb#30
  def segments=(_arg0); end

  # source://vexi//lib/vexi/models/feature_flag.rb#116
  sig { params(key: ::String, value: T.untyped).void }
  def set_property(key, value); end

  class << self
    # source://vexi//lib/vexi/models/feature_flag.rb#105
    sig { params(feature_flag: ::Vexi::FeatureFlag).returns(::Integer) }
    def calculate_state(feature_flag); end

    # source://vexi//lib/vexi/models/feature_flag.rb#81
    sig { params(name: ::String, enabled: T::Boolean).returns(::Vexi::FeatureFlag) }
    def create_boolean_feature_flag(name, enabled); end

    # source://vexi//lib/vexi/models/feature_flag.rb#76
    sig { params(name: ::String).returns(::Vexi::FeatureFlag) }
    def create_default(name); end

    # source://vexi//lib/vexi/models/feature_flag.rb#63
    sig { params(json: T::Hash[::String, T.untyped]).returns(::Vexi::FeatureFlag) }
    def from_json(json); end

    # source://vexi//lib/vexi/models/feature_flag.rb#90
    sig { params(feature_flag: ::Vexi::FeatureFlag).returns(T::Hash[::String, T.untyped]) }
    def to_h(feature_flag); end
  end
end

# GetEntityResponse is the abstract base class for get entity response.
#
# source://vexi//lib/vexi/models/get_entity_response.rb#8
class Vexi::GetEntityResponse
  # source://vexi//lib/vexi/models/get_entity_response.rb#21
  sig { params(name: ::String, entity: T.untyped, error: T.nilable(::StandardError)).void }
  def initialize(name: T.unsafe(nil), entity: T.unsafe(nil), error: T.unsafe(nil)); end

  # source://vexi//lib/vexi/models/get_entity_response.rb#15
  sig { returns(::Vexi::Entity) }
  def entity; end

  # source://vexi//lib/vexi/models/get_entity_response.rb#18
  sig { returns(T.nilable(::StandardError)) }
  def error; end

  # source://vexi//lib/vexi/models/get_entity_response.rb#12
  sig { returns(::String) }
  def name; end
end

# GetFeatureFlagResponse is the response returned by the GetFeatureFlag method.
#
# source://vexi//lib/vexi/models/get_feature_flag_response.rb#6
class Vexi::GetFeatureFlagResponse < ::Vexi::GetEntityResponse
  # source://vexi//lib/vexi/models/get_feature_flag_response.rb#14
  sig { params(name: ::String, feature_flag: T.nilable(::Vexi::FeatureFlag), error: T.nilable(::StandardError)).void }
  def initialize(name: T.unsafe(nil), feature_flag: T.unsafe(nil), error: T.unsafe(nil)); end

  # source://vexi//lib/vexi/models/get_feature_flag_response.rb#11
  sig { returns(T.nilable(::Vexi::FeatureFlag)) }
  def feature_flag; end

  # @return [FeatureFlag, nil]
  #
  # source://vexi//lib/vexi/models/get_feature_flag_response.rb#11
  def feature_flag=(_arg0); end
end

# GetSegmentResponse is the response returned by the GetSegment method.
#
# source://vexi//lib/vexi/models/get_segment_response.rb#6
class Vexi::GetSegmentResponse < ::Vexi::GetEntityResponse
  # source://vexi//lib/vexi/models/get_segment_response.rb#14
  sig { params(name: ::String, segment: T.nilable(::Vexi::Segment), error: T.nilable(::StandardError)).void }
  def initialize(name: T.unsafe(nil), segment: T.unsafe(nil), error: T.unsafe(nil)); end

  # source://vexi//lib/vexi/models/get_segment_response.rb#11
  sig { returns(T.nilable(::Vexi::Segment)) }
  def segment; end
end

# source://vexi//lib/vexi/hash_actor_collection.rb#8
class Vexi::HashActorCollection
  include ::Vexi::ActorCollection

  # source://vexi//lib/vexi/hash_actor_collection.rb#18
  sig { params(actors_hash: T::Hash[::String, T::Boolean]).void }
  def initialize(actors_hash); end

  # source://vexi//lib/vexi/hash_actor_collection.rb#65
  sig { override.params(obj: T.untyped).returns(T::Boolean) }
  def ==(obj); end

  # source://vexi//lib/vexi/hash_actor_collection.rb#23
  sig { override.params(key: ::String).returns(T.nilable(T::Boolean)) }
  def [](key); end

  # source://vexi//lib/vexi/hash_actor_collection.rb#28
  sig { override.params(key: ::String, value: T::Boolean).void }
  def []=(key, value); end

  # source://vexi//lib/vexi/hash_actor_collection.rb#15
  sig { returns(T::Hash[::String, T::Boolean]) }
  def actors_hash; end

  # source://vexi//lib/vexi/hash_actor_collection.rb#43
  sig { override.params(key: ::String).void }
  def delete(key); end

  # source://vexi//lib/vexi/hash_actor_collection.rb#38
  sig { override.params(blk: T.proc.params(elem: [::String, T::Boolean]).returns(::BasicObject)).void }
  def each(&blk); end

  # source://vexi//lib/vexi/hash_actor_collection.rb#60
  sig { override.returns(::String) }
  def inspect; end

  # source://vexi//lib/vexi/hash_actor_collection.rb#45
  sig { override.returns(T::Array[::String]) }
  def keys; end

  # source://vexi//lib/vexi/hash_actor_collection.rb#50
  sig { override.returns(::Numeric) }
  def length; end

  # source://vexi//lib/vexi/hash_actor_collection.rb#55
  sig { override.returns(T::Array[T::Boolean]) }
  def values; end
end

# source://vexi//lib/vexi/instrumentation_context.rb#8
class Vexi::InstrumentationContext
  # source://vexi//lib/vexi/instrumentation_context.rb#14
  sig { params(store: T::Hash[::Symbol, T.any(::Numeric, ::String, ::Time, T::Array[::String], T::Boolean)]).void }
  def initialize(store = T.unsafe(nil)); end

  # source://vexi//lib/vexi/instrumentation_context.rb#41
  sig { params(key: ::Symbol, value: T.any(::Numeric, ::String, ::Time, T::Array[::String], T::Boolean)).void }
  def []=(key, value); end

  # source://vexi//lib/vexi/instrumentation_context.rb#23
  sig do
    type_parameters(:U)
      .params(
        property_name: ::Symbol,
        block: T.proc.returns(T.all(T.nilable(T::Boolean), T.type_parameter(:U)))
      ).returns(T.all(T.nilable(T::Boolean), T.type_parameter(:U)))
  end
  def capture_boolean(property_name, &block); end

  # source://vexi//lib/vexi/instrumentation_context.rb#34
  sig do
    type_parameters(:U)
      .params(
        property_name: ::Symbol,
        block: T.proc.returns(T.all(T.nilable(T.any(T::Array[T.untyped], T::Hash[T.untyped, T.untyped])), T.type_parameter(:U)))
      ).returns(T.all(T.nilable(T.any(T::Array[T.untyped], T::Hash[T.untyped, T.untyped])), T.type_parameter(:U)))
  end
  def capture_collection_size(property_name, &block); end

  # source://vexi//lib/vexi/instrumentation_context.rb#46
  sig { returns(T::Hash[::Symbol, T.any(::Numeric, ::String, ::Time, T::Array[::String], T::Boolean)]) }
  def to_h; end
end

# source://vexi//lib/vexi/instrumentation_context.rb#11
Vexi::InstrumentationContext::CollectionType = T.type_alias { T.nilable(T.any(T::Array[T.untyped], T::Hash[T.untyped, T.untyped])) }

# Vexi instrumenter interface
#
# @abstract Subclasses must implement the `abstract` methods below.
#
# source://vexi//lib/vexi/instrumenter.rb#6
module Vexi::Instrumenter
  include ::Kernel

  interface!

  # @abstract
  #
  # source://vexi//lib/vexi/instrumenter.rb#19
  sig do
    abstract
      .params(
        _name: ::String,
        _payload: T::Hash[::Symbol, T.any(::Numeric, ::String, ::Time, T::Array[::String], T::Boolean)]
      ).void
  end
  def instrument(_name, _payload = T.unsafe(nil)); end
end

# source://vexi//lib/vexi/instrumenter.rb#14
Vexi::Instrumenter::NotificationContext = T.type_alias { T::Hash[::Symbol, T.any(::Numeric, ::String, ::Time, T::Array[::String], T::Boolean)] }

# source://vexi//lib/vexi/instrumenter.rb#13
Vexi::Instrumenter::NotificationContextValue = T.type_alias { T.any(::Numeric, ::String, ::Time, T::Array[::String], T::Boolean) }

# Public: Vexi custom gates evalautor interface.
#
# source://vexi//lib/vexi/non_actor_gate_evaluator.rb#8
class Vexi::NonActorGateEvaluator
  class << self
    # source://vexi//lib/vexi/non_actor_gate_evaluator.rb#13
    sig { params(feature_flag: ::Vexi::FeatureFlag).returns(T::Boolean) }
    def evaluate_boolean_gate(feature_flag); end

    # source://vexi//lib/vexi/non_actor_gate_evaluator.rb#36
    sig { params(embedded_actor_ids: ::Vexi::ActorCollection, actor_ids: T::Array[::String]).returns(T::Boolean) }
    def evaluate_embedded_actors(embedded_actor_ids, actor_ids); end

    # source://vexi//lib/vexi/non_actor_gate_evaluator.rb#27
    sig { params(feature_flag: ::Vexi::FeatureFlag, actor_ids: T::Array[::String]).returns(T::Boolean) }
    def evaluate_percentage_of_actors(feature_flag, actor_ids); end

    # source://vexi//lib/vexi/non_actor_gate_evaluator.rb#18
    sig { params(feature_flag: ::Vexi::FeatureFlag).returns(T::Boolean) }
    def evaluate_percentage_of_calls(feature_flag); end
  end
end

# Private: this constant is used to support up to 3 decimal places in percentages.
#
# source://vexi//lib/vexi/non_actor_gate_evaluator.rb#23
Vexi::NonActorGateEvaluator::SCALING_FACTOR = T.let(T.unsafe(nil), Integer)

# Public: The notifications class is used by components to publish notifications for observability
#
# source://vexi//lib/vexi/notifications.rb#12
class Vexi::Notifications
  class << self
    # source://vexi//lib/vexi/notifications.rb#21
    sig { returns(T::Hash[::Symbol, ::String]) }
    def configuration_context; end

    # @return [Hash{Symbol => String}]
    #
    # source://vexi//lib/vexi/notifications.rb#21
    def configuration_context=(_arg0); end

    # Method instrument_cache_hit_or_miss publishes an event under the name `vexi.cache.#{cached_object_type}.get`
    # whenever a cache hit or miss occurs.
    #
    # source://vexi//lib/vexi/notifications.rb#85
    sig do
      params(
        cached_object_type: ::String,
        cache_hit: T::Boolean,
        context: T::Hash[::Symbol, T.any(::Numeric, ::String, ::Time, T::Array[::String], T::Boolean)]
      ).void
    end
    def instrument_cache_hit_or_miss(cached_object_type, cache_hit, context); end

    # Method instrument_duration publishes an event under the name vexi.#{operation}.duration whenever
    # a operation timing has been measured.
    #
    # source://vexi//lib/vexi/notifications.rb#50
    sig do
      params(
        operation: ::String,
        measured_start: ::Time,
        measured_finish: ::Time,
        context: T::Hash[::Symbol, T.any(::Numeric, ::String, ::Time, T::Array[::String], T::Boolean)]
      ).void
    end
    def instrument_duration(operation, measured_start, measured_finish, context); end

    # Method instrument_exception publishes an event under the name vexi.#{operation}.error whenever an error has occurred
    #
    # source://vexi//lib/vexi/notifications.rb#34
    sig do
      params(
        operation: ::String,
        message: ::String,
        err: ::Exception,
        context: T::Hash[::Symbol, T.any(::Numeric, ::String, ::Time, T::Array[::String], T::Boolean)]
      ).void
    end
    def instrument_exception(operation, message, err, context); end

    # Method instrument_timing is a helper operation that wraps a block of code with timing
    # to call instrument_duration
    #
    # source://vexi//lib/vexi/notifications.rb#71
    sig do
      type_parameters(:U)
        .params(
          operation: ::String,
          context: T::Hash[::Symbol, T.any(::Numeric, ::String, ::Time, T::Array[::String], T::Boolean)],
          block: T.proc.params(context: ::Vexi::InstrumentationContext).returns(T.type_parameter(:U))
        ).returns(T.type_parameter(:U))
    end
    def instrument_timing(operation, context = T.unsafe(nil), &block); end

    # source://vexi//lib/vexi/notifications.rb#18
    sig { returns(::Vexi::Instrumenter) }
    def instrumenter; end

    # @return [Instrumenter]
    #
    # source://vexi//lib/vexi/notifications.rb#18
    def instrumenter=(_arg0); end
  end
end

# source://vexi//lib/vexi/observability/notification.rb#8
module Vexi::Observability; end

# Vexi payload contained in cache-hit-or-miss notifications
#
# source://vexi//lib/vexi/observability/cache_hit_or_miss_payload.rb#10
class Vexi::Observability::CacheHitOrMissPayload
  # source://vexi//lib/vexi/observability/cache_hit_or_miss_payload.rb#15
  sig { params(event: ::ActiveSupport::Notifications::Event).void }
  def initialize(event); end

  # Public: Whether it was a cache hit or miss
  #
  # source://vexi//lib/vexi/observability/cache_hit_or_miss_payload.rb#28
  sig { returns(T::Boolean) }
  def cache_hit; end

  # Public: The type of cached cache that was measured. Example: segments_actors_combination
  #
  # source://vexi//lib/vexi/observability/cache_hit_or_miss_payload.rb#24
  sig { returns(::String) }
  def cached_object_type; end

  # Public: The context tags for the measurement
  #
  # source://vexi//lib/vexi/observability/cache_hit_or_miss_payload.rb#32
  sig { returns(T::Hash[::Symbol, T.any(::Exception, ::Numeric, ::String, ::Time, T::Array[::String], T::Boolean)]) }
  def context_tags; end
end

# Vexi payload contained in duration notifications
#
# source://vexi//lib/vexi/observability/duration_payload.rb#10
class Vexi::Observability::DurationPayload
  # source://vexi//lib/vexi/observability/duration_payload.rb#15
  sig { params(event: ::ActiveSupport::Notifications::Event).void }
  def initialize(event); end

  # Public: The context tags for the measurement
  #
  # source://vexi//lib/vexi/observability/duration_payload.rb#44
  sig { returns(T::Hash[::Symbol, T.any(::Numeric, ::String, ::Time, T::Array[::String], T::Boolean)]) }
  def context_tags; end

  # Public: The feature flag for the measurement (optional)
  #
  # source://vexi//lib/vexi/observability/duration_payload.rb#52
  sig { returns(::String) }
  def custom_gate_name; end

  # Public: The entities count for the measurement (optional)
  #
  # source://vexi//lib/vexi/observability/duration_payload.rb#56
  sig { returns(T.nilable(::Numeric)) }
  def entities_count; end

  # Public: The feature flag for the measurement (optional)
  #
  # source://vexi//lib/vexi/observability/duration_payload.rb#48
  sig { returns(::String) }
  def feature_flag; end

  # Public: The finish time of the measurement
  #
  # source://vexi//lib/vexi/observability/duration_payload.rb#36
  sig { returns(::Time) }
  def measured_finish; end

  # Public: The start time of the measurement
  #
  # source://vexi//lib/vexi/observability/duration_payload.rb#32
  sig { returns(::Time) }
  def measured_start; end

  # Public: The operation that was measured
  #
  # source://vexi//lib/vexi/observability/duration_payload.rb#28
  sig { returns(::String) }
  def operation; end

  # Public: The result of the operation
  #
  # source://vexi//lib/vexi/observability/duration_payload.rb#40
  sig { returns(T.nilable(T::Boolean)) }
  def result; end
end

# Vexi payload contained in error notifications
#
# source://vexi//lib/vexi/observability/error_payload.rb#10
class Vexi::Observability::ErrorPayload
  # source://vexi//lib/vexi/observability/error_payload.rb#15
  sig { params(event: ::ActiveSupport::Notifications::Event).void }
  def initialize(event); end

  # Public: The actor ids for the error when actor ids are used (optional)
  #
  # source://vexi//lib/vexi/observability/error_payload.rb#62
  sig { returns(T::Array[::String]) }
  def actor_ids; end

  # Public: The context tags for the error
  #
  # source://vexi//lib/vexi/observability/error_payload.rb#42
  sig { returns(T::Hash[::Symbol, T.any(::Exception, ::Numeric, ::String, ::Time, T::Array[::String], T::Boolean)]) }
  def context_tags; end

  # Public: The custom gate names for the error when custom gate evaluators are used (optional)
  #
  # source://vexi//lib/vexi/observability/error_payload.rb#58
  sig { returns(T::Array[::String]) }
  def custom_gate_names; end

  # Public: The exception associated with the error (optional)
  #
  # source://vexi//lib/vexi/observability/error_payload.rb#38
  sig { returns(T.nilable(::Exception)) }
  def exception; end

  # Public: The feature flag for the error (optional)
  #
  # source://vexi//lib/vexi/observability/error_payload.rb#46
  sig { returns(::String) }
  def feature_flag; end

  # Public: The message associated with the error
  #
  # source://vexi//lib/vexi/observability/error_payload.rb#34
  sig { returns(::String) }
  def message; end

  # Public: The operation that the error occured inside. Defaults to 'unspecified'
  #
  # source://vexi//lib/vexi/observability/error_payload.rb#30
  sig { returns(::String) }
  def operation; end

  # Public: The segment names for the error (optional)
  #
  # source://vexi//lib/vexi/observability/error_payload.rb#50
  sig { returns(T::Array[::String]) }
  def segments; end

  # Public: The stage of processing for the error (optional)
  #
  # source://vexi//lib/vexi/observability/error_payload.rb#54
  sig { returns(::String) }
  def stage; end
end

# Vexi activesupport notifications instrumenter
#
# source://vexi//lib/vexi/observability/notification.rb#10
class Vexi::Observability::Notification
  include ::Vexi::Instrumenter

  # source://vexi//lib/vexi/observability/notification.rb#19
  sig do
    override
      .params(
        name: ::String,
        payload: T::Hash[::Symbol, T.any(::Numeric, ::String, ::Time, T::Array[::String], T::Boolean)]
      ).void
  end
  def instrument(name, payload = T.unsafe(nil)); end
end

# Segment represents a segment.
#
# source://vexi//lib/vexi/models/segment.rb#10
class Vexi::Segment
  include ::Vexi::Entity

  # source://vexi//lib/vexi/models/segment.rb#23
  sig { params(name: ::String, actors: ::Vexi::ActorCollection, actors_embedded: T::Boolean).void }
  def initialize(name: T.unsafe(nil), actors: T.unsafe(nil), actors_embedded: T.unsafe(nil)); end

  # source://vexi//lib/vexi/models/segment.rb#20
  sig { returns(::Vexi::ActorCollection) }
  def actors; end

  # @return [ActorCollection]
  #
  # source://vexi//lib/vexi/models/segment.rb#20
  def actors=(_arg0); end

  # source://vexi//lib/vexi/models/segment.rb#29
  sig { override.returns(::String) }
  def name; end

  # source://vexi//lib/vexi/models/segment.rb#17
  sig { params(name: ::String).void }
  def name=(name); end

  class << self
    # source://vexi//lib/vexi/models/segment.rb#45
    sig { params(name: ::String).returns(::Vexi::Segment) }
    def create_default(name); end

    # source://vexi//lib/vexi/models/segment.rb#34
    sig { params(json: T::Hash[::String, T.untyped]).returns(::Vexi::Segment) }
    def from_json(json); end
  end
end

# Public: Vexi services.
#
# source://vexi//lib/vexi/services/feature_flag_service.rb#8
module Vexi::Services; end

# Public: Feature Flag Service responsible for fetching feature flags from the cache or adapter.
#
# source://vexi//lib/vexi/services/feature_flag_service.rb#10
class Vexi::Services::FeatureFlagService < ::Vexi::AbstractEntityService
  extend T::Generic

  EntityType = type_member { { fixed: Vexi::FeatureFlag } }

  # source://vexi//lib/vexi/services/feature_flag_service.rb#18
  sig { params(adapter: ::Vexi::Adapter, cache_config: T.nilable(::Vexi::CacheConfig)).void }
  def initialize(adapter, cache_config = T.unsafe(nil)); end

  # source://vexi//lib/vexi/services/feature_flag_service.rb#23
  sig { override.returns(T::Class[EntityType]) }
  def entity_type; end

  # source://vexi//lib/vexi/services/feature_flag_service.rb#28
  sig { override.returns(::String) }
  def entity_type_name; end

  private

  # source://vexi//lib/vexi/services/feature_flag_service.rb#35
  sig { override.params(name: ::String).returns(::String) }
  def get_cache_key(name); end

  # source://vexi//lib/vexi/services/feature_flag_service.rb#47
  sig { override.params(name: ::String).returns(EntityType) }
  def get_default_entity_instance(name); end

  # source://vexi//lib/vexi/services/feature_flag_service.rb#42
  sig { override.params(names: T::Array[::String]).returns(T::Array[::Vexi::GetEntityResponse]) }
  def get_entity_responses(names); end
end

# Public: Segment service responsible for fetching segments from the cache or the adapter.
#
# source://vexi//lib/vexi/services/segment_service.rb#14
class Vexi::Services::SegmentService < ::Vexi::AbstractEntityService
  extend T::Generic

  EntityType = type_member { { fixed: Vexi::Segment } }

  # source://vexi//lib/vexi/services/segment_service.rb#22
  sig { params(adapter: ::Vexi::Adapter, cache_config: T.nilable(::Vexi::CacheConfig)).void }
  def initialize(adapter, cache_config = T.unsafe(nil)); end

  # source://vexi//lib/vexi/services/segment_service.rb#27
  sig { override.returns(T::Class[EntityType]) }
  def entity_type; end

  # source://vexi//lib/vexi/services/segment_service.rb#32
  sig { override.returns(::String) }
  def entity_type_name; end

  private

  # Private: Generate a cache key for the given segment names and actors using FNV.
  #
  # source://vexi//lib/vexi/services/segment_service.rb#57
  sig { params(segment_names: T::Array[::String], actor_ids: T::Array[::String]).returns(::String) }
  def generate_segments_actor_combination_cache_key(segment_names, actor_ids); end

  # source://vexi//lib/vexi/services/segment_service.rb#39
  sig { override.params(name: ::String).returns(::String) }
  def get_cache_key(name); end

  # source://vexi//lib/vexi/services/segment_service.rb#51
  sig { override.params(name: ::String).returns(EntityType) }
  def get_default_entity_instance(name); end

  # source://vexi//lib/vexi/services/segment_service.rb#46
  sig { override.params(names: T::Array[::String]).returns(T::Array[::Vexi::GetEntityResponse]) }
  def get_entity_responses(names); end

  # Private: Returns the enabled boolean from the cache for the provided key. If the key is not found, returns nil.
  #
  # source://vexi//lib/vexi/services/segment_service.rb#66
  sig { params(context: T::Hash[::Symbol, T.untyped], cache_key: ::String).returns(T.nilable(T::Boolean)) }
  def get_segments_actors_combination_is_enabled_from_cache(context, cache_key); end

  # source://vexi//lib/vexi/services/segment_service.rb#85
  sig { params(context: T::Hash[::Symbol, T.untyped], cache_key: ::String, enabled: T::Boolean).void }
  def set_segments_actors_combination_is_enabled_in_cache(context, cache_key, enabled); end
end

# source://vexi//lib/vexi/version.rb#4
Vexi::VERSION = T.let(T.unsafe(nil), String)
