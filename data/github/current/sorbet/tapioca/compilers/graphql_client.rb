# typed: strict
# frozen_string_literal: true

require "sorbet-runtime"

module Tapioca
  module Compilers
    # `Tapioca::Compilers::GraphqlClient` generates RBI files for the objects
    # generated by `GraphQL::Client` from our GraphQL schemas.
    #
    # The way that constants are located is somewhat unusual for a Tapica
    # compiler. Typically we would use `ObjectSpace` to look for all descendants
    # of a particular class or mixin, but in this case the `GraphQL::Client`
    # types are sometimes classes and sometimes instances of classes. Therefore
    # we start from the `::PlatformTypes` and `::Api::App::PlatformTypes`
    # namespaces and look for constants nested under them.
    #
    # For example, given the following GraphQL schema:
    #
    # ~~~graphql
    # interface Actor {
    #   avatarUrl(
    #     size: Int
    #   ): URI!
    #
    #   login: String!
    #
    #   resourcePath: URI!
    #
    #   url: URI!
    # }
    # ~~~
    #
    # `GraphQL::Client` will define the constant `::PlatformTypes::`, and
    # this compiler will produce the RBI file `platform_types/` with the following contents:
    #
    # ~~~rbi
    # class PlatformTypes::Actor < GraphQL::Client::Schema::ObjectClass
    #   sig { returns(GraphQL::Client::Schema::ScalarType) }
    #   def avatar_url; end
    #
    #   sig { returns(String) }
    #   def login; end
    #
    #   sig { returns(T.nilable(String)) }
    #   def name; end
    #
    #   sig { returns(GraphQL::Client::Schema::ScalarType) }
    #   def resource_path; end
    #
    #   sig { returns(GraphQL::Client::Schema::ScalarType) }
    #   def url; end
    # end
    # ~~~
    class GraphqlClient < Tapioca::Dsl::Compiler
      extend T::Sig

      NAMESPACES = T.let([
        ::PlatformTypes,
        ::Api::App::PlatformTypes,
      ], T::Array[Module])

      ConstantType = type_member { { fixed: Module } }

      TYPE_MAP = T.let({
        GraphQL::Types::String => "String",
        GraphQL::Types::Boolean => "T::Boolean",
        GraphQL::Types::Int => "Integer",
        GraphQL::Types::Float => "Float",
        GraphQL::Types::ID => "T.any(String, Integer)",
        GraphQL::Types::Relay::PageInfo => "%{namespace}::PageInfo",
      }, T::Hash[T::Class[T.anything], String])

      MAPPED_PLATFORM_CLASSES = T.let([
        Platform::Objects::Base,
        Platform::Scalars::Base,
        Platform::Interfaces::Base,
        Platform::Connections::Base,
        Platform::Edges::Base,
      ], T::Array[Module])


      sig { override.returns(T::Enumerable[Module]) }
      def self.gather_constants
        NAMESPACES.flat_map do |namespace|
          namespace.constants
            .map { namespace.const_get(_1) }
            .select do |const|
              const.is_a?(Module) && (
                const < GraphQL::Client::Schema::ObjectClass ||
                const.instance_of?(GraphQL::Client::Schema::UnionType) ||
                const.instance_of?(GraphQL::Client::Schema::EnumType) ||
                const.instance_of?(GraphQL::Client::Schema::InterfaceType)
              )
            end
        end
      end

      sig { override.void }
      def decorate
        const = constant

        case const
        when GraphQL::Client::Schema::UnionType
          decorate_union_type(const)
        when GraphQL::Client::Schema::EnumType
          decorate_enum_type(const)
        when GraphQL::Client::Schema::BaseType
          decorate_type(const)
        else
          $stderr.puts "Unexpected type: #{const.inspect}"
        end
      end

      private

      sig { params(const: GraphQL::Client::Schema::UnionType).void }
      def decorate_union_type(const)
        root.create_module(const.to_s)
      end

      sig { params(const: GraphQL::Client::Schema::EnumType).void }
      def decorate_enum_type(const)
        root.create_module(const.to_s) do |mod|
          const.type.values.each do |name, _value|
            mod.create_constant(name, value: "T.let(#{name.inspect}, String)")
            mod.create_method("#{name.downcase}?", return_type: "T::Boolean")
          end
        end
      end

      sig { params(const: T.all(GraphQL::Client::Schema::BaseType, Module)).void }
      def decorate_type(const)
        namespace = const.to_s.sub(/::[^:]+\z/, "")
        root.create_class(constant.to_s, superclass_name: GraphQL::Client::Schema::ObjectClass.to_s) do |klass|
          klass.create_method("__typename", return_type: "T.nilable(String)")

          const.type.fields.each do |name, field|
            return_type = graphql_to_sorbet_with_nil_check(field.type, namespace)
            klass.create_method(name.underscore, return_type: return_type)
            klass.create_method("#{name.underscore}?", return_type: "T::Boolean")
          end
        end
      end

      sig { params(type: T.class_of(GraphQL::Schema::Member), namespace: String).returns(String) }
      def graphql_to_sorbet_with_nil_check(type, namespace)
        description = graphql_to_sorbet(type, namespace)

        if type.non_null? || description == "T.untyped"
          description
        else
          "T.nilable(#{description})"
        end
      end

      sig { params(type: T.class_of(GraphQL::Schema::Member), namespace: String).returns(String) }
      def graphql_to_sorbet(type, namespace)
        unwrapped_type = type.unwrap
        description = TYPE_MAP.fetch(unwrapped_type, "T.untyped") % {
          namespace: namespace,
        }

        if platform_class_type?(unwrapped_type)
          translated_const_name = "#{namespace}::#{unwrapped_type.graphql_name}"
          translated_const = translated_const_name.safe_constantize

          if translated_const.is_a?(Class)
            description = translated_const_name
          elsif translated_const
            description = translated_const.class.to_s
          end
        end

        if unwrapped_type < Platform::Unions::Base
          union_types = unwrapped_type.possible_types.map { graphql_to_sorbet(_1, namespace) }.join(", ")
          if unwrapped_type.possible_types.length > 1
            description = "T.any(#{union_types})"
          else
            description = union_types
          end
        end

        if unwrapped_type < Platform::Enums::Base
          description = "String"
        end

        if type.list?
          description = "T::Array[#{description}]"
        end

        description
      end

      sig { params(type: Object).returns(T::Boolean) }
      def platform_class_type?(type)
        return false unless type.is_a?(Module)
        (type.ancestors & MAPPED_PLATFORM_CLASSES).any?
      end
    end
  end
end
