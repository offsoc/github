{"version":3,"file":"service-worker-xxxxxxxxxxxx.js","mappings":"uBACA,IAAMA,EAAgBC,KAOhBC,EAAa,UACbC,EAAc,iBAEpBH,EAAcI,gBAAgB,CAAC,UAAWC,IACxCA,EAAMC,SAAS,CACb,CAAC,UACC,IAAMC,EAAQ,MAAMC,OAAOC,IAAI,CAACP,EAIhC,OAAMK,EAAMG,GAAG,CAAC,IAAIC,QAAQR,EAAa,CAACI,MAAO,QAAQ,GAC3D,MAGFP,EAAcY,WAAW,EAC3B,GAEAZ,EAAcI,gBAAgB,CAAC,WAAYC,IACzCA,EAAMC,SAAS,CACb,CAAC,UAGK,sBAAuBN,EAAca,YAAY,EACnD,MAAMb,EAAca,YAAY,CAACC,iBAAiB,CAACC,MAAM,EAE7D,MAIFf,EAAcgB,OAAO,CAACC,KAAK,EAC7B,GAEAjB,EAAcI,gBAAgB,CAAC,QAASC,IAGX,aAAvBA,EAAMa,OAAO,CAACC,IAAI,EACpBd,EAAMe,WAAW,CACf,CAAC,UACC,GAAI,CAEF,IAAMC,EAAkB,MAAMhB,EAAMgB,eAAe,CACnD,GAAIA,EACF,OAAOA,EAKT,OADwB,MAAMC,MAAMjB,EAAMa,OAAO,CAEnD,CAAE,MAAOK,EAAO,CAMdC,QAAQC,GAAG,CAAC,gDAAiDF,GAE7D,IAAMhB,EAAQ,MAAMC,OAAOC,IAAI,CAACP,GAEhC,OADuB,MAAMK,EAAMmB,KAAK,CAACvB,EAE3C,CACF,KASN,E,GC5EIwB,EAA2B,CAAC,EAGhC,SAASC,EAAoBC,CAAQ,EAEpC,IAAIC,EAAeH,CAAwB,CAACE,EAAS,CACrD,GAAIC,KAAiBC,IAAjBD,EACH,OAAOA,EAAaE,OAAO,CAG5B,IAAIC,EAASN,CAAwB,CAACE,EAAS,CAAG,CAGjDG,QAAS,CAAC,CACX,EAMA,OAHAE,CAAmB,CAACL,EAAS,CAACI,EAAQA,EAAOD,OAAO,CAAEJ,GAG/CK,EAAOD,OAAO,CCpBtBJ,EAAoBO,CAAC,CAAG,IACvB,IAAIC,EAASH,GAAUA,EAAOI,UAAU,CACvC,IAAOJ,EAAO,OAAU,CACxB,IAAOA,EAER,OADAL,EAAoBU,CAAC,CAACF,EAAQ,CAAEG,EAAGH,CAAO,GACnCA,CACR,ECNAR,EAAoBU,CAAC,CAAG,CAACN,EAASQ,KACjC,IAAI,IAAIC,KAAOD,EACXZ,EAAoBc,CAAC,CAACF,EAAYC,IAAQ,CAACb,EAAoBc,CAAC,CAACV,EAASS,IAC5EE,OAAOC,cAAc,CAACZ,EAASS,EAAK,CAAEI,WAAY,GAAMC,IAAKN,CAAU,CAACC,EAAI,EAG/E,ECPAb,EAAoBc,CAAC,CAAG,CAACK,EAAKC,IAAUL,OAAOM,SAAS,CAACC,cAAc,CAACC,IAAI,CAACJ,EAAKC,G","sources":["ui/packages/service-worker/service-worker.ts","webpack/bootstrap","webpack/runtime/compat get default export","webpack/runtime/define property getters","webpack/runtime/hasOwnProperty shorthand"],"sourcesContent":["// eslint-disable-next-line ssr-friendly/no-dom-globals-in-module-scope\nconst serviceWorker = self as unknown as ServiceWorkerGlobalScope\n\n// Incrementing OFFLINE_VERSION will kick off the install event and force\n// previously cached resources to be updated from the network.\n// This variable is intentionally declared and unused.\n// eslint-disable-next-line unused-imports/no-unused-vars\nconst OFFLINE_VERSION = 1\nconst CACHE_NAME = 'offline'\nconst OFFLINE_URL = '/_offline.html'\n\nserviceWorker.addEventListener('install', event => {\n  event.waitUntil(\n    (async () => {\n      const cache = await caches.open(CACHE_NAME)\n      // Setting {cache: 'reload'} in the new request will ensure that the\n      // response isn't fulfilled from the HTTP cache; i.e., it will be from\n      // the network.\n      await cache.add(new Request(OFFLINE_URL, {cache: 'reload'}))\n    })(),\n  )\n  // Force the waiting service worker to become the active service worker.\n  serviceWorker.skipWaiting()\n})\n\nserviceWorker.addEventListener('activate', event => {\n  event.waitUntil(\n    (async () => {\n      // Enable navigation preload if it's supported.\n      // See https://developers.google.com/web/updates/2017/02/navigation-preload\n      if ('navigationPreload' in serviceWorker.registration) {\n        await serviceWorker.registration.navigationPreload.enable()\n      }\n    })(),\n  )\n\n  // Tell the active service worker to take control of the page immediately.\n  serviceWorker.clients.claim()\n})\n\nserviceWorker.addEventListener('fetch', event => {\n  // We only want to call event.respondWith() if this is a navigation request\n  // for an HTML page.\n  if (event.request.mode === 'navigate') {\n    event.respondWith(\n      (async () => {\n        try {\n          // First, try to use the navigation preload response if it's supported.\n          const preloadResponse = await event.preloadResponse\n          if (preloadResponse) {\n            return preloadResponse\n          }\n\n          // Always try the network first.\n          const networkResponse = await fetch(event.request)\n          return networkResponse\n        } catch (error) {\n          // catch is only triggered if an exception is thrown, which is likely\n          // due to a network error.\n          // If fetch() returns a valid HTTP response with a response code in\n          // the 4xx or 5xx range, the catch() will NOT be called.\n          // eslint-disable-next-line no-console\n          console.log('Fetch failed; returning offline page instead.', error)\n\n          const cache = await caches.open(CACHE_NAME)\n          const cachedResponse = await cache.match(OFFLINE_URL)\n          return cachedResponse\n        }\n      })(),\n    )\n  }\n\n  // If our if() condition is false, then this fetch handler won't intercept the\n  // request. If there are any other fetch handlers registered, they will get a\n  // chance to call event.respondWith(). If no fetch handlers call\n  // event.respondWith(), the request will be handled by the browser as if there\n  // were no service worker involvement.\n})\n","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","// getDefaultExport function for compatibility with non-harmony modules\n__webpack_require__.n = (module) => {\n\tvar getter = module && module.__esModule ?\n\t\t() => (module['default']) :\n\t\t() => (module);\n\t__webpack_require__.d(getter, { a: getter });\n\treturn getter;\n};","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))"],"names":["serviceWorker","self","CACHE_NAME","OFFLINE_URL","addEventListener","event","waitUntil","cache","caches","open","add","Request","skipWaiting","registration","navigationPreload","enable","clients","claim","request","mode","respondWith","preloadResponse","fetch","error","console","log","match","__webpack_module_cache__","__webpack_require__","moduleId","cachedModule","undefined","exports","module","__webpack_modules__","n","getter","__esModule","d","a","definition","key","o","Object","defineProperty","enumerable","get","obj","prop","prototype","hasOwnProperty","call"],"sourceRoot":""}