#!/bin/bash
#/ Usage: ghe-sanitize-secrets <prefix1> [<prefix2>] ...
#/
#/ Takes a list of secret key prefixes and then looks up those secrets and sanitizes them from the
#/ text sent in on stdin and sends the result to stdout
#/
#/ EXAMPLE
#/   Sanitize all secrets who has a key that starts with 'secrets.actions' or 'secrets.mssql'
#/     $ cat mylog.log | ghe-sanitize-secrets 'secrets.actions' 'secrets.mssql' > mylog-sanitized.log
#/
#/ WARNING 1
#/    The current minimum secret length to scrub is 6. This should only be used for randomly
#/    generated long secrets. If you sanitize a secret that is a standard word or number, then these
#/    may be in other places of the input, and thus will be filtered also. This could cause logs to
#/    be hard to read and possibly allow the secret to be reversed engineered. For example, if we
#/    were to sanitize secrets that have boolean values, it would remove 'true' or 'false' throughout
#/    the log.
#/
#/ WARNING 2
#/    This script currently does not scrub certificate values, which should never be printed to logs.
#/    If you need this functionality, the script will need to be modified to support it.
#/
#/

# ignore secrets with length 5 or less, since it has a chance to collide with other text, and real secrets would be longer anyway.
minimum_secret_length=6

usage() {
  grep '^#/' <"$0" | cut -c 4-
}

# takes a string and escapes the special characters from it so it can be used in a psed regular expression
regex_escape_string () {
  echo "$1" | sed -e 's/[]\/$*.^[]/\\&/g'
}

# takes a list of strings and creates a regex expression that matches any of those strings
regex_escape_list () {
  local terms=("$@")
  local expression=''
  if [ ${#terms[@]} == 1 ]; then
    expression+="$(regex_escape_string "${terms[0]}")"
  else
    expression+='\('
    last_index=$((${#terms[@]} - 1))
    for ((i=0;i<=last_index;i++)); do
      expression+="\($(regex_escape_string "${terms[$i]}")\)"
      if [ $i != $last_index ]; then
        expression+='\|'
      fi
    done
    expression+='\)'
  fi
  echo "$expression"
}

if [ $# == 0 ]; then
  usage
  exit 2
fi

for var in "$@"; do
    if [[ "$var" == '-h' || "$var" == '--help' ]]; then
      usage
      exit 2
    fi
done

prefix_list=("$@")

# to get list of all secrets we want to sanitize:
#   1. get list of all secret key=value pairs
#   2. use sed to delete all lines that don't have a key that begins with one of the prefixes (see prefix_expression)
#   3. use sed to return just the values of the remaining key=value pairs

# generate expression to remove secret key=value pairs that don't have the specified prefixes
prefix_expression="/^$(regex_escape_list "${prefix_list[@]}")/!d"

# $secrets is the list of secret values that we want to sanitize.
IFS=$'\n'
mapfile -t secrets < <(ghe-config --get-regexp secrets\. | LANG=C sed -e "$prefix_expression" -n -e "s/^\(secrets\.[^ ]*\) \(.\{$minimum_secret_length\}.*\)$/\2/p")

if [ ${#secrets[@]} -gt 0 ]; then

  # generate expression that matches all secrets
  expression="s/$(regex_escape_list "${secrets[@]}")/[FILTERED]/g"

  # sanitize secrets from the log
  LANG=C sed -e "$expression" < /dev/stdin
else
  cat < /dev/stdin
fi
