# typed: false

# DO NOT EDIT MANUALLY
# This is an autogenerated file for types exported from the `aleph-client` gem.
# Please instead update this file by running `bin/tapioca gem aleph-client`.

# source://aleph-client//ruby/lib/aleph/version.rb#1
module Aleph; end

# source://aleph-client//ruby/lib/aleph.rb#6
class Aleph::Client
  # @return [Client] a new instance of Client
  #
  # source://aleph-client//ruby/lib/aleph.rb#9
  def initialize(conn, hmac_key: T.unsafe(nil)); end

  # Public: Determines if an index exists for the given repository at the given commit oid.
  #
  # root_id              - Integer repository id of fork repo network's root repo
  # network_id           - Integer id of the fork repo network
  # repo_id              - Integer repository id
  # repo_owner           - String username of repository owner
  # repo_name            - String name of repository
  # commit_oid           - String commit oid
  # backends             - Array of string backends to query (order-sensitive).
  # actor_id             - Integer id of the user making the request.
  # request_ip           - String ip address from where the request is made.
  # access_token         - String the blackbird access token.
  # access_token_expires - Integer the expiration for the blackbird access token.
  # access_token_kind    - String the kind of access token.
  # session_id           - String the session id.
  #
  # Returns a Twirp::ClientResp where #data is an ExistResponse (see github/aleph/proto/lsp.proto#ExistResponse for more info).
  #
  # source://aleph-client//ruby/lib/aleph.rb#160
  def exist(root_id:, network_id:, repo_id:, repo_owner:, repo_name:, commit_oid:, actor_id:, request_ip:, access_token:, access_token_expires:, access_token_kind:, session_id:, backends: T.unsafe(nil), opt_headers: T.unsafe(nil)); end

  # Public: Find all definitions in a repo for the given list of fully qualified names.
  #
  # network_id      - Integer id of the fork repo network
  # repo_id         - Integer repository id
  # commit_oid      - String commit sha
  # qualified_names - List of fully qualified names to search for
  # language        - String language name
  #
  # Returns a Twirp::ClientResp where #data is a FindDefinitionsOfQualifiedNamesResponse (see github/aleph/proto/lsp.proto#FindDefinitionsOfQualifiedNamesResponse for more info).
  #
  # source://aleph-client//ruby/lib/aleph.rb#324
  def find_definitions_of_qualified_names(network_id:, repo_id:, commit_oid:, qualified_names:, language: T.unsafe(nil), ref: T.unsafe(nil), opt_headers: T.unsafe(nil)); end

  # Public: Find the location of the defined name who's definiens contains a given location
  #
  # network_id      - Integer id of the fork repo network
  # repo_id         - Integer repository id
  # commit_oid      - String commit sha
  # path            - String repo relative filepath
  # start_line      - First line of the span to query
  # start_character - First character of the span to query
  # end_line        - Last line of the span to query
  #                   NOTE: this is INCLUDED in the span, i.e. up to and including this line
  # end_character   - Last character of the span to query
  #                   NOTE: this is EXCLUDED from the span, i.e. up to but not including this character)
  # language        - String language name
  # ref             - String named ref
  #
  # Returns a Twirp::ClientResp where #data is a FindDefinedNameByDefiniensLocationResponse (see github/aleph/proto/lsp.proto#FindDefinedNameByDefiniensLocationResponse for more info).
  #
  # source://aleph-client//ruby/lib/aleph.rb#352
  def find_name_by_definiens_location(network_id:, repo_id:, commit_oid:, path:, start_line:, start_character:, end_line:, end_character:, language:, backends:, ref: T.unsafe(nil), opt_headers: T.unsafe(nil)); end

  # Public: Find the locations of references that match any one of the given search keys.
  #
  # network_id  - Integer id of the fork repo network
  # repo_id     - Integer repository id
  # commit_oid  - String commit sha
  # search_keys - List of search keys
  # ref         - String named ref
  #
  # Returns a Twirp::ClientResp where #data is a FindReferencesForSearchKeysResponse (see github/aleph/proto/lsp.proto#FindReferencesForSearchKeysResponse for more info).
  #
  # source://aleph-client//ruby/lib/aleph.rb#400
  def find_references_for_search_keys(network_id:, repo_id:, commit_oid:, search_keys:, references_to_consider: T.unsafe(nil), ref: T.unsafe(nil), opt_headers: T.unsafe(nil)); end

  # Public: Find all references in a repo for the given list of fully qualified names.
  #
  # root_id         - Integer repository id of fork repo network's root repo
  # network_id      - Integer id of the fork repo network
  # repo_id         - Integer repository id
  # commit_oid      - String commit sha
  # qualified_names - List of fully qualified names to search for
  # language        - String language name
  #
  # Returns a Twirp::ClientResp where #data is a FindReferencesToQualifiedNamesResponse (see github/aleph/proto/lsp.proto#FindReferencesToQualifiedNamesResponse for more info).
  #
  # source://aleph-client//ruby/lib/aleph.rb#302
  def find_references_to_qualified_names(network_id:, repo_id:, commit_oid:, qualified_names:, root_id: T.unsafe(nil), language: T.unsafe(nil), ref: T.unsafe(nil), opt_headers: T.unsafe(nil)); end

  # Public: Find the location of the defined names which call directly or indirectly into definitions whos definiens contains a given location
  #
  # network_id      - Integer id of the fork repo network
  # repo_id         - Integer repository id
  # commit_oid      - String commit sha
  # path            - String repo relative filepath
  # start_line      - First line of the span to query
  # start_character - First character of the span to query
  # end_line        - Last line of the span to query
  #                   NOTE: this is INCLUDED in the span, i.e. up to and including this line
  # end_character   - Last character of the span to query
  #                   NOTE: this is EXCLUDED from the span, i.e. up to but not including this character)
  # language        - String language name
  # ref             - String named ref
  # ranges          - Ranges/spans that determine the locations to look up
  #
  # Returns a Twirp::ClientResp where #data is a FindReflexiveTransitiveCallersByDefiniensLocationResponse (see github/aleph/proto/lsp.proto#FindReflexiveTransitiveCallersByDefiniensLocationResponse for more info).
  #
  # source://aleph-client//ruby/lib/aleph.rb#445
  def find_reflexive_transitive_callers_by_definiens_location(network_id:, repo_id:, commit_oid:, path:, start_line:, start_character:, end_line:, end_character:, language:, backends:, ref: T.unsafe(nil), ranges: T.unsafe(nil), opt_headers: T.unsafe(nil)); end

  # Public: Get symbol information about a qualified name.
  #
  # commit_oid            - String commit sha
  # network_id            - Integer id of the fork repo network
  # repo_id               - Integer repository id
  # language              - String language name
  # ref                   - String named ref
  # fully_qualified_name  - String fully qualified namee
  #
  # Returns a Twirp::ClientResp where #data is a FindSymbolInformationForFullyQualifiedNameResponse (see github/aleph/proto/lsp.proto#FindSymbolInformationForFullyQualifiedNameResponse for more info).
  #
  # source://aleph-client//ruby/lib/aleph.rb#379
  def find_symbol_information_for_fully_qualified_name(commit_oid:, network_id:, repo_id:, language:, fully_qualified_name:, ref: T.unsafe(nil), opt_headers: T.unsafe(nil)); end

  # Public: Find all symbols for a path.
  #
  # root_id    - Integer repository id of fork repo network's root repo
  # network_id - Integer id of the fork repo network
  # repo_id    - Integer repository id
  # repo_owner - String username of repository owner
  # repo_name  - String name of repository
  # sha        - String commit sha
  # path       - String repo relative filepath
  # ref        - String named ref (optional, default: nil)
  #
  # Returns a Twirp::ClientResp where #data is a FindSymbolsResponse (see github/aleph/proto/code_nav.proto#FindSymbolsResponse for more info).
  #
  # source://aleph-client//ruby/lib/aleph.rb#27
  def find_symbols_for_path(root_id:, network_id:, repo_id:, repo_owner:, repo_name:, sha:, path:, ref: T.unsafe(nil), opt_headers: T.unsafe(nil)); end

  # Public: Returns information about any pending or completed indexing operations.
  #
  # network_id                 - Integer id of the fork repo network
  # repo_id                    - Integer repository id
  # commit_oid                 - String commit oid
  #
  # source://aleph-client//ruby/lib/aleph.rb#96
  def get_indexing_status(network_id:, repo_id:, commit_oid:, opt_headers: T.unsafe(nil)); end

  # Public: Returns information about any pending or completed indexing
  # operations for a search key.
  #
  # search_key                 - String search key
  #
  # source://aleph-client//ruby/lib/aleph.rb#115
  def get_indexing_status_for_search_key(search_key:, opt_headers: T.unsafe(nil)); end

  # Public: Get the partial call graph from an initial symbol at the given path, row, and column for the provided repository.
  #
  # network_id           - Integer id of the fork repo network
  # repo_id              - Integer repository id
  # repo_owner           - String username of repository owner
  # repo_name            - String name of repository
  # commit_oid           - String commit oid
  # path                 - String repo relative filepath
  # row                  - Integer row position of symbol
  # column               - Integer column position of symbol
  # query                - String the query symbol for the code nav request.
  # backends             - Array of string backends to query (order-sensitive).
  # actor_id             - Integer id of the user making the request.
  # request_ip           - String ip address from where the request is made.
  # access_token         - String the blackbird access token.
  # access_token_expires - Integer the expiration for the blackbird access token.
  # access_token_kind    - String the kind of access token.
  # session_id           - String the session id.
  # language             - String language name.
  #
  # Returns a Twirp::ClientResp where #data is a GetPartialCallGraphResponse (see github/aleph/proto/lsp.proto#GetPartialCallGraphResponse for more info).
  #
  # source://aleph-client//ruby/lib/aleph.rb#487
  def get_partial_call_graph(root_id:, network_id:, repo_id:, repo_owner:, repo_name:, commit_oid:, path:, row:, col:, query:, ref:, actor_id:, request_ip:, access_token:, access_token_expires:, access_token_kind:, session_id:, language:, symbol_kind:, backends: T.unsafe(nil), search_dependencies: T.unsafe(nil), opt_headers: T.unsafe(nil)); end

  # Public: Force an index of a repository.
  # DEPRECATED: Use request_index for future requests
  #
  # network_id - Integer id of the fork repo network
  # repo_id    - Integer repository id
  # repo_owner - String username of repository owner
  # repo_name  - String name of repository
  # ref        - String ref (optional, default: nil). Use nil to specify the default branch.
  #
  # Returns a Twirp::ClientResp where #data is an IndexRepositoryResponse (see github/aleph/proto/code_nav.proto#IndexRepositoryResponse for more info).
  #
  # source://aleph-client//ruby/lib/aleph.rb#132
  def index_repository(network_id:, repo_id:, repo_owner:, repo_name:, ref: T.unsafe(nil), opt_headers: T.unsafe(nil)); end

  # Returns the value of attribute proxy.
  #
  # source://aleph-client//ruby/lib/aleph.rb#7
  def proxy; end

  # Public: Requests that a particular repo-commit be indexed.
  #
  # network_id                 - Integer id of the fork repo network
  # repo_id                    - Integer repository id
  # commit_oid                 - String commit oid
  # should_index_future_pushes - Whether we should index future pushes to this
  #                              repository.  If true, you must provide `ref`.
  # reason                     - The reason for requesting this repository be
  #                              indexed.
  # ref                        - A strng ref name that currently resolves to
  #                              `commit_oid`. If given, we will mark the
  #                              commit as the "most recently indexed commit"
  #                              for the ref.  If `should_index_future_pushes`
  #                              is true, we will also index any future pushes
  #                              to this ref.
  #
  # Returns a Twirp::ClientResp where #data is a RequestIndexResponse (see github/aleph/proto/code_nav.proto#RequestIndexResponse for more info).
  #
  # source://aleph-client//ruby/lib/aleph.rb#58
  def request_index(network_id:, repo_id:, commit_oid:, reason:, should_index_future_pushes: T.unsafe(nil), ref: T.unsafe(nil), opt_headers: T.unsafe(nil)); end

  # Public: Requests that a particular search key be indexed.
  #
  # search_key                 - String search key to index
  # reason                     - The reason for requesting this repository be
  #                              indexed.
  #
  # Returns a Twirp::ClientResp where #data is a RequestIndexResponse (see github/aleph/proto/code_nav.proto#RequestIndexResponse for more info).
  #
  # source://aleph-client//ruby/lib/aleph.rb#83
  def request_index_for_search_key(search_key:, reason:, opt_headers: T.unsafe(nil)); end

  # Returns the value of attribute rpc.
  #
  # source://aleph-client//ruby/lib/aleph.rb#7
  def rpc; end

  # Public: Find the definition(s) of a symbol at the given path, row, and column for the provided repository.
  #
  # root_id              - Integer repository id of fork repo network's root repo
  # network_id           - Integer id of the fork repo network
  # repo_id              - Integer repository id
  # repo_owner           - String username of repository owner
  # repo_name            - String name of repository
  # commit_oid           - String commit oid
  # path                 - String repo relative filepath
  # row                  - Integer row position of symbol
  # column               - Integer column position of symbol
  # query                - String the query symbol for the code nav request.
  # backends             - Array of string backends to query (order-sensitive).
  # actor_id             - Integer id of the user making the request.
  # request_ip           - String ip address from where the request is made.
  # access_token         - String the blackbird access token.
  # access_token_expires - Integer the expiration for the blackbird access token.
  # access_token_kind    - String the kind of access token.
  # session_id           - String the session id.
  # language             - String language name.
  #
  # Returns a Twirp::ClientResp where #data is a TextDocumentLocationResponse (see github/aleph/proto/lsp.proto#TextDocumentLocationResponse for more info).
  #
  # source://aleph-client//ruby/lib/aleph.rb#203
  def text_document_definition(root_id:, network_id:, repo_id:, repo_owner:, repo_name:, commit_oid:, path:, row:, col:, query:, ref:, actor_id:, request_ip:, access_token:, access_token_expires:, access_token_kind:, session_id:, language:, symbol_kind:, backends: T.unsafe(nil), search_dependencies: T.unsafe(nil), opt_headers: T.unsafe(nil)); end

  # Public: Find all references of a symbol at the given path, row, and column for the provided repository.
  #
  # root_id              - Integer repository id of fork repo network's root repo
  # network_id           - Integer id of the fork repo network
  # repo_id              - Integer repository id
  # repo_owner           - String username of repository owner
  # repo_name            - String name of repository
  # commit_oid           - String commit oid
  # path                 - String repo relative filepath
  # row                  - Integer row position of symbol
  # column               - Integer column position of symbol
  # query                - String the query symbol for the code nav request.
  # backends             - Array of string backends to query (order-sensitive).
  # actor_id             - Integer id of the user making the request.
  # request_ip           - String ip address from where the request is made.
  # access_token         - String the blackbird access token.
  # access_token_expires - Integer the expiration for the blackbird access token.
  # access_token_kind    - String the kind of access token.
  # session_id           - String the session id.
  # language             - String language name.
  #
  # Returns a Twirp::ClientResp where #data is a TextDocumentLocationResponse (see github/aleph/proto/lsp.proto#TextDocumentLocationResponse for more info).
  #
  # source://aleph-client//ruby/lib/aleph.rb#256
  def text_document_references(root_id:, network_id:, repo_id:, repo_owner:, repo_name:, commit_oid:, path:, row:, col:, query:, ref:, actor_id:, request_ip:, access_token:, access_token_expires:, access_token_kind:, session_id:, language:, symbol_kind:, backends: T.unsafe(nil), search_dependencies: T.unsafe(nil), opt_headers: T.unsafe(nil)); end

  # Public: Returns information about any pending or completed indexing operations.
  #
  # network_id                 - Integer id of the fork repo network
  # repo_id                    - Integer repository id
  # operation                  - String operation must be one of "enable" or "disable"
  #
  # Returns a Twirp::ClientResp where #data is a ToggleRepoNetworkResponse (see github/aleph/proto/code_nav.proto#ToggleRepoNetworkResponse for more info).
  #
  # source://aleph-client//ruby/lib/aleph.rb#419
  def toggle_repo_network(network_id:, repo_id:, operation:, opt_headers: T.unsafe(nil)); end

  # source://aleph-client//ruby/lib/aleph.rb#287
  def workspace_asset(uri:, opt_headers: T.unsafe(nil)); end

  private

  # source://aleph-client//ruby/lib/aleph.rb#519
  def headers; end

  # source://aleph-client//ruby/lib/aleph.rb#526
  def hmac_token; end
end

# source://aleph-client//ruby/lib/aleph/proto/indexing_pb.rb#60
module Aleph::Proto; end

class Aleph::Proto::Actor
  include ::Google::Protobuf::MessageExts
  extend ::Google::Protobuf::MessageExts::ClassMethods

  def initialize(*_arg0); end

  def ==(_arg0); end
  def [](_arg0); end
  def []=(_arg0, _arg1); end
  def clone; end
  def dup; end
  def eql?(_arg0); end
  def hash; end
  def inspect; end
  def method_missing(*_arg0); end
  def to_h; end
  def to_s; end

  private

  def respond_to_missing?(*_arg0); end

  class << self
    def decode(_arg0); end
    def decode_json(*_arg0); end
    def descriptor; end
    def encode(_arg0); end
    def encode_json(*_arg0); end
  end
end

module Aleph::Proto::Backend
  class << self
    def descriptor; end
    def lookup(_arg0); end
    def resolve(_arg0); end
  end
end

# source://aleph-client//ruby/lib/aleph/proto/lsp_pb.rb#275
Aleph::Proto::Backend::ALEPH_FUZZY = T.let(T.unsafe(nil), Integer)

# source://aleph-client//ruby/lib/aleph/proto/lsp_pb.rb#275
Aleph::Proto::Backend::ALEPH_FUZZY_PREVIEW = T.let(T.unsafe(nil), Integer)

# source://aleph-client//ruby/lib/aleph/proto/lsp_pb.rb#275
Aleph::Proto::Backend::ALEPH_PRECISE = T.let(T.unsafe(nil), Integer)

# source://aleph-client//ruby/lib/aleph/proto/lsp_pb.rb#275
Aleph::Proto::Backend::ALEPH_PRECISE_DEVELOPMENT = T.let(T.unsafe(nil), Integer)

# source://aleph-client//ruby/lib/aleph/proto/lsp_pb.rb#275
Aleph::Proto::Backend::ALEPH_PRECISE_PREVIEW = T.let(T.unsafe(nil), Integer)

# source://aleph-client//ruby/lib/aleph/proto/lsp_pb.rb#275
Aleph::Proto::Backend::AUTO = T.let(T.unsafe(nil), Integer)

# source://aleph-client//ruby/lib/aleph/proto/lsp_pb.rb#275
Aleph::Proto::Backend::BLACKBIRD = T.let(T.unsafe(nil), Integer)

# source://aleph-client//ruby/lib/aleph/proto/lsp_pb.rb#275
Aleph::Proto::Backend::RICH_NAV = T.let(T.unsafe(nil), Integer)

class Aleph::Proto::BounceNetworkNonce
  include ::Google::Protobuf::MessageExts
  extend ::Google::Protobuf::MessageExts::ClassMethods

  def initialize(*_arg0); end

  def ==(_arg0); end
  def [](_arg0); end
  def []=(_arg0, _arg1); end
  def clone; end
  def dup; end
  def eql?(_arg0); end
  def hash; end
  def inspect; end
  def method_missing(*_arg0); end
  def to_h; end
  def to_s; end

  private

  def respond_to_missing?(*_arg0); end

  class << self
    def decode(_arg0); end
    def decode_json(*_arg0); end
    def descriptor; end
    def encode(_arg0); end
    def encode_json(*_arg0); end
  end
end

class Aleph::Proto::ByteOffset
  include ::Google::Protobuf::MessageExts
  extend ::Google::Protobuf::MessageExts::ClassMethods

  def initialize(*_arg0); end

  def ==(_arg0); end
  def [](_arg0); end
  def []=(_arg0, _arg1); end
  def clone; end
  def dup; end
  def eql?(_arg0); end
  def hash; end
  def inspect; end
  def method_missing(*_arg0); end
  def to_h; end
  def to_s; end

  private

  def respond_to_missing?(*_arg0); end

  class << self
    def decode(_arg0); end
    def decode_json(*_arg0); end
    def descriptor; end
    def encode(_arg0); end
    def encode_json(*_arg0); end
  end
end

class Aleph::Proto::CallGraphSymbol
  include ::Google::Protobuf::MessageExts
  extend ::Google::Protobuf::MessageExts::ClassMethods

  def initialize(*_arg0); end

  def ==(_arg0); end
  def [](_arg0); end
  def []=(_arg0, _arg1); end
  def clone; end
  def dup; end
  def eql?(_arg0); end
  def hash; end
  def inspect; end
  def method_missing(*_arg0); end
  def to_h; end
  def to_s; end

  private

  def respond_to_missing?(*_arg0); end

  class << self
    def decode(_arg0); end
    def decode_json(*_arg0); end
    def descriptor; end
    def encode(_arg0); end
    def encode_json(*_arg0); end
  end
end

# source://aleph-client//ruby/lib/aleph/proto/code_nav_twirp.rb#17
class Aleph::Proto::CodeNavClient < ::Twirp::Client
  # source://twirp/1.10.0/lib/twirp/client.rb#42
  def find_symbols_for_path(input, req_opts = T.unsafe(nil)); end

  # source://twirp/1.10.0/lib/twirp/client.rb#42
  def get_indexing_status(input, req_opts = T.unsafe(nil)); end

  # source://twirp/1.10.0/lib/twirp/client.rb#42
  def index_repository(input, req_opts = T.unsafe(nil)); end

  # source://twirp/1.10.0/lib/twirp/client.rb#42
  def request_index(input, req_opts = T.unsafe(nil)); end

  # source://twirp/1.10.0/lib/twirp/client.rb#42
  def toggle_repo_network(input, req_opts = T.unsafe(nil)); end
end

# source://aleph-client//ruby/lib/aleph/proto/code_nav_twirp.rb#7
class Aleph::Proto::CodeNavService < ::Twirp::Service; end

class Aleph::Proto::ComputeDepset
  include ::Google::Protobuf::MessageExts
  extend ::Google::Protobuf::MessageExts::ClassMethods

  def initialize(*_arg0); end

  def ==(_arg0); end
  def [](_arg0); end
  def []=(_arg0, _arg1); end
  def clone; end
  def dup; end
  def eql?(_arg0); end
  def hash; end
  def inspect; end
  def method_missing(*_arg0); end
  def to_h; end
  def to_s; end

  private

  def respond_to_missing?(*_arg0); end

  class << self
    def decode(_arg0); end
    def decode_json(*_arg0); end
    def descriptor; end
    def encode(_arg0); end
    def encode_json(*_arg0); end
  end
end

class Aleph::Proto::Definition
  include ::Google::Protobuf::MessageExts
  extend ::Google::Protobuf::MessageExts::ClassMethods

  def initialize(*_arg0); end

  def ==(_arg0); end
  def [](_arg0); end
  def []=(_arg0, _arg1); end
  def clone; end
  def dup; end
  def eql?(_arg0); end
  def hash; end
  def inspect; end
  def method_missing(*_arg0); end
  def to_h; end
  def to_s; end

  private

  def respond_to_missing?(*_arg0); end

  class << self
    def decode(_arg0); end
    def decode_json(*_arg0); end
    def descriptor; end
    def encode(_arg0); end
    def encode_json(*_arg0); end
  end
end

class Aleph::Proto::DefinitionInformation
  include ::Google::Protobuf::MessageExts
  extend ::Google::Protobuf::MessageExts::ClassMethods

  def initialize(*_arg0); end

  def ==(_arg0); end
  def [](_arg0); end
  def []=(_arg0, _arg1); end
  def clone; end
  def dup; end
  def eql?(_arg0); end
  def hash; end
  def inspect; end
  def method_missing(*_arg0); end
  def to_h; end
  def to_s; end

  private

  def respond_to_missing?(*_arg0); end

  class << self
    def decode(_arg0); end
    def decode_json(*_arg0); end
    def descriptor; end
    def encode(_arg0); end
    def encode_json(*_arg0); end
  end
end

class Aleph::Proto::DeleteRepository
  include ::Google::Protobuf::MessageExts
  extend ::Google::Protobuf::MessageExts::ClassMethods

  def initialize(*_arg0); end

  def ==(_arg0); end
  def [](_arg0); end
  def []=(_arg0, _arg1); end
  def clone; end
  def dup; end
  def eql?(_arg0); end
  def hash; end
  def inspect; end
  def method_missing(*_arg0); end
  def to_h; end
  def to_s; end

  private

  def respond_to_missing?(*_arg0); end

  class << self
    def decode(_arg0); end
    def decode_json(*_arg0); end
    def descriptor; end
    def encode(_arg0); end
    def encode_json(*_arg0); end
  end
end

class Aleph::Proto::ExistRequest
  include ::Google::Protobuf::MessageExts
  extend ::Google::Protobuf::MessageExts::ClassMethods

  def initialize(*_arg0); end

  def ==(_arg0); end
  def [](_arg0); end
  def []=(_arg0, _arg1); end
  def clone; end
  def dup; end
  def eql?(_arg0); end
  def hash; end
  def inspect; end
  def method_missing(*_arg0); end
  def to_h; end
  def to_s; end

  private

  def respond_to_missing?(*_arg0); end

  class << self
    def decode(_arg0); end
    def decode_json(*_arg0); end
    def descriptor; end
    def encode(_arg0); end
    def encode_json(*_arg0); end
  end
end

class Aleph::Proto::ExistResponse
  include ::Google::Protobuf::MessageExts
  extend ::Google::Protobuf::MessageExts::ClassMethods

  def initialize(*_arg0); end

  def ==(_arg0); end
  def [](_arg0); end
  def []=(_arg0, _arg1); end
  def clone; end
  def dup; end
  def eql?(_arg0); end
  def hash; end
  def inspect; end
  def method_missing(*_arg0); end
  def to_h; end
  def to_s; end

  private

  def respond_to_missing?(*_arg0); end

  class << self
    def decode(_arg0); end
    def decode_json(*_arg0); end
    def descriptor; end
    def encode(_arg0); end
    def encode_json(*_arg0); end
  end
end

class Aleph::Proto::ExpireDepset
  include ::Google::Protobuf::MessageExts
  extend ::Google::Protobuf::MessageExts::ClassMethods

  def initialize(*_arg0); end

  def ==(_arg0); end
  def [](_arg0); end
  def []=(_arg0, _arg1); end
  def clone; end
  def dup; end
  def eql?(_arg0); end
  def hash; end
  def inspect; end
  def method_missing(*_arg0); end
  def to_h; end
  def to_s; end

  private

  def respond_to_missing?(*_arg0); end

  class << self
    def decode(_arg0); end
    def decode_json(*_arg0); end
    def descriptor; end
    def encode(_arg0); end
    def encode_json(*_arg0); end
  end
end

class Aleph::Proto::FindDefinedNameByDefiniensLocationRequest
  include ::Google::Protobuf::MessageExts
  extend ::Google::Protobuf::MessageExts::ClassMethods

  def initialize(*_arg0); end

  def ==(_arg0); end
  def [](_arg0); end
  def []=(_arg0, _arg1); end
  def clone; end
  def dup; end
  def eql?(_arg0); end
  def hash; end
  def inspect; end
  def method_missing(*_arg0); end
  def to_h; end
  def to_s; end

  private

  def respond_to_missing?(*_arg0); end

  class << self
    def decode(_arg0); end
    def decode_json(*_arg0); end
    def descriptor; end
    def encode(_arg0); end
    def encode_json(*_arg0); end
  end
end

class Aleph::Proto::FindDefinedNameByDefiniensLocationResponse
  include ::Google::Protobuf::MessageExts
  extend ::Google::Protobuf::MessageExts::ClassMethods

  def initialize(*_arg0); end

  def ==(_arg0); end
  def [](_arg0); end
  def []=(_arg0, _arg1); end
  def clone; end
  def dup; end
  def eql?(_arg0); end
  def hash; end
  def inspect; end
  def method_missing(*_arg0); end
  def to_h; end
  def to_s; end

  private

  def respond_to_missing?(*_arg0); end

  class << self
    def decode(_arg0); end
    def decode_json(*_arg0); end
    def descriptor; end
    def encode(_arg0); end
    def encode_json(*_arg0); end
  end
end

class Aleph::Proto::FindDefinitionsOfQualifiedNamesRequest
  include ::Google::Protobuf::MessageExts
  extend ::Google::Protobuf::MessageExts::ClassMethods

  def initialize(*_arg0); end

  def ==(_arg0); end
  def [](_arg0); end
  def []=(_arg0, _arg1); end
  def clone; end
  def dup; end
  def eql?(_arg0); end
  def hash; end
  def inspect; end
  def method_missing(*_arg0); end
  def to_h; end
  def to_s; end

  private

  def respond_to_missing?(*_arg0); end

  class << self
    def decode(_arg0); end
    def decode_json(*_arg0); end
    def descriptor; end
    def encode(_arg0); end
    def encode_json(*_arg0); end
  end
end

class Aleph::Proto::FindDefinitionsOfQualifiedNamesResponse
  include ::Google::Protobuf::MessageExts
  extend ::Google::Protobuf::MessageExts::ClassMethods

  def initialize(*_arg0); end

  def ==(_arg0); end
  def [](_arg0); end
  def []=(_arg0, _arg1); end
  def clone; end
  def dup; end
  def eql?(_arg0); end
  def hash; end
  def inspect; end
  def method_missing(*_arg0); end
  def to_h; end
  def to_s; end

  private

  def respond_to_missing?(*_arg0); end

  class << self
    def decode(_arg0); end
    def decode_json(*_arg0); end
    def descriptor; end
    def encode(_arg0); end
    def encode_json(*_arg0); end
  end
end

class Aleph::Proto::FindReferencesForSearchKeysRequest
  include ::Google::Protobuf::MessageExts
  extend ::Google::Protobuf::MessageExts::ClassMethods

  def initialize(*_arg0); end

  def ==(_arg0); end
  def [](_arg0); end
  def []=(_arg0, _arg1); end
  def clone; end
  def dup; end
  def eql?(_arg0); end
  def hash; end
  def inspect; end
  def method_missing(*_arg0); end
  def to_h; end
  def to_s; end

  private

  def respond_to_missing?(*_arg0); end

  class << self
    def decode(_arg0); end
    def decode_json(*_arg0); end
    def descriptor; end
    def encode(_arg0); end
    def encode_json(*_arg0); end
  end
end

class Aleph::Proto::FindReferencesForSearchKeysResponse
  include ::Google::Protobuf::MessageExts
  extend ::Google::Protobuf::MessageExts::ClassMethods

  def initialize(*_arg0); end

  def ==(_arg0); end
  def [](_arg0); end
  def []=(_arg0, _arg1); end
  def clone; end
  def dup; end
  def eql?(_arg0); end
  def hash; end
  def inspect; end
  def method_missing(*_arg0); end
  def to_h; end
  def to_s; end

  private

  def respond_to_missing?(*_arg0); end

  class << self
    def decode(_arg0); end
    def decode_json(*_arg0); end
    def descriptor; end
    def encode(_arg0); end
    def encode_json(*_arg0); end
  end
end

class Aleph::Proto::FindReferencesToQualifiedNamesRequest
  include ::Google::Protobuf::MessageExts
  extend ::Google::Protobuf::MessageExts::ClassMethods

  def initialize(*_arg0); end

  def ==(_arg0); end
  def [](_arg0); end
  def []=(_arg0, _arg1); end
  def clone; end
  def dup; end
  def eql?(_arg0); end
  def hash; end
  def inspect; end
  def method_missing(*_arg0); end
  def to_h; end
  def to_s; end

  private

  def respond_to_missing?(*_arg0); end

  class << self
    def decode(_arg0); end
    def decode_json(*_arg0); end
    def descriptor; end
    def encode(_arg0); end
    def encode_json(*_arg0); end
  end
end

class Aleph::Proto::FindReferencesToQualifiedNamesResponse
  include ::Google::Protobuf::MessageExts
  extend ::Google::Protobuf::MessageExts::ClassMethods

  def initialize(*_arg0); end

  def ==(_arg0); end
  def [](_arg0); end
  def []=(_arg0, _arg1); end
  def clone; end
  def dup; end
  def eql?(_arg0); end
  def hash; end
  def inspect; end
  def method_missing(*_arg0); end
  def to_h; end
  def to_s; end

  private

  def respond_to_missing?(*_arg0); end

  class << self
    def decode(_arg0); end
    def decode_json(*_arg0); end
    def descriptor; end
    def encode(_arg0); end
    def encode_json(*_arg0); end
  end
end

class Aleph::Proto::FindReflexiveTransitiveCallersByDefiniensLocationRequest
  include ::Google::Protobuf::MessageExts
  extend ::Google::Protobuf::MessageExts::ClassMethods

  def initialize(*_arg0); end

  def ==(_arg0); end
  def [](_arg0); end
  def []=(_arg0, _arg1); end
  def clone; end
  def dup; end
  def eql?(_arg0); end
  def hash; end
  def inspect; end
  def method_missing(*_arg0); end
  def to_h; end
  def to_s; end

  private

  def respond_to_missing?(*_arg0); end

  class << self
    def decode(_arg0); end
    def decode_json(*_arg0); end
    def descriptor; end
    def encode(_arg0); end
    def encode_json(*_arg0); end
  end
end

class Aleph::Proto::FindReflexiveTransitiveCallersByDefiniensLocationResponse
  include ::Google::Protobuf::MessageExts
  extend ::Google::Protobuf::MessageExts::ClassMethods

  def initialize(*_arg0); end

  def ==(_arg0); end
  def [](_arg0); end
  def []=(_arg0, _arg1); end
  def clone; end
  def dup; end
  def eql?(_arg0); end
  def hash; end
  def inspect; end
  def method_missing(*_arg0); end
  def to_h; end
  def to_s; end

  private

  def respond_to_missing?(*_arg0); end

  class << self
    def decode(_arg0); end
    def decode_json(*_arg0); end
    def descriptor; end
    def encode(_arg0); end
    def encode_json(*_arg0); end
  end
end

class Aleph::Proto::FindSymbolInformationForFullyQualifiedNameRequest
  include ::Google::Protobuf::MessageExts
  extend ::Google::Protobuf::MessageExts::ClassMethods

  def initialize(*_arg0); end

  def ==(_arg0); end
  def [](_arg0); end
  def []=(_arg0, _arg1); end
  def clone; end
  def dup; end
  def eql?(_arg0); end
  def hash; end
  def inspect; end
  def method_missing(*_arg0); end
  def to_h; end
  def to_s; end

  private

  def respond_to_missing?(*_arg0); end

  class << self
    def decode(_arg0); end
    def decode_json(*_arg0); end
    def descriptor; end
    def encode(_arg0); end
    def encode_json(*_arg0); end
  end
end

class Aleph::Proto::FindSymbolInformationForFullyQualifiedNameResponse
  include ::Google::Protobuf::MessageExts
  extend ::Google::Protobuf::MessageExts::ClassMethods

  def initialize(*_arg0); end

  def ==(_arg0); end
  def [](_arg0); end
  def []=(_arg0, _arg1); end
  def clone; end
  def dup; end
  def eql?(_arg0); end
  def hash; end
  def inspect; end
  def method_missing(*_arg0); end
  def to_h; end
  def to_s; end

  private

  def respond_to_missing?(*_arg0); end

  class << self
    def decode(_arg0); end
    def decode_json(*_arg0); end
    def descriptor; end
    def encode(_arg0); end
    def encode_json(*_arg0); end
  end
end

class Aleph::Proto::FindSymbolsForPathRequest
  include ::Google::Protobuf::MessageExts
  extend ::Google::Protobuf::MessageExts::ClassMethods

  def initialize(*_arg0); end

  def ==(_arg0); end
  def [](_arg0); end
  def []=(_arg0, _arg1); end
  def clone; end
  def dup; end
  def eql?(_arg0); end
  def hash; end
  def inspect; end
  def method_missing(*_arg0); end
  def to_h; end
  def to_s; end

  private

  def respond_to_missing?(*_arg0); end

  class << self
    def decode(_arg0); end
    def decode_json(*_arg0); end
    def descriptor; end
    def encode(_arg0); end
    def encode_json(*_arg0); end
  end
end

class Aleph::Proto::FindSymbolsResponse
  include ::Google::Protobuf::MessageExts
  extend ::Google::Protobuf::MessageExts::ClassMethods

  def initialize(*_arg0); end

  def ==(_arg0); end
  def [](_arg0); end
  def []=(_arg0, _arg1); end
  def clone; end
  def dup; end
  def eql?(_arg0); end
  def hash; end
  def inspect; end
  def method_missing(*_arg0); end
  def to_h; end
  def to_s; end

  private

  def respond_to_missing?(*_arg0); end

  class << self
    def decode(_arg0); end
    def decode_json(*_arg0); end
    def descriptor; end
    def encode(_arg0); end
    def encode_json(*_arg0); end
  end
end

class Aleph::Proto::GetIndexingStatusRequest
  include ::Google::Protobuf::MessageExts
  extend ::Google::Protobuf::MessageExts::ClassMethods

  def initialize(*_arg0); end

  def ==(_arg0); end
  def [](_arg0); end
  def []=(_arg0, _arg1); end
  def clone; end
  def dup; end
  def eql?(_arg0); end
  def hash; end
  def inspect; end
  def method_missing(*_arg0); end
  def to_h; end
  def to_s; end

  private

  def respond_to_missing?(*_arg0); end

  class << self
    def decode(_arg0); end
    def decode_json(*_arg0); end
    def descriptor; end
    def encode(_arg0); end
    def encode_json(*_arg0); end
  end
end

class Aleph::Proto::GetIndexingStatusResponse
  include ::Google::Protobuf::MessageExts
  extend ::Google::Protobuf::MessageExts::ClassMethods

  def initialize(*_arg0); end

  def ==(_arg0); end
  def [](_arg0); end
  def []=(_arg0, _arg1); end
  def clone; end
  def dup; end
  def eql?(_arg0); end
  def hash; end
  def inspect; end
  def method_missing(*_arg0); end
  def to_h; end
  def to_s; end

  private

  def respond_to_missing?(*_arg0); end

  class << self
    def decode(_arg0); end
    def decode_json(*_arg0); end
    def descriptor; end
    def encode(_arg0); end
    def encode_json(*_arg0); end
  end
end

class Aleph::Proto::GetPartialCallGraphResponse
  include ::Google::Protobuf::MessageExts
  extend ::Google::Protobuf::MessageExts::ClassMethods

  def initialize(*_arg0); end

  def ==(_arg0); end
  def [](_arg0); end
  def []=(_arg0, _arg1); end
  def clone; end
  def dup; end
  def eql?(_arg0); end
  def hash; end
  def inspect; end
  def method_missing(*_arg0); end
  def to_h; end
  def to_s; end

  private

  def respond_to_missing?(*_arg0); end

  class << self
    def decode(_arg0); end
    def decode_json(*_arg0); end
    def descriptor; end
    def encode(_arg0); end
    def encode_json(*_arg0); end
  end
end

class Aleph::Proto::HydroMessage
  include ::Google::Protobuf::MessageExts
  extend ::Google::Protobuf::MessageExts::ClassMethods

  def initialize(*_arg0); end

  def ==(_arg0); end
  def [](_arg0); end
  def []=(_arg0, _arg1); end
  def clone; end
  def dup; end
  def eql?(_arg0); end
  def hash; end
  def inspect; end
  def method_missing(*_arg0); end
  def to_h; end
  def to_s; end

  private

  def respond_to_missing?(*_arg0); end

  class << self
    def decode(_arg0); end
    def decode_json(*_arg0); end
    def descriptor; end
    def encode(_arg0); end
    def encode_json(*_arg0); end
  end
end

class Aleph::Proto::IndexCommit
  include ::Google::Protobuf::MessageExts
  extend ::Google::Protobuf::MessageExts::ClassMethods

  def initialize(*_arg0); end

  def ==(_arg0); end
  def [](_arg0); end
  def []=(_arg0, _arg1); end
  def clone; end
  def dup; end
  def eql?(_arg0); end
  def hash; end
  def inspect; end
  def method_missing(*_arg0); end
  def to_h; end
  def to_s; end

  private

  def respond_to_missing?(*_arg0); end

  class << self
    def decode(_arg0); end
    def decode_json(*_arg0); end
    def descriptor; end
    def encode(_arg0); end
    def encode_json(*_arg0); end
  end
end

class Aleph::Proto::IndexRepositoryRequest
  include ::Google::Protobuf::MessageExts
  extend ::Google::Protobuf::MessageExts::ClassMethods

  def initialize(*_arg0); end

  def ==(_arg0); end
  def [](_arg0); end
  def []=(_arg0, _arg1); end
  def clone; end
  def dup; end
  def eql?(_arg0); end
  def hash; end
  def inspect; end
  def method_missing(*_arg0); end
  def to_h; end
  def to_s; end

  private

  def respond_to_missing?(*_arg0); end

  class << self
    def decode(_arg0); end
    def decode_json(*_arg0); end
    def descriptor; end
    def encode(_arg0); end
    def encode_json(*_arg0); end
  end
end

class Aleph::Proto::IndexRepositoryResponse
  include ::Google::Protobuf::MessageExts
  extend ::Google::Protobuf::MessageExts::ClassMethods

  def initialize(*_arg0); end

  def ==(_arg0); end
  def [](_arg0); end
  def []=(_arg0, _arg1); end
  def clone; end
  def dup; end
  def eql?(_arg0); end
  def hash; end
  def inspect; end
  def method_missing(*_arg0); end
  def to_h; end
  def to_s; end

  private

  def respond_to_missing?(*_arg0); end

  class << self
    def decode(_arg0); end
    def decode_json(*_arg0); end
    def descriptor; end
    def encode(_arg0); end
    def encode_json(*_arg0); end
  end
end

class Aleph::Proto::IndexingResult
  include ::Google::Protobuf::MessageExts
  extend ::Google::Protobuf::MessageExts::ClassMethods

  def initialize(*_arg0); end

  def ==(_arg0); end
  def [](_arg0); end
  def []=(_arg0, _arg1); end
  def clone; end
  def dup; end
  def eql?(_arg0); end
  def hash; end
  def inspect; end
  def method_missing(*_arg0); end
  def to_h; end
  def to_s; end

  private

  def respond_to_missing?(*_arg0); end

  class << self
    def decode(_arg0); end
    def decode_json(*_arg0); end
    def descriptor; end
    def encode(_arg0); end
    def encode_json(*_arg0); end
  end
end

module Aleph::Proto::IndexingStatus
  class << self
    def descriptor; end
    def lookup(_arg0); end
    def resolve(_arg0); end
  end
end

# source://aleph-client//ruby/lib/aleph/proto/code_nav_pb.rb#125
Aleph::Proto::IndexingStatus::INDEXED_SUCCESSFULLY = T.let(T.unsafe(nil), Integer)

# source://aleph-client//ruby/lib/aleph/proto/code_nav_pb.rb#125
Aleph::Proto::IndexingStatus::INDEXING_ENQUEUED = T.let(T.unsafe(nil), Integer)

# source://aleph-client//ruby/lib/aleph/proto/code_nav_pb.rb#125
Aleph::Proto::IndexingStatus::INDEXING_FAILED = T.let(T.unsafe(nil), Integer)

# source://aleph-client//ruby/lib/aleph/proto/code_nav_pb.rb#125
Aleph::Proto::IndexingStatus::INDEXING_IN_PROGRESS = T.let(T.unsafe(nil), Integer)

# source://aleph-client//ruby/lib/aleph/proto/code_nav_pb.rb#125
Aleph::Proto::IndexingStatus::INDEXING_SKIPPED = T.let(T.unsafe(nil), Integer)

# source://aleph-client//ruby/lib/aleph/proto/code_nav_pb.rb#125
Aleph::Proto::IndexingStatus::INDEXING_TIMED_OUT = T.let(T.unsafe(nil), Integer)

# source://aleph-client//ruby/lib/aleph/proto/code_nav_pb.rb#125
Aleph::Proto::IndexingStatus::NOT_INDEXED = T.let(T.unsafe(nil), Integer)

# source://aleph-client//ruby/lib/aleph/proto/code_nav_pb.rb#125
Aleph::Proto::IndexingStatus::UNKNOWN_INDEXING_STATUS = T.let(T.unsafe(nil), Integer)

# source://aleph-client//ruby/lib/aleph/proto/lsp_twirp.rb#23
class Aleph::Proto::LanguageServerProxyClient < ::Twirp::Client
  # source://twirp/1.10.0/lib/twirp/client.rb#42
  def exist(input, req_opts = T.unsafe(nil)); end

  # source://twirp/1.10.0/lib/twirp/client.rb#42
  def find_defined_name_by_definiens_location(input, req_opts = T.unsafe(nil)); end

  # source://twirp/1.10.0/lib/twirp/client.rb#42
  def find_definitions_of_qualified_names(input, req_opts = T.unsafe(nil)); end

  # source://twirp/1.10.0/lib/twirp/client.rb#42
  def find_references_for_search_keys(input, req_opts = T.unsafe(nil)); end

  # source://twirp/1.10.0/lib/twirp/client.rb#42
  def find_references_to_qualified_names(input, req_opts = T.unsafe(nil)); end

  # source://twirp/1.10.0/lib/twirp/client.rb#42
  def find_reflexive_transitive_callers_by_definiens_location(input, req_opts = T.unsafe(nil)); end

  # source://twirp/1.10.0/lib/twirp/client.rb#42
  def find_symbol_information_for_fully_qualified_name(input, req_opts = T.unsafe(nil)); end

  # source://twirp/1.10.0/lib/twirp/client.rb#42
  def get_partial_call_graph(input, req_opts = T.unsafe(nil)); end

  # source://twirp/1.10.0/lib/twirp/client.rb#42
  def text_document_definition(input, req_opts = T.unsafe(nil)); end

  # source://twirp/1.10.0/lib/twirp/client.rb#42
  def text_document_references(input, req_opts = T.unsafe(nil)); end

  # source://twirp/1.10.0/lib/twirp/client.rb#42
  def workspace_asset(input, req_opts = T.unsafe(nil)); end
end

# source://aleph-client//ruby/lib/aleph/proto/lsp_twirp.rb#7
class Aleph::Proto::LanguageServerProxyService < ::Twirp::Service; end

class Aleph::Proto::Location
  include ::Google::Protobuf::MessageExts
  extend ::Google::Protobuf::MessageExts::ClassMethods

  def initialize(*_arg0); end

  def ==(_arg0); end
  def [](_arg0); end
  def []=(_arg0, _arg1); end
  def clone; end
  def dup; end
  def eql?(_arg0); end
  def hash; end
  def inspect; end
  def method_missing(*_arg0); end
  def to_h; end
  def to_s; end

  private

  def respond_to_missing?(*_arg0); end

  class << self
    def decode(_arg0); end
    def decode_json(*_arg0); end
    def descriptor; end
    def encode(_arg0); end
    def encode_json(*_arg0); end
  end
end

class Aleph::Proto::Package
  include ::Google::Protobuf::MessageExts
  extend ::Google::Protobuf::MessageExts::ClassMethods

  def initialize(*_arg0); end

  def ==(_arg0); end
  def [](_arg0); end
  def []=(_arg0, _arg1); end
  def clone; end
  def dup; end
  def eql?(_arg0); end
  def hash; end
  def inspect; end
  def method_missing(*_arg0); end
  def to_h; end
  def to_s; end

  private

  def respond_to_missing?(*_arg0); end

  class << self
    def decode(_arg0); end
    def decode_json(*_arg0); end
    def descriptor; end
    def encode(_arg0); end
    def encode_json(*_arg0); end
  end
end

class Aleph::Proto::Position
  include ::Google::Protobuf::MessageExts
  extend ::Google::Protobuf::MessageExts::ClassMethods

  def initialize(*_arg0); end

  def ==(_arg0); end
  def [](_arg0); end
  def []=(_arg0, _arg1); end
  def clone; end
  def dup; end
  def eql?(_arg0); end
  def hash; end
  def inspect; end
  def method_missing(*_arg0); end
  def to_h; end
  def to_s; end

  private

  def respond_to_missing?(*_arg0); end

  class << self
    def decode(_arg0); end
    def decode_json(*_arg0); end
    def descriptor; end
    def encode(_arg0); end
    def encode_json(*_arg0); end
  end
end

class Aleph::Proto::QualifiedNameLocation
  include ::Google::Protobuf::MessageExts
  extend ::Google::Protobuf::MessageExts::ClassMethods

  def initialize(*_arg0); end

  def ==(_arg0); end
  def [](_arg0); end
  def []=(_arg0, _arg1); end
  def clone; end
  def dup; end
  def eql?(_arg0); end
  def hash; end
  def inspect; end
  def method_missing(*_arg0); end
  def to_h; end
  def to_s; end

  private

  def respond_to_missing?(*_arg0); end

  class << self
    def decode(_arg0); end
    def decode_json(*_arg0); end
    def descriptor; end
    def encode(_arg0); end
    def encode_json(*_arg0); end
  end
end

class Aleph::Proto::Range
  include ::Google::Protobuf::MessageExts
  extend ::Google::Protobuf::MessageExts::ClassMethods

  def initialize(*_arg0); end

  def ==(_arg0); end
  def [](_arg0); end
  def []=(_arg0, _arg1); end
  def clone; end
  def dup; end
  def eql?(_arg0); end
  def hash; end
  def inspect; end
  def method_missing(*_arg0); end
  def to_h; end
  def to_s; end

  private

  def respond_to_missing?(*_arg0); end

  class << self
    def decode(_arg0); end
    def decode_json(*_arg0); end
    def descriptor; end
    def encode(_arg0); end
    def encode_json(*_arg0); end
  end
end

class Aleph::Proto::Ref
  include ::Google::Protobuf::MessageExts
  extend ::Google::Protobuf::MessageExts::ClassMethods

  def initialize(*_arg0); end

  def ==(_arg0); end
  def [](_arg0); end
  def []=(_arg0, _arg1); end
  def clone; end
  def dup; end
  def eql?(_arg0); end
  def hash; end
  def inspect; end
  def method_missing(*_arg0); end
  def to_h; end
  def to_s; end

  private

  def respond_to_missing?(*_arg0); end

  class << self
    def decode(_arg0); end
    def decode_json(*_arg0); end
    def descriptor; end
    def encode(_arg0); end
    def encode_json(*_arg0); end
  end
end

class Aleph::Proto::ReferenceInformation
  include ::Google::Protobuf::MessageExts
  extend ::Google::Protobuf::MessageExts::ClassMethods

  def initialize(*_arg0); end

  def ==(_arg0); end
  def [](_arg0); end
  def []=(_arg0, _arg1); end
  def clone; end
  def dup; end
  def eql?(_arg0); end
  def hash; end
  def inspect; end
  def method_missing(*_arg0); end
  def to_h; end
  def to_s; end

  private

  def respond_to_missing?(*_arg0); end

  class << self
    def decode(_arg0); end
    def decode_json(*_arg0); end
    def descriptor; end
    def encode(_arg0); end
    def encode_json(*_arg0); end
  end
end

module Aleph::Proto::ReferencesForSearchKeysAllowAliasedReferences
  class << self
    def descriptor; end
    def lookup(_arg0); end
    def resolve(_arg0); end
  end
end

# source://aleph-client//ruby/lib/aleph/proto/lsp_pb.rb#274
Aleph::Proto::ReferencesForSearchKeysAllowAliasedReferences::DirectAndAliasedReferences = T.let(T.unsafe(nil), Integer)

# source://aleph-client//ruby/lib/aleph/proto/lsp_pb.rb#274
Aleph::Proto::ReferencesForSearchKeysAllowAliasedReferences::OnlyDirectReferences = T.let(T.unsafe(nil), Integer)

class Aleph::Proto::Repo
  include ::Google::Protobuf::MessageExts
  extend ::Google::Protobuf::MessageExts::ClassMethods

  def initialize(*_arg0); end

  def ==(_arg0); end
  def [](_arg0); end
  def []=(_arg0, _arg1); end
  def clone; end
  def dup; end
  def eql?(_arg0); end
  def hash; end
  def inspect; end
  def method_missing(*_arg0); end
  def to_h; end
  def to_s; end

  private

  def respond_to_missing?(*_arg0); end

  class << self
    def decode(_arg0); end
    def decode_json(*_arg0); end
    def descriptor; end
    def encode(_arg0); end
    def encode_json(*_arg0); end
  end
end

class Aleph::Proto::RepoCommit
  include ::Google::Protobuf::MessageExts
  extend ::Google::Protobuf::MessageExts::ClassMethods

  def initialize(*_arg0); end

  def ==(_arg0); end
  def [](_arg0); end
  def []=(_arg0, _arg1); end
  def clone; end
  def dup; end
  def eql?(_arg0); end
  def hash; end
  def inspect; end
  def method_missing(*_arg0); end
  def to_h; end
  def to_s; end

  private

  def respond_to_missing?(*_arg0); end

  class << self
    def decode(_arg0); end
    def decode_json(*_arg0); end
    def descriptor; end
    def encode(_arg0); end
    def encode_json(*_arg0); end
  end
end

class Aleph::Proto::RepoName
  include ::Google::Protobuf::MessageExts
  extend ::Google::Protobuf::MessageExts::ClassMethods

  def initialize(*_arg0); end

  def ==(_arg0); end
  def [](_arg0); end
  def []=(_arg0, _arg1); end
  def clone; end
  def dup; end
  def eql?(_arg0); end
  def hash; end
  def inspect; end
  def method_missing(*_arg0); end
  def to_h; end
  def to_s; end

  private

  def respond_to_missing?(*_arg0); end

  class << self
    def decode(_arg0); end
    def decode_json(*_arg0); end
    def descriptor; end
    def encode(_arg0); end
    def encode_json(*_arg0); end
  end
end

module Aleph::Proto::RequestIndexReason
  class << self
    def descriptor; end
    def lookup(_arg0); end
    def resolve(_arg0); end
  end
end

# source://aleph-client//ruby/lib/aleph/proto/code_nav_pb.rb#124
Aleph::Proto::RequestIndexReason::CODE_NAV_USER_VIEWING_CODE = T.let(T.unsafe(nil), Integer)

# source://aleph-client//ruby/lib/aleph/proto/code_nav_pb.rb#124
Aleph::Proto::RequestIndexReason::CODE_NAV_USER_VIEWING_CODE_DIFF = T.let(T.unsafe(nil), Integer)

# source://aleph-client//ruby/lib/aleph/proto/code_nav_pb.rb#124
Aleph::Proto::RequestIndexReason::UNKNOWN_INDEXING_REQUESTER = T.let(T.unsafe(nil), Integer)

# source://aleph-client//ruby/lib/aleph/proto/code_nav_pb.rb#124
Aleph::Proto::RequestIndexReason::VEA_REPO_USER_VIEWING_ALERTS = T.let(T.unsafe(nil), Integer)

# source://aleph-client//ruby/lib/aleph/proto/code_nav_pb.rb#124
Aleph::Proto::RequestIndexReason::VEA_REPO_WITH_ALERT = T.let(T.unsafe(nil), Integer)

# source://aleph-client//ruby/lib/aleph/proto/code_nav_pb.rb#124
Aleph::Proto::RequestIndexReason::VEA_REPO_WITH_VULNERABILITY = T.let(T.unsafe(nil), Integer)

class Aleph::Proto::RequestIndexRequest
  include ::Google::Protobuf::MessageExts
  extend ::Google::Protobuf::MessageExts::ClassMethods

  def initialize(*_arg0); end

  def ==(_arg0); end
  def [](_arg0); end
  def []=(_arg0, _arg1); end
  def clone; end
  def dup; end
  def eql?(_arg0); end
  def hash; end
  def inspect; end
  def method_missing(*_arg0); end
  def to_h; end
  def to_s; end

  private

  def respond_to_missing?(*_arg0); end

  class << self
    def decode(_arg0); end
    def decode_json(*_arg0); end
    def descriptor; end
    def encode(_arg0); end
    def encode_json(*_arg0); end
  end
end

class Aleph::Proto::RequestIndexResponse
  include ::Google::Protobuf::MessageExts
  extend ::Google::Protobuf::MessageExts::ClassMethods

  def initialize(*_arg0); end

  def ==(_arg0); end
  def [](_arg0); end
  def []=(_arg0, _arg1); end
  def clone; end
  def dup; end
  def eql?(_arg0); end
  def hash; end
  def inspect; end
  def method_missing(*_arg0); end
  def to_h; end
  def to_s; end

  private

  def respond_to_missing?(*_arg0); end

  class << self
    def decode(_arg0); end
    def decode_json(*_arg0); end
    def descriptor; end
    def encode(_arg0); end
    def encode_json(*_arg0); end
  end
end

class Aleph::Proto::SearchKeySymbolInformation
  include ::Google::Protobuf::MessageExts
  extend ::Google::Protobuf::MessageExts::ClassMethods

  def initialize(*_arg0); end

  def ==(_arg0); end
  def [](_arg0); end
  def []=(_arg0, _arg1); end
  def clone; end
  def dup; end
  def eql?(_arg0); end
  def hash; end
  def inspect; end
  def method_missing(*_arg0); end
  def to_h; end
  def to_s; end

  private

  def respond_to_missing?(*_arg0); end

  class << self
    def decode(_arg0); end
    def decode_json(*_arg0); end
    def descriptor; end
    def encode(_arg0); end
    def encode_json(*_arg0); end
  end
end

class Aleph::Proto::SymbolInformation
  include ::Google::Protobuf::MessageExts
  extend ::Google::Protobuf::MessageExts::ClassMethods

  def initialize(*_arg0); end

  def ==(_arg0); end
  def [](_arg0); end
  def []=(_arg0, _arg1); end
  def clone; end
  def dup; end
  def eql?(_arg0); end
  def hash; end
  def inspect; end
  def method_missing(*_arg0); end
  def to_h; end
  def to_s; end

  private

  def respond_to_missing?(*_arg0); end

  class << self
    def decode(_arg0); end
    def decode_json(*_arg0); end
    def descriptor; end
    def encode(_arg0); end
    def encode_json(*_arg0); end
  end
end

class Aleph::Proto::TextDocumentLocationResponse
  include ::Google::Protobuf::MessageExts
  extend ::Google::Protobuf::MessageExts::ClassMethods

  def initialize(*_arg0); end

  def ==(_arg0); end
  def [](_arg0); end
  def []=(_arg0, _arg1); end
  def clone; end
  def dup; end
  def eql?(_arg0); end
  def hash; end
  def inspect; end
  def method_missing(*_arg0); end
  def to_h; end
  def to_s; end

  private

  def respond_to_missing?(*_arg0); end

  class << self
    def decode(_arg0); end
    def decode_json(*_arg0); end
    def descriptor; end
    def encode(_arg0); end
    def encode_json(*_arg0); end
  end
end

class Aleph::Proto::TextDocumentPositionRequest
  include ::Google::Protobuf::MessageExts
  extend ::Google::Protobuf::MessageExts::ClassMethods

  def initialize(*_arg0); end

  def ==(_arg0); end
  def [](_arg0); end
  def []=(_arg0, _arg1); end
  def clone; end
  def dup; end
  def eql?(_arg0); end
  def hash; end
  def inspect; end
  def method_missing(*_arg0); end
  def to_h; end
  def to_s; end

  private

  def respond_to_missing?(*_arg0); end

  class << self
    def decode(_arg0); end
    def decode_json(*_arg0); end
    def descriptor; end
    def encode(_arg0); end
    def encode_json(*_arg0); end
  end
end

module Aleph::Proto::ToggleRepoNetworkOperation
  class << self
    def descriptor; end
    def lookup(_arg0); end
    def resolve(_arg0); end
  end
end

# source://aleph-client//ruby/lib/aleph/proto/code_nav_pb.rb#126
Aleph::Proto::ToggleRepoNetworkOperation::DISABLE = T.let(T.unsafe(nil), Integer)

# source://aleph-client//ruby/lib/aleph/proto/code_nav_pb.rb#126
Aleph::Proto::ToggleRepoNetworkOperation::ENABLE = T.let(T.unsafe(nil), Integer)

# source://aleph-client//ruby/lib/aleph/proto/code_nav_pb.rb#126
Aleph::Proto::ToggleRepoNetworkOperation::UNKNOWN = T.let(T.unsafe(nil), Integer)

class Aleph::Proto::ToggleRepoNetworkRequest
  include ::Google::Protobuf::MessageExts
  extend ::Google::Protobuf::MessageExts::ClassMethods

  def initialize(*_arg0); end

  def ==(_arg0); end
  def [](_arg0); end
  def []=(_arg0, _arg1); end
  def clone; end
  def dup; end
  def eql?(_arg0); end
  def hash; end
  def inspect; end
  def method_missing(*_arg0); end
  def to_h; end
  def to_s; end

  private

  def respond_to_missing?(*_arg0); end

  class << self
    def decode(_arg0); end
    def decode_json(*_arg0); end
    def descriptor; end
    def encode(_arg0); end
    def encode_json(*_arg0); end
  end
end

class Aleph::Proto::ToggleRepoNetworkResponse
  include ::Google::Protobuf::MessageExts
  extend ::Google::Protobuf::MessageExts::ClassMethods

  def initialize(*_arg0); end

  def ==(_arg0); end
  def [](_arg0); end
  def []=(_arg0, _arg1); end
  def clone; end
  def dup; end
  def eql?(_arg0); end
  def hash; end
  def inspect; end
  def method_missing(*_arg0); end
  def to_h; end
  def to_s; end

  private

  def respond_to_missing?(*_arg0); end

  class << self
    def decode(_arg0); end
    def decode_json(*_arg0); end
    def descriptor; end
    def encode(_arg0); end
    def encode_json(*_arg0); end
  end
end

class Aleph::Proto::WorkspaceAssetRequest
  include ::Google::Protobuf::MessageExts
  extend ::Google::Protobuf::MessageExts::ClassMethods

  def initialize(*_arg0); end

  def ==(_arg0); end
  def [](_arg0); end
  def []=(_arg0, _arg1); end
  def clone; end
  def dup; end
  def eql?(_arg0); end
  def hash; end
  def inspect; end
  def method_missing(*_arg0); end
  def to_h; end
  def to_s; end

  private

  def respond_to_missing?(*_arg0); end

  class << self
    def decode(_arg0); end
    def decode_json(*_arg0); end
    def descriptor; end
    def encode(_arg0); end
    def encode_json(*_arg0); end
  end
end

class Aleph::Proto::WorkspaceAssetResponse
  include ::Google::Protobuf::MessageExts
  extend ::Google::Protobuf::MessageExts::ClassMethods

  def initialize(*_arg0); end

  def ==(_arg0); end
  def [](_arg0); end
  def []=(_arg0, _arg1); end
  def clone; end
  def dup; end
  def eql?(_arg0); end
  def hash; end
  def inspect; end
  def method_missing(*_arg0); end
  def to_h; end
  def to_s; end

  private

  def respond_to_missing?(*_arg0); end

  class << self
    def decode(_arg0); end
    def decode_json(*_arg0); end
    def descriptor; end
    def encode(_arg0); end
    def encode_json(*_arg0); end
  end
end

# source://aleph-client//ruby/lib/aleph/version.rb#2
Aleph::VERSION = T.let(T.unsafe(nil), String)

module Google::Protobuf::MessageExts::ClassMethods; end

module Hydro::Schemas::Blackbird::V0::Entities::SymbolKind
  class << self
    def descriptor; end
    def lookup(_arg0); end
    def resolve(_arg0); end
  end
end
