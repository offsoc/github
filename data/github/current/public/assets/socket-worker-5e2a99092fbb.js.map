{"version":3,"file":"socket-worker-xxxxxxxxxxxx.js","mappings":"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","sources":["node_modules/@github/alive-client/dist/alive-session.js","node_modules/@github/alive-client/dist/presence.js","node_modules/@github/alive-client/dist/presence-metadata.js","node_modules/@github/stable-socket/dist/index.js","node_modules/@github/multimap/dist/index.js","node_modules/@github/alive-client/dist/subscription-set.js","node_modules/@github/alive-client/dist/iterables.js","node_modules/@github/alive-client/dist/eventloop-tasks.js","ui/packages/alive/session.ts","ui/packages/socket-worker/socket-worker.ts"],"sourcesContent":["import { AlivePresence, getPresenceKey, isPresenceChannel } from './presence.js';\nimport { IDLE_METADATA_KEY, PresenceMetadataSet } from './presence-metadata.js';\nimport { StableSocket } from '@github/stable-socket';\nimport { SubscriptionSet } from './subscription-set.js';\nimport { eachSlice } from './iterables.js';\nimport { retry } from './eventloop-tasks.js';\nvar SocketDisconnectReasons;\n(function (SocketDisconnectReasons) {\n    SocketDisconnectReasons[\"Deploy\"] = \"Alive Redeploy\";\n    SocketDisconnectReasons[\"Reconnect\"] = \"Alive Reconnect\";\n})(SocketDisconnectReasons || (SocketDisconnectReasons = {}));\nfunction generatePresenceId() {\n    return `${Math.round(Math.random() * (Math.pow(2, 31) - 1))}_${Math.round(Date.now() / 1000)}`;\n}\nfunction getUserIdFromSocketUrl(url) {\n    const match = url.match(/\\/u\\/(\\d+)\\/ws/);\n    return match ? +match[1] : 0;\n}\nexport class AliveSession {\n    constructor(url, getUrl, inSharedWorker, notify, maxReconnectBackoff = 600000) {\n        this.url = url;\n        this.getUrl = getUrl;\n        this.inSharedWorker = inSharedWorker;\n        this.notify = notify;\n        this.maxReconnectBackoff = maxReconnectBackoff;\n        this.subscriptions = new SubscriptionSet();\n        this.state = 'online';\n        this.retrying = null;\n        this.connectionCount = 0;\n        this.presence = new AlivePresence();\n        this.presenceMetadata = new PresenceMetadataSet();\n        this.intentionallyDisconnected = false;\n        this.lastCameOnline = 0;\n        this.userId = getUserIdFromSocketUrl(url);\n        this.presenceId = generatePresenceId();\n        this.presenceKey = getPresenceKey(this.userId, this.presenceId);\n        this.socket = this.connect();\n    }\n    subscribe(subscriptions) {\n        const added = this.subscriptions.add(...subscriptions);\n        this.sendSubscribe(added);\n        for (const subscription of subscriptions) {\n            const channel = subscription.topic.name;\n            if (!isPresenceChannel(channel)) {\n                continue;\n            }\n            this.notifyCachedPresence(subscription.subscriber, channel);\n        }\n    }\n    unsubscribe(subscriptions) {\n        const removed = this.subscriptions.delete(...subscriptions);\n        this.sendUnsubscribe(removed);\n    }\n    unsubscribeAll(...subscribers) {\n        const removed = this.subscriptions.drain(...subscribers);\n        this.sendUnsubscribe(removed);\n        const updatedPresenceChannels = this.presenceMetadata.removeSubscribers(subscribers);\n        this.sendPresenceMetadataUpdate(updatedPresenceChannels);\n    }\n    requestPresence(subscriber, channels) {\n        for (const channel of channels) {\n            this.notifyCachedPresence(subscriber, channel);\n        }\n    }\n    notifyCachedPresence(subscriber, channel) {\n        const presenceItems = this.presence.getChannelItems(channel);\n        if (presenceItems.length === 0) {\n            return;\n        }\n        this.notifyPresenceChannel(channel, presenceItems);\n    }\n    updatePresenceMetadata(metadataUpdates) {\n        const updatedChannels = new Set();\n        for (const update of metadataUpdates) {\n            this.presenceMetadata.setMetadata(update);\n            updatedChannels.add(update.channelName);\n        }\n        this.sendPresenceMetadataUpdate(updatedChannels);\n    }\n    sendPresenceMetadataUpdate(channelNames) {\n        if (!channelNames.size) {\n            return;\n        }\n        const topics = [];\n        for (const channelName of channelNames) {\n            const topic = this.subscriptions.topic(channelName);\n            if (topic) {\n                topics.push(topic);\n            }\n        }\n        this.sendSubscribe(topics);\n    }\n    online() {\n        var _a;\n        this.lastCameOnline = Date.now();\n        this.state = 'online';\n        (_a = this.retrying) === null || _a === void 0 ? void 0 : _a.abort();\n        this.socket.open();\n    }\n    offline() {\n        var _a;\n        this.state = 'offline';\n        (_a = this.retrying) === null || _a === void 0 ? void 0 : _a.abort();\n        this.socket.close();\n    }\n    shutdown() {\n        if (this.inSharedWorker) {\n            self.close();\n        }\n    }\n    get reconnectWindow() {\n        const wasRecentlyOffline = Date.now() - this.lastCameOnline < 60 * 1000;\n        if (this.connectionCount === 0 || this.intentionallyDisconnected || wasRecentlyOffline) {\n            return 0;\n        }\n        return 10 * 1000;\n    }\n    socketDidOpen() {\n        this.intentionallyDisconnected = false;\n        this.connectionCount++;\n        this.socket.url = this.getUrlWithPresenceId();\n        this.sendSubscribe(this.subscriptions.topics());\n    }\n    socketDidClose(socket, code, reason) {\n        if (this.redeployEarlyReconnectTimeout !== undefined) {\n            clearTimeout(this.redeployEarlyReconnectTimeout);\n        }\n        if (reason === \"Alive Reconnect\") {\n            this.intentionallyDisconnected = true;\n        }\n        else if (reason === \"Alive Redeploy\") {\n            this.intentionallyDisconnected = true;\n            const reconnectDelayMinutes = 3 + Math.random() * 22;\n            const reconnectDelay = reconnectDelayMinutes * 60 * 1000;\n            this.redeployEarlyReconnectTimeout = setTimeout(() => {\n                this.intentionallyDisconnected = true;\n                this.socket.close(1000, 'Alive Redeploy Early Client Reconnect');\n            }, reconnectDelay);\n        }\n    }\n    socketDidFinish() {\n        if (this.state === 'offline')\n            return;\n        this.reconnect();\n    }\n    socketDidReceiveMessage(_, message) {\n        const payload = JSON.parse(message);\n        switch (payload.e) {\n            case 'ack': {\n                this.handleAck(payload);\n                break;\n            }\n            case 'msg': {\n                this.handleMessage(payload);\n                break;\n            }\n        }\n    }\n    handleAck(ack) {\n        for (const topic of this.subscriptions.topics()) {\n            topic.offset = ack.off;\n        }\n    }\n    handleMessage(msg) {\n        const channel = msg.ch;\n        const topic = this.subscriptions.topic(channel);\n        if (!topic)\n            return;\n        topic.offset = msg.off;\n        if ('e' in msg.data) {\n            const presenceItems = this.presence.handleMessage(channel, msg.data);\n            this.notifyPresenceChannel(channel, presenceItems);\n            return;\n        }\n        if (!msg.data.wait)\n            msg.data.wait = 0;\n        this.notify(this.subscriptions.subscribers(channel), {\n            channel,\n            type: 'message',\n            data: msg.data\n        });\n    }\n    notifyPresenceChannel(channel, presenceItems) {\n        var _a, _b;\n        const userPresenceById = new Map();\n        for (const presenceItem of presenceItems) {\n            const { userId, metadata, presenceKey } = presenceItem;\n            const userPresence = userPresenceById.get(userId) || { userId, isOwnUser: userId === this.userId, metadata: [] };\n            if (presenceKey === this.presenceKey) {\n                continue;\n            }\n            for (const data of metadata) {\n                if (IDLE_METADATA_KEY in data) {\n                    if (userPresence.isIdle !== false) {\n                        userPresence.isIdle = Boolean(data[IDLE_METADATA_KEY]);\n                    }\n                    continue;\n                }\n                userPresence.metadata.push(data);\n            }\n            userPresenceById.set(userId, userPresence);\n        }\n        for (const subscriber of this.subscriptions.subscribers(channel)) {\n            const userId = this.userId;\n            const otherUsers = Array.from(userPresenceById.values()).filter(user => user.userId !== userId);\n            const ownUserRemoteMetadata = (_b = (_a = userPresenceById.get(this.userId)) === null || _a === void 0 ? void 0 : _a.metadata) !== null && _b !== void 0 ? _b : [];\n            const ownUserLocalMetadata = this.presenceMetadata.getChannelMetadata(channel, {\n                subscriber,\n                markAllAsLocal: !this.inSharedWorker\n            });\n            this.notify([subscriber], {\n                channel,\n                type: 'presence',\n                data: [\n                    {\n                        userId,\n                        isOwnUser: true,\n                        metadata: [...ownUserRemoteMetadata, ...ownUserLocalMetadata]\n                    },\n                    ...otherUsers\n                ]\n            });\n        }\n    }\n    async reconnect() {\n        if (this.retrying)\n            return;\n        try {\n            this.retrying = new AbortController();\n            const url = await retry(this.getUrl, Infinity, this.maxReconnectBackoff, this.retrying.signal);\n            if (url) {\n                this.url = url;\n                this.socket = this.connect();\n            }\n            else {\n                this.shutdown();\n            }\n        }\n        catch (e) {\n            if (e.name !== 'AbortError')\n                throw e;\n        }\n        finally {\n            this.retrying = null;\n        }\n    }\n    getUrlWithPresenceId() {\n        const liveUrl = new URL(this.url, self.location.origin);\n        liveUrl.searchParams.set('shared', this.inSharedWorker.toString());\n        liveUrl.searchParams.set('p', `${this.presenceId}.${this.connectionCount}`);\n        return liveUrl.toString();\n    }\n    connect() {\n        const socket = new StableSocket(this.getUrlWithPresenceId(), this, { timeout: 4000, attempts: 7 });\n        socket.open();\n        return socket;\n    }\n    sendSubscribe(topics) {\n        const entries = Array.from(topics);\n        for (const slice of eachSlice(entries, 25)) {\n            const subscribe = {};\n            for (const topic of slice) {\n                if (isPresenceChannel(topic.name)) {\n                    subscribe[topic.signed] = JSON.stringify(this.presenceMetadata.getChannelMetadata(topic.name));\n                }\n                else {\n                    subscribe[topic.signed] = topic.offset;\n                }\n            }\n            this.socket.send(JSON.stringify({ subscribe }));\n        }\n    }\n    sendUnsubscribe(topics) {\n        const signed = Array.from(topics, t => t.signed);\n        for (const slice of eachSlice(signed, 25)) {\n            this.socket.send(JSON.stringify({ unsubscribe: slice }));\n        }\n        for (const topic of topics) {\n            if (isPresenceChannel(topic.name)) {\n                this.presence.clearChannel(topic.name);\n            }\n        }\n    }\n}\n","export function getPresenceKey(userId, presenceId) {\n    return `${userId}:${presenceId}`;\n}\nexport function decompressItem(data) {\n    const [presenceId, connectionCount] = data.p.split('.');\n    return {\n        userId: data.u,\n        presenceKey: getPresenceKey(data.u, presenceId),\n        connectionCount: Number(connectionCount),\n        metadata: data.m || []\n    };\n}\nconst presenceChannelPrefix = 'presence-';\nexport function isPresenceChannel(channelName) {\n    return channelName.startsWith(presenceChannelPrefix);\n}\nclass PresenceChannel {\n    constructor() {\n        this.presenceItems = new Map();\n    }\n    shouldUsePresenceItem(item) {\n        const existingItem = this.presenceItems.get(item.presenceKey);\n        return !existingItem || existingItem.connectionCount <= item.connectionCount;\n    }\n    addPresenceItem(item) {\n        if (!this.shouldUsePresenceItem(item)) {\n            return;\n        }\n        this.presenceItems.set(item.presenceKey, item);\n    }\n    removePresenceItem(item) {\n        if (!this.shouldUsePresenceItem(item)) {\n            return;\n        }\n        this.presenceItems.delete(item.presenceKey);\n    }\n    replacePresenceItems(items) {\n        this.presenceItems.clear();\n        for (const item of items) {\n            this.addPresenceItem(item);\n        }\n    }\n    getPresenceItems() {\n        return Array.from(this.presenceItems.values());\n    }\n}\nexport class AlivePresence {\n    constructor() {\n        this.presenceChannels = new Map();\n    }\n    getPresenceChannel(channelName) {\n        const channel = this.presenceChannels.get(channelName) || new PresenceChannel();\n        this.presenceChannels.set(channelName, channel);\n        return channel;\n    }\n    handleMessage(channelName, data) {\n        const channel = this.getPresenceChannel(channelName);\n        switch (data.e) {\n            case 'pf':\n                channel.replacePresenceItems(data.d.map(decompressItem));\n                break;\n            case 'pa':\n                channel.addPresenceItem(decompressItem(data.d));\n                break;\n            case 'pr':\n                channel.removePresenceItem(decompressItem(data.d));\n                break;\n        }\n        return this.getChannelItems(channelName);\n    }\n    getChannelItems(channelName) {\n        const channel = this.getPresenceChannel(channelName);\n        return channel.getPresenceItems();\n    }\n    clearChannel(channelName) {\n        this.presenceChannels.delete(channelName);\n    }\n}\n","export const IDLE_METADATA_KEY = '_i';\nfunction markMetadataAsLocal(metadata) {\n    return Object.assign(Object.assign({}, metadata), { isLocal: true });\n}\nclass PresenceMetadataForChannel {\n    constructor() {\n        this.subscriberMetadata = new Map();\n    }\n    setMetadata(subscriber, value) {\n        this.subscriberMetadata.set(subscriber, value);\n    }\n    removeSubscribers(subscribers) {\n        let found = false;\n        for (const subscriber of subscribers) {\n            found = this.subscriberMetadata.delete(subscriber) || found;\n        }\n        return found;\n    }\n    getMetadata(localizationOptions) {\n        if (!localizationOptions) {\n            const allMetadata = [];\n            let idle;\n            for (const subscriberMetadata of this.subscriberMetadata.values()) {\n                for (const metadata of subscriberMetadata) {\n                    if (IDLE_METADATA_KEY in metadata) {\n                        const subscriberIsIdle = Boolean(metadata[IDLE_METADATA_KEY]);\n                        idle = idle === undefined ? subscriberIsIdle : subscriberIsIdle && idle;\n                    }\n                    else {\n                        allMetadata.push(metadata);\n                    }\n                }\n            }\n            if (idle !== undefined) {\n                allMetadata.push({ [IDLE_METADATA_KEY]: idle ? 1 : 0 });\n            }\n            return allMetadata;\n        }\n        const metadata = [];\n        const { subscriber, markAllAsLocal } = localizationOptions;\n        for (const [fromSubscriber, subscriberMetadata] of this.subscriberMetadata) {\n            const shouldLocalizeMetadata = markAllAsLocal || fromSubscriber === subscriber;\n            const metadataToAdd = shouldLocalizeMetadata ? subscriberMetadata.map(markMetadataAsLocal) : subscriberMetadata;\n            metadata.push(...metadataToAdd);\n        }\n        return metadata;\n    }\n    hasSubscribers() {\n        return this.subscriberMetadata.size > 0;\n    }\n}\nexport class PresenceMetadataSet {\n    constructor() {\n        this.metadataByChannel = new Map();\n    }\n    setMetadata({ subscriber, channelName, metadata }) {\n        let channelMetadata = this.metadataByChannel.get(channelName);\n        if (!channelMetadata) {\n            channelMetadata = new PresenceMetadataForChannel();\n            this.metadataByChannel.set(channelName, channelMetadata);\n        }\n        channelMetadata.setMetadata(subscriber, metadata);\n    }\n    removeSubscribers(subscribers) {\n        const channelsWithSubscribers = new Set();\n        for (const [channelName, channelMetadata] of this.metadataByChannel) {\n            const channelHadSubscriber = channelMetadata.removeSubscribers(subscribers);\n            if (channelHadSubscriber) {\n                channelsWithSubscribers.add(channelName);\n            }\n            if (!channelMetadata.hasSubscribers()) {\n                this.metadataByChannel.delete(channelName);\n            }\n        }\n        return channelsWithSubscribers;\n    }\n    getChannelMetadata(channelName, localizationOptions) {\n        const channelMetadata = this.metadataByChannel.get(channelName);\n        return (channelMetadata === null || channelMetadata === void 0 ? void 0 : channelMetadata.getMetadata(localizationOptions)) || [];\n    }\n}\n","async function timeout(ms, signal) {\n    let id;\n    const done = new Promise((resolve, reject) => {\n        id = self.setTimeout(() => reject(new Error('timeout')), ms);\n    });\n    if (!signal)\n        return done;\n    try {\n        await Promise.race([done, whenAborted(signal)]);\n    }\n    catch (e) {\n        self.clearTimeout(id);\n        throw e;\n    }\n}\nasync function wait(ms, signal) {\n    let id;\n    const done = new Promise(resolve => {\n        id = self.setTimeout(resolve, ms);\n    });\n    if (!signal)\n        return done;\n    try {\n        await Promise.race([done, whenAborted(signal)]);\n    }\n    catch (e) {\n        self.clearTimeout(id);\n        throw e;\n    }\n}\nasync function retry(fn, attempts, maxDelay = Infinity, signal) {\n    const aborted = signal ? whenAborted(signal) : null;\n    for (let i = 0; i < attempts; i++) {\n        try {\n            const op = aborted ? Promise.race([fn(), aborted]) : fn();\n            return await op;\n        }\n        catch (e) {\n            if (e.name === 'AbortError')\n                throw e;\n            if (i === attempts - 1)\n                throw e;\n            const ms = Math.pow(2, i) * 1000;\n            const vary = rand(ms * 0.1);\n            await wait(Math.min(maxDelay, ms + vary), signal);\n        }\n    }\n    throw new Error('retry failed');\n}\nfunction whenAborted(signal) {\n    return new Promise((resolve, reject) => {\n        const error = new Error('aborted');\n        error.name = 'AbortError';\n        if (signal.aborted) {\n            reject(error);\n        }\n        else {\n            signal.addEventListener('abort', () => reject(error));\n        }\n    });\n}\nfunction rand(max) {\n    return Math.floor(Math.random() * Math.floor(max));\n}\n\nasync function connect(url, ms, signal) {\n    const socket = new WebSocket(url);\n    const opened = whenOpen(socket);\n    try {\n        await Promise.race([opened, timeout(ms, signal)]);\n        return socket;\n    }\n    catch (e) {\n        shutdown(opened);\n        throw e;\n    }\n}\nasync function shutdown(opened) {\n    try {\n        const socket = await opened;\n        socket.close();\n    }\n    catch (_a) {\n    }\n}\nfunction connectWithRetry(url, policy) {\n    const fn = () => connect(url, policy.timeout, policy.signal);\n    return retry(fn, policy.attempts, policy.maxDelay, policy.signal);\n}\nfunction whenOpen(socket) {\n    return new Promise((resolve, reject) => {\n        if (socket.readyState === WebSocket.OPEN) {\n            resolve(socket);\n        }\n        else {\n            socket.onerror = () => {\n                socket.onerror = null;\n                socket.onopen = null;\n                reject(new Error('connect failed'));\n            };\n            socket.onopen = () => {\n                socket.onerror = null;\n                socket.onopen = null;\n                resolve(socket);\n            };\n        }\n    });\n}\n\nclass StableSocket {\n    constructor(url, delegate, policy) {\n        this.socket = null;\n        this.opening = null;\n        this.url = url;\n        this.delegate = delegate;\n        this.policy = policy;\n    }\n    async open() {\n        if (this.opening || this.socket)\n            return;\n        this.opening = new AbortController();\n        const policy = Object.assign(Object.assign({}, this.policy), { signal: this.opening.signal });\n        try {\n            this.socket = await connectWithRetry(this.url, policy);\n        }\n        catch (_a) {\n            this.delegate.socketDidFinish(this);\n            return;\n        }\n        finally {\n            this.opening = null;\n        }\n        this.socket.onclose = (event) => {\n            this.socket = null;\n            this.delegate.socketDidClose(this, event.code, event.reason);\n            const fatal = this.delegate.socketShouldRetry\n                ? !this.delegate.socketShouldRetry(this, event.code)\n                : isFatal(event.code);\n            if (fatal) {\n                this.delegate.socketDidFinish(this);\n            }\n            else {\n                setTimeout(() => this.open(), rand$1(100, 100 + (this.delegate.reconnectWindow || 50)));\n            }\n        };\n        this.socket.onmessage = (event) => {\n            this.delegate.socketDidReceiveMessage(this, event.data);\n        };\n        this.delegate.socketDidOpen(this);\n    }\n    close(code, reason) {\n        if (this.opening) {\n            this.opening.abort();\n            this.opening = null;\n        }\n        else if (this.socket) {\n            this.socket.onclose = null;\n            this.socket.close(code, reason);\n            this.socket = null;\n            this.delegate.socketDidClose(this, code, reason);\n            this.delegate.socketDidFinish(this);\n        }\n    }\n    send(data) {\n        if (this.socket) {\n            this.socket.send(data);\n        }\n    }\n    isOpen() {\n        return !!this.socket;\n    }\n}\nfunction rand$1(min, max) {\n    return Math.random() * (max - min) + min;\n}\nfunction isFatal(code) {\n    return code === POLICY_VIOLATION || code === INTERNAL_ERROR;\n}\nconst POLICY_VIOLATION = 1008;\nconst INTERNAL_ERROR = 1011;\n\nclass BufferedSocket {\n    constructor(socket) {\n        this.buf = [];\n        this.socket = socket;\n        this.delegate = socket.delegate;\n        socket.delegate = this;\n    }\n    open() {\n        return this.socket.open();\n    }\n    close(code, reason) {\n        this.socket.close(code, reason);\n    }\n    send(data) {\n        if (this.socket.isOpen()) {\n            this.flush();\n            this.socket.send(data);\n        }\n        else {\n            this.buf.push(data);\n        }\n    }\n    isOpen() {\n        return this.socket.isOpen();\n    }\n    flush() {\n        for (const data of this.buf) {\n            this.socket.send(data);\n        }\n        this.buf.length = 0;\n    }\n    socketDidOpen(socket) {\n        this.flush();\n        this.delegate.socketDidOpen(socket);\n    }\n    socketDidClose(socket, code, reason) {\n        this.delegate.socketDidClose(socket, code, reason);\n    }\n    socketDidFinish(socket) {\n        this.delegate.socketDidFinish(socket);\n    }\n    socketDidReceiveMessage(socket, message) {\n        this.delegate.socketDidReceiveMessage(socket, message);\n    }\n    socketShouldRetry(socket, code) {\n        return this.delegate.socketShouldRetry ? this.delegate.socketShouldRetry(socket, code) : !isFatal(code);\n    }\n}\n\nexport { BufferedSocket, StableSocket, connect, connectWithRetry };\n","export default class MultiMap {\n    constructor(iterable) {\n        this.map = new Map();\n        if (iterable) {\n            for (const [k, v] of iterable) {\n                this.set(k, v);\n            }\n        }\n    }\n    get(key) {\n        const values = this.map.get(key);\n        return values ? values : new Set();\n    }\n    set(key, value) {\n        let values = this.map.get(key);\n        if (!values) {\n            values = new Set();\n            this.map.set(key, values);\n        }\n        values.add(value);\n        return this;\n    }\n    has(key) {\n        return this.map.has(key);\n    }\n    delete(key, value) {\n        const values = this.map.get(key);\n        if (!values)\n            return false;\n        if (!value)\n            return this.map.delete(key);\n        const deleted = values.delete(value);\n        if (!values.size)\n            this.map.delete(key);\n        return deleted;\n    }\n    drain(value) {\n        const empty = [];\n        for (const key of this.keys()) {\n            if (this.delete(key, value) && !this.has(key)) {\n                empty.push(key);\n            }\n        }\n        return empty;\n    }\n    keys() {\n        return this.map.keys();\n    }\n    values() {\n        return this.map.values();\n    }\n    entries() {\n        return this.map.entries();\n    }\n    [Symbol.iterator]() {\n        return this.entries();\n    }\n    clear() {\n        this.map.clear();\n    }\n    get size() {\n        return this.map.size;\n    }\n}\n","import MultiMap from '@github/multimap';\nexport class SubscriptionSet {\n    constructor() {\n        this.subscriptions = new MultiMap();\n        this.signatures = new Map();\n    }\n    add(...subscriptions) {\n        const added = [];\n        for (const { subscriber, topic } of subscriptions) {\n            if (!this.subscriptions.has(topic.name)) {\n                added.push(topic);\n                this.signatures.set(topic.name, topic);\n            }\n            this.subscriptions.set(topic.name, subscriber);\n        }\n        return added;\n    }\n    delete(...subscriptions) {\n        const removed = [];\n        for (const { subscriber, topic } of subscriptions) {\n            const deleted = this.subscriptions.delete(topic.name, subscriber);\n            if (deleted && !this.subscriptions.has(topic.name)) {\n                removed.push(topic);\n                this.signatures.delete(topic.name);\n            }\n        }\n        return removed;\n    }\n    drain(...subscribers) {\n        const removed = [];\n        for (const subscriber of subscribers) {\n            for (const name of this.subscriptions.drain(subscriber)) {\n                const topic = this.signatures.get(name);\n                this.signatures.delete(name);\n                removed.push(topic);\n            }\n        }\n        return removed;\n    }\n    topics() {\n        return this.signatures.values();\n    }\n    topic(name) {\n        return this.signatures.get(name) || null;\n    }\n    subscribers(topic) {\n        return this.subscriptions.get(topic).values();\n    }\n}\n","export function* eachSlice(values, size) {\n    for (let i = 0; i < values.length; i += size) {\n        yield values.slice(i, i + size);\n    }\n}\n","function whenAborted(signal) {\n    return new Promise((resolve, reject) => {\n        const error = new Error('aborted');\n        error.name = 'AbortError';\n        if (signal.aborted) {\n            reject(error);\n        }\n        else {\n            signal.addEventListener('abort', () => reject(error));\n        }\n    });\n}\nexport async function wait(ms, signal) {\n    let id;\n    const done = new Promise(resolve => {\n        id = self.setTimeout(resolve, ms);\n    });\n    if (!signal)\n        return done;\n    try {\n        await Promise.race([done, whenAborted(signal)]);\n    }\n    catch (e) {\n        self.clearTimeout(id);\n        throw e;\n    }\n}\nfunction rand(max) {\n    return Math.floor(Math.random() * Math.floor(max));\n}\nexport async function retry(fn, attempts, maxDelay = Infinity, signal) {\n    const aborted = signal ? whenAborted(signal) : null;\n    for (let i = 0; i < attempts; i++) {\n        try {\n            const op = aborted ? Promise.race([fn(), aborted]) : fn();\n            return await op;\n        }\n        catch (e) {\n            if (e.name === 'AbortError')\n                throw e;\n            if (i === attempts - 1)\n                throw e;\n            const ms = Math.pow(2, i) * 1000;\n            const vary = rand(ms * 0.1);\n            await wait(Math.min(maxDelay, ms + vary), signal);\n        }\n    }\n    throw new Error('retry failed');\n}\n","import {AliveSession as BaseAliveSession} from '@github/alive-client'\nimport type {Notifier} from '@github/alive-client'\nexport class AliveSession<T> extends BaseAliveSession<T> {\n  constructor(\n    url: string,\n    private refreshUrl: string,\n    shared: boolean,\n    notify: Notifier<T>,\n  ) {\n    super(url, () => this.getUrlFromRefreshUrl(), shared, notify)\n  }\n\n  private getUrlFromRefreshUrl() {\n    return fetchRefreshUrl(this.refreshUrl)\n  }\n}\n\ntype PostUrl = {url?: string; token?: string}\nasync function fetchRefreshUrl(url: string): Promise<string | null> {\n  const data = await fetchJSON<PostUrl>(url)\n  return data && data.url && data.token ? post(data.url, data.token) : null\n}\n\nasync function fetchJSON<T>(url: string): Promise<T | null> {\n  const response = await fetch(url, {headers: {Accept: 'application/json'}})\n  if (response.ok) {\n    return response.json()\n  } else if (response.status === 404) {\n    return null\n  } else {\n    throw new Error('fetch error')\n  }\n}\n\nasync function post(url: string, csrf: string): Promise<string> {\n  const response = await fetch(url, {\n    method: 'POST',\n    mode: 'same-origin',\n    headers: {\n      'Scoped-CSRF-Token': csrf,\n    },\n  })\n  if (response.ok) {\n    return response.text()\n  } else {\n    throw new Error('fetch error')\n  }\n}\n","import type {AliveEvent, MetadataUpdate, Topic} from '@github/alive-client'\nimport {AliveSession} from '@github-ui/alive/session'\n\ndeclare const self: SharedWorkerGlobalScope\n\ntype Command = {\n  connect?: {url: string; refreshUrl: string}\n  subscribe?: Topic[]\n  unsubscribe?: Topic[]\n  requestPresence?: string[]\n  updatePresenceMetadata?: Array<MetadataUpdate<MessagePort>>\n  hangup?: boolean\n  online?: boolean\n}\n\nfunction notify(subscribers: Iterable<MessagePort>, event: AliveEvent) {\n  for (const port of subscribers) {\n    port.postMessage(event)\n  }\n}\n\nfunction fromPort(session: AliveSession<MessagePort>, port: MessagePort, data: Command) {\n  const toSub = (topic: Topic) => ({subscriber: port, topic})\n\n  if (data.subscribe) {\n    session.subscribe(data.subscribe.map(toSub))\n  }\n\n  if (data.unsubscribe) {\n    session.unsubscribe(data.unsubscribe.map(toSub))\n  }\n\n  if (data.requestPresence) {\n    session.requestPresence(port, data.requestPresence)\n  }\n\n  if (data.updatePresenceMetadata) {\n    for (const update of data.updatePresenceMetadata) {\n      // Set the subscriber for the update\n      // This is used to track where the metadata originated\n      update.subscriber = port\n    }\n    session.updatePresenceMetadata(data.updatePresenceMetadata)\n  }\n\n  if (data.online != null) {\n    if (data.online) {\n      session.online()\n    } else {\n      session.offline()\n    }\n  }\n\n  if (data.hangup) {\n    session.unsubscribeAll(port)\n  }\n}\n\nfunction withSocket(): (event: MessageEvent) => void {\n  let session: AliveSession<MessagePort> | null = null\n  return function (event: MessageEvent) {\n    const port = event.target as MessagePort\n    const data = event.data as Command\n    if (data.connect && !session) {\n      session = new AliveSession(data.connect.url, data.connect.refreshUrl, true, notify)\n    } else if (session) {\n      fromPort(session, port, data)\n    }\n  }\n}\n\nconst process = withSocket()\n\nself.onconnect = (event: MessageEvent) => {\n  const port = event.ports[0]\n  if (port) {\n    port.onmessage = process\n  }\n}\n\nif (typeof BroadcastChannel === 'function') {\n  // Broadcast errors to all tabs.  The tabs will then forward the error Sentry.\n  const errorChannel = new BroadcastChannel('shared-worker-error')\n  self.addEventListener('error', event => {\n    const {\n      error: {name, message, stack},\n    } = event\n\n    errorChannel.postMessage({\n      error: {name, message, stack},\n    })\n  })\n}\n"],"names":["SocketDisconnectReasons","decompressItem","data","userId","presenceId","connectionCount","p","split","u","presenceKey","Number","metadata","m","isPresenceChannel","channelName","startsWith","PresenceChannel","constructor","presenceItems","Map","shouldUsePresenceItem","item","existingItem","get","addPresenceItem","set","removePresenceItem","delete","replacePresenceItems","items","clear","getPresenceItems","Array","from","values","AlivePresence","presenceChannels","getPresenceChannel","channel","handleMessage","e","d","map","getChannelItems","clearChannel","markMetadataAsLocal","Object","assign","isLocal","PresenceMetadataForChannel","subscriberMetadata","setMetadata","subscriber","value","removeSubscribers","subscribers","found","getMetadata","localizationOptions","idle","allMetadata","IDLE_METADATA_KEY","subscriberIsIdle","Boolean","undefined","push","markAllAsLocal","fromSubscriber","metadataToAdd","shouldLocalizeMetadata","hasSubscribers","size","PresenceMetadataSet","metadataByChannel","channelMetadata","channelsWithSubscribers","Set","add","getChannelMetadata","timeout","ms","signal","id","done","Promise","resolve","reject","self","setTimeout","race","whenAborted","clearTimeout","wait","retry","fn","attempts","maxDelay","Infinity","aborted","i","op","name","Math","pow","vary","floor","random","min","error","addEventListener","connect","url","socket","WebSocket","opened","readyState","OPEN","onerror","onopen","shutdown","close","_a","StableSocket","delegate","policy","opening","open","AbortController","socketDidFinish","onclose","code","socketDidClose","event","reason","socketShouldRetry","POLICY_VIOLATION","INTERNAL_ERROR","max","reconnectWindow","onmessage","socketDidReceiveMessage","socketDidOpen","abort","send","isOpen","MultiMap","iterable","k","v","key","has","deleted","drain","empty","keys","entries","Symbol","iterator","SubscriptionSet","subscriptions","signatures","added","topic","removed","topics","eachSlice","length","slice","getUrl","inSharedWorker","notify","maxReconnectBackoff","state","retrying","presence","presenceMetadata","intentionallyDisconnected","lastCameOnline","getUserIdFromSocketUrl","match","round","Date","now","subscribe","subscription","sendSubscribe","notifyCachedPresence","unsubscribe","sendUnsubscribe","unsubscribeAll","updatedPresenceChannels","sendPresenceMetadataUpdate","requestPresence","channels","notifyPresenceChannel","updatePresenceMetadata","metadataUpdates","updatedChannels","update","channelNames","online","offline","wasRecentlyOffline","getUrlWithPresenceId","redeployEarlyReconnectTimeout","reconnectDelayMinutes","reconnect","_","message","payload","JSON","parse","handleAck","ack","offset","off","msg","ch","type","_b","userPresenceById","presenceItem","userPresence","isOwnUser","isIdle","otherUsers","filter","user","ownUserRemoteMetadata","ownUserLocalMetadata","liveUrl","URL","location","origin","searchParams","toString","signed","stringify","t","AliveSession","BaseAliveSession","getUrlFromRefreshUrl","fetchRefreshUrl","refreshUrl","shared","fetchJSON","token","post","response","fetch","headers","Accept","ok","json","status","csrf","method","mode","text","port","postMessage","process","withSocket","session","target","fromPort","toSub","hangup","onconnect","ports","BroadcastChannel","errorChannel","stack"],"sourceRoot":""}