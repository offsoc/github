{"version":3,"file":"app_assets_modules_github_blob-anchor_ts-app_assets_modules_github_jump-to_page-views_ts-ui_p-38f236-xxxxxxxxxxxx.js","mappings":"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","sources":["app/assets/modules/github/blob-anchor.ts","app/assets/modules/github/jump-to/ranking.ts","app/assets/modules/github/jump-to/page-views.ts","ui/packages/filter-sort/filter-sort.ts","ui/packages/filter-sort/filter-map.ts","ui/packages/fuzzy-filter/fuzzy-filter.ts","ui/packages/visible/visible.ts"],"sourcesContent":["export interface BlobOffset {\n  // Line number\n  // Lines start at 1.\n  line: number\n\n  // Optional column number.\n  // Like lines, columns are 1-indexed.\n  column: number | null\n}\n\nexport interface BlobRange {\n  // Starting offset of range.\n  start: BlobOffset\n\n  // End offset of range.\n  // End offset may be the same as the start. This indicates a collapsed range.\n  // Should always be initialized to a value that is equal or greater than the\n  // start range such the range is always in ascending order. Reversed ranges\n  // have undefined behavior.\n  end: BlobOffset\n}\n\n// Inverse of `formatBlobRange`.\n//\n// Examples\n//\n//   parseBlobRange(\"#L3\")\n//   // => {start: {line: 3}}\n//\n//   parseBlobRange(\"L3-L5\")\n//   // => {start: {line: 3}, end: {line: 5}}\n//\n//   parseBlobRange(\"\")\n//   // => null\nexport function parseBlobRange(str: string): BlobRange | undefined {\n  const lines = str.match(/#?(?:L)(\\d+)((?:C)(\\d+))?/g)\n  if (!lines) {\n    return\n  } else if (lines.length === 1) {\n    const offset = parseBlobOffset(lines[0])\n    if (!offset) return\n    return Object.freeze({start: offset, end: offset})\n  } else if (lines.length === 2) {\n    const startOffset = parseBlobOffset(lines[0])\n    const endOffset = parseBlobOffset(lines[1]!)\n    if (!startOffset || !endOffset) return\n\n    return ascendingBlobRange(\n      Object.freeze({\n        start: startOffset,\n        end: endOffset,\n      }),\n    )\n  } else {\n    return\n  }\n}\n\n// Inverse of `parseBlobRange`.\n//\n// Examples\n//\n//   formatBlobRange({start: {line: 3}})\n//   // => \"L3\"\n//\n//   formatBlobRange({start: {line: 3}, end: {line: 5}})\n//   // => \"L3-L5\"\n//\n//   formatBlobRange({start: {line: 3, column: 1}, end: {line: 5, column: 5}})\n//   // => \"L3C1-L5C5\"\n//\n//   formatBlobRange({start: {line: 3, column: 1}, end: {line: 5,}})\n//   // => \"L3C1-L5\"\nexport function formatBlobRange(blobRange: BlobRange): string {\n  const {start, end} = ascendingBlobRange(blobRange)\n\n  if (start.column != null && end.column != null) {\n    return `L${start.line}C${start.column}-L${end.line}C${end.column}`\n  } else if (start.column != null) {\n    return `L${start.line}C${start.column}-L${end.line}`\n  } else if (end.column != null) {\n    return `L${start.line}-L${end.line}C${end.column}`\n  } else if (start.line === end.line) {\n    return `L${start.line}`\n  } else {\n    return `L${start.line}-L${end.line}`\n  }\n}\n\n// Returns a String containing the file prefix with trailing dash.\n//\n// Examples\n//\n//   parseAnchorPrefix(\"#file-zshrc-L3\")\n//   // => \"file-zshrc-\"\n//\n//   parseAnchorPrefix(\"file-zshrc-L3-L5\")\n//   // => \"file-zshrc-\"\n//\n//   parseAnchorPrefix(\"\")\n//   // => \"\"\nfunction parseAnchorPrefix(str: string): string {\n  const match = str.length < 5000 && str.match(/(file-.+?-)L\\d+?/i)\n  return match ? match[1]! : ''\n}\n\nexport type AnchorInfo = {\n  blobRange: BlobRange\n  anchorPrefix: string\n}\n\n// Examples\n//\n//   parseFileAnchor(\"#file-zshrc-L3\")\n//   // => { blobRange: {start: {line: 3}}, anchorPrefix: \"file-zshrc-\" }\n//\n//   parseFileAnchor(\"file-zshrc-L3-L5\")\n//   // => { blobRange: {start: {line: 3}, end: {line: 5}}, anchorPrefix: \"file-zshrc-\" }\n//\n//   parseFileAnchor(\"\")\n//   // => { blobRange: null, anchorPrefix: undefined }\nexport function parseFileAnchor(str: string): AnchorInfo {\n  const blobRange = parseBlobRange(str)!\n  const anchorPrefix = parseAnchorPrefix(str)\n  return {blobRange, anchorPrefix}\n}\n\n// Formats line number range pair as an anchor String.\n//\n// Examples\n//\n//   formatBlobRangeAnchor({blobRange: {start: {line: 3}}, anchorPrefix: \"\"})\n//   // => \"#L3\"\n//\n//   formatBlobRangeAnchor({blobRange: {start: {line: 3}}, anchorPrefix: \"file-zshrc-\"})\n//   // => \"#file-zshrc-L3\"\n//\n//   formatBlobRangeAnchor({blobRange: {start: {line: 3}, end: {line: 5}}, anchorPrefix: \"\"})\n//   // => \"#L3-L5\"\n//\n//   formatBlobRangeAnchor({blobRange: {start: {line: 3, column: 1}, end: {line: 5, column: 5}}, anchorPrefix: \"\"})\n//   // => \"#L3C1-L5C5\"\n//\n//   formatBlobRangeAnchor({blobRange: {start: {line: 3}, end: {line: 5}}, anchorPrefix: \"file-zshrc-\"})\n//   // => \"#file-zshrc-L3-L5\"\n//\n//   formatBlobRangeAnchor({blobRange: null, anchorPrefix: \"\"})\n//   // => \"#\"\n//\n//   formatBlobRangeAnchor({blobRange: null, anchorPrefix: \"file-zshrc-\"})\n//   // => \"#\"\nexport function formatBlobRangeAnchor({anchorPrefix, blobRange}: AnchorInfo): string {\n  if (!blobRange) return '#'\n  return `#${anchorPrefix}${formatBlobRange(blobRange)}`\n}\n\nfunction parseBlobOffset(str: string): BlobOffset | null {\n  const lineMatch = str.match(/L(\\d+)/)\n  const columnMatch = str.match(/C(\\d+)/)\n  if (lineMatch) {\n    return Object.freeze({\n      line: parseInt(lineMatch[1]!),\n      column: columnMatch ? parseInt(columnMatch[1]!) : null,\n    })\n  } else {\n    return null\n  }\n}\n\nexport function DOMRangeFromBlob(\n  blobRange: BlobRange,\n  getLineElement: (line: number) => Node | null,\n): Range | undefined {\n  const [startContainer, _startOffset] = findRangeOffset(blobRange.start, true, getLineElement)\n  const [endContainer, _endOffset] = findRangeOffset(blobRange.end, false, getLineElement)\n  if (!startContainer || !endContainer) return\n\n  // Treat -1 as full line selection\n  let startOffset = _startOffset\n  let endOffset = _endOffset\n  if (startOffset === -1) startOffset = 0\n  if (endOffset === -1) endOffset = endContainer.childNodes.length\n  if (!startContainer.ownerDocument) throw new Error(`DOMRange needs to be inside document`)\n\n  const range = startContainer.ownerDocument.createRange()\n  range.setStart(startContainer, startOffset)\n  range.setEnd(endContainer, endOffset)\n  return range\n}\n\nfunction findRangeOffset(\n  offset: BlobOffset,\n  lookAhead: boolean,\n  getLineElement: (n: number) => Node | null,\n): [Node | null, number] {\n  const error: [null, number] = [null, 0]\n\n  const lineElement = getLineElement(offset.line)\n  if (!lineElement) return error\n\n  if (offset.column == null) {\n    return [lineElement, -1]\n  }\n\n  let column = offset.column - 1\n\n  const textNodes = getAllTextNodes(lineElement)\n  for (let i = 0; i < textNodes.length; i++) {\n    const textNode = textNodes[i]!\n\n    // TODO: length might be buggy with emoji\n    const nextC = column - (textNode.textContent || '').length\n\n    if (nextC === 0) {\n      const nextTextNode = textNodes[i + 1]\n      if (lookAhead && nextTextNode) {\n        return [nextTextNode, 0]\n      } else {\n        return [textNode, column]\n      }\n    } else if (nextC < 0) {\n      return [textNode, column]\n    }\n\n    column = nextC\n  }\n\n  return error\n}\n\n// Get a flat list of text nodes in depth first order.\nfunction getAllTextNodes(el: Node): Node[] {\n  if (el.nodeType === Node.TEXT_NODE) {\n    return [el]\n  }\n  if (!el.childNodes || !el.childNodes.length) return []\n  let list: Node[] = []\n  for (const node of el.childNodes) {\n    list = list.concat(getAllTextNodes(node))\n  }\n  return list\n}\n\n// Sorts range start and end offsets to be in ascending order.\nfunction ascendingBlobRange(range: BlobRange): BlobRange {\n  const offsets = [range.start, range.end]\n  offsets.sort(compareBlobOffsets)\n\n  if (offsets[0] === range.start && offsets[1] === range.end) {\n    return range\n  } else {\n    return Object.freeze({\n      start: offsets[0]!,\n      end: offsets[1]!,\n    })\n  }\n}\n\n// Compare line offsets. May be used with Array.sort\nfunction compareBlobOffsets(a: BlobOffset, b: BlobOffset): number {\n  if (a.line === b.line && a.column === b.column) {\n    return 0\n  } else if (a.line === b.line && typeof a.column === 'number' && typeof b.column === 'number') {\n    return a.column - b.column\n  } else {\n    return a.line - b.line\n  }\n}\n","import type {PageViews} from './page-views'\n\nconst FEATURE_WEIGHTS = {frequency: 0.6, recency: 0.4}\n\nfunction sortBy<T>(items: T[], map: (item: T) => number): T[] {\n  return items.sort((a, b) => map(a) - map(b))\n}\n\ntype Scorer = (pageKey: string) => number\nexport function scorer(pageViews: PageViews): Scorer {\n  const frequencies = frequencyMap(pageViews)\n  const recencies = recencyMap(pageViews)\n  return function (pageKey: string): number {\n    return score(frequencies.get(pageKey) || 0, recencies.get(pageKey) || 0)\n  }\n}\n\nfunction score(frequency: number, recency: number): number {\n  return frequency * FEATURE_WEIGHTS.frequency + recency * FEATURE_WEIGHTS.recency\n}\n\n// Scores a relative frequency in the interval [0, 1] where higher means more frequent.\nfunction frequencyMap(pageViews: PageViews): Map<string, number> {\n  const totalVisits = [...Object.values(pageViews)].reduce((total, view) => total + view.visitCount, 0)\n  return new Map(Object.keys(pageViews).map(pageKey => [pageKey, pageViews[pageKey]!.visitCount / totalVisits]))\n}\n\n// Scores a relative recency value in the interval [0, 1] where higher means more recent.\nfunction recencyMap(pageViews: PageViews): Map<string, number> {\n  const recencyList = sortBy([...Object.keys(pageViews)], key => pageViews[key]!.lastVisitedAt)\n  const totalUniqueVisits = recencyList.length\n  return new Map(recencyList.map((key, index) => [key, (index + 1) / totalUniqueVisits]))\n}\n","import {scorer} from './ranking'\nexport {scorer} from './ranking'\n\ntype PageViewSummary = {\n  lastVisitedAt: number\n  visitCount: number\n}\n\nexport type PageViews = {[page_key: string]: PageViewSummary}\n\nconst TEAM_PAGE_REGEX = /^\\/orgs\\/([a-z0-9-]+)\\/teams\\/([\\w-]+)/\n\n// Of course this list is incomplete, but it should be good enough for the purposes of this prototype.\nconst REPOSITORY_PAGE_REGEXES = [\n  // This will overcount some things, but since every page view is ultimately compared to entities\n  // we can jump to it should be fine. Of course if we ever tried to add users or orgs to this it\n  // would break.\n  /^\\/([^/]+)\\/([^/]+)\\/?$/,\n\n  /^\\/([^/]+)\\/([^/]+)\\/blob/,\n  /^\\/([^/]+)\\/([^/]+)\\/tree/,\n  /^\\/([^/]+)\\/([^/]+)\\/issues/,\n  /^\\/([^/]+)\\/([^/]+)\\/pulls?/,\n  /^\\/([^/]+)\\/([^/]+)\\/pulse/,\n]\n\nconst PROJECT_PAGE_REGEXES = [\n  ['organization', /^\\/orgs\\/([a-z0-9-]+)\\/projects\\/([0-9-]+)/],\n  ['repository', /^\\/([^/]+)\\/([^/]+)\\/projects\\/([0-9-]+)/],\n]\n\nconst MAX_PAGE_VIEWS_TO_STORE_IN_LOCAL_STORAGE = 100\n\nexport function logPageView(path: string) {\n  const teamPageMatch = path.match(TEAM_PAGE_REGEX)\n  if (teamPageMatch) {\n    logPageViewByKey(buildTeamKey(teamPageMatch[1]!, teamPageMatch[2]!))\n    return\n  }\n\n  let projectPageMatch\n  for (let i = 0, len = PROJECT_PAGE_REGEXES.length; i < len; i++) {\n    const [ownerType, projectRegex] = PROJECT_PAGE_REGEXES[i]!\n    projectPageMatch = path.match(projectRegex!)\n    if (projectPageMatch) {\n      let ownerSlug: string | null = null\n      let number: string | null = null\n      switch (ownerType) {\n        case 'organization':\n          ownerSlug = projectPageMatch[1]!\n          number = projectPageMatch[2]!\n          break\n        case 'repository':\n          ownerSlug = `${projectPageMatch[1]}/${projectPageMatch[2]}`\n          number = projectPageMatch[3]!\n          break\n        default:\n        // Should never get here.\n      }\n      if (ownerSlug && number) {\n        logPageViewByKey(buildProjectKey(ownerSlug, number))\n      }\n      return\n    }\n  }\n\n  let repositoryPageMatch\n  for (let i = 0, len = REPOSITORY_PAGE_REGEXES.length; i < len; i++) {\n    repositoryPageMatch = path.match(REPOSITORY_PAGE_REGEXES[i]!)\n    if (repositoryPageMatch) {\n      logPageViewByKey(buildRepositoryKey(repositoryPageMatch[1]!, repositoryPageMatch[2]!))\n      return\n    }\n  }\n}\n\n// Limits localStorage entries to 100 MAX_PAGE_VIEWS_TO_STORE_IN_LOCAL_STORAGE\nfunction limitedPageViews(pageViews: PageViews) {\n  const keys = Object.keys(pageViews)\n  if (keys.length <= MAX_PAGE_VIEWS_TO_STORE_IN_LOCAL_STORAGE) {\n    return pageViews\n  }\n  const scorePage = scorer(pageViews)\n  const ranked = keys.sort((a, b) => scorePage(b) - scorePage(a)).slice(0, MAX_PAGE_VIEWS_TO_STORE_IN_LOCAL_STORAGE / 2)\n  return Object.fromEntries(ranked.map(key => [key, pageViews[key]!]))\n}\n\nfunction logPageViewByKey(key: string) {\n  const views = getPageViewsMap()\n  const now = currentEpochTimeInSeconds()\n  const hit = views[key] || {lastVisitedAt: now, visitCount: 0}\n  hit.visitCount += 1\n  hit.lastVisitedAt = now\n  views[key] = hit\n  setPageViewsMap(limitedPageViews(views))\n}\n\nfunction currentEpochTimeInSeconds(): number {\n  return Math.floor(Date.now() / 1000)\n}\n\nexport function buildTeamKey(organizationLogin: string, teamSlug: string): string {\n  return `team:${organizationLogin}/${teamSlug}`\n}\n\nexport function buildRepositoryKey(ownerLogin: string, name: string): string {\n  return `repository:${ownerLogin}/${name}`\n}\n\nexport function buildProjectKey(ownerSlug: string, number: string): string {\n  return `project:${ownerSlug}/${number}`\n}\n\nconst PAGE_VIEW_KEY_REGEX = /^(team|repository|project):[^/]+\\/[^/]+(\\/([^/]+))?$/\nconst VIEWS_KEY = 'jump_to:page_views'\n\nfunction setPageViewsMap(views: PageViews) {\n  setItem(VIEWS_KEY, JSON.stringify(views))\n}\n\nexport function getPageViewsMap(): PageViews {\n  const rawData = getItem(VIEWS_KEY)\n  if (!rawData) return {}\n\n  let json\n  try {\n    json = JSON.parse(rawData)\n  } catch {\n    // Clear localStorage since we know it's bad\n    setPageViewsMap({})\n    return {}\n  }\n\n  const pageViewMap: PageViews = {}\n  for (const key in json) {\n    if (key.match(PAGE_VIEW_KEY_REGEX)) {\n      pageViewMap[key] = json[key]\n    }\n  }\n  return pageViewMap\n}\n\nfunction setItem(key: string, value: string) {\n  try {\n    window.localStorage.setItem(key, value)\n  } catch {\n    // Storage quota exceeded.\n  }\n}\n\nfunction getItem(key: string): string | null {\n  try {\n    return window.localStorage.getItem(key)\n  } catch {\n    // Storage unavailable.\n    return null\n  }\n}\n","import {filterMap} from './filter-map'\n\nexport type MapKey<T, K> = (item: T) => K | null | undefined\nexport type Comparator<T> = (a: T, b: T) => number\n\nexport function filterSort<T, K>(items: T[], map: MapKey<T, K>, compare: Comparator<K>): T[] {\n  const sortKey = (item: T): [T, K] | null => {\n    const key = map(item)\n    return key != null ? [item, key] : null\n  }\n  return [...filterMap(items, sortKey)].sort((a, b) => compare(a[1], b[1])).map(([item]) => item)\n}\n","export type MapFilter<T, U> = (item: T) => U | null | undefined\n\nexport function* filterMap<T, U>(items: T[], map: MapFilter<T, U>): Iterable<U> {\n  for (const item of items) {\n    const value = map(item)\n    if (value != null) {\n      yield value\n    }\n  }\n}\n","// Example\n// ```js\n//     fuzzyScore(\"foo.html\", \"foo\")\n//     // => 0.6458333333333334\n// ```\n//\n// ```js\n//     // Compute re once\n//     re = fuzzyRegexp(\"foo\")\n//     fuzzyScore(\"foo.html\", re)\n//     fuzzyScore(\"bar.html\", re)\n//     // => 0.6458333333333334\n// ```\n//\n// Returns a number between 0 and 1. 0 being the worst match and 1\n// being an exact match.\n// You can change the `prefixBonusWeight` variable to alter ordering.\n// Currently fuzzy search for the labels picker uses a weaker prefix bonus to weight heavier full word matches.\nexport function fuzzyScore(string: string, query: string, prefixBonusWeight = 0.1): number {\n  let score = stringScore(string, query, prefixBonusWeight)\n  if (score && query.indexOf('/') === -1) {\n    const basename = string.substring(string.lastIndexOf('/') + 1)\n    score += stringScore(basename, query, prefixBonusWeight)\n  }\n  return score\n}\n\n// Create a regexp that can be used to fuzzy match a given string. Any\n// special regexp characters in the input string will be escaped\n// correctly.\n//\n// A query of \"bar\" becomes /(.*)(b)([^a]*?)(a)([^r]*?)(r)(.*?)/.\n//\n// /\n//  (.*)     whatever's before the first b\n//  (b)      grab the first b of bar\n//  ([^a]*?) take everything up to the a of bar\n//  (a)      take the a of bar\n//  ([^r]*?) take everything up to the r of bar\n//  (r)      take the r of bar\n//  (.*?)    take the rest of the string\n// /\nexport function fuzzyRegexp(query: string): RegExp {\n  const chars = query.toLowerCase().split('')\n\n  let regex = ''\n\n  let firstChar = true\n  for (const char of chars) {\n    // must escape these chars so we match literals\n    const c = char.replace(/[\\\\^$*+?.()|[\\]{}]/g, '\\\\$&')\n    if (firstChar) {\n      // for the first we want to greedily match anything, which pushes\n      // the first match as late as possible in the string\n      regex += `(.*)(${c})`\n      firstChar = false\n    } else {\n      regex += `([^${c}]*?)(${c})`\n    }\n  }\n  return new RegExp(`${regex}(.*?)$`, 'i')\n}\n\nexport function fuzzyHighlightElement(content: Element, text?: string, textRe?: RegExp): void {\n  if (text) {\n    const matches = content.innerHTML.trim().match(textRe || fuzzyRegexp(text))\n    if (!matches) return\n\n    let open = false\n    const html = []\n    for (let i = 1; i < matches.length; ++i) {\n      const m = matches[i]\n      if (!m) continue\n\n      if (i % 2 === 0) {\n        if (!open) {\n          // eslint-disable-next-line github/unescaped-html-literal\n          html.push('<mark>')\n          open = true\n        }\n      } else if (open) {\n        html.push('</mark>')\n        open = false\n      }\n      html.push(m)\n    }\n    content.innerHTML = html.join('')\n  } else {\n    const html = content.innerHTML.trim()\n    const clean = html.replace(/<\\/?mark>/g, '')\n    if (html !== clean) {\n      content.innerHTML = clean\n    }\n  }\n}\n\nconst wordSeparators = new Set([' ', '-', '_'])\n\n// string_score.js: Quicksilver-like string scoring algorithm.\n//  https://raw.github.com/joshaven/string_score/master/coffee/string_score.coffee\n//\n// Copyright (C) 2009-2011 Joshaven Potter <yourtech@gmail.com>\n// Copyright (C) 2010-2011 Yesudeep Mangalapilly <yesudeep@gmail.com>\n// MIT license: http://www.opensource.org/licenses/mit-license.php\n//\n// A string score implementation.\nfunction stringScore(originalString: string, abbreviation: string, prefixBonusWeight = 0.1): number {\n  let string = originalString\n  if (string === abbreviation) {\n    return 1.0\n  }\n  const stringLength = string.length\n  let totalCharacterScore = 0.0\n  let shouldAwardCommonPrefixBonus = 0\n  let firstChar = true\n  for (const char of abbreviation) {\n    const indexCLowercase = string.indexOf(char.toLowerCase())\n    const indexCUppercase = string.indexOf(char.toUpperCase())\n    const minIndex = Math.min(indexCLowercase, indexCUppercase)\n    const indexInString = minIndex > -1 ? minIndex : Math.max(indexCLowercase, indexCUppercase)\n    if (indexInString === -1) {\n      return 0.0\n    }\n    totalCharacterScore += 0.1\n    if (string[indexInString] === char) {\n      totalCharacterScore += 0.1\n    }\n    if (indexInString === 0) {\n      totalCharacterScore += 0.9 - prefixBonusWeight\n      if (firstChar) {\n        shouldAwardCommonPrefixBonus = 1\n      }\n    }\n    if (wordSeparators.has(string.charAt(indexInString - 1))) {\n      totalCharacterScore += 0.9 - prefixBonusWeight\n    }\n    string = string.substring(indexInString + 1, stringLength)\n    firstChar = false\n  }\n  const abbreviationLength = abbreviation.length\n  const abbreviationScore = totalCharacterScore / abbreviationLength\n  let finalScore = (abbreviationScore * (abbreviationLength / stringLength) + abbreviationScore) / 2\n  if (shouldAwardCommonPrefixBonus && finalScore + prefixBonusWeight < 1) {\n    finalScore += prefixBonusWeight\n  }\n  return finalScore\n}\n\nexport type TextScore = {score: number; text: string}\nexport function compare(a: TextScore, b: TextScore): -1 | 0 | 1 {\n  if (a.score > b.score) {\n    return -1\n  } else if (a.score < b.score) {\n    return 1\n  } else if (a.text < b.text) {\n    return -1\n  } else if (a.text > b.text) {\n    return 1\n  } else {\n    return 0\n  }\n}\n","// Due to the way `visible` is implemented, it causes the browser to\n// perform a full page reflow, it lays out all elements again, when called. This\n// is one of the most time consuming operations the browser can perform, so it\n// affects perceived page load times.\n//\n// The preferred way to determine element visibility is check for the presence\n// of the `hidden` attribute: `if (el.hidden) ...` and `el.hidden = false`.\n//\n// More info: https://github.com/github/eslint-plugin-github/blob/master/docs/rules/no-d-none.md.\n//\n// We would ideally like to remove the `visible` function and consistently\n// use the `hidden` attribute.\n//\n// Returns true if the element is hidden.\nfunction hidden(element: HTMLElement): boolean {\n  return element.offsetWidth <= 0 && element.offsetHeight <= 0\n}\n\nexport default function visible(element: HTMLElement): boolean {\n  return !hidden(element)\n}\n"],"names":["parseBlobRange","str","lines","match","length","offset","parseBlobOffset","Object","freeze","start","end","startOffset","endOffset","ascendingBlobRange","formatBlobRange","blobRange","column","line","parseFileAnchor","anchorPrefix","parseAnchorPrefix","formatBlobRangeAnchor","lineMatch","columnMatch","parseInt","DOMRangeFromBlob","getLineElement","startContainer","_startOffset","findRangeOffset","endContainer","_endOffset","childNodes","ownerDocument","range","createRange","setStart","setEnd","lookAhead","error","lineElement","textNodes","getAllTextNodes","el","nodeType","Node","TEXT_NODE","list","node","concat","i","textNode","nextC","textContent","nextTextNode","offsets","sort","compareBlobOffsets","a","b","FEATURE_WEIGHTS","frequency","recency","scorer","pageViews","frequencies","frequencyMap","totalVisits","values","reduce","total","view","visitCount","Map","keys","map","pageKey","recencies","recencyMap","items","recencyList","key","lastVisitedAt","totalUniqueVisits","index","get","TEAM_PAGE_REGEX","REPOSITORY_PAGE_REGEXES","PROJECT_PAGE_REGEXES","logPageView","path","projectPageMatch","repositoryPageMatch","teamPageMatch","logPageViewByKey","buildTeamKey","len","ownerType","projectRegex","ownerSlug","number","buildProjectKey","buildRepositoryKey","views","getPageViewsMap","now","Math","floor","Date","hit","setPageViewsMap","limitedPageViews","scorePage","fromEntries","ranked","slice","MAX_PAGE_VIEWS_TO_STORE_IN_LOCAL_STORAGE","organizationLogin","teamSlug","ownerLogin","name","PAGE_VIEW_KEY_REGEX","VIEWS_KEY","setItem","value","window","localStorage","JSON","stringify","json","rawData","getItem","parse","pageViewMap","filterSort","compare","filterMap","item","fuzzyScore","string","query","prefixBonusWeight","score","stringScore","indexOf","substring","lastIndexOf","fuzzyHighlightElement","content","text","textRe","matches","innerHTML","trim","fuzzyRegexp","chars","toLowerCase","split","regex","firstChar","char","c","replace","open","html","m","push","join","clean","wordSeparators","Set","originalString","abbreviation","stringLength","totalCharacterScore","shouldAwardCommonPrefixBonus","indexCLowercase","indexCUppercase","toUpperCase","minIndex","min","indexInString","max","has","charAt","abbreviationLength","abbreviationScore","finalScore","visible","element","offsetWidth","offsetHeight"],"sourceRoot":""}