# typed: false

# DO NOT EDIT MANUALLY
# This is an autogenerated file for types exported from the `aqueduct-client` gem.
# Please instead update this file by running `bin/tapioca gem aqueduct-client`.

# source://aqueduct-client//lib/aqueduct/version.rb#1
module Aqueduct
  class << self
    # source://aqueduct-client//lib/aqueduct.rb#35
    def app; end

    # source://aqueduct-client//lib/aqueduct.rb#31
    def app=(app); end

    # source://aqueduct-client//lib/aqueduct.rb#51
    def client_id; end

    # source://aqueduct-client//lib/aqueduct.rb#47
    def client_id=(client_id); end

    # @yield [_self]
    # @yieldparam _self [Aqueduct] the object that the method was called on
    #
    # source://aqueduct-client//lib/aqueduct.rb#19
    def configure; end

    # source://aqueduct-client//lib/aqueduct.rb#43
    def hostname; end

    # source://aqueduct-client//lib/aqueduct.rb#39
    def hostname=(hostname); end

    # source://aqueduct-client//lib/aqueduct.rb#61
    def site; end

    # source://aqueduct-client//lib/aqueduct.rb#57
    def site=(site); end

    # source://aqueduct-client//lib/aqueduct.rb#73
    def site_from_metadata; end

    # source://aqueduct-client//lib/aqueduct.rb#69
    def tags; end

    # source://aqueduct-client//lib/aqueduct.rb#65
    def tags=(tags); end

    # source://aqueduct-client//lib/aqueduct.rb#27
    def url; end

    # source://aqueduct-client//lib/aqueduct.rb#23
    def url=(url); end
  end
end

# source://aqueduct-client//lib/aqueduct/api/v1/api_pb.rb#388
module Aqueduct::Api; end

# source://aqueduct-client//lib/aqueduct/api/v1/api_pb.rb#389
module Aqueduct::Api::V1; end

class Aqueduct::Api::V1::AckRequest
  include ::Google::Protobuf::MessageExts
  extend ::Google::Protobuf::MessageExts::ClassMethods

  def initialize(*_arg0); end

  def ==(_arg0); end
  def [](_arg0); end
  def []=(_arg0, _arg1); end
  def clone; end
  def dup; end
  def eql?(_arg0); end
  def hash; end
  def inspect; end
  def method_missing(*_arg0); end
  def to_h; end
  def to_s; end

  private

  def respond_to_missing?(*_arg0); end

  class << self
    def decode(_arg0); end
    def decode_json(*_arg0); end
    def descriptor; end
    def encode(_arg0); end
    def encode_json(*_arg0); end
  end
end

module Aqueduct::Api::V1::AckRequest::Status
  class << self
    def descriptor; end
    def lookup(_arg0); end
    def resolve(_arg0); end
  end
end

# source://aqueduct-client//lib/aqueduct/api/v1/api_pb.rb#400
Aqueduct::Api::V1::AckRequest::Status::FAILURE = T.let(T.unsafe(nil), Integer)

# source://aqueduct-client//lib/aqueduct/api/v1/api_pb.rb#400
Aqueduct::Api::V1::AckRequest::Status::NO_STATUS = T.let(T.unsafe(nil), Integer)

# source://aqueduct-client//lib/aqueduct/api/v1/api_pb.rb#400
Aqueduct::Api::V1::AckRequest::Status::SUCCESS = T.let(T.unsafe(nil), Integer)

class Aqueduct::Api::V1::AckResponse
  include ::Google::Protobuf::MessageExts
  extend ::Google::Protobuf::MessageExts::ClassMethods

  def initialize(*_arg0); end

  def ==(_arg0); end
  def [](_arg0); end
  def []=(_arg0, _arg1); end
  def clone; end
  def dup; end
  def eql?(_arg0); end
  def hash; end
  def inspect; end
  def method_missing(*_arg0); end
  def to_h; end
  def to_s; end

  private

  def respond_to_missing?(*_arg0); end

  class << self
    def decode(_arg0); end
    def decode_json(*_arg0); end
    def descriptor; end
    def encode(_arg0); end
    def encode_json(*_arg0); end
  end
end

class Aqueduct::Api::V1::AddInactiveQueueRequest
  include ::Google::Protobuf::MessageExts
  extend ::Google::Protobuf::MessageExts::ClassMethods

  def initialize(*_arg0); end

  def ==(_arg0); end
  def [](_arg0); end
  def []=(_arg0, _arg1); end
  def clone; end
  def dup; end
  def eql?(_arg0); end
  def hash; end
  def inspect; end
  def method_missing(*_arg0); end
  def to_h; end
  def to_s; end

  private

  def respond_to_missing?(*_arg0); end

  class << self
    def decode(_arg0); end
    def decode_json(*_arg0); end
    def descriptor; end
    def encode(_arg0); end
    def encode_json(*_arg0); end
  end
end

class Aqueduct::Api::V1::AddInactiveQueueResponse
  include ::Google::Protobuf::MessageExts
  extend ::Google::Protobuf::MessageExts::ClassMethods

  def initialize(*_arg0); end

  def ==(_arg0); end
  def [](_arg0); end
  def []=(_arg0, _arg1); end
  def clone; end
  def dup; end
  def eql?(_arg0); end
  def hash; end
  def inspect; end
  def method_missing(*_arg0); end
  def to_h; end
  def to_s; end

  private

  def respond_to_missing?(*_arg0); end

  class << self
    def decode(_arg0); end
    def decode_json(*_arg0); end
    def descriptor; end
    def encode(_arg0); end
    def encode_json(*_arg0); end
  end
end

class Aqueduct::Api::V1::AddPausingRuleRequest
  include ::Google::Protobuf::MessageExts
  extend ::Google::Protobuf::MessageExts::ClassMethods

  def initialize(*_arg0); end

  def ==(_arg0); end
  def [](_arg0); end
  def []=(_arg0, _arg1); end
  def clone; end
  def dup; end
  def eql?(_arg0); end
  def hash; end
  def inspect; end
  def method_missing(*_arg0); end
  def to_h; end
  def to_s; end

  private

  def respond_to_missing?(*_arg0); end

  class << self
    def decode(_arg0); end
    def decode_json(*_arg0); end
    def descriptor; end
    def encode(_arg0); end
    def encode_json(*_arg0); end
  end
end

class Aqueduct::Api::V1::AddPausingRuleResponse
  include ::Google::Protobuf::MessageExts
  extend ::Google::Protobuf::MessageExts::ClassMethods

  def initialize(*_arg0); end

  def ==(_arg0); end
  def [](_arg0); end
  def []=(_arg0, _arg1); end
  def clone; end
  def dup; end
  def eql?(_arg0); end
  def hash; end
  def inspect; end
  def method_missing(*_arg0); end
  def to_h; end
  def to_s; end

  private

  def respond_to_missing?(*_arg0); end

  class << self
    def decode(_arg0); end
    def decode_json(*_arg0); end
    def descriptor; end
    def encode(_arg0); end
    def encode_json(*_arg0); end
  end
end

class Aqueduct::Api::V1::AddWorkerLimitRequest
  include ::Google::Protobuf::MessageExts
  extend ::Google::Protobuf::MessageExts::ClassMethods

  def initialize(*_arg0); end

  def ==(_arg0); end
  def [](_arg0); end
  def []=(_arg0, _arg1); end
  def clone; end
  def dup; end
  def eql?(_arg0); end
  def hash; end
  def inspect; end
  def method_missing(*_arg0); end
  def to_h; end
  def to_s; end

  private

  def respond_to_missing?(*_arg0); end

  class << self
    def decode(_arg0); end
    def decode_json(*_arg0); end
    def descriptor; end
    def encode(_arg0); end
    def encode_json(*_arg0); end
  end
end

# source://aqueduct-client//lib/aqueduct/api/v1/api_twirp.rb#62
class Aqueduct::Api::V1::AdminServiceClient < ::Twirp::Client
  # source://twirp/1.10.0/lib/twirp/client.rb#42
  def add_inactive_queue(input, req_opts = T.unsafe(nil)); end

  # source://twirp/1.10.0/lib/twirp/client.rb#42
  def describe_queues(input, req_opts = T.unsafe(nil)); end

  # source://twirp/1.10.0/lib/twirp/client.rb#42
  def disable_auth_enforcement(input, req_opts = T.unsafe(nil)); end

  # source://twirp/1.10.0/lib/twirp/client.rb#42
  def disable_high_throughput(input, req_opts = T.unsafe(nil)); end

  # source://twirp/1.10.0/lib/twirp/client.rb#42
  def disable_high_throughput_tag(input, req_opts = T.unsafe(nil)); end

  # source://twirp/1.10.0/lib/twirp/client.rb#42
  def disable_scheduling(input, req_opts = T.unsafe(nil)); end

  # source://twirp/1.10.0/lib/twirp/client.rb#42
  def enable_high_throughput(input, req_opts = T.unsafe(nil)); end

  # source://twirp/1.10.0/lib/twirp/client.rb#42
  def enable_high_throughput_tag(input, req_opts = T.unsafe(nil)); end

  # source://twirp/1.10.0/lib/twirp/client.rb#42
  def enable_scheduling(input, req_opts = T.unsafe(nil)); end

  # source://twirp/1.10.0/lib/twirp/client.rb#42
  def enforce_auth(input, req_opts = T.unsafe(nil)); end

  # source://twirp/1.10.0/lib/twirp/client.rb#42
  def high_throughput_enabled(input, req_opts = T.unsafe(nil)); end

  # source://twirp/1.10.0/lib/twirp/client.rb#42
  def high_throughput_tag_enabled(input, req_opts = T.unsafe(nil)); end

  # source://twirp/1.10.0/lib/twirp/client.rb#42
  def inactive_queues(input, req_opts = T.unsafe(nil)); end

  # source://twirp/1.10.0/lib/twirp/client.rb#42
  def remove_inactive_queue(input, req_opts = T.unsafe(nil)); end

  # source://twirp/1.10.0/lib/twirp/client.rb#42
  def scheduling_disabled(input, req_opts = T.unsafe(nil)); end

  # source://twirp/1.10.0/lib/twirp/client.rb#42
  def state_table_counts(input, req_opts = T.unsafe(nil)); end
end

# source://aqueduct-client//lib/aqueduct/api/v1/api_twirp.rb#41
class Aqueduct::Api::V1::AdminServiceService < ::Twirp::Service; end

# source://aqueduct-client//lib/aqueduct/api/v1/api_twirp.rb#75
class Aqueduct::Api::V1::AuthServiceClient < ::Twirp::Client
  # source://twirp/1.10.0/lib/twirp/client.rb#42
  def generate_api_key(input, req_opts = T.unsafe(nil)); end

  # source://twirp/1.10.0/lib/twirp/client.rb#42
  def get_api_key(input, req_opts = T.unsafe(nil)); end

  # source://twirp/1.10.0/lib/twirp/client.rb#42
  def revoke_api_key(input, req_opts = T.unsafe(nil)); end

  # source://twirp/1.10.0/lib/twirp/client.rb#42
  def test(input, req_opts = T.unsafe(nil)); end
end

# source://aqueduct-client//lib/aqueduct/api/v1/api_twirp.rb#66
class Aqueduct::Api::V1::AuthServiceService < ::Twirp::Service; end

class Aqueduct::Api::V1::AuthTestRequest
  include ::Google::Protobuf::MessageExts
  extend ::Google::Protobuf::MessageExts::ClassMethods

  def initialize(*_arg0); end

  def ==(_arg0); end
  def [](_arg0); end
  def []=(_arg0, _arg1); end
  def clone; end
  def dup; end
  def eql?(_arg0); end
  def hash; end
  def inspect; end
  def method_missing(*_arg0); end
  def to_h; end
  def to_s; end

  private

  def respond_to_missing?(*_arg0); end

  class << self
    def decode(_arg0); end
    def decode_json(*_arg0); end
    def descriptor; end
    def encode(_arg0); end
    def encode_json(*_arg0); end
  end
end

class Aqueduct::Api::V1::BackendIdsRequest
  include ::Google::Protobuf::MessageExts
  extend ::Google::Protobuf::MessageExts::ClassMethods

  def initialize(*_arg0); end

  def ==(_arg0); end
  def [](_arg0); end
  def []=(_arg0, _arg1); end
  def clone; end
  def dup; end
  def eql?(_arg0); end
  def hash; end
  def inspect; end
  def method_missing(*_arg0); end
  def to_h; end
  def to_s; end

  private

  def respond_to_missing?(*_arg0); end

  class << self
    def decode(_arg0); end
    def decode_json(*_arg0); end
    def descriptor; end
    def encode(_arg0); end
    def encode_json(*_arg0); end
  end
end

class Aqueduct::Api::V1::BackendIdsRequest::Client
  include ::Google::Protobuf::MessageExts
  extend ::Google::Protobuf::MessageExts::ClassMethods

  def initialize(*_arg0); end

  def ==(_arg0); end
  def [](_arg0); end
  def []=(_arg0, _arg1); end
  def clone; end
  def dup; end
  def eql?(_arg0); end
  def hash; end
  def inspect; end
  def method_missing(*_arg0); end
  def to_h; end
  def to_s; end

  private

  def respond_to_missing?(*_arg0); end

  class << self
    def decode(_arg0); end
    def decode_json(*_arg0); end
    def descriptor; end
    def encode(_arg0); end
    def encode_json(*_arg0); end
  end
end

class Aqueduct::Api::V1::BackendIdsResponse
  include ::Google::Protobuf::MessageExts
  extend ::Google::Protobuf::MessageExts::ClassMethods

  def initialize(*_arg0); end

  def ==(_arg0); end
  def [](_arg0); end
  def []=(_arg0, _arg1); end
  def clone; end
  def dup; end
  def eql?(_arg0); end
  def hash; end
  def inspect; end
  def method_missing(*_arg0); end
  def to_h; end
  def to_s; end

  private

  def respond_to_missing?(*_arg0); end

  class << self
    def decode(_arg0); end
    def decode_json(*_arg0); end
    def descriptor; end
    def encode(_arg0); end
    def encode_json(*_arg0); end
  end
end

class Aqueduct::Api::V1::BatchMessageResponse
  include ::Google::Protobuf::MessageExts
  extend ::Google::Protobuf::MessageExts::ClassMethods

  def initialize(*_arg0); end

  def ==(_arg0); end
  def [](_arg0); end
  def []=(_arg0, _arg1); end
  def clone; end
  def dup; end
  def eql?(_arg0); end
  def hash; end
  def inspect; end
  def method_missing(*_arg0); end
  def to_h; end
  def to_s; end

  private

  def respond_to_missing?(*_arg0); end

  class << self
    def decode(_arg0); end
    def decode_json(*_arg0); end
    def descriptor; end
    def encode(_arg0); end
    def encode_json(*_arg0); end
  end
end

class Aqueduct::Api::V1::DescribeQueuesRequest
  include ::Google::Protobuf::MessageExts
  extend ::Google::Protobuf::MessageExts::ClassMethods

  def initialize(*_arg0); end

  def ==(_arg0); end
  def [](_arg0); end
  def []=(_arg0, _arg1); end
  def clone; end
  def dup; end
  def eql?(_arg0); end
  def hash; end
  def inspect; end
  def method_missing(*_arg0); end
  def to_h; end
  def to_s; end

  private

  def respond_to_missing?(*_arg0); end

  class << self
    def decode(_arg0); end
    def decode_json(*_arg0); end
    def descriptor; end
    def encode(_arg0); end
    def encode_json(*_arg0); end
  end
end

class Aqueduct::Api::V1::DescribeQueuesResponse
  include ::Google::Protobuf::MessageExts
  extend ::Google::Protobuf::MessageExts::ClassMethods

  def initialize(*_arg0); end

  def ==(_arg0); end
  def [](_arg0); end
  def []=(_arg0, _arg1); end
  def clone; end
  def dup; end
  def eql?(_arg0); end
  def hash; end
  def inspect; end
  def method_missing(*_arg0); end
  def to_h; end
  def to_s; end

  private

  def respond_to_missing?(*_arg0); end

  class << self
    def decode(_arg0); end
    def decode_json(*_arg0); end
    def descriptor; end
    def encode(_arg0); end
    def encode_json(*_arg0); end
  end
end

class Aqueduct::Api::V1::DescribeQueuesResponse::ClusterQueueInfo
  include ::Google::Protobuf::MessageExts
  extend ::Google::Protobuf::MessageExts::ClassMethods

  def initialize(*_arg0); end

  def ==(_arg0); end
  def [](_arg0); end
  def []=(_arg0, _arg1); end
  def clone; end
  def dup; end
  def eql?(_arg0); end
  def hash; end
  def inspect; end
  def method_missing(*_arg0); end
  def to_h; end
  def to_s; end

  private

  def respond_to_missing?(*_arg0); end

  class << self
    def decode(_arg0); end
    def decode_json(*_arg0); end
    def descriptor; end
    def encode(_arg0); end
    def encode_json(*_arg0); end
  end
end

class Aqueduct::Api::V1::DescribeQueuesResponse::QueueInfo
  include ::Google::Protobuf::MessageExts
  extend ::Google::Protobuf::MessageExts::ClassMethods

  def initialize(*_arg0); end

  def ==(_arg0); end
  def [](_arg0); end
  def []=(_arg0, _arg1); end
  def clone; end
  def dup; end
  def eql?(_arg0); end
  def hash; end
  def inspect; end
  def method_missing(*_arg0); end
  def to_h; end
  def to_s; end

  private

  def respond_to_missing?(*_arg0); end

  class << self
    def decode(_arg0); end
    def decode_json(*_arg0); end
    def descriptor; end
    def encode(_arg0); end
    def encode_json(*_arg0); end
  end
end

class Aqueduct::Api::V1::DisableAuthEnforcementRequest
  include ::Google::Protobuf::MessageExts
  extend ::Google::Protobuf::MessageExts::ClassMethods

  def initialize(*_arg0); end

  def ==(_arg0); end
  def [](_arg0); end
  def []=(_arg0, _arg1); end
  def clone; end
  def dup; end
  def eql?(_arg0); end
  def hash; end
  def inspect; end
  def method_missing(*_arg0); end
  def to_h; end
  def to_s; end

  private

  def respond_to_missing?(*_arg0); end

  class << self
    def decode(_arg0); end
    def decode_json(*_arg0); end
    def descriptor; end
    def encode(_arg0); end
    def encode_json(*_arg0); end
  end
end

class Aqueduct::Api::V1::DisableHighThroughputRequest
  include ::Google::Protobuf::MessageExts
  extend ::Google::Protobuf::MessageExts::ClassMethods

  def initialize(*_arg0); end

  def ==(_arg0); end
  def [](_arg0); end
  def []=(_arg0, _arg1); end
  def clone; end
  def dup; end
  def eql?(_arg0); end
  def hash; end
  def inspect; end
  def method_missing(*_arg0); end
  def to_h; end
  def to_s; end

  private

  def respond_to_missing?(*_arg0); end

  class << self
    def decode(_arg0); end
    def decode_json(*_arg0); end
    def descriptor; end
    def encode(_arg0); end
    def encode_json(*_arg0); end
  end
end

class Aqueduct::Api::V1::DisableHighThroughputTagRequest
  include ::Google::Protobuf::MessageExts
  extend ::Google::Protobuf::MessageExts::ClassMethods

  def initialize(*_arg0); end

  def ==(_arg0); end
  def [](_arg0); end
  def []=(_arg0, _arg1); end
  def clone; end
  def dup; end
  def eql?(_arg0); end
  def hash; end
  def inspect; end
  def method_missing(*_arg0); end
  def to_h; end
  def to_s; end

  private

  def respond_to_missing?(*_arg0); end

  class << self
    def decode(_arg0); end
    def decode_json(*_arg0); end
    def descriptor; end
    def encode(_arg0); end
    def encode_json(*_arg0); end
  end
end

class Aqueduct::Api::V1::DisableSchedulingRequest
  include ::Google::Protobuf::MessageExts
  extend ::Google::Protobuf::MessageExts::ClassMethods

  def initialize(*_arg0); end

  def ==(_arg0); end
  def [](_arg0); end
  def []=(_arg0, _arg1); end
  def clone; end
  def dup; end
  def eql?(_arg0); end
  def hash; end
  def inspect; end
  def method_missing(*_arg0); end
  def to_h; end
  def to_s; end

  private

  def respond_to_missing?(*_arg0); end

  class << self
    def decode(_arg0); end
    def decode_json(*_arg0); end
    def descriptor; end
    def encode(_arg0); end
    def encode_json(*_arg0); end
  end
end

class Aqueduct::Api::V1::DisableThrottlePopRequest
  include ::Google::Protobuf::MessageExts
  extend ::Google::Protobuf::MessageExts::ClassMethods

  def initialize(*_arg0); end

  def ==(_arg0); end
  def [](_arg0); end
  def []=(_arg0, _arg1); end
  def clone; end
  def dup; end
  def eql?(_arg0); end
  def hash; end
  def inspect; end
  def method_missing(*_arg0); end
  def to_h; end
  def to_s; end

  private

  def respond_to_missing?(*_arg0); end

  class << self
    def decode(_arg0); end
    def decode_json(*_arg0); end
    def descriptor; end
    def encode(_arg0); end
    def encode_json(*_arg0); end
  end
end

class Aqueduct::Api::V1::EmptyResponse
  include ::Google::Protobuf::MessageExts
  extend ::Google::Protobuf::MessageExts::ClassMethods

  def initialize(*_arg0); end

  def ==(_arg0); end
  def [](_arg0); end
  def []=(_arg0, _arg1); end
  def clone; end
  def dup; end
  def eql?(_arg0); end
  def hash; end
  def inspect; end
  def method_missing(*_arg0); end
  def to_h; end
  def to_s; end

  private

  def respond_to_missing?(*_arg0); end

  class << self
    def decode(_arg0); end
    def decode_json(*_arg0); end
    def descriptor; end
    def encode(_arg0); end
    def encode_json(*_arg0); end
  end
end

class Aqueduct::Api::V1::EnableHighThroughputRequest
  include ::Google::Protobuf::MessageExts
  extend ::Google::Protobuf::MessageExts::ClassMethods

  def initialize(*_arg0); end

  def ==(_arg0); end
  def [](_arg0); end
  def []=(_arg0, _arg1); end
  def clone; end
  def dup; end
  def eql?(_arg0); end
  def hash; end
  def inspect; end
  def method_missing(*_arg0); end
  def to_h; end
  def to_s; end

  private

  def respond_to_missing?(*_arg0); end

  class << self
    def decode(_arg0); end
    def decode_json(*_arg0); end
    def descriptor; end
    def encode(_arg0); end
    def encode_json(*_arg0); end
  end
end

class Aqueduct::Api::V1::EnableHighThroughputTagRequest
  include ::Google::Protobuf::MessageExts
  extend ::Google::Protobuf::MessageExts::ClassMethods

  def initialize(*_arg0); end

  def ==(_arg0); end
  def [](_arg0); end
  def []=(_arg0, _arg1); end
  def clone; end
  def dup; end
  def eql?(_arg0); end
  def hash; end
  def inspect; end
  def method_missing(*_arg0); end
  def to_h; end
  def to_s; end

  private

  def respond_to_missing?(*_arg0); end

  class << self
    def decode(_arg0); end
    def decode_json(*_arg0); end
    def descriptor; end
    def encode(_arg0); end
    def encode_json(*_arg0); end
  end
end

class Aqueduct::Api::V1::EnableSchedulingRequest
  include ::Google::Protobuf::MessageExts
  extend ::Google::Protobuf::MessageExts::ClassMethods

  def initialize(*_arg0); end

  def ==(_arg0); end
  def [](_arg0); end
  def []=(_arg0, _arg1); end
  def clone; end
  def dup; end
  def eql?(_arg0); end
  def hash; end
  def inspect; end
  def method_missing(*_arg0); end
  def to_h; end
  def to_s; end

  private

  def respond_to_missing?(*_arg0); end

  class << self
    def decode(_arg0); end
    def decode_json(*_arg0); end
    def descriptor; end
    def encode(_arg0); end
    def encode_json(*_arg0); end
  end
end

class Aqueduct::Api::V1::EnableThrottlePopRequest
  include ::Google::Protobuf::MessageExts
  extend ::Google::Protobuf::MessageExts::ClassMethods

  def initialize(*_arg0); end

  def ==(_arg0); end
  def [](_arg0); end
  def []=(_arg0, _arg1); end
  def clone; end
  def dup; end
  def eql?(_arg0); end
  def hash; end
  def inspect; end
  def method_missing(*_arg0); end
  def to_h; end
  def to_s; end

  private

  def respond_to_missing?(*_arg0); end

  class << self
    def decode(_arg0); end
    def decode_json(*_arg0); end
    def descriptor; end
    def encode(_arg0); end
    def encode_json(*_arg0); end
  end
end

class Aqueduct::Api::V1::EnforceAuthRequest
  include ::Google::Protobuf::MessageExts
  extend ::Google::Protobuf::MessageExts::ClassMethods

  def initialize(*_arg0); end

  def ==(_arg0); end
  def [](_arg0); end
  def []=(_arg0, _arg1); end
  def clone; end
  def dup; end
  def eql?(_arg0); end
  def hash; end
  def inspect; end
  def method_missing(*_arg0); end
  def to_h; end
  def to_s; end

  private

  def respond_to_missing?(*_arg0); end

  class << self
    def decode(_arg0); end
    def decode_json(*_arg0); end
    def descriptor; end
    def encode(_arg0); end
    def encode_json(*_arg0); end
  end
end

class Aqueduct::Api::V1::GenerateApiKeyRequest
  include ::Google::Protobuf::MessageExts
  extend ::Google::Protobuf::MessageExts::ClassMethods

  def initialize(*_arg0); end

  def ==(_arg0); end
  def [](_arg0); end
  def []=(_arg0, _arg1); end
  def clone; end
  def dup; end
  def eql?(_arg0); end
  def hash; end
  def inspect; end
  def method_missing(*_arg0); end
  def to_h; end
  def to_s; end

  private

  def respond_to_missing?(*_arg0); end

  class << self
    def decode(_arg0); end
    def decode_json(*_arg0); end
    def descriptor; end
    def encode(_arg0); end
    def encode_json(*_arg0); end
  end
end

class Aqueduct::Api::V1::GenerateApiKeyResponse
  include ::Google::Protobuf::MessageExts
  extend ::Google::Protobuf::MessageExts::ClassMethods

  def initialize(*_arg0); end

  def ==(_arg0); end
  def [](_arg0); end
  def []=(_arg0, _arg1); end
  def clone; end
  def dup; end
  def eql?(_arg0); end
  def hash; end
  def inspect; end
  def method_missing(*_arg0); end
  def to_h; end
  def to_s; end

  private

  def respond_to_missing?(*_arg0); end

  class << self
    def decode(_arg0); end
    def decode_json(*_arg0); end
    def descriptor; end
    def encode(_arg0); end
    def encode_json(*_arg0); end
  end
end

class Aqueduct::Api::V1::GetApiKeyRequest
  include ::Google::Protobuf::MessageExts
  extend ::Google::Protobuf::MessageExts::ClassMethods

  def initialize(*_arg0); end

  def ==(_arg0); end
  def [](_arg0); end
  def []=(_arg0, _arg1); end
  def clone; end
  def dup; end
  def eql?(_arg0); end
  def hash; end
  def inspect; end
  def method_missing(*_arg0); end
  def to_h; end
  def to_s; end

  private

  def respond_to_missing?(*_arg0); end

  class << self
    def decode(_arg0); end
    def decode_json(*_arg0); end
    def descriptor; end
    def encode(_arg0); end
    def encode_json(*_arg0); end
  end
end

class Aqueduct::Api::V1::GetApiKeyResponse
  include ::Google::Protobuf::MessageExts
  extend ::Google::Protobuf::MessageExts::ClassMethods

  def initialize(*_arg0); end

  def ==(_arg0); end
  def [](_arg0); end
  def []=(_arg0, _arg1); end
  def clone; end
  def dup; end
  def eql?(_arg0); end
  def hash; end
  def inspect; end
  def method_missing(*_arg0); end
  def to_h; end
  def to_s; end

  private

  def respond_to_missing?(*_arg0); end

  class << self
    def decode(_arg0); end
    def decode_json(*_arg0); end
    def descriptor; end
    def encode(_arg0); end
    def encode_json(*_arg0); end
  end
end

class Aqueduct::Api::V1::GetEnabledThrottledQueuesRequest
  include ::Google::Protobuf::MessageExts
  extend ::Google::Protobuf::MessageExts::ClassMethods

  def initialize(*_arg0); end

  def ==(_arg0); end
  def [](_arg0); end
  def []=(_arg0, _arg1); end
  def clone; end
  def dup; end
  def eql?(_arg0); end
  def hash; end
  def inspect; end
  def method_missing(*_arg0); end
  def to_h; end
  def to_s; end

  private

  def respond_to_missing?(*_arg0); end

  class << self
    def decode(_arg0); end
    def decode_json(*_arg0); end
    def descriptor; end
    def encode(_arg0); end
    def encode_json(*_arg0); end
  end
end

class Aqueduct::Api::V1::GetEnabledThrottledQueuesResponse
  include ::Google::Protobuf::MessageExts
  extend ::Google::Protobuf::MessageExts::ClassMethods

  def initialize(*_arg0); end

  def ==(_arg0); end
  def [](_arg0); end
  def []=(_arg0, _arg1); end
  def clone; end
  def dup; end
  def eql?(_arg0); end
  def hash; end
  def inspect; end
  def method_missing(*_arg0); end
  def to_h; end
  def to_s; end

  private

  def respond_to_missing?(*_arg0); end

  class << self
    def decode(_arg0); end
    def decode_json(*_arg0); end
    def descriptor; end
    def encode(_arg0); end
    def encode_json(*_arg0); end
  end
end

class Aqueduct::Api::V1::HeartbeatRequest
  include ::Google::Protobuf::MessageExts
  extend ::Google::Protobuf::MessageExts::ClassMethods

  def initialize(*_arg0); end

  def ==(_arg0); end
  def [](_arg0); end
  def []=(_arg0, _arg1); end
  def clone; end
  def dup; end
  def eql?(_arg0); end
  def hash; end
  def inspect; end
  def method_missing(*_arg0); end
  def to_h; end
  def to_s; end

  private

  def respond_to_missing?(*_arg0); end

  class << self
    def decode(_arg0); end
    def decode_json(*_arg0); end
    def descriptor; end
    def encode(_arg0); end
    def encode_json(*_arg0); end
  end
end

class Aqueduct::Api::V1::HeartbeatResponse
  include ::Google::Protobuf::MessageExts
  extend ::Google::Protobuf::MessageExts::ClassMethods

  def initialize(*_arg0); end

  def ==(_arg0); end
  def [](_arg0); end
  def []=(_arg0, _arg1); end
  def clone; end
  def dup; end
  def eql?(_arg0); end
  def hash; end
  def inspect; end
  def method_missing(*_arg0); end
  def to_h; end
  def to_s; end

  private

  def respond_to_missing?(*_arg0); end

  class << self
    def decode(_arg0); end
    def decode_json(*_arg0); end
    def descriptor; end
    def encode(_arg0); end
    def encode_json(*_arg0); end
  end
end

class Aqueduct::Api::V1::HighThroughputEnabledRequest
  include ::Google::Protobuf::MessageExts
  extend ::Google::Protobuf::MessageExts::ClassMethods

  def initialize(*_arg0); end

  def ==(_arg0); end
  def [](_arg0); end
  def []=(_arg0, _arg1); end
  def clone; end
  def dup; end
  def eql?(_arg0); end
  def hash; end
  def inspect; end
  def method_missing(*_arg0); end
  def to_h; end
  def to_s; end

  private

  def respond_to_missing?(*_arg0); end

  class << self
    def decode(_arg0); end
    def decode_json(*_arg0); end
    def descriptor; end
    def encode(_arg0); end
    def encode_json(*_arg0); end
  end
end

class Aqueduct::Api::V1::HighThroughputEnabledResponse
  include ::Google::Protobuf::MessageExts
  extend ::Google::Protobuf::MessageExts::ClassMethods

  def initialize(*_arg0); end

  def ==(_arg0); end
  def [](_arg0); end
  def []=(_arg0, _arg1); end
  def clone; end
  def dup; end
  def eql?(_arg0); end
  def hash; end
  def inspect; end
  def method_missing(*_arg0); end
  def to_h; end
  def to_s; end

  private

  def respond_to_missing?(*_arg0); end

  class << self
    def decode(_arg0); end
    def decode_json(*_arg0); end
    def descriptor; end
    def encode(_arg0); end
    def encode_json(*_arg0); end
  end
end

class Aqueduct::Api::V1::HighThroughputTagEnabledRequest
  include ::Google::Protobuf::MessageExts
  extend ::Google::Protobuf::MessageExts::ClassMethods

  def initialize(*_arg0); end

  def ==(_arg0); end
  def [](_arg0); end
  def []=(_arg0, _arg1); end
  def clone; end
  def dup; end
  def eql?(_arg0); end
  def hash; end
  def inspect; end
  def method_missing(*_arg0); end
  def to_h; end
  def to_s; end

  private

  def respond_to_missing?(*_arg0); end

  class << self
    def decode(_arg0); end
    def decode_json(*_arg0); end
    def descriptor; end
    def encode(_arg0); end
    def encode_json(*_arg0); end
  end
end

class Aqueduct::Api::V1::HighThroughputTagEnabledResponse
  include ::Google::Protobuf::MessageExts
  extend ::Google::Protobuf::MessageExts::ClassMethods

  def initialize(*_arg0); end

  def ==(_arg0); end
  def [](_arg0); end
  def []=(_arg0, _arg1); end
  def clone; end
  def dup; end
  def eql?(_arg0); end
  def hash; end
  def inspect; end
  def method_missing(*_arg0); end
  def to_h; end
  def to_s; end

  private

  def respond_to_missing?(*_arg0); end

  class << self
    def decode(_arg0); end
    def decode_json(*_arg0); end
    def descriptor; end
    def encode(_arg0); end
    def encode_json(*_arg0); end
  end
end

class Aqueduct::Api::V1::InProgressJobsRequest
  include ::Google::Protobuf::MessageExts
  extend ::Google::Protobuf::MessageExts::ClassMethods

  def initialize(*_arg0); end

  def ==(_arg0); end
  def [](_arg0); end
  def []=(_arg0, _arg1); end
  def clone; end
  def dup; end
  def eql?(_arg0); end
  def hash; end
  def inspect; end
  def method_missing(*_arg0); end
  def to_h; end
  def to_s; end

  private

  def respond_to_missing?(*_arg0); end

  class << self
    def decode(_arg0); end
    def decode_json(*_arg0); end
    def descriptor; end
    def encode(_arg0); end
    def encode_json(*_arg0); end
  end
end

class Aqueduct::Api::V1::InProgressJobsResponse
  include ::Google::Protobuf::MessageExts
  extend ::Google::Protobuf::MessageExts::ClassMethods

  def initialize(*_arg0); end

  def ==(_arg0); end
  def [](_arg0); end
  def []=(_arg0, _arg1); end
  def clone; end
  def dup; end
  def eql?(_arg0); end
  def hash; end
  def inspect; end
  def method_missing(*_arg0); end
  def to_h; end
  def to_s; end

  private

  def respond_to_missing?(*_arg0); end

  class << self
    def decode(_arg0); end
    def decode_json(*_arg0); end
    def descriptor; end
    def encode(_arg0); end
    def encode_json(*_arg0); end
  end
end

class Aqueduct::Api::V1::InProgressJobsResponse::Job
  include ::Google::Protobuf::MessageExts
  extend ::Google::Protobuf::MessageExts::ClassMethods

  def initialize(*_arg0); end

  def ==(_arg0); end
  def [](_arg0); end
  def []=(_arg0, _arg1); end
  def clone; end
  def dup; end
  def eql?(_arg0); end
  def hash; end
  def inspect; end
  def method_missing(*_arg0); end
  def to_h; end
  def to_s; end

  private

  def respond_to_missing?(*_arg0); end

  class << self
    def decode(_arg0); end
    def decode_json(*_arg0); end
    def descriptor; end
    def encode(_arg0); end
    def encode_json(*_arg0); end
  end
end

class Aqueduct::Api::V1::InactiveQueuesRequest
  include ::Google::Protobuf::MessageExts
  extend ::Google::Protobuf::MessageExts::ClassMethods

  def initialize(*_arg0); end

  def ==(_arg0); end
  def [](_arg0); end
  def []=(_arg0, _arg1); end
  def clone; end
  def dup; end
  def eql?(_arg0); end
  def hash; end
  def inspect; end
  def method_missing(*_arg0); end
  def to_h; end
  def to_s; end

  private

  def respond_to_missing?(*_arg0); end

  class << self
    def decode(_arg0); end
    def decode_json(*_arg0); end
    def descriptor; end
    def encode(_arg0); end
    def encode_json(*_arg0); end
  end
end

class Aqueduct::Api::V1::InactiveQueuesResponse
  include ::Google::Protobuf::MessageExts
  extend ::Google::Protobuf::MessageExts::ClassMethods

  def initialize(*_arg0); end

  def ==(_arg0); end
  def [](_arg0); end
  def []=(_arg0, _arg1); end
  def clone; end
  def dup; end
  def eql?(_arg0); end
  def hash; end
  def inspect; end
  def method_missing(*_arg0); end
  def to_h; end
  def to_s; end

  private

  def respond_to_missing?(*_arg0); end

  class << self
    def decode(_arg0); end
    def decode_json(*_arg0); end
    def descriptor; end
    def encode(_arg0); end
    def encode_json(*_arg0); end
  end
end

# source://aqueduct-client//lib/aqueduct/api/v1/api_twirp.rb#37
class Aqueduct::Api::V1::JobQueueServiceClient < ::Twirp::Client
  # source://twirp/1.10.0/lib/twirp/client.rb#42
  def ack(input, req_opts = T.unsafe(nil)); end

  # source://twirp/1.10.0/lib/twirp/client.rb#42
  def add_pausing_rule(input, req_opts = T.unsafe(nil)); end

  # source://twirp/1.10.0/lib/twirp/client.rb#42
  def add_worker_limit(input, req_opts = T.unsafe(nil)); end

  # source://twirp/1.10.0/lib/twirp/client.rb#42
  def backend_ids(input, req_opts = T.unsafe(nil)); end

  # source://twirp/1.10.0/lib/twirp/client.rb#42
  def disable_throttle_pop(input, req_opts = T.unsafe(nil)); end

  # source://twirp/1.10.0/lib/twirp/client.rb#42
  def enable_throttle_pop(input, req_opts = T.unsafe(nil)); end

  # source://twirp/1.10.0/lib/twirp/client.rb#42
  def get_enabled_throttled_queues(input, req_opts = T.unsafe(nil)); end

  # source://twirp/1.10.0/lib/twirp/client.rb#42
  def heartbeat(input, req_opts = T.unsafe(nil)); end

  # source://twirp/1.10.0/lib/twirp/client.rb#42
  def in_progress_jobs(input, req_opts = T.unsafe(nil)); end

  # source://twirp/1.10.0/lib/twirp/client.rb#42
  def list_queues(input, req_opts = T.unsafe(nil)); end

  # source://twirp/1.10.0/lib/twirp/client.rb#42
  def pause(input, req_opts = T.unsafe(nil)); end

  # source://twirp/1.10.0/lib/twirp/client.rb#42
  def paused(input, req_opts = T.unsafe(nil)); end

  # source://twirp/1.10.0/lib/twirp/client.rb#42
  def pausing_rules(input, req_opts = T.unsafe(nil)); end

  # source://twirp/1.10.0/lib/twirp/client.rb#42
  def peek(input, req_opts = T.unsafe(nil)); end

  # source://twirp/1.10.0/lib/twirp/client.rb#42
  def queue_depth(input, req_opts = T.unsafe(nil)); end

  # source://twirp/1.10.0/lib/twirp/client.rb#42
  def receive(input, req_opts = T.unsafe(nil)); end

  # source://twirp/1.10.0/lib/twirp/client.rb#42
  def remove_pausing_rule(input, req_opts = T.unsafe(nil)); end

  # source://twirp/1.10.0/lib/twirp/client.rb#42
  def remove_worker_limit(input, req_opts = T.unsafe(nil)); end

  # source://twirp/1.10.0/lib/twirp/client.rb#42
  def resume(input, req_opts = T.unsafe(nil)); end

  # source://twirp/1.10.0/lib/twirp/client.rb#42
  def scheduled(input, req_opts = T.unsafe(nil)); end

  # source://twirp/1.10.0/lib/twirp/client.rb#42
  def scheduled_count(input, req_opts = T.unsafe(nil)); end

  # source://twirp/1.10.0/lib/twirp/client.rb#42
  def send_batch(input, req_opts = T.unsafe(nil)); end

  # source://twirp/1.10.0/lib/twirp/client.rb#42
  def worker_limits(input, req_opts = T.unsafe(nil)); end
end

# source://aqueduct-client//lib/aqueduct/api/v1/api_twirp.rb#8
class Aqueduct::Api::V1::JobQueueServiceService < ::Twirp::Service; end

class Aqueduct::Api::V1::ListQueuesRequest
  include ::Google::Protobuf::MessageExts
  extend ::Google::Protobuf::MessageExts::ClassMethods

  def initialize(*_arg0); end

  def ==(_arg0); end
  def [](_arg0); end
  def []=(_arg0, _arg1); end
  def clone; end
  def dup; end
  def eql?(_arg0); end
  def hash; end
  def inspect; end
  def method_missing(*_arg0); end
  def to_h; end
  def to_s; end

  private

  def respond_to_missing?(*_arg0); end

  class << self
    def decode(_arg0); end
    def decode_json(*_arg0); end
    def descriptor; end
    def encode(_arg0); end
    def encode_json(*_arg0); end
  end
end

class Aqueduct::Api::V1::ListQueuesResponse
  include ::Google::Protobuf::MessageExts
  extend ::Google::Protobuf::MessageExts::ClassMethods

  def initialize(*_arg0); end

  def ==(_arg0); end
  def [](_arg0); end
  def []=(_arg0, _arg1); end
  def clone; end
  def dup; end
  def eql?(_arg0); end
  def hash; end
  def inspect; end
  def method_missing(*_arg0); end
  def to_h; end
  def to_s; end

  private

  def respond_to_missing?(*_arg0); end

  class << self
    def decode(_arg0); end
    def decode_json(*_arg0); end
    def descriptor; end
    def encode(_arg0); end
    def encode_json(*_arg0); end
  end
end

class Aqueduct::Api::V1::PauseRequest
  include ::Google::Protobuf::MessageExts
  extend ::Google::Protobuf::MessageExts::ClassMethods

  def initialize(*_arg0); end

  def ==(_arg0); end
  def [](_arg0); end
  def []=(_arg0, _arg1); end
  def clone; end
  def dup; end
  def eql?(_arg0); end
  def hash; end
  def inspect; end
  def method_missing(*_arg0); end
  def to_h; end
  def to_s; end

  private

  def respond_to_missing?(*_arg0); end

  class << self
    def decode(_arg0); end
    def decode_json(*_arg0); end
    def descriptor; end
    def encode(_arg0); end
    def encode_json(*_arg0); end
  end
end

class Aqueduct::Api::V1::PausedRequest
  include ::Google::Protobuf::MessageExts
  extend ::Google::Protobuf::MessageExts::ClassMethods

  def initialize(*_arg0); end

  def ==(_arg0); end
  def [](_arg0); end
  def []=(_arg0, _arg1); end
  def clone; end
  def dup; end
  def eql?(_arg0); end
  def hash; end
  def inspect; end
  def method_missing(*_arg0); end
  def to_h; end
  def to_s; end

  private

  def respond_to_missing?(*_arg0); end

  class << self
    def decode(_arg0); end
    def decode_json(*_arg0); end
    def descriptor; end
    def encode(_arg0); end
    def encode_json(*_arg0); end
  end
end

class Aqueduct::Api::V1::PausedResponse
  include ::Google::Protobuf::MessageExts
  extend ::Google::Protobuf::MessageExts::ClassMethods

  def initialize(*_arg0); end

  def ==(_arg0); end
  def [](_arg0); end
  def []=(_arg0, _arg1); end
  def clone; end
  def dup; end
  def eql?(_arg0); end
  def hash; end
  def inspect; end
  def method_missing(*_arg0); end
  def to_h; end
  def to_s; end

  private

  def respond_to_missing?(*_arg0); end

  class << self
    def decode(_arg0); end
    def decode_json(*_arg0); end
    def descriptor; end
    def encode(_arg0); end
    def encode_json(*_arg0); end
  end
end

class Aqueduct::Api::V1::PausingRulesRequest
  include ::Google::Protobuf::MessageExts
  extend ::Google::Protobuf::MessageExts::ClassMethods

  def initialize(*_arg0); end

  def ==(_arg0); end
  def [](_arg0); end
  def []=(_arg0, _arg1); end
  def clone; end
  def dup; end
  def eql?(_arg0); end
  def hash; end
  def inspect; end
  def method_missing(*_arg0); end
  def to_h; end
  def to_s; end

  private

  def respond_to_missing?(*_arg0); end

  class << self
    def decode(_arg0); end
    def decode_json(*_arg0); end
    def descriptor; end
    def encode(_arg0); end
    def encode_json(*_arg0); end
  end
end

class Aqueduct::Api::V1::PausingRulesResponse
  include ::Google::Protobuf::MessageExts
  extend ::Google::Protobuf::MessageExts::ClassMethods

  def initialize(*_arg0); end

  def ==(_arg0); end
  def [](_arg0); end
  def []=(_arg0, _arg1); end
  def clone; end
  def dup; end
  def eql?(_arg0); end
  def hash; end
  def inspect; end
  def method_missing(*_arg0); end
  def to_h; end
  def to_s; end

  private

  def respond_to_missing?(*_arg0); end

  class << self
    def decode(_arg0); end
    def decode_json(*_arg0); end
    def descriptor; end
    def encode(_arg0); end
    def encode_json(*_arg0); end
  end
end

class Aqueduct::Api::V1::PausingRulesResponse::Rule
  include ::Google::Protobuf::MessageExts
  extend ::Google::Protobuf::MessageExts::ClassMethods

  def initialize(*_arg0); end

  def ==(_arg0); end
  def [](_arg0); end
  def []=(_arg0, _arg1); end
  def clone; end
  def dup; end
  def eql?(_arg0); end
  def hash; end
  def inspect; end
  def method_missing(*_arg0); end
  def to_h; end
  def to_s; end

  private

  def respond_to_missing?(*_arg0); end

  class << self
    def decode(_arg0); end
    def decode_json(*_arg0); end
    def descriptor; end
    def encode(_arg0); end
    def encode_json(*_arg0); end
  end
end

class Aqueduct::Api::V1::PeekRequest
  include ::Google::Protobuf::MessageExts
  extend ::Google::Protobuf::MessageExts::ClassMethods

  def initialize(*_arg0); end

  def ==(_arg0); end
  def [](_arg0); end
  def []=(_arg0, _arg1); end
  def clone; end
  def dup; end
  def eql?(_arg0); end
  def hash; end
  def inspect; end
  def method_missing(*_arg0); end
  def to_h; end
  def to_s; end

  private

  def respond_to_missing?(*_arg0); end

  class << self
    def decode(_arg0); end
    def decode_json(*_arg0); end
    def descriptor; end
    def encode(_arg0); end
    def encode_json(*_arg0); end
  end
end

class Aqueduct::Api::V1::PeekResponse
  include ::Google::Protobuf::MessageExts
  extend ::Google::Protobuf::MessageExts::ClassMethods

  def initialize(*_arg0); end

  def ==(_arg0); end
  def [](_arg0); end
  def []=(_arg0, _arg1); end
  def clone; end
  def dup; end
  def eql?(_arg0); end
  def hash; end
  def inspect; end
  def method_missing(*_arg0); end
  def to_h; end
  def to_s; end

  private

  def respond_to_missing?(*_arg0); end

  class << self
    def decode(_arg0); end
    def decode_json(*_arg0); end
    def descriptor; end
    def encode(_arg0); end
    def encode_json(*_arg0); end
  end
end

class Aqueduct::Api::V1::PopRate
  include ::Google::Protobuf::MessageExts
  extend ::Google::Protobuf::MessageExts::ClassMethods

  def initialize(*_arg0); end

  def ==(_arg0); end
  def [](_arg0); end
  def []=(_arg0, _arg1); end
  def clone; end
  def dup; end
  def eql?(_arg0); end
  def hash; end
  def inspect; end
  def method_missing(*_arg0); end
  def to_h; end
  def to_s; end

  private

  def respond_to_missing?(*_arg0); end

  class << self
    def decode(_arg0); end
    def decode_json(*_arg0); end
    def descriptor; end
    def encode(_arg0); end
    def encode_json(*_arg0); end
  end
end

class Aqueduct::Api::V1::Queue
  include ::Google::Protobuf::MessageExts
  extend ::Google::Protobuf::MessageExts::ClassMethods

  def initialize(*_arg0); end

  def ==(_arg0); end
  def [](_arg0); end
  def []=(_arg0, _arg1); end
  def clone; end
  def dup; end
  def eql?(_arg0); end
  def hash; end
  def inspect; end
  def method_missing(*_arg0); end
  def to_h; end
  def to_s; end

  private

  def respond_to_missing?(*_arg0); end

  class << self
    def decode(_arg0); end
    def decode_json(*_arg0); end
    def descriptor; end
    def encode(_arg0); end
    def encode_json(*_arg0); end
  end
end

class Aqueduct::Api::V1::QueueDepthRequest
  include ::Google::Protobuf::MessageExts
  extend ::Google::Protobuf::MessageExts::ClassMethods

  def initialize(*_arg0); end

  def ==(_arg0); end
  def [](_arg0); end
  def []=(_arg0, _arg1); end
  def clone; end
  def dup; end
  def eql?(_arg0); end
  def hash; end
  def inspect; end
  def method_missing(*_arg0); end
  def to_h; end
  def to_s; end

  private

  def respond_to_missing?(*_arg0); end

  class << self
    def decode(_arg0); end
    def decode_json(*_arg0); end
    def descriptor; end
    def encode(_arg0); end
    def encode_json(*_arg0); end
  end
end

class Aqueduct::Api::V1::QueueDepthResponse
  include ::Google::Protobuf::MessageExts
  extend ::Google::Protobuf::MessageExts::ClassMethods

  def initialize(*_arg0); end

  def ==(_arg0); end
  def [](_arg0); end
  def []=(_arg0, _arg1); end
  def clone; end
  def dup; end
  def eql?(_arg0); end
  def hash; end
  def inspect; end
  def method_missing(*_arg0); end
  def to_h; end
  def to_s; end

  private

  def respond_to_missing?(*_arg0); end

  class << self
    def decode(_arg0); end
    def decode_json(*_arg0); end
    def descriptor; end
    def encode(_arg0); end
    def encode_json(*_arg0); end
  end
end

class Aqueduct::Api::V1::ReceiveRequest
  include ::Google::Protobuf::MessageExts
  extend ::Google::Protobuf::MessageExts::ClassMethods

  def initialize(*_arg0); end

  def ==(_arg0); end
  def [](_arg0); end
  def []=(_arg0, _arg1); end
  def clone; end
  def dup; end
  def eql?(_arg0); end
  def hash; end
  def inspect; end
  def method_missing(*_arg0); end
  def to_h; end
  def to_s; end

  private

  def respond_to_missing?(*_arg0); end

  class << self
    def decode(_arg0); end
    def decode_json(*_arg0); end
    def descriptor; end
    def encode(_arg0); end
    def encode_json(*_arg0); end
  end
end

class Aqueduct::Api::V1::ReceiveResponse
  include ::Google::Protobuf::MessageExts
  extend ::Google::Protobuf::MessageExts::ClassMethods

  def initialize(*_arg0); end

  def ==(_arg0); end
  def [](_arg0); end
  def []=(_arg0, _arg1); end
  def clone; end
  def dup; end
  def eql?(_arg0); end
  def hash; end
  def inspect; end
  def method_missing(*_arg0); end
  def to_h; end
  def to_s; end

  private

  def respond_to_missing?(*_arg0); end

  class << self
    def decode(_arg0); end
    def decode_json(*_arg0); end
    def descriptor; end
    def encode(_arg0); end
    def encode_json(*_arg0); end
  end
end

class Aqueduct::Api::V1::RemoveInactiveQueueRequest
  include ::Google::Protobuf::MessageExts
  extend ::Google::Protobuf::MessageExts::ClassMethods

  def initialize(*_arg0); end

  def ==(_arg0); end
  def [](_arg0); end
  def []=(_arg0, _arg1); end
  def clone; end
  def dup; end
  def eql?(_arg0); end
  def hash; end
  def inspect; end
  def method_missing(*_arg0); end
  def to_h; end
  def to_s; end

  private

  def respond_to_missing?(*_arg0); end

  class << self
    def decode(_arg0); end
    def decode_json(*_arg0); end
    def descriptor; end
    def encode(_arg0); end
    def encode_json(*_arg0); end
  end
end

class Aqueduct::Api::V1::RemoveInactiveQueueResponse
  include ::Google::Protobuf::MessageExts
  extend ::Google::Protobuf::MessageExts::ClassMethods

  def initialize(*_arg0); end

  def ==(_arg0); end
  def [](_arg0); end
  def []=(_arg0, _arg1); end
  def clone; end
  def dup; end
  def eql?(_arg0); end
  def hash; end
  def inspect; end
  def method_missing(*_arg0); end
  def to_h; end
  def to_s; end

  private

  def respond_to_missing?(*_arg0); end

  class << self
    def decode(_arg0); end
    def decode_json(*_arg0); end
    def descriptor; end
    def encode(_arg0); end
    def encode_json(*_arg0); end
  end
end

class Aqueduct::Api::V1::RemovePausingRuleRequest
  include ::Google::Protobuf::MessageExts
  extend ::Google::Protobuf::MessageExts::ClassMethods

  def initialize(*_arg0); end

  def ==(_arg0); end
  def [](_arg0); end
  def []=(_arg0, _arg1); end
  def clone; end
  def dup; end
  def eql?(_arg0); end
  def hash; end
  def inspect; end
  def method_missing(*_arg0); end
  def to_h; end
  def to_s; end

  private

  def respond_to_missing?(*_arg0); end

  class << self
    def decode(_arg0); end
    def decode_json(*_arg0); end
    def descriptor; end
    def encode(_arg0); end
    def encode_json(*_arg0); end
  end
end

class Aqueduct::Api::V1::RemovePausingRuleResponse
  include ::Google::Protobuf::MessageExts
  extend ::Google::Protobuf::MessageExts::ClassMethods

  def initialize(*_arg0); end

  def ==(_arg0); end
  def [](_arg0); end
  def []=(_arg0, _arg1); end
  def clone; end
  def dup; end
  def eql?(_arg0); end
  def hash; end
  def inspect; end
  def method_missing(*_arg0); end
  def to_h; end
  def to_s; end

  private

  def respond_to_missing?(*_arg0); end

  class << self
    def decode(_arg0); end
    def decode_json(*_arg0); end
    def descriptor; end
    def encode(_arg0); end
    def encode_json(*_arg0); end
  end
end

class Aqueduct::Api::V1::RemoveWorkerLimitRequest
  include ::Google::Protobuf::MessageExts
  extend ::Google::Protobuf::MessageExts::ClassMethods

  def initialize(*_arg0); end

  def ==(_arg0); end
  def [](_arg0); end
  def []=(_arg0, _arg1); end
  def clone; end
  def dup; end
  def eql?(_arg0); end
  def hash; end
  def inspect; end
  def method_missing(*_arg0); end
  def to_h; end
  def to_s; end

  private

  def respond_to_missing?(*_arg0); end

  class << self
    def decode(_arg0); end
    def decode_json(*_arg0); end
    def descriptor; end
    def encode(_arg0); end
    def encode_json(*_arg0); end
  end
end

class Aqueduct::Api::V1::ResumeRequest
  include ::Google::Protobuf::MessageExts
  extend ::Google::Protobuf::MessageExts::ClassMethods

  def initialize(*_arg0); end

  def ==(_arg0); end
  def [](_arg0); end
  def []=(_arg0, _arg1); end
  def clone; end
  def dup; end
  def eql?(_arg0); end
  def hash; end
  def inspect; end
  def method_missing(*_arg0); end
  def to_h; end
  def to_s; end

  private

  def respond_to_missing?(*_arg0); end

  class << self
    def decode(_arg0); end
    def decode_json(*_arg0); end
    def descriptor; end
    def encode(_arg0); end
    def encode_json(*_arg0); end
  end
end

class Aqueduct::Api::V1::RevokeApiKeyRequest
  include ::Google::Protobuf::MessageExts
  extend ::Google::Protobuf::MessageExts::ClassMethods

  def initialize(*_arg0); end

  def ==(_arg0); end
  def [](_arg0); end
  def []=(_arg0, _arg1); end
  def clone; end
  def dup; end
  def eql?(_arg0); end
  def hash; end
  def inspect; end
  def method_missing(*_arg0); end
  def to_h; end
  def to_s; end

  private

  def respond_to_missing?(*_arg0); end

  class << self
    def decode(_arg0); end
    def decode_json(*_arg0); end
    def descriptor; end
    def encode(_arg0); end
    def encode_json(*_arg0); end
  end
end

class Aqueduct::Api::V1::ScheduledCountRequest
  include ::Google::Protobuf::MessageExts
  extend ::Google::Protobuf::MessageExts::ClassMethods

  def initialize(*_arg0); end

  def ==(_arg0); end
  def [](_arg0); end
  def []=(_arg0, _arg1); end
  def clone; end
  def dup; end
  def eql?(_arg0); end
  def hash; end
  def inspect; end
  def method_missing(*_arg0); end
  def to_h; end
  def to_s; end

  private

  def respond_to_missing?(*_arg0); end

  class << self
    def decode(_arg0); end
    def decode_json(*_arg0); end
    def descriptor; end
    def encode(_arg0); end
    def encode_json(*_arg0); end
  end
end

class Aqueduct::Api::V1::ScheduledCountResponse
  include ::Google::Protobuf::MessageExts
  extend ::Google::Protobuf::MessageExts::ClassMethods

  def initialize(*_arg0); end

  def ==(_arg0); end
  def [](_arg0); end
  def []=(_arg0, _arg1); end
  def clone; end
  def dup; end
  def eql?(_arg0); end
  def hash; end
  def inspect; end
  def method_missing(*_arg0); end
  def to_h; end
  def to_s; end

  private

  def respond_to_missing?(*_arg0); end

  class << self
    def decode(_arg0); end
    def decode_json(*_arg0); end
    def descriptor; end
    def encode(_arg0); end
    def encode_json(*_arg0); end
  end
end

class Aqueduct::Api::V1::ScheduledCountResponse::Count
  include ::Google::Protobuf::MessageExts
  extend ::Google::Protobuf::MessageExts::ClassMethods

  def initialize(*_arg0); end

  def ==(_arg0); end
  def [](_arg0); end
  def []=(_arg0, _arg1); end
  def clone; end
  def dup; end
  def eql?(_arg0); end
  def hash; end
  def inspect; end
  def method_missing(*_arg0); end
  def to_h; end
  def to_s; end

  private

  def respond_to_missing?(*_arg0); end

  class << self
    def decode(_arg0); end
    def decode_json(*_arg0); end
    def descriptor; end
    def encode(_arg0); end
    def encode_json(*_arg0); end
  end
end

class Aqueduct::Api::V1::ScheduledRequest
  include ::Google::Protobuf::MessageExts
  extend ::Google::Protobuf::MessageExts::ClassMethods

  def initialize(*_arg0); end

  def ==(_arg0); end
  def [](_arg0); end
  def []=(_arg0, _arg1); end
  def clone; end
  def dup; end
  def eql?(_arg0); end
  def hash; end
  def inspect; end
  def method_missing(*_arg0); end
  def to_h; end
  def to_s; end

  private

  def respond_to_missing?(*_arg0); end

  class << self
    def decode(_arg0); end
    def decode_json(*_arg0); end
    def descriptor; end
    def encode(_arg0); end
    def encode_json(*_arg0); end
  end
end

class Aqueduct::Api::V1::ScheduledResponse
  include ::Google::Protobuf::MessageExts
  extend ::Google::Protobuf::MessageExts::ClassMethods

  def initialize(*_arg0); end

  def ==(_arg0); end
  def [](_arg0); end
  def []=(_arg0, _arg1); end
  def clone; end
  def dup; end
  def eql?(_arg0); end
  def hash; end
  def inspect; end
  def method_missing(*_arg0); end
  def to_h; end
  def to_s; end

  private

  def respond_to_missing?(*_arg0); end

  class << self
    def decode(_arg0); end
    def decode_json(*_arg0); end
    def descriptor; end
    def encode(_arg0); end
    def encode_json(*_arg0); end
  end
end

class Aqueduct::Api::V1::ScheduledResponse::Job
  include ::Google::Protobuf::MessageExts
  extend ::Google::Protobuf::MessageExts::ClassMethods

  def initialize(*_arg0); end

  def ==(_arg0); end
  def [](_arg0); end
  def []=(_arg0, _arg1); end
  def clone; end
  def dup; end
  def eql?(_arg0); end
  def hash; end
  def inspect; end
  def method_missing(*_arg0); end
  def to_h; end
  def to_s; end

  private

  def respond_to_missing?(*_arg0); end

  class << self
    def decode(_arg0); end
    def decode_json(*_arg0); end
    def descriptor; end
    def encode(_arg0); end
    def encode_json(*_arg0); end
  end
end

class Aqueduct::Api::V1::SchedulingDisabledRequest
  include ::Google::Protobuf::MessageExts
  extend ::Google::Protobuf::MessageExts::ClassMethods

  def initialize(*_arg0); end

  def ==(_arg0); end
  def [](_arg0); end
  def []=(_arg0, _arg1); end
  def clone; end
  def dup; end
  def eql?(_arg0); end
  def hash; end
  def inspect; end
  def method_missing(*_arg0); end
  def to_h; end
  def to_s; end

  private

  def respond_to_missing?(*_arg0); end

  class << self
    def decode(_arg0); end
    def decode_json(*_arg0); end
    def descriptor; end
    def encode(_arg0); end
    def encode_json(*_arg0); end
  end
end

class Aqueduct::Api::V1::SchedulingDisabledResponse
  include ::Google::Protobuf::MessageExts
  extend ::Google::Protobuf::MessageExts::ClassMethods

  def initialize(*_arg0); end

  def ==(_arg0); end
  def [](_arg0); end
  def []=(_arg0, _arg1); end
  def clone; end
  def dup; end
  def eql?(_arg0); end
  def hash; end
  def inspect; end
  def method_missing(*_arg0); end
  def to_h; end
  def to_s; end

  private

  def respond_to_missing?(*_arg0); end

  class << self
    def decode(_arg0); end
    def decode_json(*_arg0); end
    def descriptor; end
    def encode(_arg0); end
    def encode_json(*_arg0); end
  end
end

class Aqueduct::Api::V1::SendBatchRequest
  include ::Google::Protobuf::MessageExts
  extend ::Google::Protobuf::MessageExts::ClassMethods

  def initialize(*_arg0); end

  def ==(_arg0); end
  def [](_arg0); end
  def []=(_arg0, _arg1); end
  def clone; end
  def dup; end
  def eql?(_arg0); end
  def hash; end
  def inspect; end
  def method_missing(*_arg0); end
  def to_h; end
  def to_s; end

  private

  def respond_to_missing?(*_arg0); end

  class << self
    def decode(_arg0); end
    def decode_json(*_arg0); end
    def descriptor; end
    def encode(_arg0); end
    def encode_json(*_arg0); end
  end
end

class Aqueduct::Api::V1::SendBatchResponse
  include ::Google::Protobuf::MessageExts
  extend ::Google::Protobuf::MessageExts::ClassMethods

  def initialize(*_arg0); end

  def ==(_arg0); end
  def [](_arg0); end
  def []=(_arg0, _arg1); end
  def clone; end
  def dup; end
  def eql?(_arg0); end
  def hash; end
  def inspect; end
  def method_missing(*_arg0); end
  def to_h; end
  def to_s; end

  private

  def respond_to_missing?(*_arg0); end

  class << self
    def decode(_arg0); end
    def decode_json(*_arg0); end
    def descriptor; end
    def encode(_arg0); end
    def encode_json(*_arg0); end
  end
end

class Aqueduct::Api::V1::SendRequest
  include ::Google::Protobuf::MessageExts
  extend ::Google::Protobuf::MessageExts::ClassMethods

  def initialize(*_arg0); end

  def ==(_arg0); end
  def [](_arg0); end
  def []=(_arg0, _arg1); end
  def clone; end
  def dup; end
  def eql?(_arg0); end
  def hash; end
  def inspect; end
  def method_missing(*_arg0); end
  def to_h; end
  def to_s; end

  private

  def respond_to_missing?(*_arg0); end

  class << self
    def decode(_arg0); end
    def decode_json(*_arg0); end
    def descriptor; end
    def encode(_arg0); end
    def encode_json(*_arg0); end
  end
end

class Aqueduct::Api::V1::SendResponse
  include ::Google::Protobuf::MessageExts
  extend ::Google::Protobuf::MessageExts::ClassMethods

  def initialize(*_arg0); end

  def ==(_arg0); end
  def [](_arg0); end
  def []=(_arg0, _arg1); end
  def clone; end
  def dup; end
  def eql?(_arg0); end
  def hash; end
  def inspect; end
  def method_missing(*_arg0); end
  def to_h; end
  def to_s; end

  private

  def respond_to_missing?(*_arg0); end

  class << self
    def decode(_arg0); end
    def decode_json(*_arg0); end
    def descriptor; end
    def encode(_arg0); end
    def encode_json(*_arg0); end
  end
end

class Aqueduct::Api::V1::StateTableCountsRequest
  include ::Google::Protobuf::MessageExts
  extend ::Google::Protobuf::MessageExts::ClassMethods

  def initialize(*_arg0); end

  def ==(_arg0); end
  def [](_arg0); end
  def []=(_arg0, _arg1); end
  def clone; end
  def dup; end
  def eql?(_arg0); end
  def hash; end
  def inspect; end
  def method_missing(*_arg0); end
  def to_h; end
  def to_s; end

  private

  def respond_to_missing?(*_arg0); end

  class << self
    def decode(_arg0); end
    def decode_json(*_arg0); end
    def descriptor; end
    def encode(_arg0); end
    def encode_json(*_arg0); end
  end
end

class Aqueduct::Api::V1::StateTableCountsResponse
  include ::Google::Protobuf::MessageExts
  extend ::Google::Protobuf::MessageExts::ClassMethods

  def initialize(*_arg0); end

  def ==(_arg0); end
  def [](_arg0); end
  def []=(_arg0, _arg1); end
  def clone; end
  def dup; end
  def eql?(_arg0); end
  def hash; end
  def inspect; end
  def method_missing(*_arg0); end
  def to_h; end
  def to_s; end

  private

  def respond_to_missing?(*_arg0); end

  class << self
    def decode(_arg0); end
    def decode_json(*_arg0); end
    def descriptor; end
    def encode(_arg0); end
    def encode_json(*_arg0); end
  end
end

class Aqueduct::Api::V1::StateTableCountsResponse::Count
  include ::Google::Protobuf::MessageExts
  extend ::Google::Protobuf::MessageExts::ClassMethods

  def initialize(*_arg0); end

  def ==(_arg0); end
  def [](_arg0); end
  def []=(_arg0, _arg1); end
  def clone; end
  def dup; end
  def eql?(_arg0); end
  def hash; end
  def inspect; end
  def method_missing(*_arg0); end
  def to_h; end
  def to_s; end

  private

  def respond_to_missing?(*_arg0); end

  class << self
    def decode(_arg0); end
    def decode_json(*_arg0); end
    def descriptor; end
    def encode(_arg0); end
    def encode_json(*_arg0); end
  end
end

class Aqueduct::Api::V1::StateTableCountsResponse::NodeCount
  include ::Google::Protobuf::MessageExts
  extend ::Google::Protobuf::MessageExts::ClassMethods

  def initialize(*_arg0); end

  def ==(_arg0); end
  def [](_arg0); end
  def []=(_arg0, _arg1); end
  def clone; end
  def dup; end
  def eql?(_arg0); end
  def hash; end
  def inspect; end
  def method_missing(*_arg0); end
  def to_h; end
  def to_s; end

  private

  def respond_to_missing?(*_arg0); end

  class << self
    def decode(_arg0); end
    def decode_json(*_arg0); end
    def descriptor; end
    def encode(_arg0); end
    def encode_json(*_arg0); end
  end
end

class Aqueduct::Api::V1::StateTableCountsResponse::QueueCount
  include ::Google::Protobuf::MessageExts
  extend ::Google::Protobuf::MessageExts::ClassMethods

  def initialize(*_arg0); end

  def ==(_arg0); end
  def [](_arg0); end
  def []=(_arg0, _arg1); end
  def clone; end
  def dup; end
  def eql?(_arg0); end
  def hash; end
  def inspect; end
  def method_missing(*_arg0); end
  def to_h; end
  def to_s; end

  private

  def respond_to_missing?(*_arg0); end

  class << self
    def decode(_arg0); end
    def decode_json(*_arg0); end
    def descriptor; end
    def encode(_arg0); end
    def encode_json(*_arg0); end
  end
end

class Aqueduct::Api::V1::Tag
  include ::Google::Protobuf::MessageExts
  extend ::Google::Protobuf::MessageExts::ClassMethods

  def initialize(*_arg0); end

  def ==(_arg0); end
  def [](_arg0); end
  def []=(_arg0, _arg1); end
  def clone; end
  def dup; end
  def eql?(_arg0); end
  def hash; end
  def inspect; end
  def method_missing(*_arg0); end
  def to_h; end
  def to_s; end

  private

  def respond_to_missing?(*_arg0); end

  class << self
    def decode(_arg0); end
    def decode_json(*_arg0); end
    def descriptor; end
    def encode(_arg0); end
    def encode_json(*_arg0); end
  end
end

class Aqueduct::Api::V1::ThrottleConfig
  include ::Google::Protobuf::MessageExts
  extend ::Google::Protobuf::MessageExts::ClassMethods

  def initialize(*_arg0); end

  def ==(_arg0); end
  def [](_arg0); end
  def []=(_arg0, _arg1); end
  def clone; end
  def dup; end
  def eql?(_arg0); end
  def hash; end
  def inspect; end
  def method_missing(*_arg0); end
  def to_h; end
  def to_s; end

  private

  def respond_to_missing?(*_arg0); end

  class << self
    def decode(_arg0); end
    def decode_json(*_arg0); end
    def descriptor; end
    def encode(_arg0); end
    def encode_json(*_arg0); end
  end
end

class Aqueduct::Api::V1::Worker
  include ::Google::Protobuf::MessageExts
  extend ::Google::Protobuf::MessageExts::ClassMethods

  def initialize(*_arg0); end

  def ==(_arg0); end
  def [](_arg0); end
  def []=(_arg0, _arg1); end
  def clone; end
  def dup; end
  def eql?(_arg0); end
  def hash; end
  def inspect; end
  def method_missing(*_arg0); end
  def to_h; end
  def to_s; end

  private

  def respond_to_missing?(*_arg0); end

  class << self
    def decode(_arg0); end
    def decode_json(*_arg0); end
    def descriptor; end
    def encode(_arg0); end
    def encode_json(*_arg0); end
  end
end

class Aqueduct::Api::V1::WorkerLimitsRequest
  include ::Google::Protobuf::MessageExts
  extend ::Google::Protobuf::MessageExts::ClassMethods

  def initialize(*_arg0); end

  def ==(_arg0); end
  def [](_arg0); end
  def []=(_arg0, _arg1); end
  def clone; end
  def dup; end
  def eql?(_arg0); end
  def hash; end
  def inspect; end
  def method_missing(*_arg0); end
  def to_h; end
  def to_s; end

  private

  def respond_to_missing?(*_arg0); end

  class << self
    def decode(_arg0); end
    def decode_json(*_arg0); end
    def descriptor; end
    def encode(_arg0); end
    def encode_json(*_arg0); end
  end
end

class Aqueduct::Api::V1::WorkerLimitsResponse
  include ::Google::Protobuf::MessageExts
  extend ::Google::Protobuf::MessageExts::ClassMethods

  def initialize(*_arg0); end

  def ==(_arg0); end
  def [](_arg0); end
  def []=(_arg0, _arg1); end
  def clone; end
  def dup; end
  def eql?(_arg0); end
  def hash; end
  def inspect; end
  def method_missing(*_arg0); end
  def to_h; end
  def to_s; end

  private

  def respond_to_missing?(*_arg0); end

  class << self
    def decode(_arg0); end
    def decode_json(*_arg0); end
    def descriptor; end
    def encode(_arg0); end
    def encode_json(*_arg0); end
  end
end

class Aqueduct::Api::V1::WorkerLimitsResponse::WorkerLimit
  include ::Google::Protobuf::MessageExts
  extend ::Google::Protobuf::MessageExts::ClassMethods

  def initialize(*_arg0); end

  def ==(_arg0); end
  def [](_arg0); end
  def []=(_arg0, _arg1); end
  def clone; end
  def dup; end
  def eql?(_arg0); end
  def hash; end
  def inspect; end
  def method_missing(*_arg0); end
  def to_h; end
  def to_s; end

  private

  def respond_to_missing?(*_arg0); end

  class << self
    def decode(_arg0); end
    def decode_json(*_arg0); end
    def descriptor; end
    def encode(_arg0); end
    def encode_json(*_arg0); end
  end
end

# source://aqueduct-client//lib/aqueduct/client.rb#8
class Aqueduct::Client
  # Public: Build a new aqueduct client.
  #
  # app             - The String name of the application sending to and receiving from
  #                   aqueduct (required).
  # url             - The String URL of the aqueduct service (required).
  # client_id       - A String that uniquely identifies the client.
  # site            - An optional string site for the client. Used in site pausing. Will default
  #                   to the site in production by reading KUBE_SITE or metadata
  # timeout         - An Integer HTTP timeout for aqueduct send and ack requests. Defaults to
  #                   10 seconds.
  # receive_timeout - An Integer HTTP timeout specifically for receive requests. This timeout
  #                   must be higher than the receive_job timeout. Defaults to 10 seconds.
  #
  # api_key         - An API key for authenticating with the aqueduct API.
  # api_key_version - The API key version.
  #
  # send_hmac_secret     - An optional secret key used sign payloads and set the "_hmac" header.
  # receive_hmac_secrets - Optional secrets used to verify signed payloads. Multiple secrets are
  #                        allowed to support rolling creds.
  #
  # block           - An optional block that accepts the faraday HTTP connection. Used for
  #                   configuring faraday options.
  #
  # @return [Client] a new instance of Client
  #
  # source://aqueduct-client//lib/aqueduct/client.rb#47
  def initialize(app: T.unsafe(nil), url: T.unsafe(nil), client_id: T.unsafe(nil), timeout: T.unsafe(nil), receive_timeout: T.unsafe(nil), idempotent_send: T.unsafe(nil), send_retries: T.unsafe(nil), heartbeat_retries: T.unsafe(nil), ack_retries: T.unsafe(nil), site: T.unsafe(nil), tags: T.unsafe(nil), auth_as: T.unsafe(nil), api_key: T.unsafe(nil), api_key_version: T.unsafe(nil), send_hmac_secret: T.unsafe(nil), receive_hmac_secrets: T.unsafe(nil), &block); end

  # Public: ACK a job. Refer to aqueduct API definition for additional documentation on args and
  # usage.
  #
  # queue   - The String job queue name (required).
  # job_id  - The String job ID (required).
  # success - A Boolean to incidate job success or failure, informational only (required).
  #
  # source://aqueduct-client//lib/aqueduct/client.rb#221
  def ack_job(queue:, job_id:, success:); end

  # Public: Get backend name and shard assignments for worker utilization. Refer to aqueduct
  # API definition for additional documentation on args and usage.
  #
  # source://aqueduct-client//lib/aqueduct/client.rb#291
  def backend_ids(clients:, workers:); end

  # source://aqueduct-client//lib/aqueduct/client.rb#309
  def client_id; end

  # The default worker id generated on the first receive call to this client if no worker_id
  # was specified by a caller. Useful for maintaining compatibility with one-off clients.
  #
  # source://aqueduct-client//lib/aqueduct/client.rb#315
  def default_worker_id; end

  # encode changes the encoding of payload to be BINARY
  #
  # source://aqueduct-client//lib/aqueduct/client.rb#301
  def encode(payload); end

  # Public: Heartbeat a job. Refer to aqueduct API definition for additional documentation on
  # args and usage.
  #
  # queue  - The String job queue name (required).
  # job_id - The String job ID (required).
  #
  # source://aqueduct-client//lib/aqueduct/client.rb#202
  def heartbeat_job(queue:, job_id:); end

  # Public: List in-progress jobs in a queue. Refer to aqueduct API definition for additional
  # documentation on args and usage.
  #
  # queue - The String optional job queue name.
  #
  # source://aqueduct-client//lib/aqueduct/client.rb#261
  def in_progress_jobs(queue:); end

  # Public: List queues. Refer to aqueduct API definition for additional documentation on args and
  # usage.
  #
  # source://aqueduct-client//lib/aqueduct/client.rb#272
  def list_queues; end

  # Public: Peek at jobs in a queue. Refer to aqueduct API definition for additional documentation
  # on args and usage.
  #
  # queue   - The String job queue name (required).
  # job_id  - The String job ID (required).
  # success - A Boolean to incidate job success or failure, informational only (required).
  #
  # source://aqueduct-client//lib/aqueduct/client.rb#247
  def peek_jobs(queue:, count:); end

  # Public: Query queue depth. Refer to aqueduct API definition for additional documentation on
  # args and usage.
  #
  # queue - The String optional job queue name.
  #
  # source://aqueduct-client//lib/aqueduct/client.rb#280
  def queue_depth(queue:); end

  # Public: Receive a job from aqueduct. Refer to aqueduct API definition for additional
  # documentation on args and usage.
  #
  # queues      - The Array<String> list of queues (required).
  # timeout     - The Integer poll timeout in seconds (required).
  # tags        - additional tags to merge with worker tags per-request
  # worker_id   - A long-lived id unique to the worker (or caller) invoking the Receive method.
  #               This is important for popping jobs from all Aqueduct backends for graceful
  #               failover.
  # worker_pool - The worker pool name used to logically group a set of workers. Required to
  #               enable aqueduct execution time throttling.
  #
  # source://aqueduct-client//lib/aqueduct/client.rb#171
  def receive_job(queues:, timeout:, tags: T.unsafe(nil), bypass_pausing: T.unsafe(nil), worker_id: T.unsafe(nil), worker_pool: T.unsafe(nil)); end

  # Public: Send a job to aqueduct. Refer to aqueduct API definition for additional documentation
  # on args and usage.
  #
  # queue                   - The String queue name (required).
  # payload                 - The String payload, treated as raw bytes (required).
  # headers                 - A Hash<String, String> of job headers.
  # redelivery_timeout_secs - An optional Integer redelivery timeout.
  # max_redelivery_attempts - An optional Integer max redlivery attempts.
  # deliver_at              - An optional Time or Integer UNIX timestamp.
  # external_id             - An optional ID used to identify a job e.g. ActiveJob ID
  # ttl                     - An optional TTL in seconds
  #
  # source://aqueduct-client//lib/aqueduct/client.rb#102
  def send_job(queue:, payload:, headers: T.unsafe(nil), redelivery_timeout_secs: T.unsafe(nil), max_redelivery_attempts: T.unsafe(nil), deliver_at: T.unsafe(nil), external_id: T.unsafe(nil), ttl: T.unsafe(nil)); end

  # Public: Send a batch of jobs to aqueduct. Refer to aqueduct API definition for additional documentation on args
  # and usage.
  #
  # jobs       - An array of Hashes with the following keys:
  #  app                     - The String name of the application sending to and receiving from aqueduct.
  #  queue                   - The String queue name (required).
  #  payload                 - The String payload, treated as raw bytes (required).
  #  headers                 - A Hash<String, String> of job headers.
  #  redelivery_timeout_secs - An optional Integer redelivery timeout.
  #  max_redelivery_attempts - An optional Integer max redlivery attempts.
  #  deliver_at              - An optional Time or Integer UNIX timestamp.
  #  external_id             - An optional ID used to identify a job e.g. ActiveJob ID
  # ttl                      - An optional TTL in seconds
  #
  # source://aqueduct-client//lib/aqueduct/client.rb#135
  def send_jobs(jobs); end

  # source://aqueduct-client//lib/aqueduct/client.rb#87
  def url; end

  private

  # Returns the value of attribute api_key.
  #
  # source://aqueduct-client//lib/aqueduct/client.rb#321
  def api_key; end

  # Returns the value of attribute api_key_version.
  #
  # source://aqueduct-client//lib/aqueduct/client.rb#321
  def api_key_version; end

  # Returns the value of attribute auth_as.
  #
  # source://aqueduct-client//lib/aqueduct/client.rb#321
  def auth_as; end

  # @return [Boolean]
  #
  # source://aqueduct-client//lib/aqueduct/client.rb#460
  def auth_enabled?; end

  # source://aqueduct-client//lib/aqueduct/client.rb#464
  def auth_header; end

  # source://aqueduct-client//lib/aqueduct/client.rb#382
  def build_http_client(url, timeout); end

  # source://aqueduct-client//lib/aqueduct/client.rb#427
  def build_idempotent_send_options; end

  # source://aqueduct-client//lib/aqueduct/client.rb#323
  def create_send_request(app:, queue:, payload:, headers: T.unsafe(nil), redelivery_timeout_secs: T.unsafe(nil), max_redelivery_attempts: T.unsafe(nil), deliver_at: T.unsafe(nil), external_id: T.unsafe(nil), ttl: T.unsafe(nil)); end

  # source://aqueduct-client//lib/aqueduct/client.rb#443
  def hmac_sign(value, secret:); end

  # source://aqueduct-client//lib/aqueduct/client.rb#435
  def producer_id; end

  # source://aqueduct-client//lib/aqueduct/client.rb#394
  def rpc(client, rpc, input, metadata = T.unsafe(nil)); end

  # @return [Boolean]
  #
  # source://aqueduct-client//lib/aqueduct/client.rb#439
  def sign_payload?; end

  # @return [Boolean]
  #
  # source://aqueduct-client//lib/aqueduct/client.rb#447
  def valid_payload?(resp); end

  # source://aqueduct-client//lib/aqueduct/client.rb#367
  def with_retries(retry_count:, backoff:); end

  class << self
    # source://aqueduct-client//lib/aqueduct/client.rb#21
    def generate_producer_id; end
  end
end

# source://aqueduct-client//lib/aqueduct/client.rb#17
Aqueduct::Client::API_AUTH_AS_HTTP_HEADER = T.let(T.unsafe(nil), String)

# source://aqueduct-client//lib/aqueduct/client.rb#16
Aqueduct::Client::API_AUTH_HTTP_HEADER = T.let(T.unsafe(nil), String)

# source://aqueduct-client//lib/aqueduct/client.rb#18
Aqueduct::Client::API_AUTH_SCHEME = T.let(T.unsafe(nil), String)

# 5 minutes
#
# source://aqueduct-client//lib/aqueduct/client.rb#19
Aqueduct::Client::API_TOKEN_EXPIRATION = T.let(T.unsafe(nil), Integer)

# source://aqueduct-client//lib/aqueduct/client.rb#471
class Aqueduct::Client::ClientError < ::StandardError
  # @return [ClientError] a new instance of ClientError
  #
  # source://aqueduct-client//lib/aqueduct/client.rb#474
  def initialize(metadata = T.unsafe(nil)); end

  # Returns the value of attribute metadata.
  #
  # source://aqueduct-client//lib/aqueduct/client.rb#472
  def metadata; end
end

# source://aqueduct-client//lib/aqueduct/client.rb#9
Aqueduct::Client::DEFAULT_TIMEOUT = T.let(T.unsafe(nil), Integer)

# source://aqueduct-client//lib/aqueduct/client.rb#10
Aqueduct::Client::GITHUB_REQUEST_ID_HEADER = T.let(T.unsafe(nil), String)

# source://aqueduct-client//lib/aqueduct/client.rb#11
Aqueduct::Client::GLB_VIA_HEADER = T.let(T.unsafe(nil), String)

# source://aqueduct-client//lib/aqueduct/client.rb#14
Aqueduct::Client::HMAC_ALGORITHM = T.let(T.unsafe(nil), String)

# source://aqueduct-client//lib/aqueduct/client.rb#13
Aqueduct::Client::HMAC_HEADER = T.let(T.unsafe(nil), String)

# source://aqueduct-client//lib/aqueduct/client.rb#492
class Aqueduct::Client::PayloadValidationError < ::Aqueduct::Client::ClientError
  # @return [PayloadValidationError] a new instance of PayloadValidationError
  #
  # source://aqueduct-client//lib/aqueduct/client.rb#495
  def initialize(job:); end

  # source://aqueduct-client//lib/aqueduct/client.rb#503
  def hmac; end

  # Returns the value of attribute job.
  #
  # source://aqueduct-client//lib/aqueduct/client.rb#493
  def job; end

  # source://aqueduct-client//lib/aqueduct/client.rb#507
  def job_id; end

  # source://aqueduct-client//lib/aqueduct/client.rb#511
  def queue; end

  # source://aqueduct-client//lib/aqueduct/client.rb#499
  def to_s; end
end

# source://aqueduct-client//lib/aqueduct/client.rb#479
class Aqueduct::Client::RequestError < ::Aqueduct::Client::ClientError
  # @return [RequestError] a new instance of RequestError
  #
  # source://aqueduct-client//lib/aqueduct/client.rb#482
  def initialize(error, metadata = T.unsafe(nil)); end

  # Returns the value of attribute error.
  #
  # source://aqueduct-client//lib/aqueduct/client.rb#480
  def error; end

  # Returns the value of attribute metadata.
  #
  # source://aqueduct-client//lib/aqueduct/client.rb#480
  def metadata; end

  # source://aqueduct-client//lib/aqueduct/client.rb#487
  def to_s; end
end

# source://aqueduct-client//lib/aqueduct/client.rb#516
class Aqueduct::Client::RequestIdGenerator
  class << self
    # source://aqueduct-client//lib/aqueduct/client.rb#517
    def github_request_id; end

    # source://aqueduct-client//lib/aqueduct/client.rb#521
    def glb_via; end
  end
end

# source://aqueduct-client//lib/aqueduct/client.rb#12
Aqueduct::Client::USER_AGENT_HEADER = T.let(T.unsafe(nil), String)

# source://aqueduct-client//lib/aqueduct.rb#9
Aqueduct::DEFAULT_TAGS = T.let(T.unsafe(nil), Hash)

# source://aqueduct-client//lib/aqueduct.rb#8
Aqueduct::DEFAULT_URL = T.let(T.unsafe(nil), String)

# source://aqueduct-client//lib/aqueduct.rb#11
Aqueduct::MISSING_APP_ERROR = T.let(T.unsafe(nil), String)

# source://aqueduct-client//lib/aqueduct/test_helpers/test_server.rb#4
module Aqueduct::TestHelpers; end

# A twirp test server implementation that clients can use to test aqueduct
# integration.
#
#     TestServer.run(port: 5000) do |handler|
#       client = Aqueduct::Client.new(
#         app: "test-app",
#         url: "http://127.0.0.1:5000/twirp"
#       )
#
#       client.send_job(queue: "test-queue", payload: "abc")
#       assert_equal 1, handler.enqueued_for(app: "test-app", queue: "test-queue").size
#
#       response = client.receive_job(queues: ["test-queue"])
#       assert_equal "test-app", response[:app]
#       # ...
#
#       handler.set_send_error(Twirp::Error.internal("OH NO"))
#       assert_raise { client.send_job(queue: "test-queue", payload: "abc") }
#
#       handler.set_receive_error(Twirp::Error.internal("OH NO"))
#       assert_raise { client.receive_job(queues: ["test-queue"]) }
#     end
#
# source://aqueduct-client//lib/aqueduct/test_helpers/test_server.rb#27
class Aqueduct::TestHelpers::TestServer
  class << self
    # source://aqueduct-client//lib/aqueduct/test_helpers/test_server.rb#70
    def default_logger; end

    # source://aqueduct-client//lib/aqueduct/test_helpers/test_server.rb#28
    def run(port:, handler: T.unsafe(nil), timeout: T.unsafe(nil), logger: T.unsafe(nil)); end
  end
end

# source://aqueduct-client//lib/aqueduct/test_helpers/test_server.rb#76
class Aqueduct::TestHelpers::TestServer::Handler
  # @return [Handler] a new instance of Handler
  #
  # source://aqueduct-client//lib/aqueduct/test_helpers/test_server.rb#80
  def initialize(backend_name: T.unsafe(nil)); end

  # Returns the value of attribute acks.
  #
  # source://aqueduct-client//lib/aqueduct/test_helpers/test_server.rb#77
  def acks; end

  # source://aqueduct-client//lib/aqueduct/test_helpers/test_server.rb#185
  def acks_for(app:, queue:); end

  # source://aqueduct-client//lib/aqueduct/test_helpers/test_server.rb#195
  def add_in_progress_job(app:, queue:, job_id:, payload:, client_id:, delivered_at:); end

  # source://aqueduct-client//lib/aqueduct/test_helpers/test_server.rb#99
  def enqueued_for(app:, queue:); end

  # source://aqueduct-client//lib/aqueduct/test_helpers/test_server.rb#176
  def handle_ack(request, headers); end

  # source://aqueduct-client//lib/aqueduct/test_helpers/test_server.rb#229
  def handle_backend_ids(request, headers); end

  # source://aqueduct-client//lib/aqueduct/test_helpers/test_server.rb#159
  def handle_heartbeat(request, headers); end

  # source://aqueduct-client//lib/aqueduct/test_helpers/test_server.rb#206
  def handle_in_progress_jobs(request, headers); end

  # source://aqueduct-client//lib/aqueduct/test_helpers/test_server.rb#212
  def handle_list_queues(request, headers); end

  # source://aqueduct-client//lib/aqueduct/test_helpers/test_server.rb#189
  def handle_peek(request, headers); end

  # source://aqueduct-client//lib/aqueduct/test_helpers/test_server.rb#221
  def handle_queue_depth(request, headers); end

  # source://aqueduct-client//lib/aqueduct/test_helpers/test_server.rb#126
  def handle_receive(request, headers); end

  # source://aqueduct-client//lib/aqueduct/test_helpers/test_server.rb#107
  def handle_send(request, headers); end

  # source://aqueduct-client//lib/aqueduct/test_helpers/test_server.rb#245
  def handle_send_batch(request, headers); end

  # source://aqueduct-client//lib/aqueduct/test_helpers/test_server.rb#168
  def heartbeats_for(app:, queue:); end

  # Returns the value of attribute queues.
  #
  # source://aqueduct-client//lib/aqueduct/test_helpers/test_server.rb#77
  def queues; end

  # Returns the value of attribute receive_delay.
  #
  # source://aqueduct-client//lib/aqueduct/test_helpers/test_server.rb#78
  def receive_delay; end

  # Sets the attribute receive_delay
  #
  # @param value the value to set the attribute receive_delay to.
  #
  # source://aqueduct-client//lib/aqueduct/test_helpers/test_server.rb#78
  def receive_delay=(_arg0); end

  # source://aqueduct-client//lib/aqueduct/test_helpers/test_server.rb#155
  def receives_for(app:); end

  # Returns the value of attribute requests.
  #
  # source://aqueduct-client//lib/aqueduct/test_helpers/test_server.rb#77
  def requests; end

  # Returns the value of attribute send_delay.
  #
  # source://aqueduct-client//lib/aqueduct/test_helpers/test_server.rb#78
  def send_delay; end

  # Sets the attribute send_delay
  #
  # @param value the value to set the attribute send_delay to.
  #
  # source://aqueduct-client//lib/aqueduct/test_helpers/test_server.rb#78
  def send_delay=(_arg0); end

  # source://aqueduct-client//lib/aqueduct/test_helpers/test_server.rb#172
  def set_ack_error(error); end

  # source://aqueduct-client//lib/aqueduct/test_helpers/test_server.rb#122
  def set_receive_error(error); end

  # source://aqueduct-client//lib/aqueduct/test_helpers/test_server.rb#103
  def set_send_error(error); end
end

# source://aqueduct-client//lib/aqueduct/version.rb#2
Aqueduct::VERSION = T.let(T.unsafe(nil), String)

# source://aqueduct-client//lib/aqueduct/worker/result.rb#2
module Aqueduct::Worker
  class << self
    # source://aqueduct-client//lib/aqueduct/worker.rb#17
    def config; end

    # @yield [config]
    #
    # source://aqueduct-client//lib/aqueduct/worker.rb#13
    def configure; end
  end
end

# source://aqueduct-client//lib/aqueduct/worker/aqueduct_backend.rb#3
class Aqueduct::Worker::AqueductBackend
  # @return [AqueductBackend] a new instance of AqueductBackend
  #
  # source://aqueduct-client//lib/aqueduct/worker/aqueduct_backend.rb#4
  def initialize(client:); end

  # source://aqueduct-client//lib/aqueduct/worker/aqueduct_backend.rb#102
  def client_id; end

  # source://aqueduct-client//lib/aqueduct/worker/aqueduct_backend.rb#28
  def destroy(id); end

  # source://aqueduct-client//lib/aqueduct/worker/aqueduct_backend.rb#20
  def get_worker(id); end

  # source://aqueduct-client//lib/aqueduct/worker/aqueduct_backend.rb#66
  def heartbeat(job); end

  # source://aqueduct-client//lib/aqueduct/worker/aqueduct_backend.rb#36
  def pop(queues, timeout, worker_id:, tags: T.unsafe(nil), worker_pool: T.unsafe(nil)); end

  # source://aqueduct-client//lib/aqueduct/worker/aqueduct_backend.rb#32
  def purge(queue); end

  # source://aqueduct-client//lib/aqueduct/worker/aqueduct_backend.rb#24
  def queues; end

  # source://aqueduct-client//lib/aqueduct/worker/aqueduct_backend.rb#8
  def register_worker(worker); end

  # source://aqueduct-client//lib/aqueduct/worker/aqueduct_backend.rb#87
  def report_failure(job, exception = T.unsafe(nil)); end

  # source://aqueduct-client//lib/aqueduct/worker/aqueduct_backend.rb#76
  def report_success(job); end

  # source://aqueduct-client//lib/aqueduct/worker/aqueduct_backend.rb#12
  def unregister_worker(worker, exception = T.unsafe(nil)); end

  # source://aqueduct-client//lib/aqueduct/worker/aqueduct_backend.rb#98
  def url; end

  # source://aqueduct-client//lib/aqueduct/worker/aqueduct_backend.rb#16
  def workers; end
end

# Defines the backend interface
#
# source://aqueduct-client//lib/aqueduct/worker/backend.rb#4
class Aqueduct::Worker::Backend
  # @raise [NotImplementedError]
  #
  # source://aqueduct-client//lib/aqueduct/worker/backend.rb#41
  def client_id; end

  # @raise [NotImplementedError]
  #
  # source://aqueduct-client//lib/aqueduct/worker/backend.rb#25
  def destroy(job_id); end

  # @raise [NotImplementedError]
  #
  # source://aqueduct-client//lib/aqueduct/worker/backend.rb#17
  def get_worker(worker_id); end

  # @raise [NotImplementedError]
  #
  # source://aqueduct-client//lib/aqueduct/worker/backend.rb#37
  def heartbeat(job); end

  # @raise [NotImplementedError]
  #
  # source://aqueduct-client//lib/aqueduct/worker/backend.rb#33
  def pop(queues, timeout, worker_id:, worker_pool: T.unsafe(nil)); end

  # @raise [NotImplementedError]
  #
  # source://aqueduct-client//lib/aqueduct/worker/backend.rb#29
  def purge(queue); end

  # @raise [NotImplementedError]
  #
  # source://aqueduct-client//lib/aqueduct/worker/backend.rb#21
  def queues; end

  # @raise [NotImplementedError]
  #
  # source://aqueduct-client//lib/aqueduct/worker/backend.rb#5
  def register_worker(worker); end

  # @raise [NotImplementedError]
  #
  # source://aqueduct-client//lib/aqueduct/worker/backend.rb#49
  def report_failure(job, error); end

  # @raise [NotImplementedError]
  #
  # source://aqueduct-client//lib/aqueduct/worker/backend.rb#45
  def report_success(job); end

  # @raise [NotImplementedError]
  #
  # source://aqueduct-client//lib/aqueduct/worker/backend.rb#9
  def unregister_worker(worker, exception = T.unsafe(nil)); end

  # @raise [NotImplementedError]
  #
  # source://aqueduct-client//lib/aqueduct/worker/backend.rb#13
  def workers; end
end

# source://aqueduct-client//lib/aqueduct/worker/config.rb#3
class Aqueduct::Worker::Config
  # @return [Config] a new instance of Config
  #
  # source://aqueduct-client//lib/aqueduct/worker/config.rb#89
  def initialize; end

  # Define a callback that runs in the child process after a Worker forks to
  # perform a job. Only applies when `fork_per_job` is true.
  #
  # Configured blocks are called with a Worker instance as the argument.
  #
  # source://aqueduct-client//lib/aqueduct/worker/config.rb#163
  def after_fork(&block); end

  # Define a callback that runs after a Worker performs the job. Always
  # executes even if the job execution has raised an exception.
  #
  # Configured blocks are called with the Worker and the Job as arguments.
  #
  # source://aqueduct-client//lib/aqueduct/worker/config.rb#183
  def after_perform(&block); end

  # Define a callback that runs after the Worker has started up.
  #
  # Configured blocks are called with a Worker instance as the argument.
  #
  # source://aqueduct-client//lib/aqueduct/worker/config.rb#147
  def after_startup(&block); end

  # Define a callback that runs before a Worker forks to perform a job. Only
  # applies when `fork_per_job` is true.
  #
  # Configured blocks are called with a Worker instance as the argument.
  #
  # source://aqueduct-client//lib/aqueduct/worker/config.rb#155
  def before_fork(&block); end

  # Define a callback that runs before a Worker performs the job.
  #
  # Configured blocks are called with the Worker and the Job as arguments.
  #
  # source://aqueduct-client//lib/aqueduct/worker/config.rb#175
  def before_perform(&block); end

  # Define a callback that runs before pop is called on the Backend
  #
  # source://aqueduct-client//lib/aqueduct/worker/config.rb#168
  def before_pop(&block); end

  # Disable worker heartbeats.
  #
  # source://aqueduct-client//lib/aqueduct/worker/config.rb#66
  def disable_heartbeats=(_arg0); end

  # The configured error reporter, or default.
  #
  # source://aqueduct-client//lib/aqueduct/worker/config.rb#111
  def error_reporter; end

  # Error reporter is a block that takes an exception and, if applicable,
  # the job being executed, and may publish the exception information.
  #
  # The default implementation prints the error and backtrace to STDERR.
  #
  # source://aqueduct-client//lib/aqueduct/worker/config.rb#22
  def error_reporter=(_arg0); end

  # Determines whether or not the worker will fork a new child process in
  # order to perform each job. Defaults to true.
  #
  # source://aqueduct-client//lib/aqueduct/worker/config.rb#6
  def fork_per_job=(_arg0); end

  # Is the worker configured to fork per job?
  #
  # @return [Boolean]
  #
  # source://aqueduct-client//lib/aqueduct/worker/config.rb#96
  def fork_per_job?; end

  # Determines whether or not the worker allows the current job to run to
  # completion rather than exiting immediately after receiving a SIGTERM.
  #
  # source://aqueduct-client//lib/aqueduct/worker/config.rb#10
  def graceful_term=(_arg0); end

  # Is the worker configured to terminate gracefully?
  #
  # @return [Boolean]
  #
  # source://aqueduct-client//lib/aqueduct/worker/config.rb#101
  def graceful_term?; end

  # The configured handler, or default.
  #
  # source://aqueduct-client//lib/aqueduct/worker/config.rb#106
  def handler; end

  # Handler is a block which takes the `job` as an argument and executes it.
  # Override this to define how an Aqueduct::Worker::Job is processed.
  #
  # Its default implementation is a log statement and a random sleep.
  #
  # source://aqueduct-client//lib/aqueduct/worker/config.rb#16
  def handler=(_arg0); end

  # The configured heartbeat check interval, or default (10 seconds)
  #
  # source://aqueduct-client//lib/aqueduct/worker/config.rb#136
  def heartbeat_check_interval_seconds; end

  # How often to check if a heartbeat should be sent. Mostly an internal
  # config for testing.
  #
  # source://aqueduct-client//lib/aqueduct/worker/config.rb#70
  def heartbeat_check_interval_seconds=(_arg0); end

  # The configured heartbeat interval, or default (60 seconds)
  #
  # source://aqueduct-client//lib/aqueduct/worker/config.rb#126
  def heartbeat_interval_seconds; end

  # When a worker fails to process a job within the job redelivery timeout,
  # aqueduct will redeliver the job to a different worker. This behavior is
  # desirable if a job was dropped in flight or if the worker was OOM-killed,
  # but isn't desirable if a job is simply taking a long time to process.
  # To prevent unwanted redelivery, workers send heartbeat requests to
  # aqueduct. Heartbeats indicate the job processing is still in progress and
  # each heartbeat restarts the clock on redelivery timeout.
  #
  # The default heartbeat interval is 60 seconds, which means it could take
  # aqueduct (60 seconds + redelivery timeout) to redeliver a lost job.
  # Aqueduct will redeliver jobs faster if the client descreases the
  # redelivery timeout config. *IMPORTANT:* The redelivery timeout should
  # always be greater than the heartbeat interval, and preferably >3x to
  # allow for heartbeat request failure.
  #
  # source://aqueduct-client//lib/aqueduct/worker/config.rb#63
  def heartbeat_interval_seconds=(_arg0); end

  # Has heartbeating been intentionally disabled?
  #
  # @return [Boolean]
  #
  # source://aqueduct-client//lib/aqueduct/worker/config.rb#131
  def heartbeating_disabled?; end

  # source://aqueduct-client//lib/aqueduct/worker/config.rb#140
  def invalid_payload_policy; end

  # Determines worker behavior when a payload HMAC signature is invalid. Valid values are
  #   :reject - Immedetialy ACKs the job as failed and does not call the handler (default).
  #   :ignore - Allows the invalid job to execute.
  #
  # In both cases, the :invalid_payload hook runs.
  #
  # source://aqueduct-client//lib/aqueduct/worker/config.rb#81
  def invalid_payload_policy=(policy); end

  # Define a callback that runs when a Worker encounters a job payload with an invalid signature.
  #
  # Configured blocks are called with the Worker and the Job as arguments.
  #
  # source://aqueduct-client//lib/aqueduct/worker/config.rb#198
  def on_invalid_payload(&block); end

  # Procline is a block that allows customization of the procline.
  #
  # The block is given the default version string ("aqueduct-<version>")
  # and the returned string is added to the procline: "<customized string>:
  # <status>".
  #
  # source://aqueduct-client//lib/aqueduct/worker/config.rb#29
  def procline; end

  # Procline is a block that allows customization of the procline.
  #
  # The block is given the default version string ("aqueduct-<version>")
  # and the returned string is added to the procline: "<customized string>:
  # <status>".
  #
  # source://aqueduct-client//lib/aqueduct/worker/config.rb#29
  def procline=(_arg0); end

  # Define a callback that runs when a Worker completes a Receive request without dequeuing a
  # job because all queues are empty.
  #
  # Configured blocks are called with the Worker instance as the argument.
  #
  # source://aqueduct-client//lib/aqueduct/worker/config.rb#191
  def queues_empty(&block); end

  # The configured quiesce check callback, or default (false)
  #
  # source://aqueduct-client//lib/aqueduct/worker/config.rb#116
  def quiesce_check; end

  # The quiesce check is a block called to determine if the workers should
  # be processing jobs. If the quiesce check returns true, the worker will
  # quiesce (stop processing jobs) but does not exit and will resume once
  # the next check returns false. Exceptions thrown from the check are
  # caught and will result in a quiesced worker, but are reported so it's
  # good practice to handle them in the check itself to avoid exception
  # noise. The check is always called before running the first job. The
  # default value is false (i.e. always processing).
  #
  # source://aqueduct-client//lib/aqueduct/worker/config.rb#39
  def quiesce_check=(_arg0); end

  # The configured quiesce check interval in seconds, or default (5 seconds)
  #
  # source://aqueduct-client//lib/aqueduct/worker/config.rb#121
  def quiesce_check_interval; end

  # The minimum interval in seconds from when the last check completed
  # until the check will fire again. Setting this to a high value will
  # result in fewer check calls, but will increase the time taken to
  # quiesce or resume when the underlying state the check monitors changes.
  # The default value is 5 seconds.
  #
  # source://aqueduct-client//lib/aqueduct/worker/config.rb#46
  def quiesce_check_interval=(_arg0); end

  # Internal: run the given hook, passing the given arguments to each
  # configured block.
  #
  # source://aqueduct-client//lib/aqueduct/worker/config.rb#204
  def run_hook(hook, *args); end

  # A worker pool is used to logically group a set of workers together.
  # A pool is required to enable aqueduct execution time throttling.
  #
  # source://aqueduct-client//lib/aqueduct/worker/config.rb#74
  def worker_pool; end

  # A worker pool is used to logically group a set of workers together.
  # A pool is required to enable aqueduct execution time throttling.
  #
  # source://aqueduct-client//lib/aqueduct/worker/config.rb#74
  def worker_pool=(_arg0); end
end

# source://aqueduct-client//lib/aqueduct/worker/config.rb#215
Aqueduct::Worker::Config::DEFAULT_ERROR_REPORTER = T.let(T.unsafe(nil), Proc)

# source://aqueduct-client//lib/aqueduct/worker/config.rb#210
Aqueduct::Worker::Config::DEFAULT_HANDLER = T.let(T.unsafe(nil), Proc)

# source://aqueduct-client//lib/aqueduct/worker/config.rb#225
Aqueduct::Worker::Config::DEFAULT_HEARTBEAT_CHECK_INTERVAL_SECONDS = T.let(T.unsafe(nil), Integer)

# source://aqueduct-client//lib/aqueduct/worker/config.rb#223
Aqueduct::Worker::Config::DEFAULT_HEARTBEAT_INTERVAL_SECONDS = T.let(T.unsafe(nil), Integer)

# source://aqueduct-client//lib/aqueduct/worker/config.rb#227
Aqueduct::Worker::Config::DEFAULT_INVALID_PAYLOAD_POLICY = T.let(T.unsafe(nil), Symbol)

# source://aqueduct-client//lib/aqueduct/worker/config.rb#219
Aqueduct::Worker::Config::DEFAULT_QUIESCE_CHECK = T.let(T.unsafe(nil), Proc)

# source://aqueduct-client//lib/aqueduct/worker/config.rb#221
Aqueduct::Worker::Config::DEFAULT_QUIESCE_CHECK_INTERVAL = T.let(T.unsafe(nil), Integer)

# source://aqueduct-client//lib/aqueduct/worker/config.rb#228
Aqueduct::Worker::Config::INVALID_PAYLOAD_POLICY_IGNORE = T.let(T.unsafe(nil), Symbol)

# source://aqueduct-client//lib/aqueduct/worker/config.rb#227
Aqueduct::Worker::Config::INVALID_PAYLOAD_POLICY_REJECT = T.let(T.unsafe(nil), Symbol)

# source://aqueduct-client//lib/aqueduct/worker/job.rb#3
class Aqueduct::Worker::Job
  # @return [Job] a new instance of Job
  #
  # source://aqueduct-client//lib/aqueduct/worker/job.rb#6
  def initialize(id:, app:, queue:, payload:, headers:, backend_name:, sent_at:); end

  # Returns the value of attribute app.
  #
  # source://aqueduct-client//lib/aqueduct/worker/job.rb#4
  def app; end

  # Returns the value of attribute backend_name.
  #
  # source://aqueduct-client//lib/aqueduct/worker/job.rb#4
  def backend_name; end

  # Returns the value of attribute headers.
  #
  # source://aqueduct-client//lib/aqueduct/worker/job.rb#4
  def headers; end

  # Returns the value of attribute id.
  #
  # source://aqueduct-client//lib/aqueduct/worker/job.rb#4
  def id; end

  # Returns the value of attribute payload.
  #
  # source://aqueduct-client//lib/aqueduct/worker/job.rb#4
  def payload; end

  # Returns the value of attribute queue.
  #
  # source://aqueduct-client//lib/aqueduct/worker/job.rb#4
  def queue; end

  # Returns the value of attribute sent_at.
  #
  # source://aqueduct-client//lib/aqueduct/worker/job.rb#4
  def sent_at; end

  # source://aqueduct-client//lib/aqueduct/worker/job.rb#16
  def to_s; end

  private

  # source://aqueduct-client//lib/aqueduct/worker/job.rb#22
  def truncated_payload; end
end

# A job was killed during processing by a hard shutdown.
#
# source://aqueduct-client//lib/aqueduct/worker/job_killed.rb#4
class Aqueduct::Worker::JobKilled < ::Exception; end

# Records the outcome of a job.
#
# source://aqueduct-client//lib/aqueduct/worker/job_status.rb#4
class Aqueduct::Worker::JobStatus
  # source://aqueduct-client//lib/aqueduct/worker/job_status.rb#14
  def error; end

  # source://aqueduct-client//lib/aqueduct/worker/job_status.rb#5
  def failed!(error = T.unsafe(nil)); end

  # @return [Boolean]
  #
  # source://aqueduct-client//lib/aqueduct/worker/job_status.rb#10
  def failed?; end
end

# source://aqueduct-client//lib/aqueduct/worker/result.rb#3
class Aqueduct::Worker::Result
  # @return [Result] a new instance of Result
  #
  # source://aqueduct-client//lib/aqueduct/worker/result.rb#22
  def initialize(value:, error:, invalid_payload: T.unsafe(nil), backend_name: T.unsafe(nil), backoff_seconds: T.unsafe(nil)); end

  # Returns the value of attribute backend_name.
  #
  # source://aqueduct-client//lib/aqueduct/worker/result.rb#20
  def backend_name; end

  # @return [Boolean]
  #
  # source://aqueduct-client//lib/aqueduct/worker/result.rb#46
  def backoff?; end

  # Returns the value of attribute backoff_seconds.
  #
  # source://aqueduct-client//lib/aqueduct/worker/result.rb#20
  def backoff_seconds; end

  # Returns the value of attribute error.
  #
  # source://aqueduct-client//lib/aqueduct/worker/result.rb#20
  def error; end

  # @return [Boolean]
  #
  # source://aqueduct-client//lib/aqueduct/worker/result.rb#38
  def error?; end

  # @return [Boolean]
  #
  # source://aqueduct-client//lib/aqueduct/worker/result.rb#50
  def has_backend_name?; end

  # @return [Boolean]
  #
  # source://aqueduct-client//lib/aqueduct/worker/result.rb#42
  def invalid_payload?; end

  # @return [Boolean]
  #
  # source://aqueduct-client//lib/aqueduct/worker/result.rb#30
  def ok?; end

  # @return [Boolean]
  #
  # source://aqueduct-client//lib/aqueduct/worker/result.rb#34
  def present?; end

  # Returns the value of attribute value.
  #
  # source://aqueduct-client//lib/aqueduct/worker/result.rb#20
  def value; end

  class << self
    # source://aqueduct-client//lib/aqueduct/worker/result.rb#8
    def empty(backend_name: T.unsafe(nil), backoff_seconds: T.unsafe(nil)); end

    # source://aqueduct-client//lib/aqueduct/worker/result.rb#12
    def error(error); end

    # source://aqueduct-client//lib/aqueduct/worker/result.rb#16
    def invalid_payload(value, backend_name: T.unsafe(nil)); end

    # source://aqueduct-client//lib/aqueduct/worker/result.rb#4
    def ok(value, backend_name: T.unsafe(nil), backoff_seconds: T.unsafe(nil)); end
  end
end

# source://aqueduct-client//lib/aqueduct/worker/switch.rb#5
class Aqueduct::Worker::Switch
  # @return [Switch] a new instance of Switch
  #
  # source://aqueduct-client//lib/aqueduct/worker/switch.rb#6
  def initialize(check:, interval:, logger:, reporter: T.unsafe(nil), now: T.unsafe(nil)); end

  # @return [Boolean]
  #
  # source://aqueduct-client//lib/aqueduct/worker/switch.rb#14
  def on?; end

  private

  # source://aqueduct-client//lib/aqueduct/worker/switch.rb#29
  def fire_check; end

  # @return [Boolean]
  #
  # source://aqueduct-client//lib/aqueduct/worker/switch.rb#25
  def stale?; end
end

# source://aqueduct-client//lib/aqueduct/worker/worker.rb#6
class Aqueduct::Worker::Worker
  # Public: Build a new aqueduct worker.
  #
  # backend - The Backend used for receiving and ACKing jobs (required).
  # queues  - An Array<String> of queues to receive from (required).
  # logger  - A Logger (required).
  # config  - An Aqueduct::Worker config to inject the job handler, error
  #           handler, callbacks, etc.
  #
  # @return [Worker] a new instance of Worker
  #
  # source://aqueduct-client//lib/aqueduct/worker/worker.rb#16
  def initialize(backend:, queues:, logger:, config: T.unsafe(nil)); end

  # Returns the value of attribute backend.
  #
  # source://aqueduct-client//lib/aqueduct/worker/worker.rb#7
  def backend; end

  # Returns the value of attribute config.
  #
  # source://aqueduct-client//lib/aqueduct/worker/worker.rb#7
  def config; end

  # Returns the value of attribute current_job.
  #
  # source://aqueduct-client//lib/aqueduct/worker/worker.rb#7
  def current_job; end

  # Returns the value of attribute current_job_started_at.
  #
  # source://aqueduct-client//lib/aqueduct/worker/worker.rb#7
  def current_job_started_at; end

  # source://aqueduct-client//lib/aqueduct/worker/worker.rb#150
  def id; end

  # source://aqueduct-client//lib/aqueduct/worker/worker.rb#146
  def inspect; end

  # Returns the value of attribute last_heartbeat_at.
  #
  # source://aqueduct-client//lib/aqueduct/worker/worker.rb#7
  def last_heartbeat_at; end

  # Returns the value of attribute logger.
  #
  # source://aqueduct-client//lib/aqueduct/worker/worker.rb#7
  def logger; end

  # Stop processing jobs after the current one has completed (if we're
  # currently running one).
  #
  # source://aqueduct-client//lib/aqueduct/worker/worker.rb#157
  def pause_processing; end

  # Returns the value of attribute queues.
  #
  # source://aqueduct-client//lib/aqueduct/worker/worker.rb#7
  def queues; end

  # @return [Boolean]
  #
  # source://aqueduct-client//lib/aqueduct/worker/worker.rb#142
  def send_heartbeat?; end

  # Schedule this worker for shutdown. Will finish processing the
  # current job.
  #
  # source://aqueduct-client//lib/aqueduct/worker/worker.rb#170
  def shutdown; end

  # Kill the child and shutdown immediately.
  # If not forking, abort this process.
  #
  # source://aqueduct-client//lib/aqueduct/worker/worker.rb#183
  def shutdown!(signal = T.unsafe(nil)); end

  # Should this worker shutdown as soon as current job is finished?
  #
  # @return [Boolean]
  #
  # source://aqueduct-client//lib/aqueduct/worker/worker.rb#177
  def shutdown?; end

  # source://aqueduct-client//lib/aqueduct/worker/worker.rb#117
  def start_heartbeat; end

  # source://aqueduct-client//lib/aqueduct/worker/worker.rb#138
  def stop_heartbeat; end

  # source://aqueduct-client//lib/aqueduct/worker/worker.rb#150
  def to_s; end

  # Start processing jobs again after a pause
  #
  # source://aqueduct-client//lib/aqueduct/worker/worker.rb#163
  def unpause_processing; end

  # source://aqueduct-client//lib/aqueduct/worker/worker.rb#46
  def work(interval = T.unsafe(nil), &block); end

  # source://aqueduct-client//lib/aqueduct/worker/worker.rb#42
  def worker_id; end

  private

  # chomp'd hostname of this worker's machine
  #
  # source://aqueduct-client//lib/aqueduct/worker/worker.rb#311
  def hostname; end

  # source://aqueduct-client//lib/aqueduct/worker/worker.rb#287
  def kill_child; end

  # are we paused?
  #
  # @return [Boolean]
  #
  # source://aqueduct-client//lib/aqueduct/worker/worker.rb#192
  def paused?; end

  # source://aqueduct-client//lib/aqueduct/worker/worker.rb#232
  def perform(job); end

  # source://aqueduct-client//lib/aqueduct/worker/worker.rb#255
  def perform_with_fork(job, &block); end

  # Given a status, sets the procline ($0) and logs.
  #
  # source://aqueduct-client//lib/aqueduct/worker/worker.rb#316
  def procline(status); end

  # @return [Boolean]
  #
  # source://aqueduct-client//lib/aqueduct/worker/worker.rb#196
  def quiesced?; end

  # Registers the various signal handlers a worker responds to.
  #
  # TERM: If terminating gracefully, shut down after the current job has
  #       been processed. Otherwise, shutdown immediately. Either way, don't
  #       process any new jobs.
  #  INT: Shutdown immediately, stop processing jobs.
  # QUIT: Shutdown after the current job has finished processing.
  # USR1: Kill the forked child immediately, continue processing jobs.
  # USR2: Don't process any new jobs
  # CONT: Start processing jobs again after a USR2
  #
  # source://aqueduct-client//lib/aqueduct/worker/worker.rb#210
  def register_signal_handlers; end

  # source://aqueduct-client//lib/aqueduct/worker/worker.rb#280
  def reject(job); end

  # source://aqueduct-client//lib/aqueduct/worker/worker.rb#226
  def validate_queues; end
end

# source://aqueduct-client//lib/aqueduct/worker/worker.rb#326
class Aqueduct::Worker::Worker::DirtyExit < ::RuntimeError; end

module Google::Protobuf::MessageExts::ClassMethods; end
