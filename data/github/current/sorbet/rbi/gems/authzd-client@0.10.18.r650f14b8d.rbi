# typed: false

# DO NOT EDIT MANUALLY
# This is an autogenerated file for types exported from the `authzd-client` gem.
# Please instead update this file by running `bin/tapioca gem authzd-client`.

# Define the Authzd namespace for generated Ruby
#
# source://authzd-client//ruby/lib/authzd/authorizer/client.rb#4
module Authzd; end

# source://authzd-client//ruby/lib/authzd/authorizer/client.rb#26
module Authzd::Authorizer; end

# source://authzd-client//ruby/lib/authzd/authorizer/client.rb#27
class Authzd::Authorizer::Client
  include ::Authzd::Decoratable

  # Initializes a new Client
  # - conn: the Faraday::Connection or the server address.
  #         If passed as String, the Faraday::Connection will be created with default configuration
  # - block: (optional) a block receiving this same instance that is used to initialize
  #   the middleware stack for this class services
  #
  # @return [Client] a new instance of Client
  # @yield [_self]
  # @yieldparam _self [Authzd::Authorizer::Client] the object that the method was called on
  #
  # source://authzd-client//ruby/lib/authzd/authorizer/client.rb#44
  def initialize(conn); end

  # Sends the given Authzd::Request to the server and returns a
  # Authzd::Proto::Decision denoting the result of evaluating the authorization
  # request.
  #
  # Params:
  # - request: an Authzd::Proto::Request describing the authorization check that
  # has to be performed by authzd.
  #
  # Retuns Authzd::Proto::Decision
  #
  # source://authzd-client//ruby/lib/authzd/authorizer/client.rb#59
  def authorize(request, metadata = T.unsafe(nil)); end

  # Sends the given Authzd::Proto::BatchRequest to the server and returns a
  # Authzd::Proto::BatchDecision denoting the result of evaluating the multiple
  # Authzd::Proto::Request
  #
  # Params:
  # - batch_request: an Authzd::Proto::BatchRequest describing the multiple authorization
  # checks that have to be performed by authzd.
  #
  # Retuns Authzd::Proto::BatchDecision
  #
  # @raise [EmptyBatchRequestError]
  #
  # source://authzd-client//ruby/lib/authzd/authorizer/client.rb#75
  def batch_authorize(batch_request, metadata = T.unsafe(nil)); end

  # Returns the value of attribute conn.
  #
  # source://authzd-client//ruby/lib/authzd/authorizer/client.rb#36
  def conn; end

  # Returns the value of attribute twirp_stub.
  #
  # source://authzd-client//ruby/lib/authzd/authorizer/client.rb#36
  def twirp_stub; end

  private

  # source://authzd-client//ruby/lib/authzd/authorizer/client.rb#85
  def twirp_error_to_indeterminate(twirp_response); end

  # changes Faraday timeout using a factor passed through metadata
  # unfortunately Ruby Twirp implementation does not allow
  # passing request specific parameters
  #
  # this is not thread safe
  #
  # source://authzd-client//ruby/lib/authzd/authorizer/client.rb#98
  def with_timeout_factor(metadata); end
end

# source://authzd-client//ruby/lib/authzd/authorizer/client.rb#30
class Authzd::Authorizer::Client::EmptyBatchRequestError < ::StandardError; end

# changes Faraday timeout by this factor for the provided request
# wont be forwarded as header
#
# source://authzd-client//ruby/lib/authzd/authorizer/client.rb#34
Authzd::Authorizer::Client::METADATA_TIMEOUT_FACTOR = T.let(T.unsafe(nil), String)

# source://authzd-client//ruby/lib/authzd/errors.rb#8
class Authzd::BatchError < ::Authzd::IndeterminateError
  # @return [BatchError] a new instance of BatchError
  #
  # source://authzd-client//ruby/lib/authzd/errors.rb#11
  def initialize(batch_request:); end

  # Returns the value of attribute request.
  #
  # source://authzd-client//ruby/lib/authzd/errors.rb#9
  def request; end
end

# source://authzd-client//ruby/lib/authzd/batch_response.rb#4
class Authzd::BatchResponse
  # @return [BatchResponse] a new instance of BatchResponse
  #
  # source://authzd-client//ruby/lib/authzd/batch_response.rb#16
  def initialize(batch_request, batch_decision, error); end

  # source://authzd-client//ruby/lib/authzd/batch_response.rb#39
  def [](key); end

  # distinguish a BatchResponse from Response without having
  # to check the class directly
  #
  # @return [Boolean]
  #
  # source://authzd-client//ruby/lib/authzd/batch_response.rb#45
  def batch?; end

  # Returns the value of attribute batch_decision.
  #
  # source://authzd-client//ruby/lib/authzd/batch_response.rb#5
  def batch_decision; end

  # Returns the value of attribute batch_request.
  #
  # source://authzd-client//ruby/lib/authzd/batch_response.rb#5
  def batch_request; end

  # source://authzd-client//ruby/lib/authzd/batch_response.rb#23
  def decisions; end

  # Returns the value of attribute error.
  #
  # source://authzd-client//ruby/lib/authzd/batch_response.rb#5
  def error; end

  # @return [Boolean]
  #
  # source://authzd-client//ruby/lib/authzd/batch_response.rb#35
  def error?; end

  # Returns the value of attribute map.
  #
  # source://authzd-client//ruby/lib/authzd/batch_response.rb#5
  def map; end

  # source://authzd-client//ruby/lib/authzd/batch_response.rb#31
  def requests; end

  # source://authzd-client//ruby/lib/authzd/batch_response.rb#27
  def responses; end

  private

  # source://authzd-client//ruby/lib/authzd/batch_response.rb#51
  def build_decision_map; end

  class << self
    # source://authzd-client//ruby/lib/authzd/batch_response.rb#61
    def create_batch_for_error(batch_request, error); end

    # source://authzd-client//ruby/lib/authzd/batch_response.rb#7
    def from_decision(batch_request, batch_decision); end

    # source://authzd-client//ruby/lib/authzd/batch_response.rb#11
    def from_error(batch_request, error); end
  end
end

# source://authzd-client//ruby/lib/authzd/decoratable.rb#7
module Authzd::Decoratable
  # source://authzd-client//ruby/lib/authzd/decoratable.rb#139
  def decorate(methods, with:); end

  # Decorators can be used to augment the client methods with custom features.
  # A middleware is object that has a `:request` accessor and can forward the
  # execution of `perform` to it. The following is an example of a middleware
  # implementing a read-through cache:
  #
  # ```ruby
  # class Cache
  #   attr_accessor :request
  #
  #   def initialize(cache, ttl)
  #     @cache = cache
  #     @ttl = ttl
  #   end
  #
  #   def perform(*args)
  #     @cache.fetch("authzd:client:v1:#{args.hash}", ttl: @ttl) do
  #       self.request.perform(*args)
  #     end
  #   end
  # end
  # ```
  #
  # You can use it to decorate a method in the Client, with a single middleware:
  #
  # ```ruby
  # authorizer = Authzd::Authorizer::Client.new(SERVER_ADDRESS, timeout: TIMEOUT_IN_SECONDS) do |client|
  #   client.decorate :authorize, with: Cache.new(App.cache, App.config.ttl)
  # end
  # ```
  #
  # Or with a stack of method_middleware that are applied from the left (outermost middleware)
  # to the right (innermost middleware)
  #
  # ```ruby
  # authorizer = Authzd::Authorizer::Client.new(SERVER_ADDRESS, timeout: TIMEOUT_IN_SECONDS) do |client|
  #   client.decorate :authorize, with: [logging, instrumentation, caching]
  # end
  # ```
  # Internally this method, will transform the singleton class (aka eigenclass)
  # of the receiver object converting every decorated method
  # Imagine the following class:
  #
  # class MyClass
  #   def hello(name)
  #     puts "hello #{name}"
  #   end
  #
  #   def self.decoratable_methods
  #     [:foo]
  #   end
  # end
  #
  # When the Decoratable module is included, the class will in memory be transformed
  # into something like this:
  #
  # class MyClass
  #
  #   def original_hello(name)
  #     puts "hello #{name}"
  #   end
  #
  #   def hello(*args)
  #     decorated(:hello).perform(*args)
  #   end
  #
  #   ... Rest of the methods of Decoratable
  # end
  #
  # And `decorated(:hello)`, whill generate an object responding to `:perform`
  # that has all the method_middleware properly composed, and terminated by a wrapper
  # of the original method.
  #
  # In the previous example:
  #
  # ```ruby
  # authorizer = Authzd::Authorizer::Client.new(SERVER_ADDRESS, timeout: TIMEOUT_IN_SECONDS) do |client|
  #   client.decorate :authorize, with: [logging, instrumentation, caching]
  # end
  # ```
  #
  # when we call `authorizer.authorize Request.new` the following set of calls
  # will happen
  #
  # authorizer.authorize(kwargs)
  #  logging logic before decoration
  #  logging.request.perform(kwargs)
  #    instrumentation logic before decoration
  #    instrumentation.request.perform(kwargs)
  #      caching logic before decoration
  #      caching.request.perform(kwargs)
  #        anonymous_object.perform(kwargs)
  #           authorizer.send :original_authorize, kwargs
  #      caching logic after decoration
  #     instrumentation logic after decoration
  #   logging loggic after decoration
  # return result value
  #
  # source://authzd-client//ruby/lib/authzd/decoratable.rb#121
  def use(methods, with:); end

  private

  # Composes the decorated version of the original method. And chaches it in memory
  # for future uses.
  #
  # source://authzd-client//ruby/lib/authzd/decoratable.rb#200
  def decorated(method); end

  # Hash where keys are method names and values the objects resulting
  # of applying the middleware to the methods. A decorated method is a callable
  # that composes the middleware around the original method.
  #
  # This information can be re-created from @method_middleware, but itÂ´s cached in
  #
  # source://authzd-client//ruby/lib/authzd/decoratable.rb#224
  def decorated_methods; end

  # Gets the singleton class of the decoratable instance so methods are
  # overriden only for the particular instance being decorated, and not
  # for all the instance of the class that includes this module
  #
  # source://authzd-client//ruby/lib/authzd/decoratable.rb#193
  def eigenclass; end

  # Hash where keys are the method names and values the list of middleware
  # to apply to the methods being decorated.
  #
  # source://authzd-client//ruby/lib/authzd/decoratable.rb#231
  def method_middleware; end

  # Parses a middleware from a class and a set of args
  #
  # source://authzd-client//ruby/lib/authzd/decoratable.rb#181
  def middleware_from_class_and_args(middleware_spec); end

  # Parses a middleware from a middleware instance
  #
  # source://authzd-client//ruby/lib/authzd/decoratable.rb#172
  def middleware_from_instance(middleware_spec); end

  # Determines whether a certain middleware instance has already been used
  #
  # @return [Boolean]
  #
  # source://authzd-client//ruby/lib/authzd/decoratable.rb#245
  def middleware_used?(middleware); end

  # A middleware can be a list of one or more of:
  # - a list containing a middleware class and its initialize args to build
  # a new middleware instance
  # - an instance of a middleware class.
  #
  # This method caches the list of middleware applied to each method in the
  # method_middleware member.
  #
  # @raise [Authzd::DecorationError]
  #
  # source://authzd-client//ruby/lib/authzd/decoratable.rb#154
  def register_middleware_for_method(method, middleware_spec); end

  # Caches a middleware instance. This is used to prevent a given instance
  # from decorating more than one decoratable.
  # This is necessary because middleware are stateful: they keep a reference
  # to the next middleware in the chain
  #
  # source://authzd-client//ruby/lib/authzd/decoratable.rb#239
  def use_middleware!(middleware); end
end

# Wraps the original method into an object that has the middleware spec
# of responding to .perform.
#
# source://authzd-client//ruby/lib/authzd/decoratable.rb#12
class Authzd::Decoratable::Adapter
  # @return [Adapter] a new instance of Adapter
  #
  # source://authzd-client//ruby/lib/authzd/decoratable.rb#13
  def initialize(receiver, method); end

  # source://authzd-client//ruby/lib/authzd/decoratable.rb#18
  def perform(*args); end
end

# source://authzd-client//ruby/lib/authzd/errors.rb#5
class Authzd::DecorationError < ::Authzd::Error; end

# source://authzd-client//ruby/lib/authzd/proto/enumerator_pb.rb#35
module Authzd::Enumerator; end

# source://authzd-client//ruby/lib/authzd/enumerator/client.rb#14
class Authzd::Enumerator::Client
  include ::Authzd::Decoratable

  # Initializes a new Client
  # - conn: the Faraday::Connection or the server address.
  #         If passed as String, the Faraday::Connection will be created with default configuration
  # - block: (optional) a block receiving this same instance that is used to initialize
  #   the middleware stack for this class services
  #
  # @return [Client] a new instance of Client
  # @yield [_self]
  # @yieldparam _self [Authzd::Enumerator::Client] the object that the method was called on
  #
  # source://authzd-client//ruby/lib/authzd/enumerator/client.rb#25
  def initialize(conn); end

  # Returns the value of attribute conn.
  #
  # source://authzd-client//ruby/lib/authzd/enumerator/client.rb#17
  def conn; end

  # Forwards the actor's subject enumeration request to the server.
  #
  # Params:
  # - request: an Authzd::Enumerator::ForActorRequest describing the
  #            types of subjects that we want to enumerate for the actor.
  #
  # Retuns Authzd::Enumerator::ForActorResponse
  #
  # source://authzd-client//ruby/lib/authzd/enumerator/client.rb#38
  def for_actor(request, metadata = T.unsafe(nil)); end

  # Forwards the subject's actor enumeration request to the server.
  #
  # Params:
  # - request: an Authzd::Enumerator::ForSubjectRequest describing the
  #            types of actors that we want to enumerate for the subject.
  #
  # Retuns Authzd::Enumerator::ForSubjectResponse
  #
  # source://authzd-client//ruby/lib/authzd/enumerator/client.rb#49
  def for_subject(request, metadata = T.unsafe(nil)); end

  # Returns the value of attribute twirp_stub.
  #
  # source://authzd-client//ruby/lib/authzd/enumerator/client.rb#17
  def twirp_stub; end
end

# source://authzd-client//ruby/lib/authzd/proto/enumerator_twirp.rb#14
class Authzd::Enumerator::EnumeratorClient < ::Twirp::Client
  # source://twirp/1.10.0/lib/twirp/client.rb#42
  def for_actor(input, req_opts = T.unsafe(nil)); end

  # source://twirp/1.10.0/lib/twirp/client.rb#42
  def for_subject(input, req_opts = T.unsafe(nil)); end
end

# source://authzd-client//ruby/lib/authzd/proto/enumerator_twirp.rb#7
class Authzd::Enumerator::EnumeratorService < ::Twirp::Service; end

# source://authzd-client//ruby/lib/authzd/proto/request_extensions.rb#26
class Authzd::Enumerator::ForActorRequest
  include ::Google::Protobuf::MessageExts
  extend ::Google::Protobuf::MessageExts::ClassMethods

  def initialize(*_arg0); end

  def ==(_arg0); end
  def [](_arg0); end
  def []=(_arg0, _arg1); end

  # @return [Boolean]
  #
  # source://authzd-client//ruby/lib/authzd/proto/request_extensions.rb#31
  def batch?; end

  def clone; end
  def dup; end
  def eql?(_arg0); end
  def hash; end
  def inspect; end
  def method_missing(*_arg0); end

  # source://authzd-client//ruby/lib/authzd/proto/request_extensions.rb#27
  def rpc_name; end

  def to_h; end
  def to_s; end

  private

  def respond_to_missing?(*_arg0); end

  class << self
    def decode(_arg0); end
    def decode_json(*_arg0); end
    def descriptor; end
    def encode(_arg0); end
    def encode_json(*_arg0); end
  end
end

class Authzd::Enumerator::ForActorResponse
  include ::Google::Protobuf::MessageExts
  extend ::Google::Protobuf::MessageExts::ClassMethods

  def initialize(*_arg0); end

  def ==(_arg0); end
  def [](_arg0); end
  def []=(_arg0, _arg1); end
  def clone; end
  def dup; end
  def eql?(_arg0); end
  def hash; end
  def inspect; end
  def method_missing(*_arg0); end
  def to_h; end
  def to_s; end

  private

  def respond_to_missing?(*_arg0); end

  class << self
    def decode(_arg0); end
    def decode_json(*_arg0); end
    def descriptor; end
    def encode(_arg0); end
    def encode_json(*_arg0); end
  end
end

# source://authzd-client//ruby/lib/authzd/proto/request_extensions.rb#16
class Authzd::Enumerator::ForSubjectRequest
  include ::Google::Protobuf::MessageExts
  extend ::Google::Protobuf::MessageExts::ClassMethods

  def initialize(*_arg0); end

  def ==(_arg0); end
  def [](_arg0); end
  def []=(_arg0, _arg1); end

  # @return [Boolean]
  #
  # source://authzd-client//ruby/lib/authzd/proto/request_extensions.rb#21
  def batch?; end

  def clone; end
  def dup; end
  def eql?(_arg0); end
  def hash; end
  def inspect; end
  def method_missing(*_arg0); end

  # source://authzd-client//ruby/lib/authzd/proto/request_extensions.rb#17
  def rpc_name; end

  def to_h; end
  def to_s; end

  private

  def respond_to_missing?(*_arg0); end

  class << self
    def decode(_arg0); end
    def decode_json(*_arg0); end
    def descriptor; end
    def encode(_arg0); end
    def encode_json(*_arg0); end
  end
end

class Authzd::Enumerator::ForSubjectResponse
  include ::Google::Protobuf::MessageExts
  extend ::Google::Protobuf::MessageExts::ClassMethods

  def initialize(*_arg0); end

  def ==(_arg0); end
  def [](_arg0); end
  def []=(_arg0, _arg1); end
  def clone; end
  def dup; end
  def eql?(_arg0); end
  def hash; end
  def inspect; end
  def method_missing(*_arg0); end
  def to_h; end
  def to_s; end

  private

  def respond_to_missing?(*_arg0); end

  class << self
    def decode(_arg0); end
    def decode_json(*_arg0); end
    def descriptor; end
    def encode(_arg0); end
    def encode_json(*_arg0); end
  end
end

class Authzd::Enumerator::Options
  include ::Google::Protobuf::MessageExts
  extend ::Google::Protobuf::MessageExts::ClassMethods

  def initialize(*_arg0); end

  def ==(_arg0); end
  def [](_arg0); end
  def []=(_arg0, _arg1); end
  def clone; end
  def dup; end
  def eql?(_arg0); end
  def hash; end
  def inspect; end
  def method_missing(*_arg0); end
  def to_h; end
  def to_s; end

  private

  def respond_to_missing?(*_arg0); end

  class << self
    def decode(_arg0); end
    def decode_json(*_arg0); end
    def descriptor; end
    def encode(_arg0); end
    def encode_json(*_arg0); end
  end
end

# source://authzd-client//ruby/lib/authzd/errors.rb#4
class Authzd::Error < ::StandardError; end

# source://authzd-client//ruby/lib/authzd/errors.rb#6
class Authzd::IndeterminateError < ::Authzd::Error; end

# source://authzd-client//ruby/lib/authzd/middleware/instrumenters/noop.rb#4
module Authzd::Middleware; end

# source://authzd-client//ruby/lib/authzd/middleware/base.rb#7
class Authzd::Middleware::Base
  # source://authzd-client//ruby/lib/authzd/middleware/base.rb#11
  def instrument(op, payload = T.unsafe(nil), &block); end

  # Returns the value of attribute request.
  #
  # source://authzd-client//ruby/lib/authzd/middleware/base.rb#9
  def request; end

  # Sets the attribute request
  #
  # @param value the value to set the attribute request to.
  #
  # source://authzd-client//ruby/lib/authzd/middleware/base.rb#9
  def request=(_arg0); end

  protected

  # @raise [NotImplementedError]
  #
  # source://authzd-client//ruby/lib/authzd/middleware/base.rb#18
  def middleware_name; end

  private

  # source://authzd-client//ruby/lib/authzd/middleware/base.rb#24
  def expand_instrument_name(op); end
end

# source://authzd-client//ruby/lib/authzd/middleware/circuit_breaker.rb#8
class Authzd::Middleware::CircuitBreaker < ::Authzd::Middleware::Base
  # Initializes a new instance of the middleware
  # - circuit_name will be used to determine the circuit breaker name
  # which by default will be DEFAULT_CIRCUIT_NAME
  # - options, a Hash of options to pass when building the circuit breaker
  #
  # @return [CircuitBreaker] a new instance of CircuitBreaker
  #
  # source://authzd-client//ruby/lib/authzd/middleware/circuit_breaker.rb#19
  def initialize(instrumenter: T.unsafe(nil), circuit_name: T.unsafe(nil), **options); end

  # Applies circuit breakers to request.perform
  #
  # source://authzd-client//ruby/lib/authzd/middleware/circuit_breaker.rb#26
  def perform(req, metadata = T.unsafe(nil)); end

  # Returns the value of attribute request.
  #
  # source://authzd-client//ruby/lib/authzd/middleware/circuit_breaker.rb#12
  def request; end

  # Sets the attribute request
  #
  # @param value the value to set the attribute request to.
  #
  # source://authzd-client//ruby/lib/authzd/middleware/circuit_breaker.rb#12
  def request=(_arg0); end

  protected

  # source://authzd-client//ruby/lib/authzd/middleware/circuit_breaker.rb#47
  def middleware_name; end

  private

  # source://authzd-client//ruby/lib/authzd/middleware/circuit_breaker.rb#53
  def circuit; end
end

# source://authzd-client//ruby/lib/authzd/middleware/circuit_breaker.rb#9
class Authzd::Middleware::CircuitBreaker::CircuitOpenError < ::Authzd::Error; end

# source://authzd-client//ruby/lib/authzd/middleware/circuit_breaker.rb#10
Authzd::Middleware::CircuitBreaker::DEFAULT_CIRCUIT_NAME = T.let(T.unsafe(nil), String)

# source://authzd-client//ruby/lib/authzd/middleware/hmac_signature.rb#8
class Authzd::Middleware::HmacSignature < ::Authzd::Middleware::Base
  # Initializes a new instance of the middleware
  #
  # @return [HmacSignature] a new instance of HmacSignature
  #
  # source://authzd-client//ruby/lib/authzd/middleware/hmac_signature.rb#15
  def initialize(key:, instrumenter: T.unsafe(nil)); end

  # Generates and adds the HMAC header based on the passed in key
  #
  # source://authzd-client//ruby/lib/authzd/middleware/hmac_signature.rb#23
  def perform(req, metadata = T.unsafe(nil)); end

  protected

  # source://authzd-client//ruby/lib/authzd/middleware/hmac_signature.rb#30
  def middleware_name; end

  private

  # source://authzd-client//ruby/lib/authzd/middleware/hmac_signature.rb#41
  def header_timestamp; end

  # source://authzd-client//ruby/lib/authzd/middleware/hmac_signature.rb#36
  def request_hmac; end
end

# source://authzd-client//ruby/lib/authzd/middleware/hmac_signature.rb#10
Authzd::Middleware::HmacSignature::ALGORITHM = T.let(T.unsafe(nil), String)

# source://authzd-client//ruby/lib/authzd/middleware/hmac_signature.rb#11
Authzd::Middleware::HmacSignature::HMAC_HEADER = T.let(T.unsafe(nil), String)

# source://authzd-client//ruby/lib/authzd/middleware/instrumenters/noop.rb#5
module Authzd::Middleware::Instrumenters; end

# source://authzd-client//ruby/lib/authzd/middleware/instrumenters/noop.rb#6
class Authzd::Middleware::Instrumenters::Noop
  class << self
    # @yield [payload]
    #
    # source://authzd-client//ruby/lib/authzd/middleware/instrumenters/noop.rb#7
    def instrument(name, payload = T.unsafe(nil)); end
  end
end

# source://authzd-client//ruby/lib/authzd/middleware/response_wrapper.rb#7
class Authzd::Middleware::ResponseWrapper < ::Authzd::Middleware::Base
  # Initializes a new instance of the middleware
  #
  # @return [ResponseWrapper] a new instance of ResponseWrapper
  #
  # source://authzd-client//ruby/lib/authzd/middleware/response_wrapper.rb#11
  def initialize(instrumenter: T.unsafe(nil), **_); end

  # Wraps the response returned from the next middleware into a
  # Authzd::Proto::Result object
  #
  # source://authzd-client//ruby/lib/authzd/middleware/response_wrapper.rb#17
  def perform(req, metadata = T.unsafe(nil)); end

  protected

  # source://authzd-client//ruby/lib/authzd/middleware/response_wrapper.rb#27
  def middleware_name; end

  # source://authzd-client//ruby/lib/authzd/middleware/response_wrapper.rb#31
  def perform_authorize(req, metadata); end

  # source://authzd-client//ruby/lib/authzd/middleware/response_wrapper.rb#40
  def perform_batch_authorize(batch_req, metadata); end
end

# source://authzd-client//ruby/lib/authzd/middleware/retry.rb#7
class Authzd::Middleware::Retry < ::Authzd::Middleware::Base
  # Initializes a new instance of the middleware
  # - max_attempts an integer representing how many times the middleware
  # will retry the request, in case it keeps failing.
  # - retryable_errors, an array of exception classes to rescue and retry
  # - options, a Hash of options to pass when building the Retry middleware
  # - options[:instrumenter] an object responding to `instrument` for the purpose of
  #  having observability about the events happening in the middelware.
  # - options[:wait_seconds] a float representing the time to wait (by calling
  # `sleep`) between tries
  #
  # @return [Retry] a new instance of Retry
  #
  # source://authzd-client//ruby/lib/authzd/middleware/retry.rb#23
  def initialize(instrumenter: T.unsafe(nil), max_attempts: T.unsafe(nil), retryable_errors: T.unsafe(nil), **options); end

  # Applies retry logic to request execution
  #
  # source://authzd-client//ruby/lib/authzd/middleware/retry.rb#35
  def perform(req, metadata = T.unsafe(nil)); end

  protected

  # source://authzd-client//ruby/lib/authzd/middleware/retry.rb#84
  def middleware_name; end

  private

  # given a map of Request to Decision, it returns a BatchRequest containing
  # the requests for those decisions that are INDETERMINATE and need to be retried
  #
  # source://authzd-client//ruby/lib/authzd/middleware/retry.rb#123
  def batch_for_indeterminates(map); end

  # source://authzd-client//ruby/lib/authzd/middleware/retry.rb#139
  def get_batch_indeterminates(mapped_batch); end

  # given a map of Request to Decision, and a reference BatchRequest,
  # it creates a BatchDecision containing the decisions from the map, but
  # respecting the order of the reference BatchRequest
  #
  # source://authzd-client//ruby/lib/authzd/middleware/retry.rb#113
  def map_to_batch_decision(batch_map, original_request); end

  # updates the map representing the original BatchRequest with the intermediate BatchRequest and BatchResponse
  # that result from retrying. If there are indeterminate Decisions, it raises an exception
  # that carries new BatchRequest to retry.
  #
  # @raise [Authzd::BatchError]
  #
  # source://authzd-client//ruby/lib/authzd/middleware/retry.rb#93
  def merge_and_raise(original_mapped_batch, req, res); end

  # given a target map of Request to Decision, it merges the decisions from the source map
  # into the target map. This is done by match map keys.
  #
  # source://authzd-client//ruby/lib/authzd/middleware/retry.rb#102
  def merge_decisions(target, source); end

  # Returns a batch request that contains only elements that failed
  # in the previous batch request: we don't want to retry what succeeded.
  #
  # if the request is not a batch, it is returned as-is
  #
  # source://authzd-client//ruby/lib/authzd/middleware/retry.rb#132
  def request_to_retry(req, err); end
end

# source://authzd-client//ruby/lib/authzd/middleware/retry.rb#9
Authzd::Middleware::Retry::DEFAULT_MAX_ATTEMPTS = T.let(T.unsafe(nil), Integer)

# source://authzd-client//ruby/lib/authzd/middleware/retry.rb#10
Authzd::Middleware::Retry::DEFAULT_RETRYABLE_ERRORS = T.let(T.unsafe(nil), Array)

# source://authzd-client//ruby/lib/authzd/middleware/retry.rb#11
Authzd::Middleware::Retry::INTERNAL_METADATA_TIMEOUT_FACTOR = T.let(T.unsafe(nil), String)

# source://authzd-client//ruby/lib/authzd/middleware/timing.rb#7
class Authzd::Middleware::Timing < ::Authzd::Middleware::Base
  # @return [Timing] a new instance of Timing
  #
  # source://authzd-client//ruby/lib/authzd/middleware/timing.rb#9
  def initialize(instrumenter: T.unsafe(nil)); end

  # source://authzd-client//ruby/lib/authzd/middleware/timing.rb#13
  def perform(req, metadata = T.unsafe(nil)); end

  protected

  # source://authzd-client//ruby/lib/authzd/middleware/timing.rb#23
  def middleware_name; end
end

# source://authzd-client//ruby/lib/authzd/proto/authorizer_pb.rb#53
module Authzd::Proto; end

# source://authzd-client//ruby/lib/authzd/proto/proto_extensions.rb#6
class Authzd::Proto::Attribute
  include ::Google::Protobuf::MessageExts
  extend ::Google::Protobuf::MessageExts::ClassMethods

  def initialize(*_arg0); end

  def ==(_arg0); end
  def [](_arg0); end
  def []=(_arg0, _arg1); end
  def clone; end
  def dup; end
  def eql?(_arg0); end
  def hash; end
  def inspect; end
  def method_missing(*_arg0); end
  def to_h; end
  def to_s; end

  # source://authzd-client//ruby/lib/authzd/proto/proto_extensions.rb#11
  def unwrapped_value; end

  private

  def respond_to_missing?(*_arg0); end

  class << self
    def decode(_arg0); end
    def decode_json(*_arg0); end
    def descriptor; end
    def encode(_arg0); end
    def encode_json(*_arg0); end

    # source://authzd-client//ruby/lib/authzd/proto/proto_extensions.rb#7
    def wrap(id, value); end
  end
end

# source://authzd-client//ruby/lib/authzd/proto/authorizer_twirp.rb#14
class Authzd::Proto::AuthorizerClient < ::Twirp::Client
  # source://twirp/1.10.0/lib/twirp/client.rb#42
  def authorize(input, req_opts = T.unsafe(nil)); end

  # source://twirp/1.10.0/lib/twirp/client.rb#42
  def batch_authorize(input, req_opts = T.unsafe(nil)); end
end

# source://authzd-client//ruby/lib/authzd/proto/authorizer_twirp.rb#7
class Authzd::Proto::AuthorizerService < ::Twirp::Service; end

# source://authzd-client//ruby/lib/authzd/proto/batch_extensions.rb#14
class Authzd::Proto::BatchDecision
  include ::Google::Protobuf::MessageExts
  extend ::Google::Protobuf::MessageExts::ClassMethods

  def initialize(*_arg0); end

  def ==(_arg0); end
  def [](_arg0); end
  def []=(_arg0, _arg1); end

  # @return [Boolean]
  #
  # source://authzd-client//ruby/lib/authzd/proto/batch_extensions.rb#15
  def batch?; end

  def clone; end
  def dup; end
  def eql?(_arg0); end
  def hash; end
  def inspect; end

  # Given a reference batch_request, returns a map from Request to Decision.
  #
  # The map happens on the assumption that requests and decisions map to each other
  # by order in the array. i.e, request[0] is mapped to decision[0]
  #
  # source://authzd-client//ruby/lib/authzd/proto/batch_extensions.rb#23
  def map_to_requests(batch_request); end

  def method_missing(*_arg0); end
  def to_h; end
  def to_s; end

  private

  def respond_to_missing?(*_arg0); end

  class << self
    def decode(_arg0); end
    def decode_json(*_arg0); end
    def descriptor; end
    def encode(_arg0); end
    def encode_json(*_arg0); end
  end
end

# source://authzd-client//ruby/lib/authzd/proto/batch_extensions.rb#4
class Authzd::Proto::BatchRequest
  include ::Google::Protobuf::MessageExts
  extend ::Google::Protobuf::MessageExts::ClassMethods

  def initialize(*_arg0); end

  def ==(_arg0); end
  def [](_arg0); end
  def []=(_arg0, _arg1); end

  # @return [Boolean]
  #
  # source://authzd-client//ruby/lib/authzd/proto/batch_extensions.rb#9
  def batch?; end

  def clone; end
  def dup; end
  def eql?(_arg0); end
  def hash; end
  def inspect; end
  def method_missing(*_arg0); end

  # source://authzd-client//ruby/lib/authzd/proto/batch_extensions.rb#5
  def rpc_name; end

  def to_h; end
  def to_s; end

  private

  def respond_to_missing?(*_arg0); end

  class << self
    def decode(_arg0); end
    def decode_json(*_arg0); end
    def descriptor; end
    def encode(_arg0); end
    def encode_json(*_arg0); end
  end
end

# source://authzd-client//ruby/lib/authzd/proto/decision_extensions.rb#4
class Authzd::Proto::Decision
  include ::Google::Protobuf::MessageExts
  extend ::Google::Protobuf::MessageExts::ClassMethods

  def initialize(*_arg0); end

  def ==(_arg0); end
  def [](_arg0); end
  def []=(_arg0, _arg1); end

  # Returns true if result is ALLOW
  #
  # @return [Boolean]
  #
  # source://authzd-client//ruby/lib/authzd/proto/decision_extensions.rb#34
  def allow?; end

  # @return [Boolean]
  #
  # source://authzd-client//ruby/lib/authzd/proto/decision_extensions.rb#47
  def batch?; end

  def clone; end
  def dup; end
  def eql?(_arg0); end
  def hash; end

  # Returns true if result is INDETERMINATE
  #
  # @return [Boolean]
  #
  # source://authzd-client//ruby/lib/authzd/proto/decision_extensions.rb#39
  def indeterminate?; end

  def inspect; end
  def method_missing(*_arg0); end

  # @return [Boolean]
  #
  # source://authzd-client//ruby/lib/authzd/proto/decision_extensions.rb#43
  def not_applicable?; end

  def to_h; end
  def to_s; end

  private

  def respond_to_missing?(*_arg0); end

  class << self
    # source://authzd-client//ruby/lib/authzd/proto/decision_extensions.rb#5
    def allow; end

    def decode(_arg0); end
    def decode_json(*_arg0); end

    # source://authzd-client//ruby/lib/authzd/proto/decision_extensions.rb#12
    def deny(reason: T.unsafe(nil)); end

    def descriptor; end
    def encode(_arg0); end
    def encode_json(*_arg0); end

    # source://authzd-client//ruby/lib/authzd/proto/decision_extensions.rb#26
    def indeterminate(reason: T.unsafe(nil)); end

    # source://authzd-client//ruby/lib/authzd/proto/decision_extensions.rb#19
    def not_applicable(reason: T.unsafe(nil)); end
  end
end

class Authzd::Proto::IntegerList
  include ::Google::Protobuf::MessageExts
  extend ::Google::Protobuf::MessageExts::ClassMethods

  def initialize(*_arg0); end

  def ==(_arg0); end
  def [](_arg0); end
  def []=(_arg0, _arg1); end
  def clone; end
  def dup; end
  def eql?(_arg0); end
  def hash; end
  def inspect; end
  def method_missing(*_arg0); end
  def to_h; end
  def to_s; end

  private

  def respond_to_missing?(*_arg0); end

  class << self
    def decode(_arg0); end
    def decode_json(*_arg0); end
    def descriptor; end
    def encode(_arg0); end
    def encode_json(*_arg0); end
  end
end

# source://authzd-client//ruby/lib/authzd/proto/request_extensions.rb#4
class Authzd::Proto::Request
  include ::Google::Protobuf::MessageExts
  extend ::Google::Protobuf::MessageExts::ClassMethods

  def initialize(*_arg0); end

  def ==(_arg0); end
  def [](_arg0); end
  def []=(_arg0, _arg1); end

  # @return [Boolean]
  #
  # source://authzd-client//ruby/lib/authzd/proto/request_extensions.rb#9
  def batch?; end

  def clone; end
  def dup; end
  def eql?(_arg0); end
  def hash; end
  def inspect; end
  def method_missing(*_arg0); end

  # source://authzd-client//ruby/lib/authzd/proto/request_extensions.rb#5
  def rpc_name; end

  def to_h; end
  def to_s; end

  private

  def respond_to_missing?(*_arg0); end

  class << self
    def decode(_arg0); end
    def decode_json(*_arg0); end
    def descriptor; end
    def encode(_arg0); end
    def encode_json(*_arg0); end
  end
end

module Authzd::Proto::Result
  class << self
    def descriptor; end
    def lookup(_arg0); end
    def resolve(_arg0); end
  end
end

# source://authzd-client//ruby/lib/authzd/proto/authorizer_pb.rb#62
Authzd::Proto::Result::ALLOW = T.let(T.unsafe(nil), Integer)

# source://authzd-client//ruby/lib/authzd/proto/authorizer_pb.rb#62
Authzd::Proto::Result::DENY = T.let(T.unsafe(nil), Integer)

# source://authzd-client//ruby/lib/authzd/proto/authorizer_pb.rb#62
Authzd::Proto::Result::INDETERMINATE = T.let(T.unsafe(nil), Integer)

# source://authzd-client//ruby/lib/authzd/proto/authorizer_pb.rb#62
Authzd::Proto::Result::NOT_APPLICABLE = T.let(T.unsafe(nil), Integer)

class Authzd::Proto::StringList
  include ::Google::Protobuf::MessageExts
  extend ::Google::Protobuf::MessageExts::ClassMethods

  def initialize(*_arg0); end

  def ==(_arg0); end
  def [](_arg0); end
  def []=(_arg0, _arg1); end
  def clone; end
  def dup; end
  def eql?(_arg0); end
  def hash; end
  def inspect; end
  def method_missing(*_arg0); end
  def to_h; end
  def to_s; end

  private

  def respond_to_missing?(*_arg0); end

  class << self
    def decode(_arg0); end
    def decode_json(*_arg0); end
    def descriptor; end
    def encode(_arg0); end
    def encode_json(*_arg0); end
  end
end

# source://authzd-client//ruby/lib/authzd/proto/proto_extensions.rb#16
class Authzd::Proto::Value
  include ::Google::Protobuf::MessageExts
  extend ::Google::Protobuf::MessageExts::ClassMethods

  def initialize(*_arg0); end

  def ==(_arg0); end
  def [](_arg0); end
  def []=(_arg0, _arg1); end
  def clone; end
  def dup; end
  def eql?(_arg0); end
  def hash; end
  def inspect; end
  def method_missing(*_arg0); end

  # source://authzd-client//ruby/lib/authzd/proto/proto_extensions.rb#99
  def to_f; end

  def to_h; end

  # source://authzd-client//ruby/lib/authzd/proto/proto_extensions.rb#95
  def to_i; end

  # source://authzd-client//ruby/lib/authzd/proto/proto_extensions.rb#87
  def to_s; end

  # source://authzd-client//ruby/lib/authzd/proto/proto_extensions.rb#91
  def to_sym; end

  # source://authzd-client//ruby/lib/authzd/proto/proto_extensions.rb#74
  def unwrap; end

  private

  def respond_to_missing?(*_arg0); end

  class << self
    def decode(_arg0); end
    def decode_json(*_arg0); end
    def descriptor; end
    def encode(_arg0); end
    def encode_json(*_arg0); end

    # source://authzd-client//ruby/lib/authzd/proto/proto_extensions.rb#19
    def wrap(value, empty_list_target: T.unsafe(nil)); end

    private

    # source://authzd-client//ruby/lib/authzd/proto/proto_extensions.rb#55
    def wrap_empty_list(value, empty_list_target); end

    # source://authzd-client//ruby/lib/authzd/proto/proto_extensions.rb#63
    def wrap_integer_list(value, list); end

    # source://authzd-client//ruby/lib/authzd/proto/proto_extensions.rb#42
    def wrap_list(value, list, empty_list_target); end

    # source://authzd-client//ruby/lib/authzd/proto/proto_extensions.rb#68
    def wrap_string_list(value, list); end
  end
end

# source://authzd-client//ruby/lib/authzd/response.rb#6
class Authzd::Response
  # @return [Response] a new instance of Response
  #
  # source://authzd-client//ruby/lib/authzd/response.rb#18
  def initialize(decision, error); end

  # source://authzd-client//ruby/lib/authzd/response.rb#51
  def ==(other); end

  # @return [Boolean]
  #
  # source://authzd-client//ruby/lib/authzd/response.rb#23
  def allow?; end

  # source://authzd-client//ruby/lib/authzd/response.rb#67
  def as_json(options = T.unsafe(nil)); end

  # distinguish a BatchResponse from Response without having
  # to check the class directly
  #
  # @return [Boolean]
  #
  # source://authzd-client//ruby/lib/authzd/response.rb#57
  def batch?; end

  # Returns the value of attribute decision.
  #
  # source://authzd-client//ruby/lib/authzd/response.rb#8
  def decision; end

  # @return [Boolean]
  #
  # source://authzd-client//ruby/lib/authzd/response.rb#27
  def deny?; end

  # Returns the value of attribute error.
  #
  # source://authzd-client//ruby/lib/authzd/response.rb#8
  def error; end

  # @return [Boolean]
  #
  # source://authzd-client//ruby/lib/authzd/response.rb#31
  def error?; end

  # @return [Boolean]
  #
  # source://authzd-client//ruby/lib/authzd/response.rb#39
  def indeterminate?; end

  # @return [Boolean]
  #
  # source://authzd-client//ruby/lib/authzd/response.rb#35
  def not_applicable?; end

  # source://authzd-client//ruby/lib/authzd/response.rb#47
  def reason; end

  # source://authzd-client//ruby/lib/authzd/response.rb#43
  def result; end

  # Manually generate the JSON representation of the Response
  # see https://github.com/github/authzd/issues/760
  #
  # source://authzd-client//ruby/lib/authzd/response.rb#63
  def to_json(options = T.unsafe(nil)); end

  class << self
    # source://authzd-client//ruby/lib/authzd/response.rb#10
    def from_decision(decision); end

    # source://authzd-client//ruby/lib/authzd/response.rb#14
    def from_error(error); end
  end
end

module Google::Protobuf::MessageExts::ClassMethods; end
