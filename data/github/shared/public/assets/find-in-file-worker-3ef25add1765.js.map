{"version":3,"file":"find-in-file-worker-xxxxxxxxxxxx.js","mappings":"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","sources":["ui/packages/code-nav/get-match.ts","ui/packages/ssr-utils/ssr-globals.ts","ui/packages/code-nav/code-symbol.ts","app/assets/workers/find-in-file-worker.ts","app/assets/modules/react-code-view/worker-jobs/find-in-file.ts","ui/packages/code-nav/code-navigation-info.ts"],"sourcesContent":["/**\n * Lazy iterator that returns one match at a time\n * @param regex regular expression used for the search\n * @param text raw text blob\n * @param startFromLine line in the text blob indexed from 0\n */\n\nenum MatchableType {\n  Text,\n  Symbol,\n}\n\nexport interface Matchable {\n  kind: MatchableType\n  regexp: RegExp\n}\n\nexport function symbolMatchable(symbol: string) {\n  const escapedRegex = `(\\\\W|^)${symbol.replace(/[.*+?^${}()|[\\]\\\\]/g, '\\\\$&')}(\\\\W|$)`\n  return {\n    kind: MatchableType.Symbol,\n    regexp: new RegExp(escapedRegex, 'g'),\n  }\n}\n\nexport function textMatchable(query: string) {\n  const escapedQuery = query.replace(/[.*+?^${}()|[\\]\\\\]/g, '\\\\$&')\n  return {\n    kind: MatchableType.Text,\n    regexp: new RegExp(escapedQuery, 'gi'),\n  }\n}\n\nexport function* getMatchGenerator(regex: Matchable, lines: string[], startFromLine = 0) {\n  for (let line = startFromLine; line < lines.length; line++) {\n    const snippet = lines[line]!\n\n    let match: RegExpExecArray | null\n\n    while ((match = regex.regexp.exec(snippet)) !== null) {\n      let matchContent = match[0]\n      let column = match.index\n\n      // Symbol matcher regex match leading whitespace, but don't actually include\n      // that in the match positions! This is necessary because regex\n      // lookbehinds aren't widely supported in browsers...\n      if (regex.kind === MatchableType.Symbol) {\n        if (matchContent.length > 0 && /\\W/.test(matchContent[0]!)) {\n          matchContent = matchContent.substring(1)\n          column += match[0].length - matchContent.length\n        }\n        if (matchContent.length > 0 && /\\W/.test(matchContent[matchContent.length - 1]!)) {\n          matchContent = matchContent.substring(0, matchContent.length - 1)\n        }\n      }\n\n      yield {\n        line,\n        column,\n        columnEnd: column + matchContent.length,\n        text: snippet,\n      }\n    }\n  }\n}\n","// When using SSR, browser globals are not available. If you try to use them, Node.js will throw an error\ntype SSRSafeLocation = Pick<Location, 'pathname' | 'origin' | 'search' | 'hash' | 'href'>\n\n// eslint-disable-next-line ssr-friendly/no-dom-globals-in-module-scope\nexport const ssrSafeDocument = typeof document === 'undefined' ? undefined : document\n// eslint-disable-next-line ssr-friendly/no-dom-globals-in-module-scope\nexport const ssrSafeWindow = typeof window === 'undefined' ? undefined : window\n// eslint-disable-next-line ssr-friendly/no-dom-globals-in-module-scope\nexport const ssrSafeHistory = typeof history === 'undefined' ? undefined : history\n\nexport const ssrSafeLocation: SSRSafeLocation =\n  // eslint-disable-next-line ssr-friendly/no-dom-globals-in-module-scope\n  typeof location === 'undefined' ? {pathname: '', origin: '', search: '', hash: '', href: ''} : location\n\nexport function setLocation(url: string) {\n  // eslint-disable-next-line no-restricted-syntax\n  const parsedURL: SSRSafeLocation = new URL(url)\n  const {pathname, origin, search, hash} = parsedURL\n\n  Object.assign(ssrSafeLocation, {pathname, origin, search, hash})\n}\n","import type {Repository} from '@github-ui/current-repository'\nimport type {StylingDirectivesLine} from '@github-ui/code-view-types'\nimport {blamePath, blobPath} from '@github-ui/paths'\nimport type {RefInfo} from '@github-ui/repos-types'\nimport type {SafeHTMLString} from '@github-ui/safe-html'\n\ninterface Position {\n  line: number\n  column: number\n}\n\nexport interface Range {\n  start: Position\n  end: Position\n}\n\nexport enum SymbolSource {\n  BLACKBIRD_SEARCH = 'blackbird-search',\n  BLACKBIRD_ANALYSIS = 'blackbird-analysis',\n  ALEPH_PRECISE = 'aleph-precise',\n  BLOB_CONTENT = 'blob-content-search',\n}\n\nexport class SymbolKind {\n  enumStringVal: string\n  fullName: string\n  shortName: string\n  plColor: string\n  rank: number\n\n  constructor({kind}: {kind: string | number}) {\n    const [fullName, enumStringVal] = convertBlackbirdSymbolKind(kind)\n\n    this.enumStringVal = enumStringVal\n    this.fullName = fullName\n    this.shortName = symbolKindShortName(fullName)\n    this.plColor = symbolKindColor(fullName)\n    this.rank = symbolKindRank(fullName)\n  }\n}\n\n// Convert a blackbird SymbolKind enum value to a display friendly string.\n// Source of truth: https://github.com/github/hydro-schemas/blob/main/proto/hydro/schemas/blackbird/v0/entities/symbol_kind.proto\nfunction convertBlackbirdSymbolKind(kind: string | number): [string, string] {\n  if (typeof kind === 'string') {\n    const name = kind.toString().replace('SYMBOL_KIND_', '').replace(/_DEF$/, '').replace(/_REF$/, '').toLowerCase()\n    if (kind.startsWith('SYMBOL_KIND_')) {\n      return [name, kind.toString()]\n    } else if (kind !== '' && kind !== 'unknown') {\n      let enumVal = `SYMBOL_KIND_${kind.toUpperCase()}`\n      if (kind === 'call') {\n        enumVal += '_REF'\n      } else {\n        enumVal += '_DEF'\n      }\n      return [kind, enumVal]\n    }\n  }\n\n  return ['unknown', 'SYMBOL_KIND_UNKNOWN']\n}\n\nexport function symbolKindShortName(fullName: string) {\n  switch (fullName) {\n    case 'function':\n    case 'method':\n      return 'func'\n    case 'interface':\n      return 'intf'\n    case 'implementation':\n      return 'impl'\n    case 'constant':\n      return 'const'\n    case 'module':\n      return 'mod'\n\n    case 'h1':\n    case 'h2':\n    case 'h3':\n    case 'h4':\n    case 'h5':\n    case 'h6':\n    case 'class':\n    case 'call':\n    case 'enum':\n    case 'field':\n    case 'macro':\n    case 'struct':\n    case 'trait':\n    case 'type':\n    case 'union':\n      return fullName\n\n    default:\n      return fullName.substring(0, 1)\n  }\n}\n\nfunction symbolKindColor(fullName: string) {\n  switch (fullName) {\n    case 'function':\n    case 'method':\n      return 'prettylights.syntax.entity'\n    case 'class':\n    case 'enum':\n    case 'struct':\n    case 'union':\n      return 'prettylights.syntax.constant'\n    case 'interface':\n    case 'trait':\n      return 'prettylights.syntax.keyword'\n    case 'constant':\n    case 'field':\n    case 'enum member':\n      return 'prettylights.syntax.variable'\n    case 'implementation':\n      return 'prettylights.syntax.string'\n\n    default:\n      return 'prettylights.syntax.entity'\n  }\n}\n\n// Relative rank of symbol kinds. Lower is higher relevance.\nfunction symbolKindRank(kind: string): number {\n  return (\n    {\n      class: 1,\n      struct: 1,\n      enum: 1,\n      type: 2,\n      interface: 3,\n      trait: 3,\n      module: 4,\n      implementation: 5,\n      function: 6,\n      method: 7,\n      call: 8,\n      field: 9,\n    }[kind] || 9\n  )\n}\n\nexport class CodeSymbol {\n  ident: Range\n  extent: Range\n\n  kind: SymbolKind\n  name: string\n  fullyQualifiedName: string\n  depth: number\n\n  repo: Repository\n  refInfo: RefInfo\n  path: string\n\n  // Snippet for the line the symbol is defined on\n  highlightedText: SafeHTMLString | undefined\n  stylingDirectives: StylingDirectivesLine | undefined\n  bodyText: string\n  leadingWhitespace: number | undefined\n\n  source: SymbolSource\n\n  constructor({\n    ident,\n    extent,\n    kind,\n    name,\n    fullyQualifiedName,\n    source,\n  }: {\n    ident: Range\n    extent: Range\n    kind: string | number\n    name: string\n    fullyQualifiedName: string\n    source: SymbolSource\n  }) {\n    this.ident = ident\n    this.extent = extent\n    this.kind = new SymbolKind({kind})\n    this.name = name\n    this.fullyQualifiedName = fullyQualifiedName\n    this.source = source\n  }\n\n  setSymbolDepth(depth: number) {\n    this.depth = depth\n  }\n  setFileInfo(repo: Repository, refInfo: RefInfo, path: string) {\n    this.repo = repo\n    this.refInfo = refInfo\n    this.path = path\n  }\n\n  get lineNumber() {\n    return this.ident.start.line + 1\n  }\n\n  setSnippet(\n    highlightedText: SafeHTMLString | undefined,\n    stylingDirectives: StylingDirectivesLine | undefined,\n    bodyText: string,\n    leadingWhitespace: number | undefined,\n  ) {\n    this.highlightedText = highlightedText\n    this.stylingDirectives = stylingDirectives\n    this.bodyText = bodyText\n    this.leadingWhitespace = leadingWhitespace\n  }\n\n  href(): string {\n    if (!this.repo || !this.refInfo || !this.path) {\n      return `/${window.location.pathname}#L${this.lineNumber}`\n    }\n\n    const commitish =\n      this.source === SymbolSource.BLACKBIRD_SEARCH\n        ? this.repo.defaultBranch\n        : this.refInfo.name || this.refInfo.currentOid\n\n    return blobPath({\n      owner: this.repo.ownerLogin,\n      repo: this.repo.name,\n      commitish,\n      filePath: this.path,\n      lineNumber: this.lineNumber,\n    })\n  }\n\n  // Generates a string which uniquely identifies the file this reference comes from\n  pathKey(): string {\n    return `${this.repo.ownerLogin}/${this.repo.name}/${this.refInfo.currentOid}/${this.path}`\n  }\n}\n\nexport class CodeReference {\n  ident: Range\n  repo: Repository\n  refInfo: RefInfo\n  path: string\n  isPlain: boolean\n\n  // Snippet information for the line the reference is from\n  highlightedText: SafeHTMLString | undefined\n  stylingDirectives: StylingDirectivesLine | undefined\n  bodyText: string\n  source: SymbolSource\n  leadingWhitespace: number | undefined\n\n  constructor({\n    ident,\n    repo,\n    refInfo,\n    path,\n    isPlain,\n    source,\n  }: {\n    ident: Range\n    repo: Repository\n    refInfo: RefInfo\n    path: string\n    isPlain?: boolean\n    source: SymbolSource\n  }) {\n    this.ident = ident\n    this.repo = repo\n    this.refInfo = refInfo\n    this.path = path\n    this.isPlain = isPlain ?? false\n    this.source = source\n  }\n\n  get lineNumber() {\n    return this.ident.start.line + 1\n  }\n\n  href(blame: boolean): string {\n    if (!this.repo || !this.refInfo || !this.path) {\n      return `/${window.location.pathname}#L${this.lineNumber}`\n    }\n\n    const commitish =\n      this.source === SymbolSource.BLACKBIRD_SEARCH\n        ? this.repo.defaultBranch\n        : this.refInfo.name || this.refInfo.currentOid\n\n    const params = {\n      owner: this.repo.ownerLogin,\n      repo: this.repo.name,\n      commitish,\n      filePath: this.path,\n      lineNumber: this.lineNumber,\n      plain: this.isPlain ? 1 : undefined,\n    }\n\n    return blame ? blamePath(params) : blobPath(params)\n  }\n\n  setSnippet(\n    highlightedText: SafeHTMLString | undefined,\n    stylingDirectives: StylingDirectivesLine | undefined,\n    bodyText: string,\n    leadingWhitespace: number | undefined,\n  ) {\n    this.highlightedText = highlightedText\n    this.stylingDirectives = stylingDirectives\n    this.bodyText = bodyText\n    this.leadingWhitespace = leadingWhitespace\n  }\n\n  // Generates a string which uniquely identifies the file this reference comes from\n  pathKey(): string {\n    return `${this.repo.ownerLogin}/${this.repo.name}/${this.refInfo.currentOid}/${this.path}`\n  }\n}\n\nexport type DefinitionOrReference = CodeSymbol | CodeReference\n","import type {FindInFileRequest} from '../modules/react-code-view/hooks/use-in-file-search-results'\nimport {findInFileWorkerJob} from '../modules/react-code-view/worker-jobs/find-in-file'\n\nself.onmessage = (message: {data: FindInFileRequest}) => {\n  self.postMessage(findInFileWorkerJob(message))\n}\n","import {type Range, searchInBlobContent, searchInBlobIncrementally, textMatchable} from '@github-ui/code-nav'\n\nimport type {FindInFileRequest, FindInFileResponse} from '../hooks/use-in-file-search-results'\n\nexport function findInFileWorkerJob({data}: {data: FindInFileRequest}): FindInFileResponse {\n  const {query, lines, currentCodeReferences} = data\n  let output: Range[] = []\n\n  // incremental search\n  if (currentCodeReferences) {\n    output = searchInBlobIncrementally(currentCodeReferences, lines, textMatchable(query))\n  } else {\n    output = searchInBlobContent(lines, textMatchable(query))\n  }\n\n  return {ranges: output, query}\n}\n","import type {Repository} from '@github-ui/current-repository'\nimport {codeNavigationPath} from '@github-ui/paths'\nimport {verifiedFetchJSON} from '@github-ui/verified-fetch'\n\nimport type {RefInfo} from '@github-ui/repos-types'\nimport type {BlackbirdSymbol, StylingDirectivesDocument} from '@github-ui/code-view-types'\nimport type {\n  CodeNavBackendType,\n  CodeNavPromise,\n  CodeNavResultDetails,\n  SymbolTreeBuildingData,\n  TreeNode,\n} from './code-nav-types'\nimport {\n  CodeReference,\n  type CodeSymbol,\n  type DefinitionOrReference,\n  type Range,\n  SymbolKind,\n  SymbolSource,\n} from './code-symbol'\nimport {getMatchGenerator, type Matchable, symbolMatchable, textMatchable} from './get-match'\nimport {alephSymbolToCodeReference, alephSymbolToCodeSymbol, outlineSymbolToCodeSymbol} from './symbol-result-converter'\n\nconst SEARCH_RESULT_LIMIT = 200\n\nexport interface CodeSection {\n  startLine: number\n  endLine: number\n  collapsed: boolean\n  index: number\n  level: number\n}\n\nexport class CodeNavigationInfo {\n  repo: Repository\n  refInfo: RefInfo\n  language: string\n  path: string\n  loggedIn: boolean\n  blobLines: string[]\n  symbols: CodeSymbol[]\n  lineIndexedSymbols: {[line: number]: CodeSymbol} = {}\n  isPlain: boolean\n\n  symbolTree: TreeNode[]\n  stylingDirectives: StylingDirectivesDocument | undefined\n  setLoading: (loading: boolean) => void\n  codeSections: Map<number, CodeSection[]>\n  lineToSectionMap: Map<number, CodeSection[]>\n\n  constructor(\n    repo: Repository,\n    refInfo: RefInfo,\n    path: string,\n    loggedIn: boolean,\n    rawLines: string[],\n    symbols: BlackbirdSymbol[],\n    stylingDirectives: StylingDirectivesDocument | undefined,\n    language: string,\n    isPlain: boolean,\n    setLoading: (loading: boolean) => void,\n  ) {\n    this.setLoading = setLoading\n    this.setLoading(true)\n    this.repo = repo\n    this.refInfo = refInfo\n    this.path = path\n    this.loggedIn = loggedIn\n    this.language = language\n\n    this.blobLines = rawLines\n    this.stylingDirectives = stylingDirectives\n    this.isPlain = isPlain\n    this.symbols = this.initSymbols(symbols)\n\n    this.initSymbolTree()\n    this.initCodeSections()\n    this.setLoading(false)\n  }\n\n  initCodeSections() {\n    const m = new Map()\n    const lineToSectionMap = new Map()\n    for (let i = 0; i < this.symbols.length; i++) {\n      //we don't want to deal with applying sticky if it is going to be a 2 line long sticky section\n      if (this.symbols[i]!.lineNumber < this.symbols[i]!.extent.end.line - 2) {\n        const section = {\n          startLine: this.symbols[i]!.lineNumber,\n          endLine: this.symbols[i]!.extent.end.line,\n          index: i,\n          collapsed: false,\n          level: this.symbols[i]!.depth,\n        }\n        if (m.has(section.startLine)) {\n          const tempArray = m.get(section.startLine)\n          tempArray.push(section)\n          m.set(section.startLine, tempArray)\n        } else {\n          m.set(section.startLine, [section])\n        }\n        if (m.has(section.endLine)) {\n          const tempArray = m.get(section.endLine)\n          tempArray.push(section)\n          m.set(section.endLine, tempArray)\n        } else {\n          m.set(section.endLine, [section])\n        }\n\n        //don't include the start lines or end lines because they're in the other map\n        for (let j = section.startLine + 1; j < section.endLine; j++) {\n          if (lineToSectionMap.has(j)) {\n            const tempArray = lineToSectionMap.get(j)\n            tempArray.push(section)\n            lineToSectionMap.set(j, tempArray)\n          } else {\n            lineToSectionMap.set(j, [section])\n          }\n        }\n      }\n    }\n\n    this.lineToSectionMap = lineToSectionMap\n    this.codeSections = m\n  }\n\n  initSymbols(symbols: BlackbirdSymbol[]) {\n    return symbols.map(outlineSymbol => {\n      const snippet = this.blobLines[outlineSymbol.ident_utf16.start.line_number] || ''\n      const codeSymbol = outlineSymbolToCodeSymbol(outlineSymbol, snippet, {\n        stylingDirectives: this.stylingDirectives,\n        repo: this.repo,\n        refInfo: this.refInfo,\n        path: this.path,\n      })\n\n      this.lineIndexedSymbols[codeSymbol.lineNumber] = codeSymbol\n\n      return codeSymbol\n    })\n  }\n\n  getBlobLine(line: number) {\n    return this.blobLines[line] || ''\n  }\n\n  getSymbolOnLine(lineNumber: number): CodeSymbol | undefined {\n    return this.lineIndexedSymbols[lineNumber]\n  }\n\n  initSymbolTree() {\n    if (this.symbols) {\n      const tempParents: CodeSymbol[] = []\n      const symbolTree: SymbolTreeBuildingData[] = this.symbols\n        .filter(s => s.kind.fullName !== 'field')\n        .map(symbol => {\n          let depth = 0\n          for (let i = tempParents.length - 1; i >= 0; i--) {\n            const parentSymbol = tempParents[i]!\n            if (isAfterSymbol(symbol, parentSymbol)) {\n              tempParents.pop()\n            } else {\n              depth = tempParents.length\n              break\n            }\n          }\n          tempParents.push(symbol)\n          symbol.setSymbolDepth(depth)\n          return {symbol, depth}\n        })\n      this.symbolTree = []\n\n      for (let index = 0; index < symbolTree.length; index++) {\n        const symbol = symbolTree[index]!\n        if (index + 1 < symbolTree.length) {\n          const nextSymbol = symbolTree[index + 1]!\n          if (nextSymbol.depth > symbol.depth) {\n            const symbolChildren = buildSymbolTreeChildren(symbolTree, index)\n            index += determineTotalNumberOfChildren(symbolChildren)\n            this.symbolTree.push({symbol: symbol.symbol, isParent: true, children: symbolChildren})\n            continue\n          }\n        }\n        this.symbolTree.push({symbol: symbol.symbol, isParent: false, children: []})\n      }\n    }\n  }\n\n  createReferences(matches: Range[]): CodeReference[] {\n    return matches.map(match => {\n      const reference = new CodeReference({\n        ident: match,\n        repo: this.repo,\n        refInfo: this.refInfo,\n        path: this.path,\n        isPlain: this.isPlain,\n        source: SymbolSource.BLOB_CONTENT,\n      })\n      reference.setSnippet(\n        undefined,\n        this.stylingDirectives?.[match.start.line],\n        this.blobLines[match.start.line]!,\n        undefined,\n      )\n      return reference\n    })\n  }\n\n  getReferencesToSymbol(symbolName: string): CodeReference[] {\n    //TODO: figure out loading once this is async\n    const ranges = searchInBlobContent(this.blobLines, symbolMatchable(symbolName))\n    return this.createReferences(ranges)\n  }\n\n  getReferencesToSearch(term: string): CodeReference[] {\n    //TODO: figure out loading once this is async\n    const ranges = searchInBlobContent(this.blobLines, textMatchable(term))\n    return this.createReferences(ranges)\n  }\n\n  getDefinitionsAndReferences(text: string, row: number, column: number): CodeNavPromise {\n    this.setLoading(true)\n\n    const defs = (async () => {\n      const selectedSymbol = this.getSymbolOnLine(row + 1) // row is 0-indexed, line numbers are 1-indexed\n      if (selectedSymbol && selectedSymbol.name === text) {\n        return {\n          definitions: [selectedSymbol],\n          backend: 'search' as CodeNavBackendType,\n        }\n      }\n\n      let [definitions, backend] = await this.getAlephDefinitions(text, row, column, this.loggedIn)\n\n      // Prefer locally-defined symbols over search-based definitions, unless precise results are available.\n      if (backend === 'search') {\n        const localDefinitions = this.getLocalDefinitions(text)\n        if (localDefinitions.length > 0) {\n          definitions = localDefinitions\n        }\n\n        // If we get a definition from the current file, suppress all the others\n        const localDefinition = definitions.find(d => d.path === this.path && d.repo === this.repo)\n        if (localDefinition) {\n          definitions = [localDefinition]\n        }\n        backend = 'search'\n      } else {\n        const localDefinitionsForKindFallback = this.getLocalDefinitions(text, true)\n        for (const definition of definitions) {\n          if (definition.kind.fullName === '' && definition.name === text) {\n            //local definitions always returns an array with a single item if it returns anything\n            //instead of empty string we can choose a default kind to display here when aleph and local have nothing,\n            //but for now keeping as empty string\n            definition.kind = localDefinitionsForKindFallback[0]\n              ? localDefinitionsForKindFallback[0].kind\n              : new SymbolKind({kind: ''})\n          }\n        }\n      }\n      return {\n        definitions,\n        backend,\n      }\n    })()\n\n    const localRefs = (async () => {\n      const {definitions} = await defs\n      const definitionLines = definitions.map(d => d.lineNumber)\n      const references = this.getReferencesToSymbol(text).filter(r => !definitionLines.includes(r.lineNumber))\n\n      return {\n        references,\n        backend: 'search' as CodeNavBackendType,\n      }\n    })()\n\n    const alephRefs = (async () => {\n      let symbolKind = 'SYMBOL_KIND_UNKNOWN'\n      const sym = this.getSymbolOnLine(row + 1) // row is 0-indexed, line numbers are 1-indexed\n      if (sym) {\n        // If we have this in the symbol outline (from blackbird analysis): use it.\n        symbolKind = sym.kind.enumStringVal\n      } else {\n        // Otherwise, try to use the first def\n        const {definitions} = await defs\n        symbolKind = definitions[0]?.kind?.enumStringVal || symbolKind\n      }\n      return this.getAlephReferences(text, row, column, this.loggedIn, symbolKind)\n    })()\n\n    const crossRefs = (async () => {\n      const [references, backend] = await alephRefs\n      return {\n        references,\n        backend,\n      }\n    })()\n\n    // Exclude definitions from references\n    return {\n      definitions: defs,\n      localReferences: localRefs,\n      crossReferences: crossRefs,\n      setLoading: this.setLoading,\n    }\n  }\n\n  getLocalDefinitions(text: string, getSymbolKind = false): CodeSymbol[] {\n    let bestRank = 9\n    let definitions: CodeSymbol[] = []\n    for (const sym of this.symbols) {\n      if (sym.name === text && (sym.kind.rank < bestRank || getSymbolKind)) {\n        bestRank = sym.kind.rank\n        definitions = [sym]\n      }\n    }\n\n    return definitions\n  }\n\n  async getAlephDefinitions(\n    text: string,\n    row: number,\n    column: number,\n    loggedIn: boolean,\n  ): Promise<[CodeSymbol[], CodeNavBackendType]> {\n    let backend: CodeNavBackendType = 'search'\n    if ((text === '' && row === -1 && column === -1) || !loggedIn) {\n      return [[], backend]\n    }\n\n    const definitionsUrl = codeNavigationPath({\n      repo: this.repo,\n      type: 'definition',\n      q: text,\n      language: this.language,\n      row,\n      column,\n      ref: this.refInfo.name,\n      path: this.path,\n      codeNavContext: 'BLOB_VIEW',\n      symbolKind: null,\n    })\n\n    let response: Response\n    try {\n      response = await verifiedFetchJSON(definitionsUrl)\n    } catch (e) {\n      return [[], backend]\n    }\n\n    if (!response.ok) {\n      return [[], backend]\n    }\n\n    let resultDetails: CodeNavResultDetails\n    try {\n      resultDetails = await response.json()\n    } catch (e) {\n      return [[], backend]\n    }\n\n    backend = parseAlephBackendType(resultDetails.backend) ?? 'search'\n\n    const definitions = resultDetails.payload\n      .flatMap(refs => refs)\n      .map(alephSymbol => {\n        return alephSymbolToCodeSymbol(alephSymbol, {\n          stylingDirectives: this.stylingDirectives,\n          repo: this.repo,\n          refInfo: this.refInfo,\n          path: this.path,\n          symbol: text,\n          backend,\n        })\n      })\n\n    return [definitions, backend]\n  }\n\n  async getAlephReferences(\n    text: string,\n    row: number,\n    column: number,\n    loggedIn: boolean,\n    symbolKind: string,\n  ): Promise<[CodeReference[], CodeNavBackendType]> {\n    let backend: CodeNavBackendType = 'search'\n    if ((text === '' && row === -1 && column === -1) || !loggedIn) {\n      return [[], backend]\n    }\n\n    const referencesUrl = codeNavigationPath({\n      repo: this.repo,\n      type: 'references',\n      q: text,\n      language: this.language,\n      row,\n      column,\n      ref: this.refInfo.name,\n      path: this.path,\n      codeNavContext: 'BLOB_VIEW',\n      symbolKind,\n    })\n\n    const partialResponse = await verifiedFetchJSON(referencesUrl)\n    if (!partialResponse.ok) {\n      return [[], backend]\n    }\n\n    let response: CodeNavResultDetails\n    try {\n      response = await partialResponse.json()\n    } catch (e) {\n      return [[], backend]\n    }\n\n    backend = parseAlephBackendType(response.backend) ?? 'search'\n\n    const observedLines = new Set<number>()\n    const isCheckedLine = (line: number) => {\n      if (observedLines.has(line)) {\n        return true\n      } else {\n        observedLines.add(line)\n        return false\n      }\n    }\n\n    const references = response.payload\n      .flatMap(refs => refs)\n      .reduce<CodeReference[]>((results, alephSymbol) => {\n        if (alephSymbol.path === this.path) {\n          return results\n        }\n        const reference = alephSymbolToCodeReference(alephSymbol, {\n          stylingDirectives: this.stylingDirectives,\n          repo: this.repo,\n          refInfo: this.refInfo,\n          path: this.path,\n          backend,\n        })\n\n        if (isCheckedLine(reference.lineNumber)) {\n          return results\n        }\n\n        results.push(reference)\n        return results\n      }, [])\n      // For some reason, aleph returns references out of order, so we need to sort\n      // them by line number.\n      .sort((a, b) => a.lineNumber - b.lineNumber)\n\n    return [references, backend]\n  }\n}\n\nexport function parseAlephBackendType(fromAleph: string): CodeNavBackendType | null {\n  switch (fromAleph) {\n    case 'ALEPH_PRECISE':\n    case 'ALEPH_PRECISE_PREVIEW':\n    case 'ALEPH_PRECISE_DEVELOPMENT':\n      return 'precise'\n    case 'BLACKBIRD':\n      return 'search'\n    default:\n      return null\n  }\n}\n\nexport function isAfterSymbol(symbolA: CodeSymbol, symbolB: CodeSymbol): boolean {\n  return symbolA.extent.start.line === symbolB.extent.end.line\n    ? symbolA.extent.start.column > symbolB.extent.end.column\n    : symbolA.extent.start.line > symbolB.extent.end.line\n}\n\nfunction buildSymbolTreeChildren(symbolTree: SymbolTreeBuildingData[], currentIndex: number) {\n  const symbolChildren: TreeNode[] = []\n  const symbol = symbolTree[currentIndex]!\n  for (let i = currentIndex + 1; i < symbolTree.length; i++) {\n    const tempSymbol = symbolTree[i]!\n    if (tempSymbol.depth > symbol.depth) {\n      const tempChildren = buildSymbolTreeChildren(symbolTree, i)\n      i += determineTotalNumberOfChildren(tempChildren)\n      symbolChildren.push({\n        symbol: tempSymbol.symbol,\n        children: tempChildren,\n        isParent: tempChildren.length > 0,\n      })\n    } else {\n      break\n    }\n  }\n  return symbolChildren\n}\n\nfunction determineTotalNumberOfChildren(node: TreeNode[]) {\n  let total = node.length\n  for (let i = 0; i < node.length; i++) {\n    const currNode = node[i]!\n    if (currNode.isParent) {\n      total += determineTotalNumberOfChildren(currNode.children)\n    }\n  }\n\n  return total\n}\n\nexport function searchInBlobContent(lines: string[], m: Matchable): Range[] {\n  const output: Range[] = []\n  const matches = getMatchGenerator(m, lines)\n  let match = matches.next()\n\n  while (!match.done && output.length < SEARCH_RESULT_LIMIT) {\n    const {column, columnEnd, line} = match.value\n    output.push({\n      start: {\n        line,\n        column,\n      },\n      end: {\n        line,\n        column: columnEnd,\n      },\n    })\n\n    match = matches.next()\n  }\n  return output\n}\n\nexport function searchInBlobIncrementally(\n  codeRefs: DefinitionOrReference[],\n  lines: string[],\n  matchable: Matchable,\n): Range[] {\n  if (codeRefs.length === 0) {\n    // In the incremental search we are narrowing results. If there are no results for a less specific search, there won't be any further matches.\n    return []\n  }\n\n  const startedAtResultLimit = codeRefs.length >= SEARCH_RESULT_LIMIT\n\n  const checkedLine: Record<number, true> = {}\n  const searchResults = codeRefs.reduce<Range[]>((output, ref) => {\n    if (checkedLine[ref.ident.start.line]) {\n      return output\n    }\n\n    checkedLine[ref.ident.start.line] = true\n    const matches = getMatchGenerator(matchable, [lines[ref.ident.start.line]!])\n    let match = matches.next()\n    while (!match.done && output.length < SEARCH_RESULT_LIMIT) {\n      const {column, columnEnd} = match.value\n      output.push({\n        start: {\n          line: ref.ident.start.line,\n          column,\n        },\n        end: {\n          line: ref.ident.start.line,\n          column: columnEnd,\n        },\n      })\n      match = matches.next()\n    }\n\n    return output\n  }, [])\n\n  // Add new results from the raw blob. Note: this is only necessary if we dropped the number\n  // of results below the maximum in the previous phase!\n  if (searchResults.length < SEARCH_RESULT_LIMIT && startedAtResultLimit) {\n    const startFromLine = codeRefs[codeRefs.length - 1]!.ident.start.line\n    const matchesInRawBlob = getMatchGenerator(matchable, lines, startFromLine)\n    let match = matchesInRawBlob.next()\n    while (!match.done && searchResults.length < SEARCH_RESULT_LIMIT) {\n      const {line, column, columnEnd} = match.value\n      searchResults.push({\n        start: {\n          line,\n          column,\n        },\n        end: {\n          line,\n          column: columnEnd,\n        },\n      })\n      match = matchesInRawBlob.next()\n    }\n  }\n\n  return searchResults\n}\n"],"names":["textMatchable","query","kind","regexp","replace","getMatchGenerator","regex","lines","startFromLine","line","length","match","snippet","exec","matchContent","column","index","test","substring","columnEnd","text","window","history","location","SymbolSource","MatchableType","self","onmessage","postMessage","findInFileWorkerJob","data","currentCodeReferences","ranges","searchInBlobIncrementally","codeRefs","matchable","startedAtResultLimit","checkedLine","searchResults","reduce","output","ref","ident","start","matches","next","done","value","push","end","matchesInRawBlob","searchInBlobContent","m","message"],"sourceRoot":""}