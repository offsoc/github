# typed: true

# DO NOT EDIT MANUALLY
# This is an autogenerated file for types exported from the `failbot` gem.
# Please instead update this file by running `bin/tapioca gem failbot`.

# Failbot asynchronously takes exceptions and reports them to the
# exception logger du jour. Keeps the main app from failing or lagging if
# the exception logger service is down or slow.
#
# source://failbot//lib/failbot/middleware.rb#1
module Failbot
  extend ::Failbot
  extend ::Failbot::SensitiveDataScrubber

  # source://failbot//lib/failbot.rb#401
  def already_reporting; end

  # source://failbot//lib/failbot.rb#397
  def already_reporting=(bool); end

  # source://failbot//lib/failbot.rb#74
  def backend; end

  # source://failbot//lib/failbot.rb#78
  def backtrace_trimmer; end

  # Public: your last chance to modify the context that is to be reported with an exception.
  #
  # The key value pairs that are returned from your block will get squashed into the context,
  # replacing the values of any keys that were already present.
  #
  # Example:
  #
  # Failbot.before_report do |exception, context|
  #   # context is { "a" => 1, "b" => 2 }
  #   { :a => 0, :c => 3 }
  # end
  #
  # context gets reported as { "a" => 0, "b" => "2", "c" => 3 }
  #
  # source://failbot//lib/failbot.rb#148
  def before_report(&block); end

  # source://failbot//lib/failbot.rb#338
  def clear_before_report; end

  # source://failbot//lib/failbot.rb#334
  def clear_config; end

  # source://failbot//lib/failbot.rb#86
  def context; end

  # Public: Disable exception reporting. This is equivalent to calling
  # `Failbot.setup("FAILBOT_REPORT" => 0)`, but can be called after setup.
  #
  #     Failbot.disable do
  #       something_that_might_go_kaboom
  #     end
  #
  # block - an optional block to perform while reporting is disabled. If a block
  #         is passed, reporting will be re-enabled after the block is called.
  #
  # source://failbot//lib/failbot.rb#243
  def disable(&block); end

  # Public: Enable exception reporting. Reporting is enabled by default, but
  # this can be called if it is explicitly disabled by calling `Failbot.disable`
  # or setting `FAILBOT_REPORTING => "0"` in `Failbot.setup`.
  #
  # source://failbot//lib/failbot.rb#259
  def enable; end

  # Extract exception info into a simple Hash.
  #
  # e - The exception object to turn into a Hash.
  #
  # Returns a Hash.
  #
  # source://failbot//lib/failbot.rb#347
  def exception_info(e); end

  # source://failbot//lib/failbot.rb#370
  def fetch_failbot_context(data, original_exception); end

  # source://failbot//lib/failbot.rb#82
  def frame_processing_pipeline; end

  # source://failbot//lib/failbot.rb#70
  def hostname; end

  # Installs an at_exit hook to report exceptions that raise all the way out of
  # the stack and halt the interpreter. This is useful for catching boot time
  # errors as well and even signal kills.
  #
  # To use, call this method very early during the program's boot to cover as
  # much code as possible:
  #
  #   require 'failbot'
  #   Failbot.install_unhandled_exception_hook!
  #
  # Returns true when the hook was installed, nil when the hook had previously
  # been installed by another component.
  #
  # source://failbot//lib/failbot/exit_hook.rb#51
  def install_unhandled_exception_hook!; end

  # Public: Set an instrumenter to be called when exceptions are reported.
  #
  #   class CustomInstrumenter
  #     def instrument(name, payload = {})
  #       warn "Exception: #{payload["class"]}\n#{payload.inspect}"
  #     end
  #   end
  #
  #   Failbot.instrumenter = CustomInstrumenter
  #
  # The instrumenter must conform to the `ActiveSupport::Notifications`
  # interface, which defines `#instrument` and accepts:
  #
  # name    - the String name of the event (e.g. "report.failbot")
  # payload - a Hash of the exception context.
  #
  # source://failbot//lib/failbot.rb#49
  def instrumenter; end

  # Public: Set an instrumenter to be called when exceptions are reported.
  #
  #   class CustomInstrumenter
  #     def instrument(name, payload = {})
  #       warn "Exception: #{payload["class"]}\n#{payload.inspect}"
  #     end
  #   end
  #
  #   Failbot.instrumenter = CustomInstrumenter
  #
  # The instrumenter must conform to the `ActiveSupport::Notifications`
  # interface, which defines `#instrument` and accepts:
  #
  # name    - the String name of the event (e.g. "report.failbot")
  # payload - a Hash of the exception context.
  #
  # source://failbot//lib/failbot.rb#49
  def instrumenter=(_arg0); end

  # source://failbot//lib/failbot.rb#380
  def logger; end

  # source://failbot//lib/failbot.rb#393
  def logger=(logger); end

  # Tap into any other method invocation on the Failbot module (especially report)
  # and lazy load and configure everything the first time.
  #
  # source://failbot//lib/failbot/exit_hook.rb#76
  def method_missing(method, *args, &block); end

  # source://failbot//lib/failbot.rb#62
  def pop; end

  # source://failbot//lib/failbot.rb#66
  def pop_sensitive; end

  # source://failbot//lib/failbot.rb#362
  def populate_from_failbot_context(data, e); end

  # source://failbot//lib/failbot.rb#54
  def push(info = T.unsafe(nil), &block); end

  # source://failbot//lib/failbot.rb#58
  def push_sensitive(info = T.unsafe(nil), &block); end

  # source://failbot//lib/failbot.rb#94
  def remove_from_report(key); end

  # Public: Sends an exception to the exception tracking service along
  # with a hash of custom attributes to be included with the report. When the
  # raise_errors option is set, this method raises the exception instead of
  # reporting to the exception tracking service.
  #
  # e     - The Exception object. Must respond to #message and #backtrace.
  # other - Hash of additional attributes to include with the report.
  #
  # Examples
  #
  #   begin
  #     my_code
  #   rescue => e
  #     Failbot.report(e, :user => current_user)
  #   end
  #
  # Returns nothing.
  #
  # @raise [MissingSetupError]
  #
  # source://failbot//lib/failbot.rb#204
  def report(e, other = T.unsafe(nil)); end

  # source://failbot//lib/failbot.rb#216
  def report!(e, other = T.unsafe(nil)); end

  # source://failbot//lib/failbot.rb#220
  def report_from_thread(thread, e, other = T.unsafe(nil)); end

  # source://failbot//lib/failbot.rb#229
  def report_from_thread!(thread, e, other = T.unsafe(nil)); end

  # Public: exceptions that were reported. Only available when using the
  # memory and file backends.
  #
  # Returns an Array of exceptions data Hash.
  #
  # source://failbot//lib/failbot.rb#267
  def reports; end

  # source://failbot//lib/failbot.rb#329
  def reset!; end

  # source://failbot//lib/failbot.rb#98
  def reset_context; end

  # Specify a custom block for calculating rollups. It should accept:
  #
  # exception - The exception object
  # context   - The context hash
  #
  # The block must return a String.
  #
  # If a `rollup` attribute is supplied at the time of reporting, either via
  # the `failbot_context` method on an exception, or passed to `Failbot.report`,
  # it will be used as the rollup and this block will not be called.
  #
  # source://failbot//lib/failbot.rb#163
  def rollup(&block); end

  # source://failbot//lib/failbot.rb#291
  def sanitize(attrs); end

  # source://failbot//lib/failbot.rb#90
  def sensitive_context; end

  # Public: Setup the backend for reporting exceptions.
  #
  # @raise [SetupError]
  # @yield [@config]
  #
  # source://failbot//lib/failbot.rb#128
  def setup(settings = T.unsafe(nil), default_context = T.unsafe(nil)); end

  # Combines all context hashes into a single hash converting non-standard
  # data types in values to strings, then combines the result with a custom
  # info hash provided in the other argument.
  #
  # other - Optional array of hashes to also squash in on top of the context
  #         stack hashes.
  #
  # Returns a Hash with all keys and values.
  #
  # source://failbot//lib/failbot.rb#279
  def squash_contexts(*contexts_to_squash); end

  # source://failbot//lib/failbot.rb#181
  def use_default_rollup; end

  private

  # source://failbot//lib/failbot.rb#529
  def calculate_elapsed_ms(start_time); end

  # source://failbot//lib/failbot.rb#588
  def failbot_exception_details(exception); end

  # source://failbot//lib/failbot.rb#604
  def get_exception_backtrace(exception); end

  # source://failbot//lib/failbot.rb#600
  def get_exception_message(exception); end

  # source://failbot//lib/failbot.rb#596
  def get_exception_type(exception); end

  # source://failbot//lib/failbot.rb#504
  def handle_reporting_error(action:, data:, instrumentation_data:, original_exception:, failbot_exception:, start_time: T.unsafe(nil)); end

  # source://failbot//lib/failbot.rb#499
  def handle_reporting_success(data:, instrumentation_data:, start_time:); end

  # @return [Boolean]
  #
  # source://failbot//lib/failbot.rb#609
  def ignore_error?(error); end

  # Internal: Publish an event to the instrumenter
  #
  # source://failbot//lib/failbot.rb#534
  def instrument(name, payload = T.unsafe(nil)); end

  # @return [Boolean]
  #
  # source://failbot//lib/failbot.rb#407
  def is_setup?; end

  # source://failbot//lib/failbot.rb#538
  def log_already_reporting(original_exception); end

  # source://failbot//lib/failbot.rb#547
  def log_failure(action, original_exception, exception); end

  # source://failbot//lib/failbot.rb#571
  def log_failure_to_fetch_custom_context(exception); end

  # source://failbot//lib/failbot.rb#561
  def log_failure_to_log(action, exception); end

  # source://failbot//lib/failbot.rb#462
  def process_exception(thread, provided_context, sensitive_context, data, e, other); end

  # source://failbot//lib/failbot.rb#489
  def report_exception(data); end

  # source://failbot//lib/failbot.rb#514
  def report_failure(action, data, instrumentation_data, exception, reporting_error, start_time = T.unsafe(nil)); end

  # source://failbot//lib/failbot.rb#523
  def report_success(data, instrumentation_data, start_time); end

  # source://failbot//lib/failbot.rb#411
  def report_with_context!(thread, provided_context, sensitive_context, e, other = T.unsafe(nil)); end

  # source://failbot//lib/failbot.rb#580
  def to_semconv(exception); end

  class << self
    # source://failbot//lib/failbot.rb#123
    def exception_classname_from_hash(hash); end

    # Helpers needed to parse hashes included in e.g. Failbot.reports.
    #
    # source://failbot//lib/failbot.rb#119
    def exception_message_from_hash(hash); end
  end
end

class Failbot::Backtrace; end

class Failbot::Backtrace::Frame
  class << self
    # source://failbot//lib/failbot/backtrace/frame.rb#26
    def convert_to_hash(line); end

    # source://failbot//lib/failbot/backtrace/frame.rb#36
    def new_frame_hash(path, line_number, method); end

    # Returns a frame hash given a backtrace line string or raises ParseError if it's malformed.
    #
    # source://failbot//lib/failbot/backtrace/frame.rb#18
    def parse(line, processing_pipeline = T.unsafe(nil)); end
  end
end

# Regex matching the components of a ruby stack frame as they are printed in a backtrace.
# Regex adapted from sentry's parser:
# https://github.com/getsentry/sentry-ruby/blob/478c4cff5daf00719d46c0777a73da268e796b25/sentry-ruby/lib/sentry/backtrace.rb#L10-L16
#
# source://failbot//lib/failbot/backtrace/frame.rb#8
Failbot::Backtrace::Frame::FRAME_FORMAT = T.let(T.unsafe(nil), Regexp)

class Failbot::Backtrace::Frame::ParseError < ::StandardError; end

class Failbot::Backtrace::Trimmer
  # @return [Trimmer] a new instance of Trimmer
  #
  # source://failbot//lib/failbot/backtrace/trimmer.rb#6
  def initialize(stacktrace_frame_limit, truncate_exception_types); end

  # @return [Boolean]
  #
  # source://failbot//lib/failbot/backtrace/trimmer.rb#18
  def should_trim?(exception_class, traces); end

  # Returns the value of attribute stacktrace_frame_limit.
  #
  # source://failbot//lib/failbot/backtrace/trimmer.rb#4
  def stacktrace_frame_limit; end

  # source://failbot//lib/failbot/backtrace/trimmer.rb#11
  def trim(traces); end

  # Returns the value of attribute truncate_exception_types.
  #
  # source://failbot//lib/failbot/backtrace/trimmer.rb#4
  def truncate_exception_types; end

  private

  # source://failbot//lib/failbot/backtrace/trimmer.rb#33
  def backtrace_too_long(traces); end

  # source://failbot//lib/failbot/backtrace/trimmer.rb#29
  def exception_in_truncation_list(exception_class); end

  # source://failbot//lib/failbot/backtrace/trimmer.rb#25
  def truncate_all_exceptions_by_default; end
end

# This is the default backtrace parser for the Structured formatter.
class Failbot::BacktraceParser
  class << self
    # Takes an Exception instance, returns an array of hashes with the keys that the Structured formatter expects.
    #
    # source://failbot//lib/failbot/backtrace_parser.rb#7
    def call(exception, backtrace_trimmer: T.unsafe(nil), frame_processing_pipeline: T.unsafe(nil)); end

    # source://failbot//lib/failbot/backtrace_parser.rb#17
    def maybe_trim_backtrace(exception, backtrace, backtrace_trimmer); end

    # @raise [ArgumentError]
    #
    # source://failbot//lib/failbot/backtrace_parser.rb#25
    def parse_backtrace(backtrace, frame_processing_pipeline = T.unsafe(nil)); end
  end
end

# source://failbot//lib/failbot/backtrace_parser.rb#4
Failbot::BacktraceParser::EMPTY_ARRAY = T.let(T.unsafe(nil), Array)

class Failbot::CircuitBreakerOpenError < ::StandardError
  # @return [CircuitBreakerOpenError] a new instance of CircuitBreakerOpenError
  #
  # source://failbot//lib/failbot/errors.rb#21
  def initialize; end
end

class Failbot::Config
  # @return [Config] a new instance of Config
  #
  # source://failbot//lib/failbot/config.rb#27
  def initialize(settings, default_context); end

  # Returns the value of attribute app_override.
  #
  # source://failbot//lib/failbot/config.rb#15
  def app_override; end

  # Returns the value of attribute backend.
  #
  # source://failbot//lib/failbot/config.rb#15
  def backend; end

  # Returns the value of attribute backtrace_trimmer.
  #
  # source://failbot//lib/failbot/config.rb#15
  def backtrace_trimmer; end

  # source://failbot//lib/failbot/config.rb#37
  def configure_failbot; end

  # Returns the value of attribute connect_timeout_seconds.
  #
  # source://failbot//lib/failbot/config.rb#15
  def connect_timeout_seconds; end

  # Stack of context information to include in the next failbot report. These
  # hashes are condensed down into one and included in the next report. Don't
  # mess with this structure directly - use the #push and #pop methods.
  #
  # source://failbot//lib/failbot/config.rb#65
  def context; end

  # Returns the value of attribute enable_timeout.
  #
  # source://failbot//lib/failbot/config.rb#15
  def enable_timeout; end

  # Returns the value of attribute exception_formatter.
  #
  # source://failbot//lib/failbot/config.rb#15
  def exception_formatter; end

  # Returns the value of attribute frame_processing_pipeline.
  #
  # source://failbot//lib/failbot/config.rb#15
  def frame_processing_pipeline; end

  # source://failbot//lib/failbot/config.rb#125
  def hostname; end

  # Returns the value of attribute ignored_error_classes.
  #
  # source://failbot//lib/failbot/config.rb#15
  def ignored_error_classes; end

  # Remove the last info hash from the context stack.
  #
  # source://failbot//lib/failbot/config.rb#105
  def pop; end

  # source://failbot//lib/failbot/config.rb#109
  def pop_sensitive; end

  # Add info to be sent in the next failbot report, should one occur.
  #
  # info  - Hash of name => value pairs to include in the exception report.
  # block - When given, the info is removed from the current context after the
  #         block is executed.
  #
  # Returns the value returned by the block when given; otherwise, returns nil.
  #
  # source://failbot//lib/failbot/config.rb#80
  def push(info = T.unsafe(nil)); end

  # source://failbot//lib/failbot/config.rb#92
  def push_sensitive(info = T.unsafe(nil)); end

  # Returns the value of attribute raise_errors.
  #
  # source://failbot//lib/failbot/config.rb#15
  def raise_errors; end

  # Returns the value of attribute raise_processing_errors.
  #
  # source://failbot//lib/failbot/config.rb#15
  def raise_processing_errors; end

  # source://failbot//lib/failbot/config.rb#33
  def register_frame_processing_pipeline(pipeline); end

  # source://failbot//lib/failbot/config.rb#118
  def remove_from_report(key); end

  # source://failbot//lib/failbot/config.rb#113
  def reset_context; end

  # source://failbot//lib/failbot/config.rb#69
  def sensitive_context; end

  # Returns the value of attribute thread_local_already_reporting.
  #
  # source://failbot//lib/failbot/config.rb#15
  def thread_local_already_reporting; end

  # Returns the value of attribute thread_local_context.
  #
  # source://failbot//lib/failbot/config.rb#15
  def thread_local_context; end

  # Returns the value of attribute thread_local_report_errors.
  #
  # source://failbot//lib/failbot/config.rb#15
  def thread_local_report_errors; end

  # Returns the value of attribute thread_local_sensitive_context.
  #
  # source://failbot//lib/failbot/config.rb#15
  def thread_local_sensitive_context; end

  # Returns the value of attribute timeout_seconds.
  #
  # source://failbot//lib/failbot/config.rb#15
  def timeout_seconds; end

  # source://failbot//lib/failbot/config.rb#55
  def validate_settings; end

  private

  # source://failbot//lib/failbot/config.rb#244
  def circuit_breaker_properties; end

  # Populate default context from settings.  Since settings commonly comes from
  # ENV, this allows setting defaults for the context via the environment.
  #
  # source://failbot//lib/failbot/config.rb#235
  def populate_context_from_settings; end

  # @return [Boolean]
  #
  # source://failbot//lib/failbot/config.rb#259
  def raise_processing_errors?; end

  # source://failbot//lib/failbot/config.rb#202
  def set_app_override; end

  # source://failbot//lib/failbot/config.rb#172
  def set_backend; end

  # source://failbot//lib/failbot/config.rb#228
  def set_backtrace_trimmer; end

  # source://failbot//lib/failbot/config.rb#206
  def set_catalog_service_in_default_context; end

  # source://failbot//lib/failbot/config.rb#163
  def set_connect_timeout; end

  # source://failbot//lib/failbot/config.rb#155
  def set_enable_timeout; end

  # source://failbot//lib/failbot/config.rb#212
  def set_exception_formatter; end

  # source://failbot//lib/failbot/config.rb#222
  def set_ignored_error_classes; end

  # source://failbot//lib/failbot/config.rb#192
  def set_raise_errors; end

  # source://failbot//lib/failbot/config.rb#151
  def set_raise_processing_errors; end

  # source://failbot//lib/failbot/config.rb#147
  def set_thread_local_already_reporting; end

  # source://failbot//lib/failbot/config.rb#132
  def set_thread_local_context; end

  # source://failbot//lib/failbot/config.rb#196
  def set_thread_local_report_errors; end

  class << self
    # source://failbot//lib/failbot/config.rb#21
    def configure_failbot(settings, default_context); end
  end
end

# source://failbot//lib/failbot/config.rb#10
Failbot::Config::EXCEPTION_FORMATS = T.let(T.unsafe(nil), Hash)

class Failbot::Config::InvalidSettingsError < ::StandardError
  # @return [InvalidSettingsError] a new instance of InvalidSettingsError
  #
  # source://failbot//lib/failbot/config.rb#5
  def initialize; end
end

# source://failbot//lib/failbot/console_backend.rb#4
class Failbot::ConsoleBackend
  # source://failbot//lib/failbot/console_backend.rb#5
  def report(data); end
end

# Default rollup for an exception. Exceptions with the same rollup are
# grouped together in Haystack. The rollup is an MD5 hash of the exception
# class and the raising file, line, and method.
#
# source://failbot//lib/failbot.rb#170
Failbot::DEFAULT_ROLLUP = T.let(T.unsafe(nil), Proc)

# source://failbot//lib/failbot.rb#110
Failbot::EXCEPTION_DETAIL = T.let(T.unsafe(nil), String)

module Failbot::ExceptionFormat; end

# The format recognized by haystack.
class Failbot::ExceptionFormat::Haystack
  class << self
    # Format an exception.
    #
    # source://failbot//lib/failbot/exception_format/haystack.rb#7
    def call(e); end

    # given a hash generated by this class, return the exception class name.
    #
    # source://failbot//lib/failbot/exception_format/haystack.rb#29
    def exception_classname_from_hash(hash); end

    # given a hash generated by this class, return the exception message.
    #
    # source://failbot//lib/failbot/exception_format/haystack.rb#24
    def exception_message_from_hash(hash); end

    # Pretty-print Exception#cause (and nested causes) for inclusion in needle
    # context
    #
    # e     - The Exception object whose #cause should be printed
    # depth - Integer number of Exception#cause objects to descend into.
    #
    # Returns a String.
    #
    # source://failbot//lib/failbot/exception_format/haystack.rb#40
    def pretty_print_cause(e, depth = T.unsafe(nil)); end

    # Pretty-print a single Exception#cause
    #
    # e - The Exception object whose #cause should be printed
    #
    # Returns a String.
    #
    # source://failbot//lib/failbot/exception_format/haystack.rb#69
    def pretty_print_one_cause(e); end
  end
end

# A newer exception format , based on the one sentry uses.  Aside from
# different names and locations for things, the notable difference from
# haystack is that backtrace data has more structure.
class Failbot::ExceptionFormat::Structured
  class << self
    # Format an exception.
    #
    # source://failbot//lib/failbot/exception_format/structured.rb#18
    def call(e, frame_processing_pipeline = T.unsafe(nil)); end

    # given a hash generated by this class, return the exception class name.
    def exception_classname_from_hash(hash); end

    # source://failbot//lib/failbot/exception_format/structured.rb#27
    def exception_details(e, frame_processing_pipeline); end

    # given a hash generated by this class, return the exception message.
    def exception_message_from_hash(hash); end
  end
end

# source://failbot//lib/failbot/exception_format/structured.rb#9
Failbot::ExceptionFormat::Structured::EMPTY_ARRAY = T.let(T.unsafe(nil), Array)

# source://failbot//lib/failbot/exception_format/structured.rb#11
Failbot::ExceptionFormat::Structured::FURTHER_CAUSES_WERE_OMITTED = T.let(T.unsafe(nil), Hash)

class Failbot::FileBackend
  # @return [FileBackend] a new instance of FileBackend
  #
  # source://failbot//lib/failbot/file_backend.rb#5
  def initialize(path); end

  # @raise [StandardError]
  #
  # source://failbot//lib/failbot/file_backend.rb#27
  def ping; end

  # source://failbot//lib/failbot/file_backend.rb#13
  def report(data); end

  # source://failbot//lib/failbot/file_backend.rb#19
  def reports; end
end

# source://failbot//lib/failbot/http_backend.rb#6
class Failbot::HTTPBackend
  # @raise [ArgumentError]
  # @return [HTTPBackend] a new instance of HTTPBackend
  #
  # source://failbot//lib/failbot/http_backend.rb#10
  def initialize(url, connect_timeout = T.unsafe(nil), timeout_seconds = T.unsafe(nil), circuit_breaker_properties = T.unsafe(nil)); end

  # Returns the value of attribute circuit_breaker.
  #
  # source://failbot//lib/failbot/http_backend.rb#7
  def circuit_breaker; end

  # Returns the value of attribute connect_timeout.
  #
  # source://failbot//lib/failbot/http_backend.rb#8
  def connect_timeout; end

  # Sets the attribute connect_timeout
  #
  # @param value the value to set the attribute connect_timeout to.
  #
  # source://failbot//lib/failbot/http_backend.rb#8
  def connect_timeout=(_arg0); end

  # source://failbot//lib/failbot/http_backend.rb#32
  def password; end

  # source://failbot//lib/failbot/http_backend.rb#36
  def ping; end

  # source://failbot//lib/failbot/http_backend.rb#20
  def report(data); end

  # source://failbot//lib/failbot/http_backend.rb#24
  def reports; end

  # Returns the value of attribute rw_timeout.
  #
  # source://failbot//lib/failbot/http_backend.rb#8
  def rw_timeout; end

  # Sets the attribute rw_timeout
  #
  # @param value the value to set the attribute rw_timeout to.
  #
  # source://failbot//lib/failbot/http_backend.rb#8
  def rw_timeout=(_arg0); end

  # source://failbot//lib/failbot/http_backend.rb#28
  def user; end

  private

  # source://failbot//lib/failbot/http_backend.rb#49
  def generate_request_body(data); end

  # source://failbot//lib/failbot/http_backend.rb#53
  def send_data(data); end

  # source://failbot//lib/failbot/http_backend.rb#69
  def send_request(request); end

  # Using yield for performance reasons: I'd rather pass an explicit block so
  # that's clear what the method does, but that's 1.5 times slower than using yield
  #
  # @raise [Failbot::CircuitBreakerOpenError]
  #
  # source://failbot//lib/failbot/http_backend.rb#95
  def with_circuit_breaker; end
end

# We'll include this many nested Exception#cause objects in the needle
# context. We limit the number of objects to prevent excessive recursion and
# large needle contexts.
#
# source://failbot//lib/failbot.rb#116
Failbot::MAXIMUM_CAUSE_DEPTH = T.let(T.unsafe(nil), Integer)

# source://failbot//lib/failbot/memory_backend.rb#2
class Failbot::MemoryBackend
  # @return [MemoryBackend] a new instance of MemoryBackend
  #
  # source://failbot//lib/failbot/memory_backend.rb#3
  def initialize; end

  # source://failbot//lib/failbot/memory_backend.rb#10
  def fail!; end

  # source://failbot//lib/failbot/memory_backend.rb#19
  def ping; end

  # source://failbot//lib/failbot/memory_backend.rb#14
  def report(data); end

  # Returns the value of attribute reports.
  #
  # source://failbot//lib/failbot/memory_backend.rb#8
  def reports; end

  # Sets the attribute reports
  #
  # @param value the value to set the attribute reports to.
  #
  # source://failbot//lib/failbot/memory_backend.rb#8
  def reports=(_arg0); end
end

class Failbot::MissingSetupError < ::StandardError
  # @return [MissingSetupError] a new instance of MissingSetupError
  #
  # source://failbot//lib/failbot/errors.rb#9
  def initialize; end
end

class Failbot::ReportingError < ::StandardError
  # @return [ReportingError] a new instance of ReportingError
  #
  # source://failbot//lib/failbot/errors.rb#15
  def initialize; end
end

# Rack middleware that rescues exceptions raised from the downstream app and
# reports to failbot. The exception is reraised after being sent to haystack
# so upstream middleware can still display an error page or whathaveyou.
#
# source://failbot//lib/failbot/middleware.rb#5
class Failbot::Rescuer
  # @return [Rescuer] a new instance of Rescuer
  #
  # source://failbot//lib/failbot/middleware.rb#6
  def initialize(app, other); end

  # source://failbot//lib/failbot/middleware.rb#11
  def call(env); end

  class << self
    # source://failbot//lib/failbot/middleware.rb#26
    def context(env); end

    # Borrowed from Rails.
    #
    # source://failbot//lib/failbot/middleware.rb#59
    def filter_parameters(filter_words, unfiltered_parameters); end

    # source://failbot//lib/failbot/middleware.rb#50
    def filtered_parameters(env, params); end

    # source://failbot//lib/failbot/middleware.rb#46
    def report(exception, env, other = T.unsafe(nil)); end
  end
end

# source://failbot//lib/failbot.rb#111
Failbot::SENSITIVE_CONTEXT = T.let(T.unsafe(nil), String)

module Failbot::SensitiveDataScrubber
  # source://failbot//lib/failbot/sensitive_data_scrubber.rb#9
  def scrub(hash); end

  # source://failbot//lib/failbot/sensitive_data_scrubber.rb#34
  def scrub_url(url); end

  # source://failbot//lib/failbot/sensitive_data_scrubber.rb#15
  def scrub_urls(value, max_depth = T.unsafe(nil)); end
end

# source://failbot//lib/failbot/sensitive_data_scrubber.rb#4
Failbot::SensitiveDataScrubber::BASIC_AUTH_REGEX = T.let(T.unsafe(nil), Regexp)

# source://failbot//lib/failbot/sensitive_data_scrubber.rb#3
Failbot::SensitiveDataScrubber::FILTERED = T.let(T.unsafe(nil), String)

# source://failbot//lib/failbot/sensitive_data_scrubber.rb#7
Failbot::SensitiveDataScrubber::MAX_DEPTH = T.let(T.unsafe(nil), Integer)

# source://failbot//lib/failbot/sensitive_data_scrubber.rb#6
Failbot::SensitiveDataScrubber::QUERY_STRING_REGEX = T.let(T.unsafe(nil), Regexp)

# source://failbot//lib/failbot/sensitive_data_scrubber.rb#5
Failbot::SensitiveDataScrubber::SENSITIVE_KEYWORDS = T.let(T.unsafe(nil), Array)

class Failbot::SetupError < ::StandardError
  # @return [SetupError] a new instance of SetupError
  #
  # source://failbot//lib/failbot/errors.rb#3
  def initialize; end
end

# Public: A simplified implementation of [`::Concurrent::ThreadLocalVar`](https://github.com/ruby-concurrency/concurrent-ruby/blob/7dc6eb04142f008ffa79a59c125669c6fcbb85a8/lib/concurrent-ruby/concurrent/atomic/thread_local_var.rb)
#
# Why not just use `concurrent-ruby`? We wanted to minimize external dependencies to avoid conflicts with gems already installed with `github/github`.
class Failbot::ThreadLocalVariable
  # @return [ThreadLocalVariable] a new instance of ThreadLocalVariable
  #
  # source://failbot//lib/failbot/thread_local_variable.rb#7
  def initialize(&block); end

  # source://failbot//lib/failbot/thread_local_variable.rb#12
  def value; end

  # source://failbot//lib/failbot/thread_local_variable.rb#16
  def value=(val); end

  # source://failbot//lib/failbot/thread_local_variable.rb#20
  def value_from_thread(thread); end
end

# source://failbot//lib/failbot/version.rb#2
Failbot::VERSION = T.let(T.unsafe(nil), String)

# source://failbot//lib/failbot/waiter_backend.rb#2
class Failbot::WaiterBackend
  # @return [WaiterBackend] a new instance of WaiterBackend
  #
  # source://failbot//lib/failbot/waiter_backend.rb#7
  def initialize(delay = T.unsafe(nil)); end

  # source://failbot//lib/failbot/waiter_backend.rb#17
  def ping; end

  # source://failbot//lib/failbot/waiter_backend.rb#12
  def report(data); end

  # This backend waits a configured amount of time before returning.  This is
  # intended be used to test timeouts.  Delay is the number of seconds to wait.
  #
  # source://failbot//lib/failbot/waiter_backend.rb#6
  def reports; end
end
