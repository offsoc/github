# typed: true

# DO NOT EDIT MANUALLY
# This is an autogenerated file for types exported from the `resqued` gem.
# Please instead update this file by running `bin/tapioca gem resqued`.

# source://resqued//lib/resqued/backoff.rb#1
module Resqued
  class << self
    # source://resqued//lib/resqued.rb#7
    def capture_start_ctx!; end
  end
end

# source://resqued//lib/resqued/backoff.rb#2
class Resqued::Backoff
  # @return [Backoff] a new instance of Backoff
  #
  # source://resqued//lib/resqued/backoff.rb#3
  def initialize(options = T.unsafe(nil)); end

  # Public: Tell backoff that the thing unexpectedly died.
  #
  # source://resqued//lib/resqued/backoff.rb#18
  def died; end

  # Public: How much longer until `wait?` will be false?
  #
  # @return [Boolean]
  #
  # source://resqued//lib/resqued/backoff.rb#29
  def how_long?; end

  # Public: Tell backoff that the thing we might want to back off from just started.
  #
  # source://resqued//lib/resqued/backoff.rb#11
  def started; end

  # Public: Check if we should wait before starting again.
  #
  # @return [Boolean]
  #
  # source://resqued//lib/resqued/backoff.rb#24
  def wait?; end

  private

  # Private: The next time when you're allowed to start a process.
  #
  # source://resqued//lib/resqued/backoff.rb#36
  def next_start_at; end

  # Private.
  #
  # source://resqued//lib/resqued/backoff.rb#41
  def now; end
end

# source://resqued//lib/resqued/config/dsl.rb#2
module Resqued::Config
  class << self
    # Public: Build a new ConfigFile instance.
    #
    # Resqued::Config is a module because the evaluators say so, so this `new` is a factory for another class.
    #
    # source://resqued//lib/resqued/config.rb#11
    def new(paths); end
  end
end

# A config handler that executes the `after_exit` block.
#
#     after_exit do |worker_summary|
#       # Runs in each listener.
#     end
#
# source://resqued//lib/resqued/config/after_exit.rb#10
class Resqued::Config::AfterExit < ::Resqued::Config::Base
  # Public.
  #
  # @return [AfterExit] a new instance of AfterExit
  #
  # source://resqued//lib/resqued/config/after_exit.rb#12
  def initialize(options = T.unsafe(nil)); end

  # DSL: execute the `after_exit` block.
  #
  # @yield [@worker_summary]
  #
  # source://resqued//lib/resqued/config/after_exit.rb#17
  def after_exit; end
end

# A config handler that executes the `after_fork` block.
#
#     after_fork do |resque_worker|
#       # Runs in each worker.
#     end
#
# source://resqued//lib/resqued/config/after_fork.rb#10
class Resqued::Config::AfterFork < ::Resqued::Config::Base
  # Public.
  #
  # @return [AfterFork] a new instance of AfterFork
  #
  # source://resqued//lib/resqued/config/after_fork.rb#12
  def initialize(options = T.unsafe(nil)); end

  # DSL: execute the `after_fork` block.
  #
  # @yield [@resque_worker]
  #
  # source://resqued//lib/resqued/config/after_fork.rb#17
  def after_fork; end
end

# Base class for config handlers.
#
# source://resqued//lib/resqued/config/base.rb#6
class Resqued::Config::Base
  include ::Resqued::Config::Dsl

  # Public: Apply the configuration in `str`.
  #
  # Currently, this is a simple wrapper around `instance_eval`.
  #
  # source://resqued//lib/resqued/config/base.rb#13
  def apply(str, filename = T.unsafe(nil)); end

  # Public: Apply the configuration from several files.
  #
  # source://resqued//lib/resqued/config/base.rb#19
  def apply_all(configs); end

  private

  # Private: Override require_relative to work around https://bugs.ruby-lang.org/issues/4487
  #
  # source://resqued//lib/resqued/config/base.rb#43
  def require_relative(path); end

  # Private: The results of applying the config.
  #
  # source://resqued//lib/resqued/config/base.rb#31
  def results; end

  # Private: Set a base path for require_relative.
  #
  # source://resqued//lib/resqued/config/base.rb#35
  def with_current_path(path); end
end

# A config handler that executes the `before_fork` block.
#
#     before_fork do
#       # Runs once, before forking all the workers.
#     end
#
# source://resqued//lib/resqued/config/before_fork.rb#10
class Resqued::Config::BeforeFork < ::Resqued::Config::Base
  # @return [BeforeFork] a new instance of BeforeFork
  #
  # source://resqued//lib/resqued/config/before_fork.rb#11
  def initialize(options = T.unsafe(nil)); end

  # DSL: Execute the `before_fork` block.
  #
  # @yield [@resqued]
  #
  # source://resqued//lib/resqued/config/before_fork.rb#16
  def before_fork; end
end

# Does the things that the config file says to do.
#
# source://resqued//lib/resqued/config.rb#16
class Resqued::Config::Configuration
  # @return [Configuration] a new instance of Configuration
  #
  # source://resqued//lib/resqued/config.rb#17
  def initialize(config_paths); end

  # Public: Perform the `after_exit` action from the config.
  #
  # source://resqued//lib/resqued/config.rb#32
  def after_exit(worker_summary); end

  # Public: Performs the `after_fork` action from the config.
  #
  # source://resqued//lib/resqued/config.rb#27
  def after_fork(worker); end

  # Public: Performs the `before_fork` action from the config.
  #
  # source://resqued//lib/resqued/config.rb#22
  def before_fork(resqued); end

  # Public: Builds the workers specified in the config.
  #
  # source://resqued//lib/resqued/config.rb#37
  def build_workers; end
end

# Defines the DSL for resqued config files.
#
# Each subclass should override parts of the dsl that it cares about.
#
# source://resqued//lib/resqued/config/dsl.rb#6
module Resqued::Config::Dsl
  # Public: Define a block to be run once after each worker exits.
  #
  # source://resqued//lib/resqued/config/dsl.rb#16
  def after_exit(&block); end

  # Public: Define a block to be run in each worker.
  #
  # source://resqued//lib/resqued/config/dsl.rb#12
  def after_fork(&block); end

  # Public: Define a block to be run once, before forking all the workers.
  #
  # source://resqued//lib/resqued/config/dsl.rb#8
  def before_fork(&block); end

  # Public: Define the queues worked by members of the worker pool.
  #
  # source://resqued//lib/resqued/config/dsl.rb#32
  def queue(*queues); end

  # Public: Define a worker that will work on a queue.
  #
  # source://resqued//lib/resqued/config/dsl.rb#20
  def worker(*queues); end

  # Public: Define a factory Proc that creates Resque::Workers
  #
  # source://resqued//lib/resqued/config/dsl.rb#28
  def worker_factory(&block); end

  # Public: Define a pool of workers that will work '*', or the queues specified by `queue`.
  #
  # source://resqued//lib/resqued/config/dsl.rb#24
  def worker_pool(count, *queues_and_options); end
end

# A config handler that builds workers.
#
# No worker processes are spawned by this class.
#
# source://resqued//lib/resqued/config/worker.rb#9
class Resqued::Config::Worker < ::Resqued::Config::Base
  # Public.
  #
  # @return [Worker] a new instance of Worker
  #
  # source://resqued//lib/resqued/config/worker.rb#11
  def initialize(options = T.unsafe(nil)); end

  # DSL: Define a queue for the worker_pool to work from.
  #
  #     queue 'one'
  #     queue '*'
  #     queue 'four-a', 'four-b', :percent => 10
  #     queue 'five', :count => 5
  #
  # source://resqued//lib/resqued/config/worker.rb#53
  def queue(*queues); end

  # DSL: Create a worker for the exact queues listed.
  #
  #     worker 'one', :interval => 1
  #
  # source://resqued//lib/resqued/config/worker.rb#21
  def worker(*queues); end

  # DSL: Define a factory Proc used to create Resque::Workers. The factory
  # Proc receives a list of queues as an argument.
  #
  #    worker_factory { |queues| Resque::Worker.new(*queues) }
  #
  # source://resqued//lib/resqued/config/worker.rb#43
  def worker_factory(&block); end

  # DSL: Set up a pool of workers. Define queues for the members of the pool with `queue`.
  #
  #     worker_pool 20, :interval => 1
  #
  # source://resqued//lib/resqued/config/worker.rb#32
  def worker_pool(count, *queues); end

  private

  # Internal: Like @queues but with concrete fixed concurrency values. All
  # percentage based concurrency values are converted to fixnum total number
  # of workers that queue should run on.
  #
  # source://resqued//lib/resqued/config/worker.rb#101
  def _fixed_concurrency_queues; end

  # Internal: Convert a queue worker concurrency value to a fixed number of
  # workers. This supports values that are fixed numbers as well as percentage
  # values (between 0.0 and 1.0). The value may also be nil, in which case the
  # maximum worker_processes value is returned.
  #
  # source://resqued//lib/resqued/config/worker.rb#109
  def _translate_concurrency_value(value); end

  # Internal: Build the pool workers.
  #
  # Build an array of Worker objects with queue lists configured based
  # on the concurrency values established and the total number of workers.
  #
  # source://resqued//lib/resqued/config/worker.rb#82
  def build_pool_workers!; end

  # source://resqued//lib/resqued/config/worker.rb#73
  def results; end
end

# A listener process. Watches resque queues and forks workers.
#
# source://resqued//lib/resqued/listener.rb#13
class Resqued::Listener
  include ::Resqued::Logging
  include ::Resqued::ProclineVersion
  include ::Resqued::Sleepy

  # Configure a new listener object.
  #
  # Runs in the master process.
  #
  # @return [Listener] a new instance of Listener
  #
  # source://resqued//lib/resqued/listener.rb#21
  def initialize(options); end

  # Private: make sure all the workers stop.
  #
  # Resque workers have gaps in their signal-handling ability.
  #
  # source://resqued//lib/resqued/listener.rb#124
  def burn_down_workers(signal); end

  # Private: Check if master reports any dead workers.
  #
  # source://resqued//lib/resqued/listener.rb#192
  def check_for_expired_workers; end

  # Public: As an alternative to #run, exec a new ruby instance for this listener.
  #
  # Runs in the master process.
  #
  # source://resqued//lib/resqued/listener.rb#31
  def exec; end

  # Private.
  #
  # source://resqued//lib/resqued/listener.rb#207
  def finish_worker(worker_pid, status); end

  # Private.
  #
  # source://resqued//lib/resqued/listener.rb#263
  def info; end

  # Private.
  #
  # source://resqued//lib/resqued/listener.rb#228
  def init_workers(config); end

  # Private: send a signal to all the workers.
  #
  # source://resqued//lib/resqued/listener.rb#142
  def kill_all(signal); end

  # Private: just the workers running as children of this listener.
  #
  # source://resqued//lib/resqued/listener.rb#157
  def my_workers; end

  # Private: Split the workers into [not-running, running]
  #
  # source://resqued//lib/resqued/listener.rb#162
  def partition_workers; end

  # Private: Check for workers that have stopped running
  #
  # source://resqued//lib/resqued/listener.rb#177
  def reap_workers(waitpidflags = T.unsafe(nil)); end

  # Private: Report child process status.
  #
  # Examples:
  #
  #     report_to_master("+12345,queue")  # Worker process PID:12345 started, working on a job from "queue".
  #     report_to_master("-12345")        # Worker process PID:12345 exited.
  #
  # source://resqued//lib/resqued/listener.rb#243
  def report_to_master(status); end

  # Public: Run the main loop.
  #
  # source://resqued//lib/resqued/listener.rb#71
  def run; end

  # Private.
  #
  # source://resqued//lib/resqued/listener.rb#104
  def run_workers_run; end

  # Private: just the running workers.
  #
  # source://resqued//lib/resqued/listener.rb#152
  def running_workers; end

  # Private.
  #
  # source://resqued//lib/resqued/listener.rb#94
  def set_default_resque_logger; end

  # Private.
  #
  # source://resqued//lib/resqued/listener.rb#216
  def start_idle_workers; end

  # Private: all available workers
  #
  # source://resqued//lib/resqued/listener.rb#149
  def workers; end

  # Private.
  #
  # source://resqued//lib/resqued/listener.rb#252
  def write_procline(status); end

  # Private.
  #
  # source://resqued//lib/resqued/listener.rb#167
  def yawn(sleep_time = T.unsafe(nil)); end

  class << self
    # Public: Given args from #exec, start this listener.
    #
    # source://resqued//lib/resqued/listener.rb#48
    def exec!; end
  end
end

# source://resqued//lib/resqued/listener.rb#66
Resqued::Listener::ALL_SIGNALS = T.let(T.unsafe(nil), Array)

# source://resqued//lib/resqued/listener.rb#65
Resqued::Listener::SIGNALS = T.let(T.unsafe(nil), Array)

# source://resqued//lib/resqued/listener.rb#68
Resqued::Listener::SIGNAL_QUEUE = T.let(T.unsafe(nil), Array)

# source://resqued//lib/resqued/listener_pool.rb#5
class Resqued::ListenerPool
  include ::Prelude::Enumerator
  include ::Enumerable

  # Public: Initialize a new pool, and store state in the given master's state.
  #
  # @return [ListenerPool] a new instance of ListenerPool
  #
  # source://resqued//lib/resqued/listener_pool.rb#9
  def initialize(master_state); end

  # Public: Don't consider the current listener to be current anymore.
  #
  # source://resqued//lib/resqued/listener_pool.rb#66
  def clear_current!; end

  # Public: Forget which listener was the last good one.
  #
  # source://resqued//lib/resqued/listener_pool.rb#87
  def clear_last_good!; end

  # Public: The current ListenerProxy, if available.
  #
  # source://resqued//lib/resqued/listener_pool.rb#56
  def current; end

  # Public: The pid of the current listener, if available.
  #
  # source://resqued//lib/resqued/listener_pool.rb#61
  def current_pid; end

  # Public: Change the current listener into the last good listener.
  #
  # source://resqued//lib/resqued/listener_pool.rb#71
  def cycle_current; end

  # Public: Remove the given pid from the set of known listeners, and return its ListenerProxy.
  #
  # source://resqued//lib/resqued/listener_pool.rb#50
  def delete(pid); end

  # Public: Iterate through all active ListenerProxy instances.
  #
  # source://resqued//lib/resqued/listener_pool.rb#19
  def each(&block); end

  # Public: Are the listeners all gone?
  #
  # @return [Boolean]
  #
  # source://resqued//lib/resqued/listener_pool.rb#29
  def empty?; end

  # Public: The last good (previous current) ListenerProxy, if available.
  #
  # source://resqued//lib/resqued/listener_pool.rb#77
  def last_good; end

  # Public: The pid of the last good listener, if available.
  #
  # source://resqued//lib/resqued/listener_pool.rb#82
  def last_good_pid; end

  # Public: Number of active listeners.
  #
  # source://resqued//lib/resqued/listener_pool.rb#24
  def size; end

  # Public: Initialize a new listener, run it, and record it as the current listener. Returns its ListenerProxy.
  #
  # source://resqued//lib/resqued/listener_pool.rb#34
  def start!; end

  private

  # source://resqued//lib/resqued/listener_pool.rb#93
  def next_listener_id; end
end

# Controls a listener process from the master process.
#
# source://resqued//lib/resqued/listener_proxy.rb#9
class Resqued::ListenerProxy
  include ::Resqued::Logging

  # Public.
  #
  # @return [ListenerProxy] a new instance of ListenerProxy
  #
  # source://resqued//lib/resqued/listener_proxy.rb#13
  def initialize(state); end

  # Public: wrap up all the things, this object is going home.
  #
  # source://resqued//lib/resqued/listener_proxy.rb#20
  def dispose; end

  # Public: Stop the listener process.
  #
  # source://resqued//lib/resqued/listener_proxy.rb#58
  def kill(signal); end

  # Public: The pid of the running listener process.
  #
  # source://resqued//lib/resqued/listener_proxy.rb#33
  def pid; end

  # Public: An IO to select on to check if there is incoming data available.
  #
  # source://resqued//lib/resqued/listener_proxy.rb#28
  def read_pipe; end

  # Public: Check for updates on running worker information.
  #
  # source://resqued//lib/resqued/listener_proxy.rb#74
  def read_worker_status(options); end

  # Public: Start the listener process.
  #
  # source://resqued//lib/resqued/listener_proxy.rb#38
  def run; end

  # Public: Get the list of workers running from this listener.
  #
  # source://resqued//lib/resqued/listener_proxy.rb#64
  def running_workers; end

  # Returns the value of attribute state.
  #
  # source://resqued//lib/resqued/listener_proxy.rb#17
  def state; end

  # Public: Tell the listener process that a worker finished.
  #
  # source://resqued//lib/resqued/listener_proxy.rb#99
  def worker_finished(pid); end

  # Private: Map worker pids to queue names
  #
  # source://resqued//lib/resqued/listener_proxy.rb#69
  def worker_pids; end
end

# source://resqued//lib/resqued/listener_state.rb#2
class Resqued::ListenerState
  # Returns the value of attribute master_socket.
  #
  # source://resqued//lib/resqued/listener_state.rb#3
  def master_socket; end

  # Sets the attribute master_socket
  #
  # @param value the value to set the attribute master_socket to.
  #
  # source://resqued//lib/resqued/listener_state.rb#3
  def master_socket=(_arg0); end

  # Returns the value of attribute options.
  #
  # source://resqued//lib/resqued/listener_state.rb#4
  def options; end

  # Sets the attribute options
  #
  # @param value the value to set the attribute options to.
  #
  # source://resqued//lib/resqued/listener_state.rb#4
  def options=(_arg0); end

  # Returns the value of attribute pid.
  #
  # source://resqued//lib/resqued/listener_state.rb#5
  def pid; end

  # Sets the attribute pid
  #
  # @param value the value to set the attribute pid to.
  #
  # source://resqued//lib/resqued/listener_state.rb#5
  def pid=(_arg0); end

  # Returns the value of attribute worker_pids.
  #
  # source://resqued//lib/resqued/listener_state.rb#6
  def worker_pids; end

  # Sets the attribute worker_pids
  #
  # @param value the value to set the attribute worker_pids to.
  #
  # source://resqued//lib/resqued/listener_state.rb#6
  def worker_pids=(_arg0); end
end

# Mixin for any class that wants to write messages to the log file.
#
# source://resqued//lib/resqued/logging.rb#5
module Resqued::Logging
  # Private (in classes that include this module)
  #
  # source://resqued//lib/resqued/logging.rb#91
  def log(level, message = T.unsafe(nil)); end

  # Public.
  #
  # @return [Boolean]
  #
  # source://resqued//lib/resqued/logging.rb#81
  def log_to_stdout?; end

  # Public: Re-open all log files.
  #
  # source://resqued//lib/resqued/logging.rb#86
  def reopen_logs; end

  class << self
    # source://resqued//lib/resqued/logging.rb#13
    def build_logger; end

    # Public: Make sure the log IO is closed.
    #
    # source://resqued//lib/resqued/logging.rb#61
    def close_log; end

    # Public.
    #
    # source://resqued//lib/resqued/logging.rb#75
    def log_file; end

    # Public.
    #
    # source://resqued//lib/resqued/logging.rb#69
    def log_file=(path); end

    # Public: Get a `Logger`.
    #
    # source://resqued//lib/resqued/logging.rb#9
    def logger; end

    # Private: Get an IO to write log messages to.
    #
    # source://resqued//lib/resqued/logging.rb#44
    def logging_io; end
  end
end

# The master process.
# * Spawns a listener.
# * Tracks all work. (IO pipe from listener.)
# * Handles signals.
#
# source://resqued//lib/resqued/master.rb#15
class Resqued::Master
  include ::Resqued::Logging
  include ::Resqued::Pidfile
  include ::Resqued::ProclineVersion
  include ::Resqued::Sleepy

  # @return [Master] a new instance of Master
  #
  # source://resqued//lib/resqued/master.rb#21
  def initialize(state, options = T.unsafe(nil)); end

  # Private.
  #
  # source://resqued//lib/resqued/master.rb#83
  def dump_object_counts; end

  # Private: dat main loop.
  #
  # source://resqued//lib/resqued/master.rb#44
  def go_ham; end

  # source://resqued//lib/resqued/master.rb#224
  def install_signal_handlers; end

  # source://resqued//lib/resqued/master.rb#178
  def kill_all_listeners(signal); end

  # source://resqued//lib/resqued/master.rb#174
  def kill_listener(signal, listener); end

  # Listener message: A listener finished booting, and is ready to
  # start workers.
  #
  # Promotes a booting listener to be the current listener.
  #
  # source://resqued//lib/resqued/master.rb#143
  def listener_running(listener); end

  # source://resqued//lib/resqued/master.rb#251
  def listener_status(listener, status); end

  # source://resqued//lib/resqued/master.rb#239
  def no_more_unexpected_exits; end

  # Private: Spin up a new listener.
  #
  # The old one will be killed when the new one is ready for workers.
  #
  # source://resqued//lib/resqued/master.rb#159
  def prepare_new_listener; end

  # source://resqued//lib/resqued/master.rb#118
  def read_listeners; end

  # source://resqued//lib/resqued/master.rb#188
  def reap_all_listeners(waitpid_flags = T.unsafe(nil)); end

  # source://resqued//lib/resqued/master.rb#230
  def report_unexpected_exits; end

  # Public: Starts the master process.
  #
  # source://resqued//lib/resqued/master.rb#29
  def run(ready_pipe = T.unsafe(nil)); end

  # source://resqued//lib/resqued/master.rb#109
  def start_listener; end

  # source://resqued//lib/resqued/master.rb#261
  def status_message(type, pid, status); end

  # source://resqued//lib/resqued/master.rb#184
  def wait_for_workers; end

  # Listener message: A worker just stopped working.
  #
  # Forwards the message to the other listeners.
  #
  # source://resqued//lib/resqued/master.rb#132
  def worker_finished(pid); end

  # Listener message: A worker just started working.
  #
  # source://resqued//lib/resqued/master.rb#125
  def worker_started(pid); end

  # source://resqued//lib/resqued/master.rb#257
  def worker_status(pid, status); end

  # source://resqued//lib/resqued/master.rb#247
  def write_procline; end

  # source://resqued//lib/resqued/master.rb#243
  def yawn(duration); end
end

# source://resqued//lib/resqued/master.rb#218
Resqued::Master::OPTIONAL_SIGNALS = T.let(T.unsafe(nil), Array)

# source://resqued//lib/resqued/master.rb#219
Resqued::Master::OTHER_SIGNALS = T.let(T.unsafe(nil), Array)

# source://resqued//lib/resqued/master.rb#217
Resqued::Master::SIGNALS = T.let(T.unsafe(nil), Array)

# source://resqued//lib/resqued/master.rb#222
Resqued::Master::SIGNAL_QUEUE = T.let(T.unsafe(nil), Array)

# source://resqued//lib/resqued/master.rb#220
Resqued::Master::TRAPS = T.let(T.unsafe(nil), Array)

# Tracks state from the master process. On re-exec, this object will
# be serialized and passed to the new master.
#
# source://resqued//lib/resqued/master_state.rb#4
class Resqued::MasterState
  # @return [MasterState] a new instance of MasterState
  #
  # source://resqued//lib/resqued/master_state.rb#5
  def initialize; end

  # Paths of app's resqued configuration files. The paths are passed
  # to the listener, and the listener reads the config so that it
  # knows which workers to create.
  #
  # source://resqued//lib/resqued/master_state.rb#70
  def config_paths; end

  # The PID of the newest listener. This is the one listener that
  # should continue running.
  #
  # source://resqued//lib/resqued/master_state.rb#74
  def current_listener_pid; end

  # The PID of the newest listener. This is the one listener that
  # should continue running.
  #
  # source://resqued//lib/resqued/master_state.rb#74
  def current_listener_pid=(_arg0); end

  # (Deprecated.) If true, on SIGHUP re-exec the master process before
  # starting a new listener.
  #
  # source://resqued//lib/resqued/master_state.rb#78
  def exec_on_hup; end

  # If true, on SIGTERM/SIGQUIT/SIGINT, don't wait for listeners to
  # exit before the master exits.
  #
  # source://resqued//lib/resqued/master_state.rb#82
  def fast_exit; end

  # Public: When starting fresh, from command-line options, assign the
  # initial values.
  #
  # source://resqued//lib/resqued/master_state.rb#12
  def init(options); end

  # The PID of the newest listener that booted successfully. This
  # listener won't be stopped until a newer listener boots
  # successfully.
  #
  # source://resqued//lib/resqued/master_state.rb#87
  def last_good_listener_pid; end

  # The PID of the newest listener that booted successfully. This
  # listener won't be stopped until a newer listener boots
  # successfully.
  #
  # source://resqued//lib/resqued/master_state.rb#87
  def last_good_listener_pid=(_arg0); end

  # A hash of pid => ListenerState for all running listeners.
  #
  # source://resqued//lib/resqued/master_state.rb#93
  def listener_states; end

  # The number of listeners that have been created by this master.
  #
  # source://resqued//lib/resqued/master_state.rb#90
  def listeners_created; end

  # The number of listeners that have been created by this master.
  #
  # source://resqued//lib/resqued/master_state.rb#90
  def listeners_created=(_arg0); end

  # Set to true when this master is paused and should not be running
  # any listeners.
  #
  # source://resqued//lib/resqued/master_state.rb#97
  def paused; end

  # Set to true when this master is paused and should not be running
  # any listeners.
  #
  # source://resqued//lib/resqued/master_state.rb#97
  def paused=(_arg0); end

  # If set, the master's PID will be written to this file.
  #
  # source://resqued//lib/resqued/master_state.rb#100
  def pidfile; end

  # Public: Restore state from a serialized form.
  #
  # source://resqued//lib/resqued/master_state.rb#20
  def restore(data); end

  # Public: Return an array of open sockets or other file handles that
  # should be forwarded to a new master.
  #
  # source://resqued//lib/resqued/master_state.rb#63
  def sockets; end

  # Public: Return this state so that it can be serialized.
  #
  # source://resqued//lib/resqued/master_state.rb#40
  def to_h; end
end

# Mixin that manages a pidfile for a process.
#
# source://resqued//lib/resqued/pidfile.rb#3
module Resqued::Pidfile
  # Private.
  #
  # source://resqued//lib/resqued/pidfile.rb#27
  def remove_pidfile(filename); end

  # Public: Create a pidfile, execute the block, then remove the pidfile.
  #
  # source://resqued//lib/resqued/pidfile.rb#5
  def with_pidfile(filename); end

  # Private.
  #
  # source://resqued//lib/resqued/pidfile.rb#13
  def write_pidfile(filename); end
end

# source://resqued//lib/resqued/procline_version.rb#4
module Resqued::ProclineVersion
  # source://resqued//lib/resqued/procline_version.rb#5
  def procline_version; end
end

# source://resqued//lib/resqued/replace_master.rb#5
class Resqued::ReplaceMaster
  class << self
    # Public: Replace the current master process with a new one, while preserving state.
    #
    # source://resqued//lib/resqued/replace_master.rb#7
    def exec!(state); end

    # Internal: Returns exec options for each open socket in 'state'.
    #
    # source://resqued//lib/resqued/replace_master.rb#12
    def exec_opts(state); end

    # Internal: Restore the master's state, and remove the state file.
    #
    # source://resqued//lib/resqued/replace_master.rb#36
    def restore_state(state, path); end

    # Internal: Write out current state to a file, so that a new master can pick up from where we left off.
    #
    # source://resqued//lib/resqued/replace_master.rb#24
    def store_state(state); end
  end
end

# source://resqued//lib/resqued/runtime_info.rb#2
class Resqued::RuntimeInfo
  # Returns the value of attribute app_version.
  #
  # source://resqued//lib/resqued/runtime_info.rb#3
  def app_version; end

  # Sets the attribute app_version
  #
  # @param value the value to set the attribute app_version to.
  #
  # source://resqued//lib/resqued/runtime_info.rb#3
  def app_version=(_arg0); end
end

# source://resqued//lib/resqued.rb#5
Resqued::START_CTX = T.let(T.unsafe(nil), Hash)

# source://resqued//lib/resqued/sleepy.rb#5
module Resqued::Sleepy
  # Public: Break out of `yawn`.
  #
  # source://resqued//lib/resqued/sleepy.rb#18
  def awake; end

  # Private.
  #
  # source://resqued//lib/resqued/sleepy.rb#23
  def self_pipe; end

  # Public: Like sleep, but the sleep is interrupted if input is
  # detected on one of the provided IO objects, or if `awake` is
  # called (e.g. from a signal handler).
  #
  # source://resqued//lib/resqued/sleepy.rb#9
  def yawn(duration, *inputs); end
end

# source://resqued//lib/resqued/version.rb#2
Resqued::VERSION = T.let(T.unsafe(nil), String)

# Models a worker process.
#
# source://resqued//lib/resqued/worker.rb#8
class Resqued::Worker
  include ::Resqued::Logging

  # @return [Worker] a new instance of Worker
  #
  # source://resqued//lib/resqued/worker.rb#24
  def initialize(options); end

  # Public: The amount of time we need to wait before starting a new worker.
  #
  # source://resqued//lib/resqued/worker.rb#83
  def backing_off_for; end

  # Public: The old worker process finished!
  #
  # source://resqued//lib/resqued/worker.rb#64
  def finished!(process_status); end

  # Public: True if there is no worker process mapped to this object.
  #
  # @return [Boolean]
  #
  # source://resqued//lib/resqued/worker.rb#40
  def idle?; end

  # Public: Shut this worker down.
  #
  # source://resqued//lib/resqued/worker.rb#117
  def kill(signal); end

  # Public: The pid of the worker process.
  #
  # source://resqued//lib/resqued/worker.rb#34
  def pid; end

  # Public: A string that compares if this worker is equivalent to a worker in another Resqued::Listener.
  #
  # source://resqued//lib/resqued/worker.rb#50
  def queue_key; end

  # Private.
  #
  # source://resqued//lib/resqued/worker.rb#37
  def queues; end

  # Public: True if this worker is running in this process.
  #
  # @return [Boolean]
  #
  # source://resqued//lib/resqued/worker.rb#45
  def running_here?; end

  # Public: Start a job, if there's one waiting in one of my queues.
  #
  # source://resqued//lib/resqued/worker.rb#88
  def try_start; end

  # Public: Claim this worker for another listener's worker.
  #
  # source://resqued//lib/resqued/worker.rb#55
  def wait_for(pid); end
end

# source://resqued//lib/resqued/worker.rb#11
Resqued::Worker::DEFAULT_WORKER_FACTORY = T.let(T.unsafe(nil), Proc)

# Metadata for an exited listener worker.
#
# source://resqued//lib/resqued/worker.rb#126
class Resqued::WorkerSummary
  # @return [WorkerSummary] a new instance of WorkerSummary
  #
  # source://resqued//lib/resqued/worker.rb#129
  def initialize(alive_time_sec:, process_status:); end

  # Returns the value of attribute alive_time_sec.
  #
  # source://resqued//lib/resqued/worker.rb#127
  def alive_time_sec; end

  # Returns the value of attribute process_status.
  #
  # source://resqued//lib/resqued/worker.rb#127
  def process_status; end
end
