# typed: true

# DO NOT EDIT MANUALLY
# This is an autogenerated file for types exported from the `zache` gem.
# Please instead update this file by running `bin/tapioca gem zache`.

# source://zache//lib/zache.rb#39
class Zache
  # Makes a new object of the cache.
  #
  # "sync" is whether the hash is thread-safe (`true`)
  # or not (`false`); it is recommended to leave this parameter untouched,
  # unless you really know what you are doing.
  #
  # If the <tt>dirty</tt> argument is set to <tt>true</tt>, a previously
  # calculated result will be returned if it exists and is already expired.
  #
  # @return [Zache] a new instance of Zache
  #
  # source://zache//lib/zache.rb#77
  def initialize(sync: T.unsafe(nil), dirty: T.unsafe(nil)); end

  # Remove keys that are expired.
  #
  # source://zache//lib/zache.rb#179
  def clean; end

  # @return [Boolean]
  #
  # source://zache//lib/zache.rb#183
  def empty?; end

  # Checks whether the value exists in the cache by the provided key. Returns
  # TRUE if the value is here. If the key is already expired in the hash,
  # it will be removed by this method and the result will be FALSE.
  #
  # @return [Boolean]
  #
  # source://zache//lib/zache.rb#119
  def exists?(key, dirty: T.unsafe(nil)); end

  # Checks whether the key exists in the cache and is expired. If the
  # key is absent FALSE is returned.
  #
  # @return [Boolean]
  #
  # source://zache//lib/zache.rb#130
  def expired?(key); end

  # Gets the value from the cache by the provided key.
  #
  # If the value is not
  # found in the cache, it will be calculated via the provided block. If
  # the block is not given, an exception will be raised (unless <tt>dirty</tt>
  # is set to <tt>true</tt>). The lifetime
  # must be in seconds. The default lifetime is huge, which means that the
  # key will never be expired.
  #
  # If the <tt>dirty</tt> argument is set to <tt>true</tt>, a previously
  # calculated result will be returned if it exists and is already expired.
  #
  # source://zache//lib/zache.rb#100
  def get(key, lifetime: T.unsafe(nil), dirty: T.unsafe(nil), &block); end

  # Is cache currently locked doing something?
  #
  # @return [Boolean]
  #
  # source://zache//lib/zache.rb#143
  def locked?; end

  # Returns the modification time of the key, if it exists.
  # If not, current time is returned.
  #
  # source://zache//lib/zache.rb#137
  def mtime(key); end

  # Put a value into the cache.
  #
  # source://zache//lib/zache.rb#148
  def put(key, value, lifetime: T.unsafe(nil)); end

  # Removes the value from the cache, by the provided key. If the key is absent
  # and the block is provided, the block will be called.
  #
  # source://zache//lib/zache.rb#160
  def remove(key); end

  # Remove all keys from the cache.
  #
  # source://zache//lib/zache.rb#165
  def remove_all; end

  # Remove all keys that match the block.
  #
  # source://zache//lib/zache.rb#170
  def remove_by; end

  # Total number of keys currently in cache.
  #
  # source://zache//lib/zache.rb#85
  def size; end

  private

  # source://zache//lib/zache.rb#189
  def calc(key, lifetime); end

  # source://zache//lib/zache.rb#202
  def synchronized(&block); end
end

# Fake implementation that doesn't cache anything, but behaves like it
# does. It implements all methods of the original class, but doesn't do
# any caching. This is very useful for testing.
#
# source://zache//lib/zache.rb#43
class Zache::Fake
  # source://zache//lib/zache.rb#66
  def clean; end

  # @return [Boolean]
  #
  # source://zache//lib/zache.rb#52
  def exists?(*_arg0); end

  # source://zache//lib/zache.rb#48
  def get(*_arg0); end

  # @return [Boolean]
  #
  # source://zache//lib/zache.rb#56
  def locked?; end

  # source://zache//lib/zache.rb#60
  def put(*_arg0); end

  # source://zache//lib/zache.rb#62
  def remove(_key); end

  # source://zache//lib/zache.rb#64
  def remove_all; end

  # source://zache//lib/zache.rb#44
  def size; end
end
