#!/bin/bash
#/ Usage: ghe-ssl-generate-self-signed [<ip_address>]
set -e

. /etc/github/enterprise-release

if [ "$(whoami)" != "root" ]; then
  exec sudo -E "$0" "$@"
fi

export PATH=/bin:/sbin:/usr/sbin:/usr/bin:/usr/local/bin:/usr/local/sbin

function log {
  echo "$(date '+%Y-%m-%d %H:%M:%S') - $1" >&2
}

function fetch_instance_ip {
  local instance_ip
  instance_ip=$(ip -f inet addr show eth0 | grep inet | awk '{ print $2 }' | cut -d '/' -f 1 | head -1)
  if [ -z "$instance_ip" ]; then
    log "Error: Could not fetch instance IP"
  else
    log "Fetched instance IP: $instance_ip"
  fi
  echo "$instance_ip"
}

function fetch_instance_ipv6 {
  local instance_ipv6
  instance_ipv6=$(ip -f inet6 addr show eth0 | grep inet6 | grep "scope global" | awk '{ print $2 }' | cut -d '/' -f 1)
  if [ -z "$instance_ipv6" ]; then
    log "Error: Could not fetch instance IPv6"
  else
    log "Fetched instance IPv6: $instance_ipv6"
  fi
  echo "$instance_ipv6"
}

function fetch_public_ip {
  local public_ip=""
  if [ -f /etc/github/ec2-ami ]; then
    local public_ipv4_endpoint="http://169.254.169.254/latest/meta-data/public-ipv4"
    local imds_token
    imds_token=$(curl -f -s --retry 1 --max-time 5 --noproxy 169.254.169.254 -X PUT -H "X-aws-ec2-metadata-token-ttl-seconds: 500" "http://169.254.169.254/latest/api/token" || true)

    if [ -n "$imds_token" ]; then
      log "Using IMDSv2 for fetching public IP"
      public_ip=$(curl -f -s --retry 1 --max-time 5 --noproxy 169.254.169.254 -H "X-aws-ec2-metadata-token: $imds_token" "$public_ipv4_endpoint" | tr -d '\n' || true)
    else
      log "Using IMDSv1 for fetching public IP"
      public_ip=$(curl -f -s --retry 1 --max-time 5 --noproxy 169.254.169.254 "$public_ipv4_endpoint" | tr -d '\n' || true)
    fi
    if [ -z "$public_ip" ]; then
      log "Error: Could not fetch public IP using EC2 metadata"
    else
      log "Fetched public IP using EC2 metadata: $public_ip"
    fi
  fi
  if [ "$RELEASE_PLATFORM" = "gce" ]; then
    public_ip=$(curl -H "Metadata-Flavor: Google" -s http://169.254.169.254/computeMetadata/v1/instance/network-interfaces/0/access-configs/0/external-ip || true)
    if [ -z "$public_ip" ]; then
      log "Error: Could not fetch public IP using GCE metadata"
    else
      log "Fetched public IP using GCE metadata: $public_ip"
    fi
  fi
  if [ "$RELEASE_PLATFORM" = "azure" ]; then
    public_ip=$(curl -H Metadata:true "http://169.254.169.254/metadata/instance/network/interface/0/ipv4/ipAddress/0/publicIpAddress?api-version=2017-08-01&format=text" || true)
    if [ -z "$public_ip" ]; then
      log "Error: Could not fetch public IP using Azure metadata"
    else
      log "Fetched public IP using Azure metadata: $public_ip"
    fi
  fi
  echo "$public_ip"
}

function fetch_vpc_id {
  local vpc_id=""
  if [ -f /etc/github/ec2-ami ]; then
    local imds_token
    imds_token=$(curl -f -s --retry 1 --max-time 5 --noproxy 169.254.169.254 -X PUT -H "X-aws-ec2-metadata-token-ttl-seconds: 500" "http://169.254.169.254/latest/api/token" || true)
    
    if [ -n "$imds_token" ]; then
      log "Using IMDSv2 for fetching VPC ID"
      vpc_id=$(curl -H "X-aws-ec2-metadata-token: $imds_token" -f -s --retry 1 --max-time 5 --noproxy 169.254.169.254 http://169.254.169.254/latest/meta-data/network/interfaces/macs/$(cat /sys/class/net/eth0/address)/vpc-id || true)
    else
      log "Using IMDSv1 for fetching VPC ID"
      vpc_id=$(curl -f -s --retry 1 --max-time 5 --noproxy 169.254.169.254 http://169.254.169.254/latest/meta-data/network/interfaces/macs/$(cat /sys/class/net/eth0/address)/vpc-id || true)
    fi
    if [ -z "$vpc_id" ]; then
      log "Error: Could not fetch VPC ID"
    else
      log "Fetched VPC ID: $vpc_id"
    fi
  fi
  echo "$vpc_id"
}

function fetch_public_hostname {
  local public_hostname=""
  if [ -f /etc/github/ec2-ami ]; then
    local public_hostname_endpoint="http://169.254.169.254/latest/meta-data/public-hostname"
    local imds_token
    imds_token=$(curl -f -s --retry 1 --max-time 5 --noproxy 169.254.169.254 -X PUT -H "X-aws-ec2-metadata-token-ttl-seconds: 500" "http://169.254.169.254/latest/api/token" || true)
    
    if [ -n "$imds_token" ]; then
      log "Using IMDSv2 for fetching public hostname"
      public_hostname=$(curl -f -s --retry 1 --max-time 5 --noproxy 169.254.169.254 -H "X-aws-ec2-metadata-token: $imds_token" "$public_hostname_endpoint" | tr -d '\n' || true)
    else
      log "Using IMDSv1 for fetching public hostname"
      public_hostname=$(curl -f -s --retry 1 --max-time 5 --noproxy 169.254.169.254 "$public_hostname_endpoint" | tr -d '\n' || true)
    fi
    if [ -z "$public_hostname" ]; then
      log "Error: Could not fetch public hostname using EC2 metadata"
    else
      log "Fetched public hostname using EC2 metadata: $public_hostname"
    fi
  fi
  if [ "$RELEASE_PLATFORM" = 'azure' -a -f /var/lib/waagent/SharedConfig.xml ]; then
    local service
    service=$(curl -H Metadata:true "http://169.254.169.254/metadata/instance/compute/name?api-version=2017-08-01&format=text")
    if [ -n "$service" ]; then
      public_hostname="$service.cloudapp.net"
      log "Fetched public hostname using Azure metadata: $public_hostname"
    else
      log "Error: Could not fetch public hostname using Azure metadata"
    fi
  fi
  echo "$public_hostname"
}

if [ -n "$1" ]; then
  instance_ip="$1"
  public_ip=$(fetch_public_ip)
else
  tries=1
  instance_ip=$(fetch_instance_ip)
  public_ip=$(fetch_public_ip)

  while ([ -f /etc/github/ec2-ami ] && ([ -z "$instance_ip" ] || [ -z "$public_ip" ])) || \
        ([ "$RELEASE_PLATFORM" = 'azure' -o "$RELEASE_PLATFORM" = "gce" ] && [ -z "$public_ip" ]) || \
        ([ ! -f /etc/github/ec2-ami ] && [ -z "$instance_ip" ]); do
    if [ $tries -gt 10 ]; then
      if [ -n "$(fetch_vpc_id)" ]; then
        log "In a VPC, no public IP by default."
        break
      elif ([ "$RELEASE_PLATFORM" = "azure" ] || [ "$RELEASE_PLATFORM" = "gce" ]) && [ -n "$instance_ip" ]; then
        log "Continuing without public IP"
        break
      fi
      log "Bailing on IP address wait."
      exit 1
    fi

    log "Waiting for an IP address. Attempt: $tries"
    sleep 0.5
    tries=$((tries+1))
    instance_ip=$(fetch_instance_ip)
    public_ip=$(fetch_public_ip)
  done
fi

# Fallback mechanism for when no public IP is found
if [ -z "$public_ip" ]; then
  log "No public IP found, using instance IP as fallback"
  public_ip="$instance_ip"
fi

subject_alt_name=""

instance_ipv6=$(fetch_instance_ipv6)
public_hostname=$(fetch_public_hostname)

if ghe-config 'core.github-hostname'; then
  github_hostname=$(ghe-config 'core.github-hostname')
  cn="CN=$github_hostname"
  if [ -n "$github_hostname" ]; then
    subject_alt_name+=",DNS:$github_hostname,DNS:*.$github_hostname"
    if [[ $github_hostname =~ ^[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}$ ]]; then
      subject_alt_name+=",IP:$github_hostname"
    fi
  fi
fi

if [ -n "$public_hostname" ]; then
  subject_alt_name+=",DNS:$public_hostname,DNS:*.$public_hostname"
fi

if [ -n "$public_ip" ]; then
  log "Got public IP address: '$public_ip'."
  cn=${cn:="CN=$public_ip"}
  subject_alt_name+=",IP:$public_ip,DNS:$public_ip"
fi

if [ -n "$instance_ip" ] && [ "$instance_ip" != "$github_hostname" ]; then
  log "Got instance IP address: '$instance_ip'."
  cn=${cn:="CN=$instance_ip"}
  # IE (and thus Windows) needs IP-addresses in SAN to be fake DNS entries, see http://www.michaelm.info/blog/?p=1281
  subject_alt_name+=",IP:$instance_ip,DNS:$instance_ip"
fi

if [ -n "$instance_ipv6" ]; then
  for ip in $instance_ipv6; do
    cn=${cn:="CN=$ip"}
    subject_alt_name+=",IP:$ip,DNS:$ip"
  done
fi

if [ -n "$subject_alt_name" ]; then
  subject_alt_name="subjectAltName=${subject_alt_name:1}"
  log "Subject Alt Name: $subject_alt_name"
else
  log "No Subject Alt Name"
fi

openssl req -new -newkey rsa:2048 -days 365 -nodes -sha256 -x509 -keyout /etc/haproxy/ssl.key -out /etc/haproxy/ssl.crt -config <(
cat <<-EOF
[req]
distinguished_name = req_distinguished_name
x509_extensions = v3_req
prompt = no

[req_distinguished_name]
$cn
O=GitHub Automatic Self Signed Certificate

[v3_req]
subjectKeyIdentifier = hash
authorityKeyIdentifier = keyid,issuer
basicConstraints = CA:TRUE
$subject_alt_name
extendedKeyUsage = critical, serverAuth
EOF
)

# ordering matters here: we want to make sure we don't have the combined
# key/cert in place before update-ca-certificates has finished, otherwise
# the ghe-storage init script (which waits on the ssl.crt+key file) may
# kick off another racing update-ca-certificates run
ln -sf /etc/haproxy/ssl.crt /usr/local/share/ca-certificates/haproxy.crt
lockrun --wait --lockfile=/var/run/ghe-update-ca-certificates.lock -- /usr/sbin/update-ca-certificates --fresh

echo ""
echo "############ SELF-SIGNED SSL CERTIFICATE ##################"
/usr/bin/openssl x509 -noout -in /etc/haproxy/ssl.crt -fingerprint -serial
echo "###########################################################"
echo ""

cat /etc/haproxy/ssl.crt /etc/haproxy/ssl.key > /etc/haproxy/ssl.crt+key
chmod 400 /etc/haproxy/ssl.key /etc/haproxy/ssl.crt+key
