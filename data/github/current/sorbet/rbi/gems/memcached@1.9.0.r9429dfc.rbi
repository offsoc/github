# typed: true

# DO NOT EDIT MANUALLY
# This is an autogenerated file for types exported from the `memcached` gem.
# Please instead update this file by running `bin/tapioca gem memcached`.

# The Memcached client class.
#
# source://memcached//lib/memcached.rb#21
class Memcached
  # Create a new Memcached instance. Accepts string or array of server strings, as well an an optional configuration hash.
  #
  #   Memcached.new('localhost', ...) # A single server
  #   Memcached.new(['web001:11212', 'web002:11212'], ...) # Two servers with custom ports
  #   Memcached.new(['web001:11211:2', 'web002:11211:8'], ...) # Two servers with default ports and explicit weights
  #
  # Weights only affect Ketama hashing.  If you use Ketama hashing and don't specify a weight, the client will poll each server's stats and use its size as the weight.
  #
  # Valid option parameters are:
  #
  # <tt>:prefix_key</tt>:: A string to prepend to every key, for namespacing. Max length is 127. Defaults to the empty string.
  # <tt>:prefix_delimiter</tt>:: A character to append to the prefix key. Defaults to the empty string.
  # <tt>:codec</tt>:: An object to use as the codec for encoded requests. Defaults to Memcached::MarshalCodec.
  # <tt>:hash</tt>:: The name of a hash function to use. Possible values are: <tt>:crc</tt>, <tt>:default</tt>, <tt>:fnv1_32</tt>, <tt>:fnv1_64</tt>, <tt>:fnv1a_32</tt>, <tt>:fnv1a_64</tt>, <tt>:hsieh</tt>, <tt>:md5</tt>, <tt>:murmur</tt>, and <tt>:none</tt>. <tt>:fnv1_32</tt> is fast and well known, and is the default. Use <tt>:md5</tt> for compatibility with other ketama clients. <tt>:none</tt> is for use when there is a single server, and performs no actual hashing.
  # <tt>:distribution</tt>:: Either <tt>:modula</tt>, <tt>:consistent_ketama</tt>, <tt>:consistent_wheel</tt>, or <tt>:ketama</tt>. Defaults to <tt>:ketama</tt>.
  # <tt>:server_failure_limit</tt>:: How many consecutive failures to allow before marking a host as dead. Has no effect unless <tt>:retry_timeout</tt> is also set.
  # <tt>:retry_timeout</tt>:: How long to wait until retrying a dead server. Has no effect unless <tt>:server_failure_limit</tt> is non-zero. Defaults to <tt>30</tt>.
  # <tt>:auto_eject_hosts</tt>:: Whether to temporarily eject dead hosts from the pool. Defaults to <tt>true</tt>. Note that in the event of an ejection, <tt>:auto_eject_hosts</tt> will remap the entire pool unless <tt>:distribution</tt> is set to <tt>:consistent</tt>.
  # <tt>:exception_retry_limit</tt>:: How many times to retry before raising exceptions in <tt>:exceptions_to_retry</tt>. Defaults to <tt>5</tt>.
  # <tt>:exceptions_to_retry</tt>:: Which exceptions to retry. Defaults to <b>ServerIsMarkedDead</b>, <b>ATimeoutOccurred</b>, <b>ConnectionBindFailure</b>, <b>ConnectionFailure</b>, <b>ConnectionSocketCreateFailure</b>, <b>Failure</b>, <b>MemoryAllocationFailure</b>, <b>ReadFailure</b>, <b>ServerError</b>, <b>SystemError</b>, <b>UnknownReadFailure</b>, and <b>WriteFailure</b>.
  # <tt>:cache_lookups</tt>:: Whether to cache hostname lookups for the life of the instance. Defaults to <tt>true</tt>.
  # <tt>:support_cas</tt>:: Flag CAS support in the client. Accepts <tt>true</tt> or <tt>false</tt>. Defaults to <tt>false</tt> because it imposes a slight performance penalty. Note that your server must also support CAS or you will trigger <b>ProtocolError</b> exceptions.
  # <tt>:tcp_nodelay</tt>:: Turns on the no-delay feature for connecting sockets. Accepts <tt>true</tt> or <tt>false</tt>. Performance may or may not change, depending on your system.
  # <tt>:no_block</tt>:: Whether to use pipelining for writes. Defaults to <tt>false</tt>.
  # <tt>:buffer_requests</tt>:: Whether to use an internal write buffer. Accepts <tt>true</tt> or <tt>false</tt>. Calling <tt>get</tt> or closing the connection will force the buffer to flush. Client behavior is undefined unless <tt>:no_block</tt> is enabled. Defaults to <tt>false</tt>.
  # <tt>:noreply</tt>:: Ask server not to reply for storage commands. Client behavior is undefined unless <tt>:no_block</tt> and <tt>:buffer_requests</tt> are enabled. Defaults to <tt>false</tt>.
  # <tt>:show_backtraces</tt>:: Whether <b>NotFound</b> and <b>NotStored</b> exceptions should include backtraces. Generating backtraces is slow, so this is off by default. Turn it on to ease debugging.
  # <tt>:connect_timeout</tt>:: How long to wait for a connection to a server. Defaults to 2 seconds. Set to <tt>0</tt> if you want to wait forever.
  # <tt>:timeout</tt>:: How long to wait for a response from the server. Defaults to 0.25 seconds. Set to <tt>0</tt> if you want to wait forever.
  # <tt>:default_ttl</tt>:: The <tt>ttl</tt> to use on set if no <tt>ttl</tt> is specified, in seconds. Defaults to one week. Set to <tt>0</tt> if you want things to never expire.
  # <tt>:default_weight</tt>:: The weight to use if <tt>:ketama_weighted</tt> is <tt>true</tt>, but no weight is specified for a server.
  # <tt>:hash_with_prefix_key</tt>:: Whether to include the prefix when calculating which server a key falls on. Defaults to <tt>true</tt>.
  # <tt>:use_udp</tt>:: Use the UDP protocol to reduce connection overhead. Defaults to false.
  # <tt>:binary_protocol</tt>:: Use the binary protocol. Defaults to false. Please note that using the binary protocol is usually <b>slower</b> than the ASCII protocol.
  # <tt>:sort_hosts</tt>:: Whether to force the server list to stay sorted. This defeats consistent hashing and is rarely useful.
  # <tt>:verify_key</tt>:: Validate keys before accepting them. Never disable this.
  # <tt>:poll_max_retries</tt>:: Maximum poll timeout retries before marking a flush failed on timeouts.
  #
  # Please note that when <tt>:no_block => true</tt>, update methods do not raise on errors. For example, if you try to <tt>set</tt> an invalid key, it will appear to succeed. The actual setting of the key occurs after libmemcached has returned control to your program, so there is no way to backtrack and raise the exception.
  #
  # @return [Memcached] a new instance of Memcached
  #
  # source://memcached//lib/memcached/memcached.rb#109
  def initialize(servers = T.unsafe(nil), opts = T.unsafe(nil)); end

  # Add a key/value pair. Raises <b>Memcached::NotStored</b> if the key already exists on the server. The parameters are the same as <tt>set</tt>.
  #
  # source://memcached//lib/memcached/memcached.rb#333
  def add(key, value, ttl = T.unsafe(nil), encode = T.unsafe(nil), flags = T.unsafe(nil)); end

  # source://memcached//lib/memcached/memcached.rb#333
  def add_orig(key, value, ttl = T.unsafe(nil), encode = T.unsafe(nil), flags = T.unsafe(nil)); end

  # Appends a string to a key's value. Accepts a String <tt>key</tt> and a String <tt>value</tt>. Raises <b>Memcached::NotFound</b> if the key does not exist on the server.
  #
  # Note that the key must be initialized to an unencoded string first, via <tt>set</tt>, <tt>add</tt>, or <tt>replace</tt> with <tt>encode</tt> set to <tt>false</tt>.
  #
  # source://memcached//lib/memcached/memcached.rb#400
  def append(key, value); end

  # source://memcached//lib/memcached/memcached.rb#400
  def append_orig(key, value); end

  # Reads a key's value from the server and yields it to a block. Replaces the key's value with the result of the block as long as the key hasn't been updated in the meantime, otherwise raises <b>Memcached::NotStored</b>. Accepts a String <tt>key</tt> and a block.
  #
  # Also accepts an optional <tt>ttl</tt> value.
  #
  # CAS stands for "compare and swap", and avoids the need for manual key mutexing. CAS support must be enabled in Memcached.new or a <b>Memcached::ClientError</b> will be raised. Note that CAS may be buggy in memcached itself.
  # :retry_on_exceptions does not apply to this method
  #
  # source://memcached//lib/memcached/memcached.rb#433
  def cas(keys, ttl = T.unsafe(nil), decode = T.unsafe(nil)); end

  # source://memcached//lib/memcached/memcached.rb#433
  def cas_orig(keys, ttl = T.unsafe(nil), decode = T.unsafe(nil)); end

  # Safely copy this instance. Returns a Memcached instance.
  #
  # <tt>clone</tt> is useful for threading, since each thread must have its own unshared Memcached
  # object.
  #
  # source://memcached//lib/memcached/memcached.rb#245
  def clone; end

  # Reads a key's value from the server and yields it to a block. Replaces the key's value with the result of the block as long as the key hasn't been updated in the meantime, otherwise raises <b>Memcached::NotStored</b>. Accepts a String <tt>key</tt> and a block.
  #
  # Also accepts an optional <tt>ttl</tt> value.
  #
  # CAS stands for "compare and swap", and avoids the need for manual key mutexing. CAS support must be enabled in Memcached.new or a <b>Memcached::ClientError</b> will be raised. Note that CAS may be buggy in memcached itself.
  # :retry_on_exceptions does not apply to this method
  #
  # source://memcached//lib/memcached/memcached.rb#433
  def compare_and_swap(keys, ttl = T.unsafe(nil), decode = T.unsafe(nil)); end

  # source://memcached//lib/memcached/memcached.rb#433
  def compare_and_swap_orig(keys, ttl = T.unsafe(nil), decode = T.unsafe(nil)); end

  # Decrement a key's value. The parameters and exception behavior are the same as <tt>increment</tt>.
  #
  # source://memcached//lib/memcached/memcached.rb#365
  def decr(key, offset = T.unsafe(nil)); end

  # source://memcached//lib/memcached/memcached.rb#365
  def decr_orig(key, offset = T.unsafe(nil)); end

  # Decrement a key's value. The parameters and exception behavior are the same as <tt>increment</tt>.
  #
  # source://memcached//lib/memcached/memcached.rb#365
  def decrement(key, offset = T.unsafe(nil)); end

  # source://memcached//lib/memcached/memcached.rb#365
  def decrement_orig(key, offset = T.unsafe(nil)); end

  # Deletes a key/value pair from the server. Accepts a String <tt>key</tt>. Raises <b>Memcached::NotFound</b> if the key does not exist.
  #
  # source://memcached//lib/memcached/memcached.rb#464
  def delete(key); end

  # source://memcached//lib/memcached/memcached.rb#464
  def delete_orig(key); end

  # Safely copy this instance. Returns a Memcached instance.
  #
  # <tt>clone</tt> is useful for threading, since each thread must have its own unshared Memcached
  # object.
  # :stopdoc:
  #
  # source://memcached//lib/memcached/memcached.rb#245
  def dup; end

  # Check if a key exists on the server. It will return nil if the value is found, or raise
  # <tt>Memcached::NotFound</tt> if the key does not exist.
  #
  # source://memcached//lib/memcached/memcached.rb#515
  def exist(key); end

  # source://memcached//lib/memcached/memcached.rb#515
  def exist_orig(key); end

  # Flushes all key/value pairs from all the servers.
  #
  # source://memcached//lib/memcached/memcached.rb#477
  def flush; end

  # source://memcached//lib/memcached/memcached.rb#477
  def flush_orig; end

  # Gets a key's value from the server. Accepts a String <tt>key</tt> or array of String <tt>keys</tt>.
  #
  # Also accepts a <tt>decode</tt> value, which defaults to <tt>true</tt>. Set <tt>decode</tt> to <tt>false</tt> if you want the <tt>value</tt> to be returned directly as a String. Otherwise it will be assumed to be an encoded Ruby object and decoded.
  #
  # If you pass a String key, and the key does not exist on the server, <b>Memcached::NotFound</b> will be raised. If you pass an array of keys, memcached's <tt>multiget</tt> mode will be used, and a hash of key/value pairs will be returned. The hash will contain only the keys that were found.
  #
  # The multiget behavior is subject to change in the future; however, for multiple lookups, it is much faster than normal mode.
  #
  # Note that when you rescue Memcached::NotFound exceptions, you should use a the block rescue syntax instead of the inline syntax. Block rescues are very fast, but inline rescues are very slow.
  #
  # source://memcached//lib/memcached/memcached.rb#500
  def get(keys, decode = T.unsafe(nil)); end

  # Gets a key's value from the previous server. Only useful with random distribution.
  #
  # @raise [ArgumentError]
  #
  # source://memcached//lib/memcached/memcached.rb#523
  def get_from_last(key, decode = T.unsafe(nil)); end

  # source://memcached//lib/memcached/memcached.rb#523
  def get_from_last_orig(key, decode = T.unsafe(nil)); end

  # source://memcached//lib/memcached/memcached.rb#500
  def get_orig(keys, decode = T.unsafe(nil)); end

  # Increment a key's value. Accepts a String <tt>key</tt>. Raises <b>Memcached::NotFound</b> if the key does not exist.
  #
  # Also accepts an optional <tt>offset</tt> paramater, which defaults to 1. <tt>offset</tt> must be an integer.
  #
  # Note that the key must be initialized to an unencoded integer first, via <tt>set</tt>, <tt>add</tt>, or <tt>replace</tt> with <tt>encode</tt> set to <tt>false</tt>.
  # :stopdoc:
  #
  # source://memcached//lib/memcached/memcached.rb#353
  def incr(key, offset = T.unsafe(nil)); end

  # source://memcached//lib/memcached/memcached.rb#353
  def incr_orig(key, offset = T.unsafe(nil)); end

  # Increment a key's value. Accepts a String <tt>key</tt>. Raises <b>Memcached::NotFound</b> if the key does not exist.
  #
  # Also accepts an optional <tt>offset</tt> paramater, which defaults to 1. <tt>offset</tt> must be an integer.
  #
  # Note that the key must be initialized to an unencoded integer first, via <tt>set</tt>, <tt>add</tt>, or <tt>replace</tt> with <tt>encode</tt> set to <tt>false</tt>.
  #
  # source://memcached//lib/memcached/memcached.rb#353
  def increment(key, offset = T.unsafe(nil)); end

  # source://memcached//lib/memcached/memcached.rb#353
  def increment_orig(key, offset = T.unsafe(nil)); end

  # :startdoc:
  #
  # source://memcached//lib/memcached/memcached.rb#62
  def options; end

  # source://memcached//lib/memcached/memcached.rb#62
  def options_orig; end

  # Return the current prefix key.
  #
  # source://memcached//lib/memcached/memcached.rb#232
  def prefix_key; end

  # source://memcached//lib/memcached/memcached.rb#232
  def prefix_key_orig; end

  # Prepends a string to a key's value. The parameters and exception behavior are the same as <tt>append</tt>.
  #
  # source://memcached//lib/memcached/memcached.rb#414
  def prepend(key, value); end

  # source://memcached//lib/memcached/memcached.rb#414
  def prepend_orig(key, value); end

  # Disconnect from all currently connected servers
  #
  # source://memcached//lib/memcached/memcached.rb#269
  def quit; end

  # source://memcached//lib/memcached/memcached.rb#269
  def quit_orig; end

  # Replace a key/value pair. Raises <b>Memcached::NotFound</b> if the key does not exist on the server. The parameters are the same as <tt>set</tt>.
  #
  # source://memcached//lib/memcached/memcached.rb#382
  def replace(key, value, ttl = T.unsafe(nil), encode = T.unsafe(nil), flags = T.unsafe(nil)); end

  # source://memcached//lib/memcached/memcached.rb#382
  def replace_orig(key, value, ttl = T.unsafe(nil), encode = T.unsafe(nil), flags = T.unsafe(nil)); end

  # Reset the state of the libmemcached struct. This is useful for changing the server list at runtime.
  #
  # source://memcached//lib/memcached/memcached.rb#253
  def reset(current_servers = T.unsafe(nil)); end

  # source://memcached//lib/memcached/memcached.rb#253
  def reset_orig(current_servers = T.unsafe(nil)); end

  # Return the server used by a particular key.
  #
  # source://memcached//lib/memcached/memcached.rb#534
  def server_by_key(key); end

  # source://memcached//lib/memcached/memcached.rb#534
  def server_by_key_orig(key); end

  # Return the array of server strings used to configure this instance.
  #
  # source://memcached//lib/memcached/memcached.rb#211
  def servers; end

  # source://memcached//lib/memcached/memcached.rb#211
  def servers_orig; end

  # Set a key/value pair. Accepts a String <tt>key</tt> and an arbitrary Ruby object. Overwrites any existing value on the server.
  #
  # Accepts an optional <tt>ttl</tt> value to specify the maximum lifetime of the key on the server, in seconds. <tt>ttl</tt> must be a <tt>FixNum</tt>. <tt>0</tt> means no ttl. Note that there is no guarantee that the key will persist as long as the <tt>ttl</tt>, but it will not persist longer.
  #
  # Also accepts an <tt>encode</tt> value, which defaults to <tt>true</tt> and uses the default Marshal codec. Set <tt>encode</tt> to <tt>false</tt>, and pass a String as the <tt>value</tt>, if you want to set a raw byte array.
  #
  # source://memcached//lib/memcached/memcached.rb#317
  def set(key, value, ttl = T.unsafe(nil), encode = T.unsafe(nil), flags = T.unsafe(nil)); end

  # source://memcached//lib/memcached/memcached.rb#317
  def set_orig(key, value, ttl = T.unsafe(nil), encode = T.unsafe(nil), flags = T.unsafe(nil)); end

  # Set the prefix key.
  #
  # source://memcached//lib/memcached/memcached.rb#218
  def set_prefix_key(key); end

  # source://memcached//lib/memcached/memcached.rb#218
  def set_prefix_key_orig(key); end

  # Set the server list.
  # FIXME Does not necessarily free any existing server structs.
  #
  # source://memcached//lib/memcached/memcached.rb#183
  def set_servers(servers); end

  # source://memcached//lib/memcached/memcached.rb#183
  def set_servers_orig(servers); end

  # Should retry the exception
  #
  # source://memcached//lib/memcached/memcached.rb#275
  def should_retry(exception, tries); end

  # source://memcached//lib/memcached/memcached.rb#275
  def should_retry_orig(exception, tries); end

  # Return a Hash of statistics responses from the set of servers. Each value is an array with one entry for each server, in the same order the servers were defined.
  #
  # source://memcached//lib/memcached/memcached.rb#546
  def stats(subcommand = T.unsafe(nil)); end

  # source://memcached//lib/memcached/memcached.rb#546
  def stats_orig(subcommand = T.unsafe(nil)); end

  # source://activesupport/7.2.0.alpha.258796693b/lib/active_support/core_ext/object/with.rb#26
  def with_orig(**attributes); end

  private

  # Checks the return code from Rlibmemcached against the exception list. Raises the corresponding exception if the return code is not Memcached::Success or Memcached::ActionQueued. Accepts an integer return code and an optional key, for exception messages.
  #
  # source://memcached//lib/memcached/memcached.rb#587
  def check_return_code(ret, key = T.unsafe(nil)); end

  # source://memcached//lib/memcached/memcached.rb#649
  def destroy_credentials; end

  # Find which server failed most recently.
  # FIXME Is this still necessary with cached_errno?
  #
  # source://memcached//lib/memcached/memcached.rb#632
  def detect_failure; end

  # Get a behavior value for this Memcached instance. Accepts a Symbol.
  #
  # @raise [ArgumentError]
  #
  # source://memcached//lib/memcached/behaviors.rb#60
  def get_behavior(behavior); end

  # Turn an array of keys into a hash of keys to servers.
  #
  # source://memcached//lib/memcached/memcached.rb#624
  def inspect_keys(keys, server = T.unsafe(nil)); end

  # Stringify an opaque server struct
  #
  # source://memcached//lib/memcached/memcached.rb#669
  def inspect_server(server); end

  # @return [Boolean]
  #
  # source://memcached//lib/memcached/memcached.rb#664
  def is_unix_socket?(server); end

  # source://memcached//lib/memcached/memcached.rb#710
  def multi_cas(hash, ttl, flags_and_cas, encode, tries); end

  # source://memcached//lib/memcached/memcached.rb#686
  def multi_get(keys, decode); end

  # source://memcached//lib/memcached/memcached.rb#602
  def reraise(key, ret); end

  # Return an array of raw <tt>memcached_host_st</tt> structs for this instance.
  #
  # source://memcached//lib/memcached/memcached.rb#295
  def server_structs; end

  # Set a behavior option for this Memcached instance. Accepts a Symbol <tt>behavior</tt> and either <tt>true</tt>, <tt>false</tt>, or a Symbol for <tt>value</tt>. Arguments are validated and converted into integers for the struct setter method.
  #
  # @raise [ArgumentError]
  #
  # source://memcached//lib/memcached/behaviors.rb#40
  def set_behavior(behavior, value); end

  # Set the behaviors on the struct from the current options.
  #
  # source://memcached//lib/memcached/memcached.rb#641
  def set_behaviors; end

  # Set the SASL credentials from the current options. If credentials aren't provided, try to get them from the environment.
  #
  # source://memcached//lib/memcached/memcached.rb#656
  def set_credentials; end

  # source://memcached//lib/memcached/memcached.rb#732
  def single_cas(key, value, ttl, flags, cas, encode); end

  # source://memcached//lib/memcached/memcached.rb#678
  def single_get(key, decode); end

  class << self
    # :stopdoc:
    #
    # source://memcached//lib/memcached/behaviors.rb#6
    def load_constants(prefix, hash = T.unsafe(nil)); end

    private

    # source://memcached//lib/memcached/exceptions.rb#54
    def camelize(string); end
  end
end

# source://memcached//lib/memcached/exceptions.rb#68
class Memcached::ABadKeyWasProvidedOrCharactersOutOfRange < ::Memcached::Error; end

# source://memcached//lib/memcached/exceptions.rb#68
class Memcached::AKeyLengthOfZeroWasProvided < ::Memcached::Error; end

# source://memcached//lib/memcached/exceptions.rb#68
class Memcached::ATimeoutOccurred < ::Memcached::Error; end

# source://memcached//lib/memcached/exceptions.rb#68
class Memcached::ActionNotSupported < ::Memcached::Error; end

# source://memcached//lib/memcached/exceptions.rb#68
class Memcached::ActionQueued < ::Memcached::Error; end

# source://memcached//lib/memcached/exceptions.rb#68
class Memcached::AuthenticationFailure < ::Memcached::Error; end

# source://memcached//lib/memcached/behaviors.rb#13
Memcached::BEHAVIORS = T.let(T.unsafe(nil), Hash)

# source://memcached//lib/memcached/behaviors.rb#15
Memcached::BEHAVIOR_VALUES = T.let(T.unsafe(nil), Hash)

# source://memcached//lib/memcached/behaviors.rb#28
Memcached::CONVERSION_FACTORS = T.let(T.unsafe(nil), Hash)

# source://memcached//lib/memcached/exceptions.rb#68
class Memcached::ClientError < ::Memcached::Error; end

# source://memcached//lib/memcached/exceptions.rb#68
class Memcached::ConnectionBindFailure < ::Memcached::Error; end

# source://memcached//lib/memcached/exceptions.rb#68
class Memcached::ConnectionDataDoesNotExist < ::Memcached::Error; end

# source://memcached//lib/memcached/exceptions.rb#68
class Memcached::ConnectionDataExists < ::Memcached::Error; end

# source://memcached//lib/memcached/exceptions.rb#68
class Memcached::ConnectionFailure < ::Memcached::Error; end

# source://memcached//lib/memcached/exceptions.rb#68
class Memcached::ConnectionSocketCreateFailure < ::Memcached::Error; end

# source://memcached//lib/memcached/exceptions.rb#68
class Memcached::ContinueAuthentication < ::Memcached::Error; end

# source://memcached//lib/memcached/exceptions.rb#68
class Memcached::CouldNotOpenUnixSocket < ::Memcached::Error; end

# source://memcached//lib/memcached/memcached.rb#8
Memcached::DEFAULTS = T.let(T.unsafe(nil), Hash)

# source://memcached//lib/memcached/behaviors.rb#26
Memcached::DIRECT_VALUE_BEHAVIORS = T.let(T.unsafe(nil), Array)

# source://memcached//lib/memcached/behaviors.rb#23
Memcached::DISTRIBUTION_VALUES = T.let(T.unsafe(nil), Hash)

# source://memcached//lib/memcached/memcached.rb#6
Memcached::EMPTY_ARRAY = T.let(T.unsafe(nil), Array)

# source://memcached//lib/memcached/exceptions.rb#59
Memcached::ERRNO_HASH = T.let(T.unsafe(nil), Hash)

# source://memcached//lib/memcached/exceptions.rb#61
Memcached::EXCEPTIONS = T.let(T.unsafe(nil), Array)

# source://memcached//lib/memcached/exceptions.rb#68
class Memcached::EncounteredAnUnknownStatKey < ::Memcached::Error; end

# Superclass for all Memcached runtime exceptions.
#
# Subclasses correspond one-to-one with server response strings or libmemcached errors. For example, raising <b>Memcached::NotFound</b> means that the server returned <tt>"NOT_FOUND\r\n"</tt>.
#
# == Subclasses
#
# * Memcached::ABadKeyWasProvidedOrCharactersOutOfRange
# * Memcached::AKeyLengthOfZeroWasProvided
# * Memcached::ATimeoutOccurred
# * Memcached::ActionNotSupported
# * Memcached::ActionQueued
# * Memcached::ClientError
# * Memcached::ConnectionBindFailure
# * Memcached::ConnectionDataDoesNotExist
# * Memcached::ConnectionDataExists
# * Memcached::ConnectionFailure
# * Memcached::ConnectionSocketCreateFailure
# * Memcached::CouldNotOpenUnixSocket
# * Memcached::EncounteredAnUnknownStatKey
# * Memcached::Failure
# * Memcached::FetchWasNotCompleted
# * Memcached::HostnameLookupFailure
# * Memcached::ItemValue
# * Memcached::MemoryAllocationFailure
# * Memcached::NoServersDefined
# * Memcached::NotFound
# * Memcached::NotStored
# * Memcached::PartialRead
# * Memcached::ProtocolError
# * Memcached::ReadFailure
# * Memcached::ServerDelete
# * Memcached::ServerEnd
# * Memcached::ServerError
# * Memcached::ServerIsMarkedDead
# * Memcached::ServerValue
# * Memcached::SomeErrorsWereReported
# * Memcached::StatValue
# * Memcached::SystemError
# * Memcached::TheHostTransportProtocolDoesNotMatchThatOfTheClient
# * Memcached::UnknownReadFailure
# * Memcached::WriteFailure
#
# source://memcached//lib/memcached/exceptions.rb#48
class Memcached::Error < ::RuntimeError
  def memcached_key; end
  def memcached_key=(_arg0); end
end

# source://memcached//lib/memcached/experimental.rb#2
module Memcached::Experimental
  # TOUCH is used to set a new expiration time for an existing item
  #
  # source://memcached//lib/memcached/experimental.rb#4
  def touch(key, ttl = T.unsafe(nil)); end
end

# source://memcached//lib/memcached/memcached.rb#5
Memcached::FLAGS = T.let(T.unsafe(nil), Integer)

# source://memcached//lib/memcached/exceptions.rb#68
class Memcached::FailedToSendAuthenticationToServer < ::Memcached::Error; end

# source://memcached//lib/memcached/exceptions.rb#68
class Memcached::Failure < ::Memcached::Error; end

# source://memcached//lib/memcached/exceptions.rb#68
class Memcached::FetchWasNotCompleted < ::Memcached::Error; end

# source://memcached//lib/memcached/behaviors.rb#20
Memcached::HASH_VALUES = T.let(T.unsafe(nil), Hash)

# source://memcached//lib/memcached/exceptions.rb#68
class Memcached::HostnameLookupFailure < ::Memcached::Error; end

# :stopdoc:
#
# source://memcached//lib/memcached/memcached.rb#59
Memcached::IGNORED = T.let(T.unsafe(nil), Integer)

# source://memcached//lib/memcached/exceptions.rb#68
class Memcached::ItemValue < ::Memcached::Error; end

# source://memcached//lib/memcached.rb#22
Memcached::Lib = Rlibmemcached

# source://memcached//lib/memcached/marshal_codec.rb#2
module Memcached::MarshalCodec
  class << self
    # source://memcached//lib/memcached/marshal_codec.rb#6
    def decode(key, value, flags); end

    # source://memcached//lib/memcached/marshal_codec.rb#3
    def encode(key, value, flags); end
  end
end

# source://memcached//lib/memcached/exceptions.rb#68
class Memcached::MemoryAllocationFailure < ::Memcached::Error; end

# source://memcached//lib/memcached/exceptions.rb#68
class Memcached::NoServersDefined < ::Memcached::Error; end

# source://memcached//lib/memcached/exceptions.rb#68
class Memcached::NotFound < ::Memcached::Error; end

# source://memcached//lib/memcached/exceptions.rb#68
class Memcached::NotStored < ::Memcached::Error; end

# source://memcached//lib/memcached/exceptions.rb#68
class Memcached::PartialRead < ::Memcached::Error; end

# source://memcached//lib/memcached/exceptions.rb#68
class Memcached::ProtocolError < ::Memcached::Error; end

# A legacy compatibility wrapper for the Memcached class. It has basic compatibility with the <b>memcache-client</b> API and Rails 3.2. (Note that ActiveSupport::Duration objects are supported, but not recommended, as ttl parameters. Using Fixnum ttls, such as provided by time_constants.gem, is much faster.)
#
# source://memcached//lib/memcached/rails.rb#10
class Memcached::Rails < ::Memcached
  # See Memcached#new for details.
  #
  # @return [Rails] a new instance of Rails
  #
  # source://memcached//lib/memcached/rails.rb#22
  def initialize(*args); end

  # Wraps Memcached#get so that it doesn't raise. This has the side-effect of preventing you from
  # storing <tt>nil</tt> values.
  #
  # source://memcached//lib/memcached/rails.rb#58
  def [](key, raw = T.unsafe(nil)); end

  # Wraps Memcached#set.
  #
  # source://memcached//lib/memcached/rails.rb#112
  def []=(key, value, ttl = T.unsafe(nil), raw = T.unsafe(nil)); end

  # Check if there are any servers defined?
  #
  # @return [Boolean]
  #
  # source://memcached//lib/memcached/rails.rb#47
  def active?; end

  # Wraps Memcached#add so that it doesn't raise.
  #
  # source://memcached//lib/memcached/rails.rb#153
  def add(key, value, ttl = T.unsafe(nil), raw = T.unsafe(nil)); end

  # Wraps Memcached#append so that it doesn't raise.
  #
  # source://memcached//lib/memcached/rails.rb#192
  def append(*args); end

  # Wraps Memcached#cas so that it doesn't raise. Doesn't set anything if no value is present.
  #
  # source://memcached//lib/memcached/rails.rb#89
  def cas(key, ttl = T.unsafe(nil), raw = T.unsafe(nil), &block); end

  # source://memcached//lib/memcached/memcached.rb#477
  def clear; end

  # Wraps Memcached#cas so that it doesn't raise. Doesn't set anything if no value is present.
  #
  # source://memcached//lib/memcached/rails.rb#89
  def compare_and_swap(key, ttl = T.unsafe(nil), raw = T.unsafe(nil), &block); end

  # Wraps Memcached#decr so that it doesn't raise.
  #
  # source://memcached//lib/memcached/rails.rb#184
  def decr(*args); end

  # source://memcached//lib/memcached/rails.rb#243
  def decrement(name, amount = T.unsafe(nil), options = T.unsafe(nil)); end

  # Wraps Memcached#delete so that it doesn't raise.
  #
  # source://memcached//lib/memcached/rails.rb#166
  def delete(key, options = T.unsafe(nil)); end

  # Returns whether the key exists, even if the value is nil.
  #
  # @return [Boolean]
  #
  # source://memcached//lib/memcached/rails.rb#79
  def exist?(key, options = T.unsafe(nil)); end

  # source://memcached//lib/memcached/rails.rb#137
  def fetch(key, options = T.unsafe(nil)); end

  # source://memcached//lib/memcached/memcached.rb#477
  def flush_all; end

  # Wraps Memcached#get so that it doesn't raise. This has the side-effect of preventing you from
  # storing <tt>nil</tt> values.
  #
  # source://memcached//lib/memcached/rails.rb#58
  def get(key, raw = T.unsafe(nil)); end

  # Wraps Memcached#get.
  #
  # source://memcached//lib/memcached/rails.rb#104
  def get_multi(keys, raw = T.unsafe(nil)); end

  # Wraps Memcached#incr so that it doesn't raise.
  #
  # source://memcached//lib/memcached/rails.rb#176
  def incr(*args); end

  # source://memcached//lib/memcached/rails.rb#236
  def increment(name, amount = T.unsafe(nil), options = T.unsafe(nil)); end

  def log_exception(e); end

  # Returns the value of attribute logger.
  #
  # source://memcached//lib/memcached/rails.rb#17
  def logger; end

  # source://memcached//lib/memcached/rails.rb#38
  def logger=(logger); end

  # source://memcached//lib/memcached/rails.rb#42
  def namespace; end

  # Wraps Memcached#prepend so that it doesn't raise.
  #
  # source://memcached//lib/memcached/rails.rb#200
  def prepend(*args); end

  # Alternative to #get. Accepts a key and an optional options hash supporting the single option
  # :raw.
  #
  # source://memcached//lib/memcached/rails.rb#67
  def read(key, options = T.unsafe(nil)); end

  # source://memcached//lib/memcached/rails.rb#213
  def read_multi(*keys); end

  # Return an array of server objects.
  #
  # source://memcached//lib/memcached/rails.rb#219
  def servers; end

  def servers=(servers); end

  # Wraps Memcached#set.
  #
  # source://memcached//lib/memcached/rails.rb#112
  def set(key, value, ttl = T.unsafe(nil), raw = T.unsafe(nil)); end

  # Wraps Memcached#set_servers to convert server objects to strings.
  #
  # source://memcached//lib/memcached/rails.rb#228
  def set_servers(servers); end

  # Alternative to #set. Accepts a key, value, and an optional options hash supporting the
  # options :raw and :ttl.
  #
  # source://memcached//lib/memcached/rails.rb#126
  def write(key, value, options = T.unsafe(nil)); end
end

# source://memcached//lib/memcached/rails.rb#12
Memcached::Rails::DEFAULTS = T.let(T.unsafe(nil), Hash)

# source://memcached//lib/memcached/exceptions.rb#68
class Memcached::ReadFailure < ::Memcached::Error; end

# source://memcached//lib/memcached/exceptions.rb#68
class Memcached::ServerDelete < ::Memcached::Error; end

# source://memcached//lib/memcached/exceptions.rb#68
class Memcached::ServerEnd < ::Memcached::Error; end

# source://memcached//lib/memcached/exceptions.rb#68
class Memcached::ServerError < ::Memcached::Error; end

# source://memcached//lib/memcached/exceptions.rb#68
class Memcached::ServerIsMarkedDead < ::Memcached::Error; end

# source://memcached//lib/memcached/exceptions.rb#68
class Memcached::ServerValue < ::Memcached::Error; end

# source://memcached//lib/memcached/exceptions.rb#68
class Memcached::SomeErrorsWereReported < ::Memcached::Error; end

# source://memcached//lib/memcached/exceptions.rb#68
class Memcached::StatValue < ::Memcached::Error; end

# source://memcached//lib/memcached/exceptions.rb#68
class Memcached::Stored < ::Memcached::Error; end

# source://memcached//lib/memcached/exceptions.rb#68
class Memcached::Success < ::Memcached::Error; end

# source://memcached//lib/memcached/exceptions.rb#68
class Memcached::SystemError < ::Memcached::Error; end

# source://memcached//lib/memcached/exceptions.rb#68
class Memcached::TheHostTransportProtocolDoesNotMatchThatOfTheClient < ::Memcached::Error; end

# source://memcached//lib/memcached/exceptions.rb#68
class Memcached::UnknownReadFailure < ::Memcached::Error; end

# source://memcached//lib/memcached.rb#26
Memcached::VERSION = T.let(T.unsafe(nil), String)

# source://memcached//lib/memcached/exceptions.rb#68
class Memcached::WriteFailure < ::Memcached::Error; end

# The generated SWIG module for accessing libmemcached's C API.
#
# Includes the full set of libmemcached static methods (as defined in <tt>$INCLUDE_PATH/libmemcached/memcached.h</tt>), and classes for the available structs:
#
# * <b>Rlibmemcached::MemcachedResultSt</b>
# * <b>Rlibmemcached::MemcachedServerSt</b>
# * <b>Rlibmemcached::MemcachedSt</b>
# * <b>Rlibmemcached::MemcachedStatSt</b>
# * <b>Rlibmemcached::MemcachedStringSt</b>
#
# A number of SWIG typemaps and C helper methods are also defined in <tt>ext/libmemcached.i</tt>.
#
# source://memcached//lib/memcached.rb#16
module Rlibmemcached
  private

  def memcached_add(*_arg0); end
  def memcached_add_by_key(*_arg0); end
  def memcached_analyze(*_arg0); end
  def memcached_append(*_arg0); end
  def memcached_append_by_key(*_arg0); end
  def memcached_behavior_get(*_arg0); end
  def memcached_behavior_set(*_arg0); end
  def memcached_callback_get(*_arg0); end
  def memcached_callback_set(*_arg0); end
  def memcached_cas(*_arg0); end
  def memcached_cas_by_key(*_arg0); end
  def memcached_clone(*_arg0); end
  def memcached_create(*_arg0); end
  def memcached_decrement(*_arg0); end
  def memcached_decrement_with_initial(*_arg0); end
  def memcached_delete(*_arg0); end
  def memcached_delete_by_key(*_arg0); end
  def memcached_destroy_sasl_auth_data(*_arg0); end
  def memcached_dump(*_arg0); end
  def memcached_exist(*_arg0); end
  def memcached_exist_by_key(*_arg0); end
  def memcached_fetch(*_arg0); end
  def memcached_fetch_execute(*_arg0); end
  def memcached_fetch_result(*_arg0); end
  def memcached_fetch_rvalue(*_arg0); end
  def memcached_flush(*_arg0); end
  def memcached_flush_buffers(*_arg0); end
  def memcached_free(*_arg0); end
  def memcached_generate_hash(*_arg0); end
  def memcached_generate_hash_rvalue(*_arg0); end
  def memcached_generate_hash_value(*_arg0); end
  def memcached_get(*_arg0); end
  def memcached_get_by_key(*_arg0); end
  def memcached_get_from_last(*_arg0); end
  def memcached_get_from_last_rvalue(*_arg0); end
  def memcached_get_len(*_arg0); end
  def memcached_get_memory_allocators(*_arg0); end
  def memcached_get_rvalue(*_arg0); end
  def memcached_get_sasl_callbacks(*_arg0); end
  def memcached_get_user_data(*_arg0); end
  def memcached_increment(*_arg0); end
  def memcached_increment_with_initial(*_arg0); end
  def memcached_lib_version(*_arg0); end
  def memcached_mget(*_arg0); end
  def memcached_mget_by_key(*_arg0); end
  def memcached_mget_len(*_arg0); end
  def memcached_prepend(*_arg0); end
  def memcached_prepend_by_key(*_arg0); end
  def memcached_quit(*_arg0); end
  def memcached_replace(*_arg0); end
  def memcached_replace_by_key(*_arg0); end
  def memcached_result_create(*_arg0); end
  def memcached_result_free(*_arg0); end
  def memcached_result_length(*_arg0); end
  def memcached_result_reset(*_arg0); end
  def memcached_result_set_value(*_arg0); end
  def memcached_result_value(*_arg0); end
  def memcached_sasl_authenticate_connection(*_arg0); end
  def memcached_select_server_at(*_arg0); end
  def memcached_select_stat_at(*_arg0); end
  def memcached_server_add(*_arg0); end
  def memcached_server_add_udp(*_arg0); end
  def memcached_server_add_udp_with_weight(*_arg0); end
  def memcached_server_add_unix_socket(*_arg0); end
  def memcached_server_add_unix_socket_with_weight(*_arg0); end
  def memcached_server_add_with_weight(*_arg0); end
  def memcached_server_by_key(*_arg0); end
  def memcached_server_clone(*_arg0); end
  def memcached_server_create(*_arg0); end
  def memcached_server_create_with(*_arg0); end
  def memcached_server_cursor(*_arg0); end
  def memcached_server_error(*_arg0); end
  def memcached_server_error_reset(*_arg0); end
  def memcached_server_free(*_arg0); end
  def memcached_server_list_append(*_arg0); end
  def memcached_server_list_append_with_weight(*_arg0); end
  def memcached_server_list_count(*_arg0); end
  def memcached_server_list_free(*_arg0); end
  def memcached_server_push(*_arg0); end
  def memcached_server_remove(*_arg0); end
  def memcached_servers_parse(*_arg0); end
  def memcached_set(*_arg0); end
  def memcached_set_by_key(*_arg0); end
  def memcached_set_memory_allocators(*_arg0); end
  def memcached_set_sasl_auth_data(*_arg0); end
  def memcached_set_sasl_callbacks(*_arg0); end
  def memcached_set_user_data(*_arg0); end
  def memcached_stat(*_arg0); end
  def memcached_stat_free(*_arg0); end
  def memcached_stat_get_keys(*_arg0); end
  def memcached_stat_get_value(*_arg0); end
  def memcached_stat_servername(*_arg0); end
  def memcached_strerror(*_arg0); end
  def memcached_touch(*_arg0); end
  def memcached_touch_by_key(*_arg0); end
  def memcached_verbosity(*_arg0); end
  def memcached_version(*_arg0); end
  def run_distribution(*_arg0); end

  class << self
    def memcached_add(*_arg0); end
    def memcached_add_by_key(*_arg0); end
    def memcached_analyze(*_arg0); end
    def memcached_append(*_arg0); end
    def memcached_append_by_key(*_arg0); end
    def memcached_behavior_get(*_arg0); end
    def memcached_behavior_set(*_arg0); end
    def memcached_callback_get(*_arg0); end
    def memcached_callback_set(*_arg0); end
    def memcached_cas(*_arg0); end
    def memcached_cas_by_key(*_arg0); end
    def memcached_clone(*_arg0); end
    def memcached_create(*_arg0); end
    def memcached_decrement(*_arg0); end
    def memcached_decrement_with_initial(*_arg0); end
    def memcached_delete(*_arg0); end
    def memcached_delete_by_key(*_arg0); end
    def memcached_destroy_sasl_auth_data(*_arg0); end
    def memcached_dump(*_arg0); end
    def memcached_exist(*_arg0); end
    def memcached_exist_by_key(*_arg0); end
    def memcached_fetch(*_arg0); end
    def memcached_fetch_execute(*_arg0); end
    def memcached_fetch_result(*_arg0); end
    def memcached_fetch_rvalue(*_arg0); end
    def memcached_flush(*_arg0); end
    def memcached_flush_buffers(*_arg0); end
    def memcached_free(*_arg0); end
    def memcached_generate_hash(*_arg0); end
    def memcached_generate_hash_rvalue(*_arg0); end
    def memcached_generate_hash_value(*_arg0); end
    def memcached_get(*_arg0); end
    def memcached_get_by_key(*_arg0); end
    def memcached_get_from_last(*_arg0); end
    def memcached_get_from_last_rvalue(*_arg0); end
    def memcached_get_len(*_arg0); end
    def memcached_get_memory_allocators(*_arg0); end
    def memcached_get_rvalue(*_arg0); end
    def memcached_get_sasl_callbacks(*_arg0); end
    def memcached_get_user_data(*_arg0); end
    def memcached_increment(*_arg0); end
    def memcached_increment_with_initial(*_arg0); end
    def memcached_lib_version(*_arg0); end
    def memcached_mget(*_arg0); end
    def memcached_mget_by_key(*_arg0); end
    def memcached_mget_len(*_arg0); end
    def memcached_prepend(*_arg0); end
    def memcached_prepend_by_key(*_arg0); end
    def memcached_quit(*_arg0); end
    def memcached_replace(*_arg0); end
    def memcached_replace_by_key(*_arg0); end
    def memcached_result_create(*_arg0); end
    def memcached_result_free(*_arg0); end
    def memcached_result_length(*_arg0); end
    def memcached_result_reset(*_arg0); end
    def memcached_result_set_value(*_arg0); end
    def memcached_result_value(*_arg0); end
    def memcached_sasl_authenticate_connection(*_arg0); end
    def memcached_select_server_at(*_arg0); end
    def memcached_select_stat_at(*_arg0); end
    def memcached_server_add(*_arg0); end
    def memcached_server_add_udp(*_arg0); end
    def memcached_server_add_udp_with_weight(*_arg0); end
    def memcached_server_add_unix_socket(*_arg0); end
    def memcached_server_add_unix_socket_with_weight(*_arg0); end
    def memcached_server_add_with_weight(*_arg0); end
    def memcached_server_by_key(*_arg0); end
    def memcached_server_clone(*_arg0); end
    def memcached_server_create(*_arg0); end
    def memcached_server_create_with(*_arg0); end
    def memcached_server_cursor(*_arg0); end
    def memcached_server_error(*_arg0); end
    def memcached_server_error_reset(*_arg0); end
    def memcached_server_free(*_arg0); end
    def memcached_server_list_append(*_arg0); end
    def memcached_server_list_append_with_weight(*_arg0); end
    def memcached_server_list_count(*_arg0); end
    def memcached_server_list_free(*_arg0); end
    def memcached_server_push(*_arg0); end
    def memcached_server_remove(*_arg0); end
    def memcached_servers_parse(*_arg0); end
    def memcached_set(*_arg0); end
    def memcached_set_by_key(*_arg0); end
    def memcached_set_memory_allocators(*_arg0); end
    def memcached_set_sasl_auth_data(*_arg0); end
    def memcached_set_sasl_callbacks(*_arg0); end
    def memcached_set_user_data(*_arg0); end
    def memcached_stat(*_arg0); end
    def memcached_stat_free(*_arg0); end
    def memcached_stat_get_keys(*_arg0); end
    def memcached_stat_get_value(*_arg0); end
    def memcached_stat_servername(*_arg0); end
    def memcached_strerror(*_arg0); end
    def memcached_touch(*_arg0); end
    def memcached_touch_by_key(*_arg0); end
    def memcached_verbosity(*_arg0); end
    def memcached_version(*_arg0); end
    def run_distribution(*_arg0); end
  end
end

Rlibmemcached::GET_LEN_ARG_UNSPECIFIED = T.let(T.unsafe(nil), Integer)
Rlibmemcached::GET_LEN_BUFSZ = T.let(T.unsafe(nil), Integer)
Rlibmemcached::LIBMEMCACHED_VERSION_STRING = T.let(T.unsafe(nil), String)
Rlibmemcached::MEMCACHED_AUTH_CONTINUE = T.let(T.unsafe(nil), Integer)
Rlibmemcached::MEMCACHED_AUTH_FAILURE = T.let(T.unsafe(nil), Integer)
Rlibmemcached::MEMCACHED_AUTH_PROBLEM = T.let(T.unsafe(nil), Integer)
Rlibmemcached::MEMCACHED_BAD_KEY_PROVIDED = T.let(T.unsafe(nil), Integer)
Rlibmemcached::MEMCACHED_BEHAVIOR_AUTO_EJECT_HOSTS = T.let(T.unsafe(nil), Integer)
Rlibmemcached::MEMCACHED_BEHAVIOR_BINARY_PROTOCOL = T.let(T.unsafe(nil), Integer)
Rlibmemcached::MEMCACHED_BEHAVIOR_BUFFER_REQUESTS = T.let(T.unsafe(nil), Integer)
Rlibmemcached::MEMCACHED_BEHAVIOR_CACHE_LOOKUPS = T.let(T.unsafe(nil), Integer)
Rlibmemcached::MEMCACHED_BEHAVIOR_CONNECT_TIMEOUT = T.let(T.unsafe(nil), Integer)
Rlibmemcached::MEMCACHED_BEHAVIOR_DISTRIBUTION = T.let(T.unsafe(nil), Integer)
Rlibmemcached::MEMCACHED_BEHAVIOR_HASH = T.let(T.unsafe(nil), Integer)
Rlibmemcached::MEMCACHED_BEHAVIOR_HASH_WITH_PREFIX_KEY = T.let(T.unsafe(nil), Integer)
Rlibmemcached::MEMCACHED_BEHAVIOR_IO_BYTES_WATERMARK = T.let(T.unsafe(nil), Integer)
Rlibmemcached::MEMCACHED_BEHAVIOR_IO_KEY_PREFETCH = T.let(T.unsafe(nil), Integer)
Rlibmemcached::MEMCACHED_BEHAVIOR_IO_MSG_WATERMARK = T.let(T.unsafe(nil), Integer)
Rlibmemcached::MEMCACHED_BEHAVIOR_KETAMA = T.let(T.unsafe(nil), Integer)
Rlibmemcached::MEMCACHED_BEHAVIOR_KETAMA_HASH = T.let(T.unsafe(nil), Integer)
Rlibmemcached::MEMCACHED_BEHAVIOR_KETAMA_WEIGHTED = T.let(T.unsafe(nil), Integer)
Rlibmemcached::MEMCACHED_BEHAVIOR_NOREPLY = T.let(T.unsafe(nil), Integer)
Rlibmemcached::MEMCACHED_BEHAVIOR_NO_BLOCK = T.let(T.unsafe(nil), Integer)
Rlibmemcached::MEMCACHED_BEHAVIOR_POLL_MAX_RETRIES = T.let(T.unsafe(nil), Integer)
Rlibmemcached::MEMCACHED_BEHAVIOR_POLL_TIMEOUT = T.let(T.unsafe(nil), Integer)
Rlibmemcached::MEMCACHED_BEHAVIOR_RCV_TIMEOUT = T.let(T.unsafe(nil), Integer)
Rlibmemcached::MEMCACHED_BEHAVIOR_RETRY_TIMEOUT = T.let(T.unsafe(nil), Integer)
Rlibmemcached::MEMCACHED_BEHAVIOR_SERVER_FAILURE_LIMIT = T.let(T.unsafe(nil), Integer)
Rlibmemcached::MEMCACHED_BEHAVIOR_SND_TIMEOUT = T.let(T.unsafe(nil), Integer)
Rlibmemcached::MEMCACHED_BEHAVIOR_SOCKET_RECV_SIZE = T.let(T.unsafe(nil), Integer)
Rlibmemcached::MEMCACHED_BEHAVIOR_SOCKET_SEND_SIZE = T.let(T.unsafe(nil), Integer)
Rlibmemcached::MEMCACHED_BEHAVIOR_SORT_HOSTS = T.let(T.unsafe(nil), Integer)
Rlibmemcached::MEMCACHED_BEHAVIOR_SUPPORT_CAS = T.let(T.unsafe(nil), Integer)
Rlibmemcached::MEMCACHED_BEHAVIOR_TCP_NODELAY = T.let(T.unsafe(nil), Integer)
Rlibmemcached::MEMCACHED_BEHAVIOR_USER_DATA = T.let(T.unsafe(nil), Integer)
Rlibmemcached::MEMCACHED_BEHAVIOR_USE_UDP = T.let(T.unsafe(nil), Integer)
Rlibmemcached::MEMCACHED_BEHAVIOR_VERIFY_KEY = T.let(T.unsafe(nil), Integer)
Rlibmemcached::MEMCACHED_BUFFERED = T.let(T.unsafe(nil), Integer)
Rlibmemcached::MEMCACHED_CALLBACK_CLEANUP_FUNCTION = T.let(T.unsafe(nil), Integer)
Rlibmemcached::MEMCACHED_CALLBACK_CLONE_FUNCTION = T.let(T.unsafe(nil), Integer)
Rlibmemcached::MEMCACHED_CALLBACK_DELETE_TRIGGER = T.let(T.unsafe(nil), Integer)
Rlibmemcached::MEMCACHED_CALLBACK_GET_FAILURE = T.let(T.unsafe(nil), Integer)
Rlibmemcached::MEMCACHED_CALLBACK_PREFIX_KEY = T.let(T.unsafe(nil), Integer)
Rlibmemcached::MEMCACHED_CALLBACK_USER_DATA = T.let(T.unsafe(nil), Integer)
Rlibmemcached::MEMCACHED_CLIENT_ERROR = T.let(T.unsafe(nil), Integer)
Rlibmemcached::MEMCACHED_CONNECTION_BIND_FAILURE = T.let(T.unsafe(nil), Integer)
Rlibmemcached::MEMCACHED_CONNECTION_FAILURE = T.let(T.unsafe(nil), Integer)
Rlibmemcached::MEMCACHED_CONNECTION_SOCKET_CREATE_FAILURE = T.let(T.unsafe(nil), Integer)
Rlibmemcached::MEMCACHED_CONNECTION_TCP = T.let(T.unsafe(nil), Integer)
Rlibmemcached::MEMCACHED_CONNECTION_UDP = T.let(T.unsafe(nil), Integer)
Rlibmemcached::MEMCACHED_CONNECTION_UNIX_SOCKET = T.let(T.unsafe(nil), Integer)
Rlibmemcached::MEMCACHED_CONNECTION_UNKNOWN = T.let(T.unsafe(nil), Integer)
Rlibmemcached::MEMCACHED_CONTINUUM_ADDITION = T.let(T.unsafe(nil), Integer)
Rlibmemcached::MEMCACHED_CONTINUUM_SIZE = T.let(T.unsafe(nil), Integer)
Rlibmemcached::MEMCACHED_DATA_DOES_NOT_EXIST = T.let(T.unsafe(nil), Integer)
Rlibmemcached::MEMCACHED_DATA_EXISTS = T.let(T.unsafe(nil), Integer)
Rlibmemcached::MEMCACHED_DEFAULT_PORT = T.let(T.unsafe(nil), Integer)
Rlibmemcached::MEMCACHED_DEFAULT_TIMEOUT = T.let(T.unsafe(nil), Integer)
Rlibmemcached::MEMCACHED_DELETED = T.let(T.unsafe(nil), Integer)
Rlibmemcached::MEMCACHED_DISTRIBUTION_CONSISTENT = T.let(T.unsafe(nil), Integer)
Rlibmemcached::MEMCACHED_DISTRIBUTION_CONSISTENT_KETAMA = T.let(T.unsafe(nil), Integer)
Rlibmemcached::MEMCACHED_DISTRIBUTION_MODULA = T.let(T.unsafe(nil), Integer)
Rlibmemcached::MEMCACHED_DISTRIBUTION_RANDOM = T.let(T.unsafe(nil), Integer)
Rlibmemcached::MEMCACHED_END = T.let(T.unsafe(nil), Integer)
Rlibmemcached::MEMCACHED_ERRNO = T.let(T.unsafe(nil), Integer)
Rlibmemcached::MEMCACHED_EXPIRATION_NOT_ADD = T.let(T.unsafe(nil), Integer)
Rlibmemcached::MEMCACHED_FAILURE = T.let(T.unsafe(nil), Integer)
Rlibmemcached::MEMCACHED_FAIL_UNIX_SOCKET = T.let(T.unsafe(nil), Integer)
Rlibmemcached::MEMCACHED_FETCH_NOTFINISHED = T.let(T.unsafe(nil), Integer)
Rlibmemcached::MEMCACHED_HASH_CRC = T.let(T.unsafe(nil), Integer)
Rlibmemcached::MEMCACHED_HASH_DEFAULT = T.let(T.unsafe(nil), Integer)
Rlibmemcached::MEMCACHED_HASH_FNV1A_32 = T.let(T.unsafe(nil), Integer)
Rlibmemcached::MEMCACHED_HASH_FNV1A_64 = T.let(T.unsafe(nil), Integer)
Rlibmemcached::MEMCACHED_HASH_FNV1_32 = T.let(T.unsafe(nil), Integer)
Rlibmemcached::MEMCACHED_HASH_FNV1_64 = T.let(T.unsafe(nil), Integer)
Rlibmemcached::MEMCACHED_HASH_HSIEH = T.let(T.unsafe(nil), Integer)
Rlibmemcached::MEMCACHED_HASH_JENKINS = T.let(T.unsafe(nil), Integer)
Rlibmemcached::MEMCACHED_HASH_MD5 = T.let(T.unsafe(nil), Integer)
Rlibmemcached::MEMCACHED_HASH_MURMUR = T.let(T.unsafe(nil), Integer)
Rlibmemcached::MEMCACHED_HASH_NONE = T.let(T.unsafe(nil), Integer)
Rlibmemcached::MEMCACHED_HOST_LOOKUP_FAILURE = T.let(T.unsafe(nil), Integer)
Rlibmemcached::MEMCACHED_INVALID_HOST_PROTOCOL = T.let(T.unsafe(nil), Integer)
Rlibmemcached::MEMCACHED_ITEM = T.let(T.unsafe(nil), Integer)
Rlibmemcached::MEMCACHED_MAXIMUM_RETURN = T.let(T.unsafe(nil), Integer)
Rlibmemcached::MEMCACHED_MAX_BUFFER = T.let(T.unsafe(nil), Integer)
Rlibmemcached::MEMCACHED_MAX_HOST_LENGTH = T.let(T.unsafe(nil), Integer)
Rlibmemcached::MEMCACHED_MAX_HOST_SORT_LENGTH = T.let(T.unsafe(nil), Integer)
Rlibmemcached::MEMCACHED_MAX_KEY = T.let(T.unsafe(nil), Integer)
Rlibmemcached::MEMCACHED_MEMORY_ALLOCATION_FAILURE = T.let(T.unsafe(nil), Integer)
Rlibmemcached::MEMCACHED_NOTFOUND = T.let(T.unsafe(nil), Integer)
Rlibmemcached::MEMCACHED_NOTSTORED = T.let(T.unsafe(nil), Integer)
Rlibmemcached::MEMCACHED_NOT_SUPPORTED = T.let(T.unsafe(nil), Integer)
Rlibmemcached::MEMCACHED_NO_KEY_PROVIDED = T.let(T.unsafe(nil), Integer)
Rlibmemcached::MEMCACHED_NO_SERVERS = T.let(T.unsafe(nil), Integer)
Rlibmemcached::MEMCACHED_PARTIAL_READ = T.let(T.unsafe(nil), Integer)
Rlibmemcached::MEMCACHED_POINTS_PER_SERVER = T.let(T.unsafe(nil), Integer)
Rlibmemcached::MEMCACHED_POINTS_PER_SERVER_KETAMA = T.let(T.unsafe(nil), Integer)
Rlibmemcached::MEMCACHED_PREFIX_KEY_MAX_SIZE = T.let(T.unsafe(nil), Integer)
Rlibmemcached::MEMCACHED_PROTOCOL_ERROR = T.let(T.unsafe(nil), Integer)
Rlibmemcached::MEMCACHED_READ_FAILURE = T.let(T.unsafe(nil), Integer)
Rlibmemcached::MEMCACHED_SERVER_ERROR = T.let(T.unsafe(nil), Integer)
Rlibmemcached::MEMCACHED_SERVER_MARKED_DEAD = T.let(T.unsafe(nil), Integer)
Rlibmemcached::MEMCACHED_SOME_ERRORS = T.let(T.unsafe(nil), Integer)
Rlibmemcached::MEMCACHED_STAT = T.let(T.unsafe(nil), Integer)
Rlibmemcached::MEMCACHED_STORED = T.let(T.unsafe(nil), Integer)
Rlibmemcached::MEMCACHED_STRIDE = T.let(T.unsafe(nil), Integer)
Rlibmemcached::MEMCACHED_SUCCESS = T.let(T.unsafe(nil), Integer)
Rlibmemcached::MEMCACHED_TIMEOUT = T.let(T.unsafe(nil), Integer)
Rlibmemcached::MEMCACHED_UNKNOWN_READ_FAILURE = T.let(T.unsafe(nil), Integer)
Rlibmemcached::MEMCACHED_UNKNOWN_STAT_KEY = T.let(T.unsafe(nil), Integer)
Rlibmemcached::MEMCACHED_VALUE = T.let(T.unsafe(nil), Integer)
Rlibmemcached::MEMCACHED_VERSION_STRING_LENGTH = T.let(T.unsafe(nil), Integer)
Rlibmemcached::MEMCACHED_WRITE_FAILURE = T.let(T.unsafe(nil), Integer)

class Rlibmemcached::MemcachedAnalysisSt
  def initialize(*_arg0); end

  def average_item_size(*_arg0); end
  def average_item_size=(*_arg0); end
  def least_free_server(*_arg0); end
  def least_free_server=(*_arg0); end
  def least_remaining_bytes(*_arg0); end
  def least_remaining_bytes=(*_arg0); end
  def longest_uptime(*_arg0); end
  def longest_uptime=(*_arg0); end
  def most_consumed_server(*_arg0); end
  def most_consumed_server=(*_arg0); end
  def most_used_bytes(*_arg0); end
  def most_used_bytes=(*_arg0); end
  def oldest_server(*_arg0); end
  def oldest_server=(*_arg0); end
  def pool_hit_ratio(*_arg0); end
  def pool_hit_ratio=(*_arg0); end
end

class Rlibmemcached::MemcachedResultSt
  def initialize(*_arg0); end

  def cas(*_arg0); end
  def cas=(*_arg0); end
  def expiration(*_arg0); end
  def expiration=(*_arg0); end
  def flags(*_arg0); end
  def flags=(*_arg0); end
  def is_allocated(*_arg0); end
  def is_allocated=(*_arg0); end
  def key(*_arg0); end
  def key=(*_arg0); end
  def key_length(*_arg0); end
  def key_length=(*_arg0); end
  def root(*_arg0); end
  def root=(*_arg0); end
  def value(*_arg0); end
  def value=(*_arg0); end
end

class Rlibmemcached::MemcachedServerSt
  def initialize(*_arg0); end

  def address_info(*_arg0); end
  def address_info=(*_arg0); end
  def cached_errno(*_arg0); end
  def cached_errno=(*_arg0); end
  def cached_server_error(*_arg0); end
  def cached_server_error=(*_arg0); end
  def count(*_arg0); end
  def count=(*_arg0); end
  def cursor_active(*_arg0); end
  def cursor_active=(*_arg0); end
  def fd(*_arg0); end
  def fd=(*_arg0); end
  def hostname(*_arg0); end
  def hostname=(*_arg0); end
  def io_bytes_sent(*_arg0); end
  def io_bytes_sent=(*_arg0); end
  def is_allocated(*_arg0); end
  def is_allocated=(*_arg0); end
  def limit_maxbytes(*_arg0); end
  def limit_maxbytes=(*_arg0); end
  def major_version(*_arg0); end
  def major_version=(*_arg0); end
  def micro_version(*_arg0); end
  def micro_version=(*_arg0); end
  def minor_version(*_arg0); end
  def minor_version=(*_arg0); end
  def next_retry(*_arg0); end
  def next_retry=(*_arg0); end
  def port(*_arg0); end
  def port=(*_arg0); end
  def read_buffer(*_arg0); end
  def read_buffer=(*_arg0); end
  def read_buffer_length(*_arg0); end
  def read_buffer_length=(*_arg0); end
  def read_data_length(*_arg0); end
  def read_data_length=(*_arg0); end
  def read_ptr(*_arg0); end
  def read_ptr=(*_arg0); end
  def root(*_arg0); end
  def root=(*_arg0); end
  def server_failure_counter(*_arg0); end
  def server_failure_counter=(*_arg0); end
  def sockaddr_inited(*_arg0); end
  def sockaddr_inited=(*_arg0); end
  def type(*_arg0); end
  def type=(*_arg0); end
  def weight(*_arg0); end
  def weight=(*_arg0); end
  def write_buffer(*_arg0); end
  def write_buffer=(*_arg0); end
  def write_buffer_offset(*_arg0); end
  def write_buffer_offset=(*_arg0); end
end

class Rlibmemcached::MemcachedSt
  def initialize(*_arg0); end

  def cached_errno(*_arg0); end
  def cached_errno=(*_arg0); end
  def call_calloc(*_arg0); end
  def call_calloc=(*_arg0); end
  def call_free(*_arg0); end
  def call_free=(*_arg0); end
  def call_malloc(*_arg0); end
  def call_malloc=(*_arg0); end
  def call_realloc(*_arg0); end
  def call_realloc=(*_arg0); end
  def connect_timeout(*_arg0); end
  def connect_timeout=(*_arg0); end
  def continuum(*_arg0); end
  def continuum=(*_arg0); end
  def continuum_count(*_arg0); end
  def continuum_count=(*_arg0); end
  def continuum_points_counter(*_arg0); end
  def continuum_points_counter=(*_arg0); end
  def cursor_server(*_arg0); end
  def cursor_server=(*_arg0); end
  def delete_trigger(*_arg0); end
  def delete_trigger=(*_arg0); end
  def distribution(*_arg0); end
  def distribution=(*_arg0); end
  def flags(*_arg0); end
  def flags=(*_arg0); end
  def get_key_failure(*_arg0); end
  def get_key_failure=(*_arg0); end
  def hash(*_arg0); end
  def hash=(*_arg0); end
  def hash_continuum(*_arg0); end
  def hash_continuum=(*_arg0); end
  def hosts(*_arg0); end
  def hosts=(*_arg0); end
  def io_bytes_watermark(*_arg0); end
  def io_bytes_watermark=(*_arg0); end
  def io_key_prefetch(*_arg0); end
  def io_key_prefetch=(*_arg0); end
  def io_msg_watermark(*_arg0); end
  def io_msg_watermark=(*_arg0); end
  def is_allocated(*_arg0); end
  def is_allocated=(*_arg0); end
  def last_server_key(*_arg0); end
  def last_server_key=(*_arg0); end
  def live_host_indices(*_arg0); end
  def live_host_indices=(*_arg0); end
  def live_host_indices_size(*_arg0); end
  def live_host_indices_size=(*_arg0); end
  def next_distribution_rebuild(*_arg0); end
  def next_distribution_rebuild=(*_arg0); end
  def number_of_hosts(*_arg0); end
  def number_of_hosts=(*_arg0); end
  def number_of_live_hosts(*_arg0); end
  def number_of_live_hosts=(*_arg0); end
  def on_cleanup(*_arg0); end
  def on_cleanup=(*_arg0); end
  def on_clone(*_arg0); end
  def on_clone=(*_arg0); end
  def poll_max_retries(*_arg0); end
  def poll_max_retries=(*_arg0); end
  def poll_timeout(*_arg0); end
  def poll_timeout=(*_arg0); end
  def prefix_key(*_arg0); end
  def prefix_key=(*_arg0); end
  def prefix_key_length(*_arg0); end
  def prefix_key_length=(*_arg0); end
  def purging(*_arg0); end
  def purging=(*_arg0); end
  def rcv_timeout(*_arg0); end
  def rcv_timeout=(*_arg0); end
  def recv_size(*_arg0); end
  def recv_size=(*_arg0); end
  def result(*_arg0); end
  def result=(*_arg0); end
  def retry_timeout(*_arg0); end
  def retry_timeout=(*_arg0); end
  def sasl_callbacks(*_arg0); end
  def sasl_callbacks=(*_arg0); end
  def send_size(*_arg0); end
  def send_size=(*_arg0); end
  def server_failure_limit(*_arg0); end
  def server_failure_limit=(*_arg0); end
  def snd_timeout(*_arg0); end
  def snd_timeout=(*_arg0); end
  def user_data(*_arg0); end
  def user_data=(*_arg0); end
end

class Rlibmemcached::MemcachedStatSt
  def initialize(*_arg0); end

  def bytes(*_arg0); end
  def bytes=(*_arg0); end
  def bytes_read(*_arg0); end
  def bytes_read=(*_arg0); end
  def bytes_written(*_arg0); end
  def bytes_written=(*_arg0); end
  def cmd_get(*_arg0); end
  def cmd_get=(*_arg0); end
  def cmd_set(*_arg0); end
  def cmd_set=(*_arg0); end
  def connection_structures(*_arg0); end
  def connection_structures=(*_arg0); end
  def curr_connections(*_arg0); end
  def curr_connections=(*_arg0); end
  def curr_items(*_arg0); end
  def curr_items=(*_arg0); end
  def evictions(*_arg0); end
  def evictions=(*_arg0); end
  def get_hits(*_arg0); end
  def get_hits=(*_arg0); end
  def get_misses(*_arg0); end
  def get_misses=(*_arg0); end
  def limit_maxbytes(*_arg0); end
  def limit_maxbytes=(*_arg0); end
  def pid(*_arg0); end
  def pid=(*_arg0); end
  def pointer_size(*_arg0); end
  def pointer_size=(*_arg0); end
  def rusage_system_microseconds(*_arg0); end
  def rusage_system_microseconds=(*_arg0); end
  def rusage_system_seconds(*_arg0); end
  def rusage_system_seconds=(*_arg0); end
  def rusage_user_microseconds(*_arg0); end
  def rusage_user_microseconds=(*_arg0); end
  def rusage_user_seconds(*_arg0); end
  def rusage_user_seconds=(*_arg0); end
  def threads(*_arg0); end
  def threads=(*_arg0); end
  def time(*_arg0); end
  def time=(*_arg0); end
  def total_connections(*_arg0); end
  def total_connections=(*_arg0); end
  def total_items(*_arg0); end
  def total_items=(*_arg0); end
  def uptime(*_arg0); end
  def uptime=(*_arg0); end
  def version(*_arg0); end
  def version=(*_arg0); end
end
