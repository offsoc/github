# typed: false

# DO NOT EDIT MANUALLY
# This is an autogenerated file for types exported from the `tcr` gem.
# Please instead update this file by running `bin/tapioca gem tcr`.

# source://tcr//lib/tcr.rb#77
class OpenSSL::SSL::SSLSocket
  include ::Prelude::Enumerator
  include ::Enumerable
  include ::OpenSSL::Buffering
  include ::OpenSSL::SSL::SocketForwarder

  class << self
    # source://tcr//lib/tcr.rb#79
    def new(io, *args); end
  end
end

# source://tcr//lib/tcr.rb#89
class Socket < ::BasicSocket
  class << self
    # source://tcr//lib/tcr.rb#93
    def tcp(host, port, *socket_opts); end
  end
end

class Socket::ResolutionError < ::SocketError
  def error_code; end
end

# The monkey patch shim
#
# source://tcr//lib/tcr.rb#63
class TCPSocket < ::IPSocket
  class << self
    # source://tcr//lib/tcr.rb#67
    def open(address, port, *args); end
  end
end

# source://tcr//lib/tcr/cassette.rb#3
module TCR
  extend ::TCR

  # source://tcr//lib/tcr.rb#21
  def cassette; end

  # source://tcr//lib/tcr.rb#25
  def cassette=(v); end

  # source://tcr//lib/tcr.rb#17
  def configuration; end

  # @yield [configuration]
  #
  # source://tcr//lib/tcr.rb#13
  def configure; end

  # source://tcr//lib/tcr.rb#29
  def disabled; end

  # source://tcr//lib/tcr.rb#33
  def disabled=(v); end

  # source://tcr//lib/tcr.rb#37
  def save_session; end

  # @raise [ArgumentError]
  #
  # source://tcr//lib/tcr.rb#51
  def turned_off(&block); end

  # source://tcr//lib/tcr.rb#40
  def use_cassette(name, options = T.unsafe(nil), &block); end
end

# source://tcr//lib/tcr/cassette.rb#4
class TCR::Cassette
  # @return [Cassette] a new instance of Cassette
  #
  # source://tcr//lib/tcr/cassette.rb#7
  def initialize(name); end

  # source://tcr//lib/tcr/cassette.rb#39
  def check_hits_all_sessions; end

  # Returns the value of attribute name.
  #
  # source://tcr//lib/tcr/cassette.rb#5
  def name; end

  # source://tcr//lib/tcr/cassette.rb#22
  def next_session; end

  # @return [Boolean]
  #
  # source://tcr//lib/tcr/cassette.rb#18
  def recording?; end

  # source://tcr//lib/tcr/cassette.rb#32
  def save; end

  protected

  # source://tcr//lib/tcr/cassette.rb#75
  def filename; end

  # source://tcr//lib/tcr/cassette.rb#61
  def marshal(content); end

  # source://tcr//lib/tcr/cassette.rb#47
  def unmarshal(content); end

  # source://tcr//lib/tcr/cassette.rb#79
  def verify_cassette_path_is_writable; end
end

# source://tcr//lib/tcr/configuration.rb#2
class TCR::Configuration
  # @return [Configuration] a new instance of Configuration
  #
  # source://tcr//lib/tcr/configuration.rb#5
  def initialize; end

  # Returns the value of attribute block_for_reads.
  #
  # source://tcr//lib/tcr/configuration.rb#3
  def block_for_reads; end

  # Sets the attribute block_for_reads
  #
  # @param value the value to set the attribute block_for_reads to.
  #
  # source://tcr//lib/tcr/configuration.rb#3
  def block_for_reads=(_arg0); end

  # Returns the value of attribute cassette_library_dir.
  #
  # source://tcr//lib/tcr/configuration.rb#3
  def cassette_library_dir; end

  # Sets the attribute cassette_library_dir
  #
  # @param value the value to set the attribute cassette_library_dir to.
  #
  # source://tcr//lib/tcr/configuration.rb#3
  def cassette_library_dir=(_arg0); end

  # Returns the value of attribute format.
  #
  # source://tcr//lib/tcr/configuration.rb#3
  def format; end

  # Sets the attribute format
  #
  # @param value the value to set the attribute format to.
  #
  # source://tcr//lib/tcr/configuration.rb#3
  def format=(_arg0); end

  # Returns the value of attribute hit_all.
  #
  # source://tcr//lib/tcr/configuration.rb#3
  def hit_all; end

  # Sets the attribute hit_all
  #
  # @param value the value to set the attribute hit_all to.
  #
  # source://tcr//lib/tcr/configuration.rb#3
  def hit_all=(_arg0); end

  # Returns the value of attribute hook_tcp_ports.
  #
  # source://tcr//lib/tcr/configuration.rb#3
  def hook_tcp_ports; end

  # Sets the attribute hook_tcp_ports
  #
  # @param value the value to set the attribute hook_tcp_ports to.
  #
  # source://tcr//lib/tcr/configuration.rb#3
  def hook_tcp_ports=(_arg0); end

  # source://tcr//lib/tcr/configuration.rb#9
  def reset_defaults!; end
end

# source://tcr//lib/tcr/errors.rb#6
class TCR::DirectionMismatchError < ::TCR::TCRError; end

# source://tcr//lib/tcr/errors.rb#5
class TCR::ExtraSessionsError < ::TCR::TCRError; end

# source://tcr//lib/tcr/errors.rb#3
class TCR::NoCassetteError < ::TCR::TCRError; end

# source://tcr//lib/tcr/errors.rb#4
class TCR::NoMoreSessionsError < ::TCR::TCRError; end

# source://tcr//lib/tcr/recordable_tcp_socket.rb#149
class TCR::RecordableSSLSocket < ::SimpleDelegator
  # @return [RecordableSSLSocket] a new instance of RecordableSSLSocket
  #
  # source://tcr//lib/tcr/recordable_tcp_socket.rb#150
  def initialize(tcr_socket); end

  # source://tcr//lib/tcr/recordable_tcp_socket.rb#164
  def cipher; end

  # source://tcr//lib/tcr/recordable_tcp_socket.rb#208
  def connect; end

  # source://tcr//lib/tcr/recordable_tcp_socket.rb#204
  def connect_nonblock(*_arg0); end

  # source://tcr//lib/tcr/recordable_tcp_socket.rb#180
  def flush; end

  # source://tcr//lib/tcr/recordable_tcp_socket.rb#191
  def hostname=(args); end

  # source://tcr//lib/tcr/recordable_tcp_socket.rb#194
  def io; end

  # source://tcr//lib/tcr/recordable_tcp_socket.rb#212
  def post_connection_check(*args); end

  # source://tcr//lib/tcr/recordable_tcp_socket.rb#184
  def session; end

  # source://tcr//lib/tcr/recordable_tcp_socket.rb#188
  def session=(args); end

  # source://tcr//lib/tcr/recordable_tcp_socket.rb#198
  def shutdown; end

  # source://tcr//lib/tcr/recordable_tcp_socket.rb#160
  def ssl_version; end

  # source://tcr//lib/tcr/recordable_tcp_socket.rb#172
  def sync; end

  # source://tcr//lib/tcr/recordable_tcp_socket.rb#176
  def sync=(arg); end

  # source://tcr//lib/tcr/recordable_tcp_socket.rb#168
  def sync_close=(arg); end
end

# source://tcr//lib/tcr/recordable_tcp_socket.rb#7
class TCR::RecordableTCPSocket
  # @raise [TCR::NoCassetteError]
  # @return [RecordableTCPSocket] a new instance of RecordableTCPSocket
  #
  # source://tcr//lib/tcr/recordable_tcp_socket.rb#10
  def initialize(address, port, cassette); end

  # source://tcr//lib/tcr/recordable_tcp_socket.rb#74
  def close; end

  # @return [Boolean]
  #
  # source://tcr//lib/tcr/recordable_tcp_socket.rb#66
  def closed?; end

  # source://tcr//lib/tcr/recordable_tcp_socket.rb#34
  def getc(*args); end

  # source://tcr//lib/tcr/recordable_tcp_socket.rb#38
  def gets(*args); end

  # Returns the value of attribute live.
  #
  # source://tcr//lib/tcr/recordable_tcp_socket.rb#8
  def live; end

  # source://tcr//lib/tcr/recordable_tcp_socket.rb#46
  def print(str, *args); end

  # source://tcr//lib/tcr/recordable_tcp_socket.rb#30
  def read(*args); end

  # source://tcr//lib/tcr/recordable_tcp_socket.rb#42
  def read_nonblock(*args); end

  # Returns the value of attribute recording.
  #
  # source://tcr//lib/tcr/recordable_tcp_socket.rb#8
  def recording; end

  # source://tcr//lib/tcr/recordable_tcp_socket.rb#82
  def setsockopt(*args); end

  # Returns the value of attribute socket.
  #
  # source://tcr//lib/tcr/recordable_tcp_socket.rb#8
  def socket; end

  # source://tcr//lib/tcr/recordable_tcp_socket.rb#60
  def to_io; end

  # source://tcr//lib/tcr/recordable_tcp_socket.rb#50
  def write(str, *args); end

  # source://tcr//lib/tcr/recordable_tcp_socket.rb#55
  def write_nonblock(str, *args); end

  private

  # source://tcr//lib/tcr/recordable_tcp_socket.rb#97
  def _block_for_read_data; end

  # source://tcr//lib/tcr/recordable_tcp_socket.rb#103
  def _check_for_blocked_reads; end

  # source://tcr//lib/tcr/recordable_tcp_socket.rb#135
  def _delegate_call(method, args); end

  # @raise [TCR::DirectionMismatchError]
  #
  # source://tcr//lib/tcr/recordable_tcp_socket.rb#144
  def _ensure_direction(desired, actual); end

  # source://tcr//lib/tcr/recordable_tcp_socket.rb#91
  def _intercept_socket; end

  # source://tcr//lib/tcr/recordable_tcp_socket.rb#119
  def _read(method, args, opts = T.unsafe(nil)); end

  # source://tcr//lib/tcr/recordable_tcp_socket.rb#107
  def _write(method, data, args); end

  # source://tcr//lib/tcr/recordable_tcp_socket.rb#87
  def check_recording_for_errors; end
end

# source://tcr//lib/tcr/errors.rb#2
class TCR::TCRError < ::StandardError; end

# source://tcr//lib/tcr/version.rb#2
TCR::VERSION = T.let(T.unsafe(nil), String)
